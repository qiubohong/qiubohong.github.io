<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>qborfy知识库</title>
  
  
  <link href="https://www.qborfy.com/atom.xml" rel="self"/>
  
  <link href="https://www.qborfy.com/"/>
  <updated>2023-07-28T15:48:29.774Z</updated>
  <id>https://www.qborfy.com/</id>
  
  <author>
    <name>qborfy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一次性完整学完搭建PWA项目</title>
    <link href="https://www.qborfy.com/today/20230301.html"/>
    <id>https://www.qborfy.com/today/20230301.html</id>
    <published>2023-07-28T10:00:01.000Z</published>
    <updated>2023-07-28T15:48:29.774Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com" target="_blank" rel="noopener">Qborfy</a></p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在开发一个简单的个人记录网站，技术栈是使用 Vite + Vue3，由于使用的单台服务器，有时候服务器会被限制带宽，所以平时都会比较访问比较慢。所以想实现一个离线应用，而 PWA 应用则是目前最佳方案。</p><p>本文涉及知识点如下：</p><ul><li>PWA 的概念</li><li>Service Worker使用</li><li>用构建工具搭建 PWA 应用</li></ul><a id="more"></a><h1 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h1><blockquote><p>渐进式 Web 应用（Progressive Web App，PWA）是一个使用 web 平台技术构建的应用程序，但它提供的用户体验就像一个特定平台的应用程序。 ——<a href="https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps" target="_blank" rel="noopener">MDN 渐进式 Web 应用（PWA）</a></p></blockquote><p>正如上文所描述一样 PWA 最终目的让你的 web 网站可以像 app 应用一样可以给到用户去离线体验，简单点说，就是没有网络，你也可以正常访问该网站的一些资源。</p><p>PWA从技术上分为三个部分：</p><ul><li>主应用，就是平时我们开发网站所包含的内容，有：html，js，css等</li><li>Web app manifests，主要为<code>manifest.json</code>，提供浏览器安装 PWA 所需的信息，例如应用程序名称和图标等</li><li>Service Worker，主要为js文件，提供基本的离线缓存资源能力</li></ul><h2 id="manifest-json"><a href="#manifest-json" class="headerlink" title="manifest.json"></a>manifest.json</h2><p><code>manifest.json</code>描述web网站的信息（如名称，作者，图标和描述）的JSON文件，具体例子如下所示。</p><p><code>manifest.json</code>是需要在网站中html文件中 head中引用，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"manifest"</span> <span class="attr">href</span>=<span class="string">"/manifest.json"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>完整的<code>manifest.json</code>示例：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"网站完整名称"</span>, </span><br><span class="line">  "short_name": "网站简称", // 在没有足够空间显示 Web 应用程序的全名时使用</span><br><span class="line">  "start_url": ".", // 从启动应用程序时加载的 URL。如果以相对 URL 的形式给出，则基本 URL 将是 manifest 的 URL</span><br><span class="line">  "display": "standalone", // 访问网站窗口展示模式，如：fullscreen/standalone</span><br><span class="line">  "background_color": "#fff", // 背景颜色</span><br><span class="line">  "description": "网站描述",</span><br><span class="line">  "icons": [ // 网站图标</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"images/touch/homescreen48.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"48x48"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"images/touch/homescreen72.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"72x72"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"images/touch/homescreen96.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"96x96"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"images/touch/homescreen144.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"144x144"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"images/touch/homescreen168.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"168x168"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"images/touch/homescreen192.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"192x192"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解基本的描述文件，下面我们将进入<code>Service Worker</code>作为其中整个控制中心，我们将在下面进行着重了解。</p><h1 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>我们先来看看官方定义：</p><blockquote><p>Service worker 是一个注册在指定源和路径下的事件驱动 worker。它采用 JavaScript 文件的形式，控制关联的页面或者网站，拦截并修改访问和资源请求，细粒度地缓存资源。你可以完全控制应用在特定情形（最常见的情形是网络不可用）下的表现。 —— <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">MDN Service Worker</a></p></blockquote><p>进行简单总结一下  Service Woker是什么：</p><ul><li>是一个区别于主 JavaScript 线程，运行在其他单独线程，但是必须要注册到主 JavaScript 线程中</li><li>是用JavaScript编写的</li><li>可以拦截并修改访问和资源请求，从而实现资源缓存</li></ul><p><strong>出于安全考量，Service worker 只能由 HTTPS 承载，毕竟修改网络请求的能力暴露给中间人攻击会非常危险，如果允许访问这些强大的 API，此类攻击将会变得很严重。</strong></p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>Service Woker的生命周期如下：</p><ol><li>注册，使用 ServiceWorkerContainer.register() 方法首次注册 service worker</li><li>下载，页面首次加载后会下载ServiceWorker或者过去 24 小时没有被下载会再次下载</li><li>安装，首次启用 service worker，页面会首先尝试安装，如果现有 service worker 已启用，新版本会在后台安装，但仍不会被激活——这个时序称为 worker in waiting。</li><li>激活，首次启用 service worker，安装结束后会直接激活，新版本的service worker会直到所有已加载的页面不再使用旧的 service worker 才会激活新的 service worker，但是可以通过ServiceWorkerGlobalScope.skipWaiting() 可以更快地进行激活。</li></ol><p><img src="/assets/img/sw-lifecycle.svg" alt></p><p>Service Worker提供几个事件用来监听生命周期的变化，如下：</p><ul><li><code>self.addEventListener(&quot;install&quot;)</code> 该事件触发时的标准行为是准备 service worker 用于使用，例如使用内建的 storage API 来创建缓存，并且放置应用离线时所需资源。</li><li><code>self.addEventListener(&quot;activate&quot;)</code> 事件触发的时间点通常是清理旧缓存以及其他与你的 service worker 的先前版本相关的东西。</li><li><code>self.addEventListener(&quot;fetch&quot;)</code>  事件触发的时间点是每次获取 service worker 控制的资源时，都会触发 fetch 事件 </li></ul><p><strong>这里的<code>this</code>代表的是 Service Worker 本身对象。</strong></p><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><p>了解完后，我们需要知道 Service Worker 有哪些常用的 API接口，或者当我们需要去实现一个 PWA 会用到哪些 API 接口，具体如下：</p><ul><li><code>navigator.serviceWorker.register()</code> 主 JavaScript 线程注册  Service Worker 方法</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache" target="_blank" rel="noopener"><code>Cache</code></a> 与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CacheStorage" target="_blank" rel="noopener"><code>CacheStorage</code></a> 用来控制缓存</li></ul><h2 id="尝鲜使用"><a href="#尝鲜使用" class="headerlink" title="尝鲜使用"></a>尝鲜使用</h2><h3 id="第一步-写个-demo站点"><a href="#第一步-写个-demo站点" class="headerlink" title="第一步 写个 demo站点"></a>第一步 写个 demo站点</h3><p>我们肯定需要有一个站点，里面有 html/css/js文件，代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"manifest"</span> <span class="attr">href</span>=<span class="string">"./manifest.json"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Service Worker测试页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./test.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>测试 Service Worker<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./test.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">        // 这里开始注册 Service Worker</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="第二步-注册-Service-Worker"><a href="#第二步-注册-Service-Worker" class="headerlink" title="第二步 注册 Service Worker"></a>第二步 注册 Service Worker</h3><p>这一步有两个 事情：</p><ul><li>写Service Worker的相关逻辑的js文件 (且叫<code>sw.js</code>)</li><li>将<code>sw.js</code>注册到html文件中<br>具体代码如下：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册 Service worker</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> <span class="built_in">window</span>.navigator) &#123;</span><br><span class="line">    <span class="keyword">const</span> registerServiceWorker = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"serviceWorker"</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> registration = <span class="keyword">await</span> navigator.serviceWorker.register(<span class="string">"./sw.js"</span>, &#123;</span><br><span class="line">                    scope: <span class="string">"/"</span>,</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">if</span> (registration.installing) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">"正在安装 Service worker"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (registration.waiting) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">"已安装 Service worker installed"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (registration.active) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">"激活 Service worker"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">`注册失败：<span class="subst">$&#123;error&#125;</span>`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    registerServiceWorker();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sw.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// self等同于 this</span></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'install'</span>);</span><br><span class="line">    <span class="comment">// ... 安装完成 可以开始拦截请求加入缓存 cache 中</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'activate'</span>);</span><br><span class="line">    <span class="comment">// ... 激活完成 可以开始拦截请求加入缓存 cache 中</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="第三步-缓存管理"><a href="#第三步-缓存管理" class="headerlink" title="第三步 缓存管理"></a>第三步 缓存管理</h3><p>缓存管理包括两部分，一个是缓存资源，另外一个同步更新资源，在 ServiceWorker 代码中是通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache" target="_blank" rel="noopener"><code>Cache</code></a> 与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CacheStorage" target="_blank" rel="noopener"><code>CacheStorage</code></a>去控制，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sw.js</span></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 确保 Service Worker 不会在 waitUntil() 里面的代码执行完毕之前安装完成</span></span><br><span class="line">    event.waitUntil(</span><br><span class="line">        <span class="comment">// 创建了叫做 v1 的新缓存</span></span><br><span class="line">        caches.open(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">            cache.addAll([</span><br><span class="line">                <span class="string">'./index.html'</span>, <span class="comment">// 相对于 sw.js 的路径 缓存 index.html</span></span><br><span class="line">            ]);</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存优先</span></span><br><span class="line"><span class="keyword">const</span> cacheFirst = <span class="keyword">async</span> (request) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 从缓存中读取 respondWith表示拦截请求并返回自定义的响应</span></span><br><span class="line">    <span class="keyword">const</span> responseFromCache = <span class="keyword">await</span> caches.match(request);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'responseFromCache'</span>, responseFromCache);</span><br><span class="line">    <span class="keyword">if</span> (responseFromCache) &#123;</span><br><span class="line">        <span class="keyword">return</span> responseFromCache</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fetch(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">"fetch"</span>, (event) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 拦截请求</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'caches match'</span>,);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fetch'</span>, event.request.url);</span><br><span class="line">    event.respondWith(cacheFirst(event.request));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="动态缓存"><a href="#动态缓存" class="headerlink" title="动态缓存"></a>动态缓存</h4><p>当然，上面是将固定的资源进行缓存，如果是需要对整个页面请求资源进行缓存管理，那么可以通过<code>fetch</code>事件拦截请求实现动态缓存，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存优先</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; request </span></span><br><span class="line"><span class="comment"> * @returns </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> cacheFirst = <span class="keyword">async</span> (request) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 从缓存中读取 respondWith表示拦截请求并返回自定义的响应</span></span><br><span class="line">    <span class="keyword">const</span> responseFromCache = <span class="keyword">await</span> caches.match(request);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'responseFromCache'</span>, responseFromCache);</span><br><span class="line">    <span class="keyword">if</span> (responseFromCache) &#123;</span><br><span class="line">        <span class="keyword">return</span> responseFromCache</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果缓存中没有，就从网络中请求</span></span><br><span class="line">    <span class="keyword">const</span> responseFromServer = <span class="keyword">await</span> fetch(request);</span><br><span class="line">    <span class="keyword">const</span> cache = <span class="keyword">await</span> caches.open(cacheName);</span><br><span class="line">    <span class="comment">// 将请求到的资源添加到缓存中</span></span><br><span class="line">    cache.put(request, responseFromServer.clone());</span><br><span class="line">    <span class="keyword">return</span> responseFromServer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">"fetch"</span>, (event) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 拦截请求</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'caches match'</span>,);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fetch'</span>, event.request.url);</span><br><span class="line">    event.respondWith(cacheFirst(event.request));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>缓存成功后，可以在 DevTools找到 网络请求状态，会标识是从 Service Worker 获取资源，具体如下图：</p><p><img src="/assets/img/20230301.png" alt="Alt text"></p><h3 id="第四步-更新缓存池"><a href="#第四步-更新缓存池" class="headerlink" title="第四步 更新缓存池"></a>第四步 更新缓存池</h3><p>当你的Service Worker  js文件有更新，需要删除旧的缓存，同时启动新的 Service Worker cache，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deleteCache = <span class="keyword">async</span> (key) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> caches.delete(key);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> deleteOldCaches = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> cacheKeepList = [<span class="string">"v2"</span>];</span><br><span class="line">  <span class="keyword">const</span> keyList = <span class="keyword">await</span> caches.keys();</span><br><span class="line">  <span class="keyword">const</span> cachesToDelete = keyList.filter(<span class="function">(<span class="params">key</span>) =&gt;</span> !cacheKeepList.includes(key));</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(cachesToDelete.map(deleteCache));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">"activate"</span>, (event) =&gt; &#123;</span><br><span class="line">  event.waitUntil(deleteOldCaches());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>讲完了这些，可能还需要实际体验一把，可以访问<a href="https://qborfy.com/code/serviceworker/index.html" target="_blank" rel="noopener">在线Service Worker Demo</a>，源码在这里<a href="https://github.com/qiubohong/qiubohong.github.io/tree/master/code/serviceworker/index.html" target="_blank" rel="noopener">Github qborfy/service worker</a>。</p><h1 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h1><p>上面讲述了 Service Worker 的概念和使用，但是在实际项目中，如果要按照这一套去实现，会遇到很多问题，如：经过打包后我们的 js , css等文件是动态生成的，从而导致每次都需要更新 Service Worker的 Cache 版本池。</p><p>所以需要结合构建工具去让项目更快支持 PWA应用开发，具体有以下几个。</p><h2 id="Vite构建"><a href="#Vite构建" class="headerlink" title="Vite构建"></a>Vite构建</h2><p>Vite官方推荐使用插件<a href="https://github.com/vite-pwa/vite-plugin-pwa" target="_blank" rel="noopener">vite-plugin-pwa</a>，使用如下：</p><p><strong>注意： <code>vite</code>版本需要 3+</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vite-plugin-pwa -D</span><br></pre></td></tr></table></figure><p>调整<code>vite</code>的配置文件<code>vite.config.js</code>，最小配置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; VitePWA &#125; <span class="keyword">from</span> <span class="string">'vite-plugin-pwa'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    VitePWA(&#123;</span><br><span class="line">      registerType: <span class="string">'autoUpdate'</span>, <span class="comment">// 注册更新模式方式  默认是autoUpdate，将会自动更新，其他还有prompt和skipWaiting</span></span><br><span class="line">      injectRegister: <span class="string">'auto'</span>, <span class="comment">// 控制如何在应用程序中注册ServiceWorker 默认值是 'auto' ，其他如：'inline' 则是注入一个简单的注册脚本，内联在应用程序入口点中</span></span><br><span class="line">      manifest: &#123; <span class="comment">// manifest.json 文件配置</span></span><br><span class="line">        name: <span class="string">'qborfy study website'</span>,</span><br><span class="line">        short_name: <span class="string">'qborfyStudy'</span>,</span><br><span class="line">        description: <span class="string">'qborfy study website'</span>,</span><br><span class="line">        theme_color: <span class="string">'#ffffff'</span>,</span><br><span class="line">        icons: [</span><br><span class="line">          &#123;</span><br><span class="line">            src: <span class="string">'favicon.png'</span>,</span><br><span class="line">            sizes: <span class="string">'192x192'</span>,</span><br><span class="line">            type: <span class="string">'image/png'</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            src: <span class="string">'favicon.png'</span>,</span><br><span class="line">            sizes: <span class="string">'512x512'</span>,</span><br><span class="line">            type: <span class="string">'image/png'</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>最终会在 <code>npm run build</code>后，完成以下几个事情：</p><ul><li>生成<code>registerSW.js</code>，用来注册<code>Service Worker</code>的<code>sw.js</code>文件</li><li>生成<code>sw.js</code>文件，在 <code>index.html</code>引入</li><li>生成<code>manifest.webmanifest</code>，在 <code>index.html</code>引入，声明网站的信息，可以在<code>manifest</code>配置项调整</li><li>生成<code>workbox.xxx.js</code>，用来管理缓存使用策略的代码，可以通过<code>strategies</code>去配置</li></ul><p>其他更多帮助文档可以到官方文档查看, <a href="https://vite-pwa-org.netlify.app/guide/" target="_blank" rel="noopener">vite-plugin-pwa官方文档</a></p><h2 id="Webpack构建"><a href="#Webpack构建" class="headerlink" title="Webpack构建"></a>Webpack构建</h2><p>Webpack作为前端最主流的构建工具，当然也有对应插件去实现，那就是<a href="https://github.com/GoogleChrome/workbox/tree/v7/packages/workbox-webpack-plugin" target="_blank" rel="noopener">workbox-webpack-plugin插件</a>，其实是Chrome自己开源的<a href="https://github.com/GoogleChrome/workbox/" target="_blank" rel="noopener">workbox工具库</a>中支持的插件之一。</p><p>具体用法如下：</p><ol><li><p>安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install workbox-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure></li><li><p>webpack.config.js增加插件配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> WorkboxPlugin = <span class="built_in">require</span>(<span class="string">'workbox-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> WorkboxPlugin.GenerateSW(&#123;</span><br><span class="line">            clientsClaim: <span class="literal">true</span>, <span class="comment">// 快速启用服务</span></span><br><span class="line">            skipWaiting: <span class="literal">true</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在index.html注册 service worker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (&apos;serviceWorker&apos; in navigator) &#123;</span><br><span class="line">    window.addEventListener(&apos;load&apos;, async () =&gt; &#123;</span><br><span class="line">        console.log(&apos;page load...&apos;);</span><br><span class="line">        let res = await navigator.serviceWorker.register(&apos;/service-worker.js&apos;);</span><br><span class="line">        console.log(res, &apos;serviceWorker res&apos;);</span><br><span class="line">        if (res) &#123;</span><br><span class="line">            console.log(&apos;register success!&apos;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.log(&apos;register fail!&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>更多帮助可以到<a href="https://developer.chrome.com/docs/workbox/modules/workbox-webpack-plugin/" target="_blank" rel="noopener">workbox 官方文档</a>中查看</p><h2 id="workbox工具库"><a href="#workbox工具库" class="headerlink" title="workbox工具库"></a>workbox工具库</h2><p>其实上面两个插件都是基于 Chrome 开源的 <a href="https://github.com/GoogleChrome/workbox/" target="_blank" rel="noopener">workbox工具库</a>去做二次封装实现的，接下来我们对<code>workbox.js</code>做一个简单的了解，方便后续如果我们需要自己去开发符合项目的 service worker控制。</p><blockquote><p>Service Worker有很多抽象的概念和 API，如：网络请求！缓存策略！缓存管理！预缓存！等等， Workbox的作用就是将复杂的 API 进行抽象，使更易于使用。</p><p>Workbox 是一组简化常见服务工作线程路由和缓存的模块。每个可用模块都解决 Service Worker 开发的特定方面。 Workbox 旨在使 Service Worker 的使用尽可能简单，同时允许在需要时灵活地满足复杂的应用程序要求。</p></blockquote><p>如何使用<code>Workbox</code>，官方提供两种方式：</p><ul><li>结合构建工具使用，如上面的 Vite 或者  Webpack</li><li>没有构建工具，官方提供了<a href="https://developer.chrome.com/docs/workbox/modules/workbox-sw/" target="_blank" rel="noopener">workbox-sw</a>，让你可以利用 workbox api去实现自己的 service worker策略</li></ul><p>这里简单使用一下，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sw.js</span></span><br><span class="line"><span class="comment">// 引入 workbox importScripts是 Service Worker  中的全局方法，用于引入外部脚本</span></span><br><span class="line">importScripts(<span class="string">'https://storage.googleapis.com/workbox-cdn/releases/6.4.1/workbox-sw.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面就可以直接使用workbox对象的方法，如：workbox.precaching.*， workbox.routing.*等</span></span><br><span class="line"><span class="comment">// 这里表示当请求的资源是图片时，使用 CacheFirst 策略，也就是优先从缓存中读取，如果缓存中没有，就从网络中请求</span></span><br><span class="line">workbox.routing.registerRoute(</span><br><span class="line">    (&#123; request &#125;) =&gt; request.destination === <span class="string">'image'</span>,</span><br><span class="line">    <span class="keyword">new</span> workbox.strategies.CacheFirst()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>其他使用说明文档可以到<a href="https://developer.chrome.com/docs/workbox" target="_blank" rel="noopener">workbox 官方文档</a>中查看。</p><h1 id="其他相关"><a href="#其他相关" class="headerlink" title="其他相关"></a>其他相关</h1><p>这里我还收集了一些开发 PWA 后续可能会用到的点，大家可以看看。</p><h2 id="Service-Worker其他"><a href="#Service-Worker其他" class="headerlink" title="Service Worker其他"></a>Service Worker其他</h2><p>本文主要是想通过 PWA 去优化个人网站的访问速度，PWA 不仅仅只能做缓存优化，还包括一下几点：</p><ul><li>通知 Notification，可以在后台接受服务器通知，然后告知用户</li><li>通讯 Message，可以和主 JS 线程通讯</li><li>后台更新，可以在用户没有访问页面的时候进行后台定时更新</li></ul><h2 id="如何发布一个-PWA-应用"><a href="#如何发布一个-PWA-应用" class="headerlink" title="如何发布一个 PWA 应用"></a>如何发布一个 PWA 应用</h2><ul><li><a href="https://chromeos.dev/en/publish/pwa-in-play" target="_blank" rel="noopener">如何发布一个PWA应用到Google Play Store</a></li><li><a href="https://learn.microsoft.com/en-us/microsoft-edge/progressive-web-apps-chromium/how-to/microsoft-store" target="_blank" rel="noopener">如何发布一个PWA应用到Microsoft Store</a></li><li><a href="https://developer.oculus.com/documentation/web/pwa-submit-app/" target="_blank" rel="noopener">如何发布一个PWA应用到Meta Quest Store</a></li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>Service Worker 缓存空间限制，Chrome 没有限制大小， Safari 限制50MB</li><li>当第一次访问页面，资源的请求是早于 Service Worker 的，所以静态资源是无法缓存的；只有当 Service Worker 安装完毕，用户第二次访问页面的时候，这些资源才会被缓存起来；所以 Service Worker 真正生效是在第三次访问</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/huangpb123/article/details/89498418" target="_blank" rel="noopener">Service Worker ——这应该是一个挺全面的整理</a></li><li><a href="https://juejin.cn/post/7039258299086143524" target="_blank" rel="noopener">vite pwa项目使用</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps" target="_blank" rel="noopener">MDN 渐进式 Web 应用（PWA）</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers" target="_blank" rel="noopener">如何使用一个 Service Worker</a></li><li><a href="https://developer.chrome.com/docs/workbox" target="_blank" rel="noopener">workbox 官方文档</a></li><li><a href="https://vite-pwa-org.netlify.app/" target="_blank" rel="noopener">Vite-plugin-pwa官方文档</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近在开发一个简单的个人记录网站，技术栈是使用 Vite + Vue3，由于使用的单台服务器，有时候服务器会被限制带宽，所以平时都会比较访问比较慢。所以想实现一个离线应用，而 PWA 应用则是目前最佳方案。&lt;/p&gt;
&lt;p&gt;本文涉及知识点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PWA 的概念&lt;/li&gt;
&lt;li&gt;Service Worker使用&lt;/li&gt;
&lt;li&gt;用构建工具搭建 PWA 应用&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="技术分享" scheme="https://www.qborfy.com/tags/技术分享/"/>
    
    <category term="每日更新" scheme="https://www.qborfy.com/tags/每日更新/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客添加GitHub评论功能</title>
    <link href="https://www.qborfy.com/today/20230228.html"/>
    <id>https://www.qborfy.com/today/20230228.html</id>
    <published>2023-07-17T10:00:01.000Z</published>
    <updated>2023-07-18T04:48:27.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>其实从今年开始运营这个博客，我一直想增加一些新的交互功能，如：评论，之前一直有些问题没搞定，现在终于通过 Google 搜索解决问题了， 其实也算是每天学习一些新东西。</p><p>解决问题：给 Hexo 博客新增 Github评论功能</p><p>为什么选择 Github 呢？是因为 Github 对于偏向开发人员基本上属于一个必注册网站，而我博客的内容又偏向于技术，所以才会采取这个。</p><a id="more"></a><h1 id="Gitalk"><a href="#Gitalk" class="headerlink" title="Gitalk"></a>Gitalk</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>引入 Github评论功能，网上有很多现成的方案，这里就一一列举了，我采用了最主流的库——<a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">Gitalk.js</a>，教程详细，不仅仅只能用于 Hexo，还可以适用于任何网站。</p><blockquote><p>Gitalk 是一个基于 GitHub Issue 和 Preact 开发的评论插件。 —— <a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">Gitalk.js</a></p></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用起来也非常简单，其实就是页面找个放置评论的位置，将对应资源引入，然后直接初始化使用即可。代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"gitalk-container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">var gitalk = new Gitalk(&#123;</span><br><span class="line">  clientID: 'GitHub Application Client ID', //  申请的GitHub Application Client ID.</span><br><span class="line">  clientSecret: 'GitHub Application Client Secret',  //  申请的GitHub Application Client Secret.</span><br><span class="line">  repo: 'GitHub repo', //  这里填写 Github的仓库名</span><br><span class="line">  owner: 'GitHub repo owner',  //  这里填写 Github的账户名</span><br><span class="line">  admin: ['GitHub repo owner and collaborators, only these guys can initialize github issues'], //  这里填写 Github的账户名</span><br><span class="line">  id: location.pathname,      // Ensure uniqueness and length less than 50</span><br><span class="line">  distractionFreeMode: false  // 类似 Facebook 的无干扰模式</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gitalk.render('gitalk-container')</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如何申请Github Application授权登录，只需要在<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">这里申请即可</a>，只需要注意信任域名为自己的域名即可，如下图：</p><img src="/assets/img/2023-07-17.png" style="width:50%"><h2 id="hexo使用"><a href="#hexo使用" class="headerlink" title="hexo使用"></a>hexo使用</h2><p>以<code>yilia-plus</code>主题为例子，其他主题只需要放到对应位置即可，具体步骤如下所示：</p><ol><li>在文件夹<code>layout/_partial/post</code>新增文件 <code>gitalk.ejs</code>，内容如下：</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"gitalk-container"</span> <span class="attr">style</span>=<span class="string">"padding: 0px 30px 0px 30px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">if(<span class="tag">&lt;<span class="name">%=theme.gitalk.enable%</span>&gt;</span>)&#123;</span></span><br><span class="line">var gitalk = new Gitalk(&#123;</span><br><span class="line"><span class="xml">  clientID: '<span class="tag">&lt;<span class="name">%=theme.gitalk.ClientID%</span>&gt;</span>',</span></span><br><span class="line"><span class="xml">  clientSecret: '<span class="tag">&lt;<span class="name">%=theme.gitalk.ClientSecret%</span>&gt;</span>',</span></span><br><span class="line"><span class="xml">  repo: '<span class="tag">&lt;<span class="name">%=theme.gitalk.repo%</span>&gt;</span>',</span></span><br><span class="line"><span class="xml">  owner: '<span class="tag">&lt;<span class="name">%=theme.gitalk.githubID%</span>&gt;</span>',</span></span><br><span class="line"><span class="xml">  admin: ['<span class="tag">&lt;<span class="name">%=theme.gitalk.adminUser%</span>&gt;</span>'],</span></span><br><span class="line"><span class="xml">  id: '<span class="tag">&lt;<span class="name">%=</span> <span class="attr">page.date</span> %&gt;</span>',</span></span><br><span class="line"><span class="xml">  distractionFreeMode: '<span class="tag">&lt;<span class="name">%=theme.gitalk.distractionFreeMode%</span>&gt;</span>',</span></span><br><span class="line">    proxy: 'https://test.com/proxy', // 这个是坑（Gitalk 本身提供了代理服务，但是国内经常无法访问），由于Github 采用的 OAuth 协议，所以需要我们自己写一套服务去支撑</span><br><span class="line">&#125;)</span><br><span class="line">gitalk.render('gitalk-container') </span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在主题中找到<code>layout/_partial/post/article.ejs</code>中想放置评论位置，加入判断是否启用 <code>gitalk</code>，代码如下：</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span>(<span class="attr">theme.gitalk.enable</span>)&#123; %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%-</span> <span class="attr">partial</span>('<span class="attr">post</span>/<span class="attr">gitalk</span>', &#123;</span></span><br><span class="line"><span class="tag">      <span class="attr">key:</span> <span class="attr">post.slug</span>,</span></span><br><span class="line"><span class="tag">      <span class="attr">title:</span> <span class="attr">post.title</span>,</span></span><br><span class="line"><span class="tag">      <span class="attr">url:</span> <span class="attr">config.url</span>+<span class="attr">url_for</span>(<span class="attr">post.path</span>)</span></span><br><span class="line"><span class="tag">    &#125;) %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在主题根目录配置文件<code>_config.yml</code> 打开<code>gitalk</code>配置，如下：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#6、gitalk评论</span></span><br><span class="line"><span class="attr">gitalk:</span></span><br><span class="line"><span class="attr">  enable:</span>  <span class="literal">true</span></span><br><span class="line"><span class="attr">  githubID:</span>  <span class="string">xxxxxx</span>  <span class="comment"># 配置项基本于 GitTalk保持一致</span></span><br><span class="line"><span class="attr">  repo:</span>  <span class="string">'xxxxx'</span></span><br><span class="line"><span class="attr">  ClientID:</span>  <span class="string">'xxxxxx'</span></span><br><span class="line"><span class="attr">  ClientSecret:</span>  <span class="string">'xxxxx'</span></span><br><span class="line"><span class="attr">  adminUser:</span>  <span class="string">xxxx</span></span><br><span class="line"><span class="attr">  distractionFreeMode:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h2 id="Gitalk-提示-“NetError”"><a href="#Gitalk-提示-“NetError”" class="headerlink" title="Gitalk 提示 “NetError”"></a>Gitalk 提示 “NetError”</h2><p>其实是 Gitalk 内置了 proxy 代理服务去请求完成 Github OAuth 鉴权服务，但是由于国内会经常无法正常请求该代理服务，所以需要我们自己去完成 Github OAuth 鉴权，这里我简单写了一下代码，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>)</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'koa-bodyparser'</span>)</span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>)</span><br><span class="line"><span class="comment">// github application的配置</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    client_id: <span class="string">'xxxxx'</span>,</span><br><span class="line">    client_secret: <span class="string">'xxxxxxxxx'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> koa()</span><br><span class="line">app.use(bodyParser())</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">'/proxy'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 获取Github OAuth鉴权回调的 code 值</span></span><br><span class="line">    <span class="keyword">const</span> &#123; code &#125; = ctx.request.body</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'code'</span>, code)</span><br><span class="line">    <span class="keyword">const</span> params = &#123;</span><br><span class="line">        client_id: config.client_id,</span><br><span class="line">        client_secret: config.client_secret,</span><br><span class="line">        code: code</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> axios.post(<span class="string">'https://github.com/login/oauth/access_token'</span>, params)</span><br><span class="line">        <span class="keyword">const</span> access_token = res.data.split(<span class="string">'&amp;'</span>)[<span class="number">0</span>].split(<span class="string">'='</span>)[<span class="number">1</span>]</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'res.data'</span>, res.data)</span><br><span class="line">        <span class="comment">// 请求成功后返回access_token 去获取 Github 相关信息</span></span><br><span class="line">        ctx.body = &#123;</span><br><span class="line">            access_token</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">        ctx.body = &#123; <span class="attr">err</span>: err &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(router.routes())</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3003</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server is running at http://localhost:3003'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://github.com/gitalk/gitalk/issues/359" target="_blank" rel="noopener">Error: Network Error怎么解决</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;其实从今年开始运营这个博客，我一直想增加一些新的交互功能，如：评论，之前一直有些问题没搞定，现在终于通过 Google 搜索解决问题了， 其实也算是每天学习一些新东西。&lt;/p&gt;
&lt;p&gt;解决问题：给 Hexo 博客新增 Github评论功能&lt;/p&gt;
&lt;p&gt;为什么选择 Github 呢？是因为 Github 对于偏向开发人员基本上属于一个必注册网站，而我博客的内容又偏向于技术，所以才会采取这个。&lt;/p&gt;</summary>
    
    
    
    
    <category term="技术分享" scheme="https://www.qborfy.com/tags/技术分享/"/>
    
    <category term="每日更新" scheme="https://www.qborfy.com/tags/每日更新/"/>
    
  </entry>
  
  <entry>
    <title>前端面试100道手写题（7）—— 循环轮播图</title>
    <link href="https://www.qborfy.com/face100/7-loop-pic.html"/>
    <id>https://www.qborfy.com/face100/7-loop-pic.html</id>
    <published>2023-07-15T14:00:00.000Z</published>
    <updated>2023-07-13T09:33:12.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>循环轮播图，基本上大家用的都是现有组件，如果要让你自己设计实现一个，其实最主要的两个点：循环算法和滚动动画</p><p>手写难度：⭐️⭐️</p><p>涉及知识点：</p><ul><li>循环算法，最低复杂度</li><li>CSS 动画</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;循环轮播图，基本上大家用的都是现有组件，如果要让你自己设计实现一个，其实最主要的两个点：循环算法和滚动动画&lt;/p&gt;
&lt;p&gt;手写难度：⭐️⭐️</summary>
      
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/学习总结/"/>
    
    <category term="前端面试" scheme="https://www.qborfy.com/tags/前端面试/"/>
    
  </entry>
  
  <entry>
    <title>前端面试100道手写题（6）—— 虚拟滚动</title>
    <link href="https://www.qborfy.com/face100/6-visual-scroll.html"/>
    <id>https://www.qborfy.com/face100/6-visual-scroll.html</id>
    <published>2023-07-05T14:00:00.000Z</published>
    <updated>2023-07-13T08:51:47.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>虚拟滚动在前端中是一个很常见的解决方案，由于浏览器对于内存的限制，当页面需要展示大量 DOM 节点（如：列表数据超过 10 万）的时候，如果完整渲染整个 DOM 树，当页面数据需要更新重新渲染的时候就会出现滚动卡顿，这个时候就需要虚拟滚动去模拟浏览器原生滚动事件，从而避免这个卡顿情况。</p><p>手写难度：⭐️⭐️⭐️</p><p>涉及知识点：</p><ul><li>滚动监听事件 wheel/move</li><li>事件节流</li><li>滚动偏移量 offset</li><li>按需渲染计算方案</li></ul><a id="more"></a><h1 id="虚拟滚动"><a href="#虚拟滚动" class="headerlink" title="虚拟滚动"></a>虚拟滚动</h1><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><ul><li>步骤 1： 监听虚拟滚动容器的 <code>wheel</code>或<code>touchmove</code> 事件</li><li>步骤 2： 创造子容器用于填充父容器，使得父容器可以滚动</li><li>步骤 3： 提供一个渲染子元素 item函数，返回 dom 节点</li><li>步骤 4： 计算每个元素的高度，然后计算出总共应该渲染多少个子元素 item</li><li>步骤 5： 当发生滚动事件的时候，更新子容器的偏移高度，然后触发 步骤 4</li></ul><h2 id="抽象方案"><a href="#抽象方案" class="headerlink" title="抽象方案"></a>抽象方案</h2><p>定义一个类<code>Scroll</code>，接收参数为：</p><ul><li><code>el</code> 列表容器 DOM 节点</li><li><code>list</code> 列表数据</li><li><code>itemRender</code> 子元素渲染函数</li><li><code>itemHeight</code> 子元素高度</li></ul><p>使用例子为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scroll = <span class="keyword">new</span> Scroll(&#123;</span><br><span class="line">    el: <span class="built_in">document</span>.getElementById(<span class="string">'scroll'</span>),</span><br><span class="line">    list: [],</span><br><span class="line">    itemRender: <span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> child = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">        child.innerText = <span class="string">`第<span class="subst">$&#123;item&#125;</span>个div`</span>;</span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>同时需要支持以下函数:</p><ul><li><code>update</code> 列表数组更新， 触发重新渲染</li></ul><p>虚拟滚动列表执行步骤：</p><ol><li>构造函数初始化，如：<code>start</code> <code>end</code> 代表位置</li><li><code>bindEvents</code> 监听滚动事件，触发后续渲染<code>render</code></li><li><code>init</code> 初始化一个内置容器，用来放置子元素，从而不影响父容器的高度，使得父容器可以滚动</li><li><code>render</code>计算容器滚动高度和元素 item 渲染高度，判断应该渲染哪部分元素 item</li></ol><p>简易版源码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scroll</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(&#123; el, list, itemRender, itemHeight = <span class="number">30</span> &#125;) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$list = el; <span class="comment">// 列表容器</span></span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">        <span class="keyword">this</span>.itemRender = itemRender;</span><br><span class="line">        <span class="keyword">this</span>.itemHeight = itemHeight;</span><br><span class="line">        <span class="keyword">this</span>.start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.bindEvents();</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init() &#123;</span><br><span class="line">        <span class="comment">// 创建一个子容器，用于渲染列表项</span></span><br><span class="line">        <span class="keyword">const</span> childContainer = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">        childContainer.style.position = <span class="string">'relative'</span>;</span><br><span class="line">        childContainer.style.width = <span class="string">'100%'</span>;</span><br><span class="line">        childContainer.style.boxSizing = <span class="string">'border-box'</span>;</span><br><span class="line">        childContainer.style.paddingTop = <span class="string">'0px'</span>;</span><br><span class="line">        childContainer.style.overflow = <span class="string">'hidden'</span>;</span><br><span class="line">        childContainer.style.height = <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.list.length * <span class="keyword">this</span>.itemHeight&#125;</span>px`</span>;</span><br><span class="line">        <span class="keyword">this</span>.$list.appendChild(childContainer);</span><br><span class="line">        <span class="keyword">this</span>.$child = childContainer;</span><br><span class="line">        <span class="keyword">this</span>.render();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bindEvents() &#123;</span><br><span class="line">        <span class="keyword">let</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> updateOffset = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.render();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.$list.addEventListener(<span class="string">'scroll'</span>, updateOffset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    update() &#123;</span><br><span class="line">        <span class="keyword">this</span>.render();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; list, itemRender, itemHeight &#125; = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">const</span> &#123; scrollTop, clientHeight &#125; = <span class="keyword">this</span>.$list;</span><br><span class="line">        <span class="keyword">const</span> start = <span class="built_in">Math</span>.floor(scrollTop / itemHeight);</span><br><span class="line">        <span class="keyword">const</span> gap = <span class="built_in">Math</span>.ceil(clientHeight / itemHeight);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'start'</span>, start)</span><br><span class="line">        <span class="keyword">if</span> (start &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> end = start + gap * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (start === <span class="keyword">this</span>.start &amp;&amp; end === <span class="keyword">this</span>.end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end &gt; list.length) &#123;</span><br><span class="line">            end = list.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新子容器的高度和偏移量</span></span><br><span class="line">        <span class="keyword">this</span>.$child.style.height = <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.list.length * <span class="keyword">this</span>.itemHeight&#125;</span>px`</span>;</span><br><span class="line">        <span class="keyword">this</span>.$child.style.paddingTop = <span class="string">`<span class="subst">$&#123;start * itemHeight&#125;</span>px`</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> item = list[i];</span><br><span class="line">            <span class="keyword">const</span> $item = itemRender(item);</span><br><span class="line">            $item.style.height = <span class="string">`<span class="subst">$&#123;itemHeight&#125;</span>px`</span>;</span><br><span class="line">            fragment.appendChild($item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.$child.innerHTML = <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">this</span>.$child.appendChild(fragment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子看起来虚拟滚动是不是十分简单，但是其实有些功能还需要优化，具体如下：</p><ul><li>节流触发滚动函数，避免每次滚动都进行更新</li><li>列表缓存，减少列表渲染样式更新</li><li>提前进行更新渲染，减少因为滚动导致的更新等等</li></ul><p>完整代码我放到 github 上，大家感兴趣可以去看看<a href="https://github.com/qiubohong/hundred-interview-questions/blob/main/6-visual-scroll" target="_blank" rel="noopener">Github Router完整实现</a></p><p><a href="https://qborfy.com/code/face/visualscroll/index.html" target="_blank" rel="noopener">Demo体验可以看这里</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://juejin.cn/post/6844904183582162957" target="_blank" rel="noopener">《新手也能看懂的虚拟滚动实现方法》</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;虚拟滚动在前端中是一个很常见的解决方案，由于浏览器对于内存的限制，当页面需要展示大量 DOM 节点（如：列表数据超过 10 万）的时候，如果完整渲染整个 DOM 树，当页面数据需要更新重新渲染的时候就会出现滚动卡顿，这个时候就需要虚拟滚动去模拟浏览器原生滚动事件，从而避免这个卡顿情况。&lt;/p&gt;
&lt;p&gt;手写难度：⭐️⭐️⭐️&lt;/p&gt;
&lt;p&gt;涉及知识点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;滚动监听事件 wheel/move&lt;/li&gt;
&lt;li&gt;事件节流&lt;/li&gt;
&lt;li&gt;滚动偏移量 offset&lt;/li&gt;
&lt;li&gt;按需渲染计算方案&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/学习总结/"/>
    
    <category term="前端面试" scheme="https://www.qborfy.com/tags/前端面试/"/>
    
  </entry>
  
  <entry>
    <title>前端面试100道手写题（5）—— Router路由</title>
    <link href="https://www.qborfy.com/face100/5-router-component.html"/>
    <id>https://www.qborfy.com/face100/5-router-component.html</id>
    <published>2023-06-20T14:00:00.000Z</published>
    <updated>2023-07-13T08:52:13.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前端路由，大家都使用过，那么有没有想过它是怎么实现的吗？如：Vue-Router 或者 React-Router。或许有个大概印象，但是真正要自己去实现还是没有什么思路，那么这篇文章将完整的实现思路去实现一次。</p><p>手写难度：⭐️⭐️⭐️</p><p>涉及知识点：</p><ul><li>history api 和监听事件</li><li>onhashchange 监听事件</li><li>Web Component 自定义组件</li></ul><a id="more"></a><h1 id="路由管理"><a href="#路由管理" class="headerlink" title="路由管理"></a>路由管理</h1><p>路由管理，是指的 web 应用在浏览器下根据不同的url地址展示不同的内容或者页面。</p><p>不管是 Vue-Router 或者  React-Router，基本上都是基于浏览器两种路由控制有一定了解，如下：</p><ul><li>hash，代表网页中的一个位置，通常用来做锚点使用，后面被用于单页web 应用的路由控制</li><li>history，代表网页的历史记录，同时提供接口操作浏览器的曾经在标签页或者框架里访问的会话历史记录</li></ul><p>下面我们对两个进行简单了解。</p><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><blockquote><p>Hash，通常是指的浏览器 URL 地址中带#的值，如：<code>URL = https://baidu.com/#/page1</code>，那么 <code>URL.hash=&#39;#/page1&#39;</code></p></blockquote><p>Hash 常用的 的几个方法：</p><p><strong><code>hashchange</code></strong></p><blockquote><p>当 URL 的片段标识符更改时，将触发hashchange事件</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'hashchange'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'The hash has changed!'</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p><strong><code>调整 hash</code></strong></p><p>除了监听改变之外，我们还需要对Hash 自由调整，如：添加或者修改，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.hash = <span class="string">'#/page2'</span></span><br></pre></td></tr></table></figure><h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><blockquote><p><code>History</code> 接口允许操作浏览器的曾经在标签页或者框架里访问的会话历史记录。</p></blockquote><p><code>History</code> 提供的 API 接口：</p><ul><li><code>pushState(state, unused, url)</code>  按指定的名称和 URL（如果提供该参数）将数据 push 进会话历史栈  如：<code>history.pushState({page: 1}, &quot;title 1&quot;, &quot;?page=1&quot;)</code></li><li><code>replaceState(state, unused, url)</code>  按指定的数据、名称和 URL（如果提供该参数），更新 history 栈上最新的条目 如：<code>history.replaceState({page: 3}, &quot;title 3&quot;, &quot;?page=3&quot;);</code></li><li><code>back()</code> 转到浏览器会话历史的上一页 等价于 <code>history.go(-1)</code></li><li><code>forward()</code> 转到浏览器会话历史的下一页 等价于 <code>history.go(1)</code></li></ul><p>还有一个比较重要的事件就是 <code>onpopstate</code>，用来监听浏览器的历史记录发生变化的。</p><h1 id="Router-实现"><a href="#Router-实现" class="headerlink" title="Router 实现"></a>Router 实现</h1><p>在了解完路由管理机制，接下来我们对  <code>Vue-Router</code>  和  <code>React-Router</code> 的功能实现做一个总结，一个基础的 <code>Router</code> 应该具备以下功能：</p><ul><li>路由中心，负责注册、匹配、存储等功能</li><li><code>router-view</code> 和 <code>router-link</code>组件实现</li><li>跳转api</li></ul><p>Router基本功能流程要点如下：</p><div class="mxgraph-container">    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/router-flow.drawio&quot;}"></div></div><p>接下来我们就按照每个功能模块进行简单实现。</p><h2 id="路由中心"><a href="#路由中心" class="headerlink" title="路由中心"></a>路由中心</h2><p>路由中心功能分为两块，一是注册管理，二是监听匹配。</p><h3 id="注册管理"><a href="#注册管理" class="headerlink" title="注册管理"></a>注册管理</h3><p>注册管理，顾名思义就是将所有路由对应页面组件配置统一管理，当路由改变的时候，可以直接从配置找到对应页面组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册路由</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; routes </span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; mode </span></span><br><span class="line"><span class="comment"> * @returns </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRouter</span>(<span class="params">routes, mode=<span class="string">'history'</span></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 保存路由</span></span><br><span class="line">    <span class="keyword">const</span> matcherMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> route <span class="keyword">of</span> routes) &#123;</span><br><span class="line">        matcherMap.set(route.name, route)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加路由</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addRoutes</span>(<span class="params">routes</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> route <span class="keyword">of</span> routes) &#123;</span><br><span class="line">            matcherMap.set(route.name, route)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除路由</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">removeRoutes</span>(<span class="params">routes</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> route <span class="keyword">of</span> routes) &#123;</span><br><span class="line">            matcherMap.delete(route.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取路由</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getRoutes</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> matcherMap</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取路由</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getRoute</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> matcherMap.get(name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> router = &#123;</span><br><span class="line">        addRoutes,</span><br><span class="line">        removeRoutes,</span><br><span class="line">        getRoutes,</span><br><span class="line">        getRoute</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> router</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由匹配"><a href="#路由匹配" class="headerlink" title="路由匹配"></a>路由匹配</h3><p>这里我们就简单实现一下，将 <code>path</code>作为 map 的 key 去存储，忽略一下比较复杂的情况，如： query 中 params和  <code>/path/:id</code>等情况</p><p>因此我们只需要通过获取 <code>matcherMap</code> 对象中对应的组件即可。</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>组件渲染，其实在 Vue 或者 React 中都有对应渲染组件的方法，这里为了更简单实现例子，我们使用了<code>Web Component</code>规范去实现自定义组件<code>&lt;router-view&gt;</code>展示和渲染组件。</p><p>分为两个功能点：</p><ol><li>自定义组件<code>&lt;router-view&gt;</code></li><li>匹配到路由组件后渲染对应组件</li></ol><h3 id="lt-router-view-gt-组件实现"><a href="#lt-router-view-gt-组件实现" class="headerlink" title="&lt;router-view&gt;组件实现"></a><code>&lt;router-view&gt;</code>组件实现</h3><p>这里使用 WebCompoent 去实现，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义路由组件</span></span><br><span class="line">customElements.define(<span class="string">'router-view'</span>, <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">const</span> template = <span class="built_in">document</span>.createElement(<span class="string">'template'</span>);</span><br><span class="line">        template.id = <span class="string">'router-view'</span>;</span><br><span class="line">        template.innerHTML = <span class="string">'&lt;div&gt;&lt;slot name="content"&gt;&lt;/slot&gt;&lt;/div&gt;'</span>;</span><br><span class="line">        <span class="keyword">const</span> templateContent = template.content;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> shadowRoot = <span class="keyword">this</span>.attachShadow(&#123; <span class="attr">mode</span>: <span class="string">"open"</span> &#125;);</span><br><span class="line">        shadowRoot.appendChild(templateContent.cloneNode(<span class="literal">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="渲染对应组件"><a href="#渲染对应组件" class="headerlink" title="渲染对应组件"></a>渲染对应组件</h3><p>当监听到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路由回调</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> route = match(<span class="built_in">window</span>.location)</span><br><span class="line">    <span class="keyword">if</span> (currentRoute &amp;&amp; currentRoute.path === route.path) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!route) &#123;</span><br><span class="line">        <span class="comment">// 路由不存在，跳转到首页</span></span><br><span class="line">        push(<span class="string">'/'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (route) &#123;</span><br><span class="line">        currentRoute = route</span><br><span class="line">        <span class="keyword">const</span> component = route.component</span><br><span class="line">        <span class="comment">// 渲染组件</span></span><br><span class="line">        <span class="built_in">document</span>.querySelector(<span class="string">'router-view'</span>).innerHTML = <span class="string">`&lt;<span class="subst">$&#123;component&#125;</span> slot="content"&gt;&lt;/<span class="subst">$&#123;component&#125;</span>&gt;`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码我放到 github 上，大家感兴趣可以去看看<a href="https://github.com/qiubohong/hundred-interview-questions/blob/main/5-router-component" target="_blank" rel="noopener">Github Router完整实现</a></p><p><a href="https://qborfy.com/code/face/router/index.html#/" target="_blank" rel="noopener">Demo体验可以看这里</a></p><h1 id="额外知识点"><a href="#额外知识点" class="headerlink" title="额外知识点"></a>额外知识点</h1><h2 id="WebComponent"><a href="#WebComponent" class="headerlink" title="WebComponent"></a>WebComponent</h2><blockquote><p>Web Component 是一套不同的技术，允许你创建可重用的定制元素（它们的功能封装在你的代码之外）并且在你的 web 应用中使用它们。 —— <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_components" target="_blank" rel="noopener">Web Component</a></p></blockquote><p>简单的理解，就是浏览器可以允许你自定义HTML 标签，且包含自定义的 CSS 样式和 JS 脚本逻辑。里面有三个点学习：</p><ul><li>Custom element（自定义元素），通过 JS 可以自定义 HTML 标签</li><li>Shadow DOM（影子 DOM），可以将HTML DOM 树以附加 Shadow DOM到自定义 HTMl 标签中，从而不影响原本 HTML DOM 树结构</li><li>HTML template（HTML 模板），支持<template> 和 <slot> 元素，使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用</slot></template></li></ul><h3 id="实践例子"><a href="#实践例子" class="headerlink" title="实践例子"></a>实践例子</h3><ol><li>自定义HTML 标签代码如下：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMl</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="comment">// 必须首先调用 super 方法</span></span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 shadow root</span></span><br><span class="line">        <span class="keyword">const</span> shadow = <span class="keyword">this</span>.attachShadow(&#123;<span class="attr">mode</span>: <span class="string">'open'</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 spans</span></span><br><span class="line">        <span class="keyword">const</span> wrapper = <span class="built_in">document</span>.createElement(<span class="string">'h1'</span>);</span><br><span class="line">        wrapper.innerHTML = <span class="string">'测试自定义元素'</span>;</span><br><span class="line"></span><br><span class="line">        shadow.appendChild(wrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首次被插入到文档 DOM 节点上时被调用</span></span><br><span class="line">    connectedCallback() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'首次被插入到文档 DOM 节点上时被调用'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当 custom element 从文档 DOM 中删除时，被调用</span></span><br><span class="line">    disconnectedCallback() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'当 custom element 从文档 DOM 中删除时，被调用'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当 custom element 被移动到新的文档时，被调用</span></span><br><span class="line">    adoptedCallback() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'当 custom element 被移动到新的文档时，被调用'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加、删除或者修改某个属性时被调用</span></span><br><span class="line">    attributeChangedCallback(name, oldValue, newValue) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'增加、删除或者修改某个属性时被调用'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注册组件标签，这里比较重要</span></span><br><span class="line">customElements.define(<span class="string">'custom-html'</span>, PopUpInfo);</span><br></pre></td></tr></table></figure><p>实际应用如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里就会展示h1 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">custom-html</span>&gt;</span><span class="tag">&lt;/<span class="name">custom-html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用 <code>template</code>模板 + <code>slot</code>插槽<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用模板 --&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"template"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- slot 通过 name 确定放在哪里 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"title"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自定义标签使用示范 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article-page</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- slot 标识使用哪个插槽 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">"title"</span>&gt;</span>这是标题<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">"content"</span>&gt;</span>这是内容<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">article-page</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="class"><span class="keyword">class</span> <span class="title">Article</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span></span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">constructor</span>()&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">super</span>();</span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> template = <span class="built_in">document</span>.getElementById(<span class="string">'template'</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> templateContent = template.content;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> shadowRoot = <span class="keyword">this</span>.attachShadow(&#123;<span class="attr">mode</span>: <span class="string">'open'</span>&#125;).appendChild(templateContent.cloneNode(<span class="literal">true</span>));</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        customElements.define(<span class="string">'article-page'</span>, Article);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History" target="_blank" rel="noopener">MDN History资料</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_components" target="_blank" rel="noopener">Web Component 自定义组件</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前端路由，大家都使用过，那么有没有想过它是怎么实现的吗？如：Vue-Router 或者 React-Router。或许有个大概印象，但是真正要自己去实现还是没有什么思路，那么这篇文章将完整的实现思路去实现一次。&lt;/p&gt;
&lt;p&gt;手写难度：⭐️⭐️⭐️&lt;/p&gt;
&lt;p&gt;涉及知识点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;history api 和监听事件&lt;/li&gt;
&lt;li&gt;onhashchange 监听事件&lt;/li&gt;
&lt;li&gt;Web Component 自定义组件&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/学习总结/"/>
    
    <category term="前端面试" scheme="https://www.qborfy.com/tags/前端面试/"/>
    
  </entry>
  
  <entry>
    <title>前端架构成长之路——微前端系列(二)之qiankun框架实战</title>
    <link href="https://www.qborfy.com/framework/frontend-microapp-2.html"/>
    <id>https://www.qborfy.com/framework/frontend-microapp-2.html</id>
    <published>2023-06-18T10:00:01.000Z</published>
    <updated>2023-06-16T09:13:18.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前有写过专门一篇关于微前端架构的基础知识——<a href="https://qborfy.com/framework/frontend-microapp-1.html" target="_blank" rel="noopener">《前端架构成长之路——微前端架构理论篇》</a>，但是里面主要讲几个点：</p><ul><li>微前端是什么，具体能做些什么</li><li>微前端的一些主流框架</li><li>微前端拆分项目的一些原则</li></ul><p>那么其实对于微前端应用还是有些不太清楚，下面就用微前端架构去对某个古老项目进行框架升级，这其实也是微前端架构主要特性之一，对项目升级的方案之一。</p><a id="more"></a><p>在使用 <code>qiankun</code>  框架之前，脑子里有几个疑问：</p><ul><li><code>qiankun</code> 是怎么做到将不同框架的项目放在一起，是通过打包，还是其他方式：<ul><li><code>qiankun</code> 是有<code>1个主基座</code> + <code>N 个微应用</code></li><li><code>qiankun</code> 利用路由控制，去加载不同的微应用，微应用与主应用之间消除跨域问题</li><li><code>qiankun</code> 需要在子应用里加入生命周期钩子函数提供给主应用调用</li></ul></li></ul><p>搞明白后，我们就可以开始进行项目实战，</p><h1 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h1><p>由于本次是将老项目升级到新版本框架中，因此将采用 Monorepo 架构对新老项目进行统一管理。项目结构大概 如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">qiankun-demo</span><br><span class="line">├── apps # 应用层</span><br><span class="line">|  ├── main #  基座项目</span><br><span class="line">|  |  ├── ...</span><br><span class="line">|  ├── old #  老版项目</span><br><span class="line">|  |  ├── ...</span><br><span class="line">|  └── new #  新版项目</span><br><span class="line">|     ├── ...</span><br><span class="line">├── README.md</span><br><span class="line">├── nx.json #  nx.js 管理Monorepo</span><br><span class="line">├── package.json</span><br><span class="line">├── pnpm-lock.yaml</span><br><span class="line">├── pnpm-workspace.yaml</span><br></pre></td></tr></table></figure><h2 id="main-基座项目"><a href="#main-基座项目" class="headerlink" title="main-基座项目"></a>main-基座项目</h2><p> <code>qiankun</code> 的基座项目和普通 web 项目初始化没有什么区别，你可以基于 <code>React</code>  或  <code>Vue</code> 作为基座项目框架都可以，但是需要入口文件需要做一下调整，下面我以 <code>Vue+Vite</code> 项目为例:</p><p>步骤一： 初始化项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm create vite@latest main-vue -- --template vue</span><br><span class="line"><span class="meta">#</span> 添加 qiankun</span><br><span class="line">npm i qiankun -S</span><br></pre></td></tr></table></figure><p>步骤二：在<code>main.ts</code>准备好基座项目以及注册微应用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; registerMicroApps, start , runAfterFirstMounted, setDefaultMountApp&#125; <span class="keyword">from</span> <span class="string">'qiankun'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./style.css'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Step1 初始化应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">createApp(App).mount(<span class="string">'#app'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Step2 注册子应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">registerMicroApps(</span><br><span class="line">    [</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">'old-web'</span>, <span class="comment">// 注册后子应用的名字 老项目启动端口为8080</span></span><br><span class="line">            entry: <span class="string">'//localhost:8080'</span>, <span class="comment">// 这里可以根据环境变量配置</span></span><br><span class="line">            container: <span class="string">'#subapp-viewport'</span>,</span><br><span class="line">            activeRule: <span class="string">'/old'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">'new-web'</span>, <span class="comment">// 注册后子应用的名字 新项目启动端口为8090</span></span><br><span class="line">            entry: <span class="string">'//localhost:8090'</span>,</span><br><span class="line">            container: <span class="string">'#subapp-viewport'</span>,</span><br><span class="line">            activeRule: <span class="string">'/new'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// qiankun 生命周期钩子 - 加载前</span></span><br><span class="line">        beforeLoad: [</span><br><span class="line">            (app) =&gt; &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'[LifeCycle] before load %c%s'</span>, <span class="string">'color: green;'</span>, app.name);</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">        beforeMount: [</span><br><span class="line">            (app) =&gt; &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'[LifeCycle] before mount %c%s'</span>, <span class="string">'color: green;'</span>, app.name);</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">        afterMount: [</span><br><span class="line">            (app) =&gt; &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'[LifeCycle] after mount %c%s'</span>, <span class="string">'color: green;'</span>, app.name);</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">        beforeUnmount: <span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'[LifeCycle] before Unmount %c%s'</span>, <span class="string">'color: green;'</span>, app.name);</span><br><span class="line">        &#125;,</span><br><span class="line">        afterUnmount: [</span><br><span class="line">            (app) =&gt; &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'[LifeCycle] after unmount %c%s'</span>, <span class="string">'color: green;'</span>, app.name);</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;,);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Step3 设置默认进入的子应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// setDefaultMountApp('/old');</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Step4 启动应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">start();</span><br><span class="line"></span><br><span class="line">runAfterFirstMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[MainApp] first app mounted'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="microapp-微应用"><a href="#microapp-微应用" class="headerlink" title="microapp-微应用"></a>microapp-微应用</h2><p>微应用其实改动代码不多，只是需要将qiankun 所需要的接口(<code>bootstrap</code>, <code>mount</code> <code>unmount</code>) 暴露出来即可</p><p>步骤一： 新建 <code>public-path.js</code> 代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要用来区分 qiankun 加载资源路径</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.__POWERED_BY_QIANKUN__) &#123;</span><br><span class="line">  __webpack_public_path__ = <span class="built_in">window</span>.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤二： 在 <code>app.js</code> 加入<code>qiankun</code>的接口，将 render 函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>)</span><br><span class="line"><span class="keyword">var</span> ReactDom = <span class="built_in">require</span>(<span class="string">'react-dom'</span>)</span><br><span class="line"><span class="keyword">var</span> ReactRouter2 = <span class="built_in">require</span>(<span class="string">'react-router'</span>)</span><br><span class="line"><span class="keyword">var</span> RouteConfig = <span class="built_in">require</span>(<span class="string">'./config/RouteConfig'</span>)</span><br><span class="line"><span class="keyword">var</span> Utils = <span class="built_in">require</span>(<span class="string">'radmin'</span>).Utils</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createHistory &#125; <span class="keyword">from</span> <span class="string">'history'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./public-path.js'</span></span><br><span class="line"><span class="keyword">import</span> ReactRouter, &#123; Router, Route, useRouterHistory &#125; <span class="keyword">from</span> <span class="string">'react-router'</span></span><br><span class="line"><span class="keyword">var</span> appHistory = useRouterHistory(createHistory)(&#123; <span class="attr">queryKey</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'../less/index.less'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。</span></span><br><span class="line"><span class="comment"> * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[react15] react app bootstraped'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">props = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[react15] props from main framework'</span>, props);</span><br><span class="line">  <span class="keyword">const</span> &#123; container &#125; = props;</span><br><span class="line">  <span class="comment">// 这里判断 container 是否qiankun 携带进来的</span></span><br><span class="line">  ReactDom.render(&lt;ReactRouter2.Router routes=&#123;Utils.combineConfig(RouteConfig)&#125; history=&#123;appHistory&#125; /&gt;, container ? container.querySelector('#react15Root') : document.getElementById('react15Root'))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export async function unmount(props) &#123;</span><br><span class="line">  const &#123; container &#125; = props;</span><br><span class="line">  ReactDOM.unmountComponentAtNode(</span><br><span class="line">    container ? container.querySelector('#react15Root') : document.getElementById('react15Root'),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">// 独立的时候可自主运行</span><br><span class="line">if (!window.__POWERED_BY_QIANKUN__) &#123;</span><br><span class="line">  bootstrap().then(mount);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">  window.bootstrap = bootstrap;</span><br><span class="line">  window.mount = mount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤三： 在<code>webpack.config.js</code>调整打包配置，将 <code>app.js</code>暴露到<code>window</code>中:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: [</span><br><span class="line">        path.resolve(__dirname, <span class="string">'./src/js/app'</span>)</span><br><span class="line">    ],</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'hot'</span>),</span><br><span class="line">        filename: <span class="string">'app.js'</span>,</span><br><span class="line">        library: <span class="string">`<span class="subst">$&#123;packageName&#125;</span>-[name]`</span>,</span><br><span class="line">        libraryTarget: <span class="string">'umd'</span>,</span><br><span class="line">        globalObject: <span class="string">'window'</span>,</span><br><span class="line">        jsonpFunction: <span class="string">`webpackJsonp_<span class="subst">$&#123;packageName&#125;</span>`</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了这里，基本上就可以完成项目改造工作了，但是后续还需要其他一些改动点，如：</p><ol><li>基座项目需要切换为真实域名，可以按照构建环境变量去切换</li><li>微应用需要注意资源使用相对路径</li><li>针对不同打包工具，都需要将<code>bootstrap</code> <code>mount</code> 函数进行暴露到 <code>window</code> 对象中，因为 <code>qiankun</code> 会拦截代理 <code>window</code>去运行微应用</li><li>需要解决不同应用之间的登录态等问题</li></ol><h1 id="qiankun-的缺陷"><a href="#qiankun-的缺陷" class="headerlink" title="qiankun 的缺陷"></a>qiankun 的缺陷</h1><p>虽然 qiankun 使用起来很简单，但是在实际应用还是存在一些缺陷，但是在将其引入到项目中的时候，需要考虑这些点：</p><ul><li>对于 jQuery 老项目支持度不够，即使有解决方案，但是需要对 qiankun 整个框架原理深入了解才能明白如何解决</li><li>沙箱隔离机制并不完美，如：写 css 代码挂载到 document.body，会导致样式污染</li><li>通讯机制较简单，基于一个全局的 globalState 对象，去提供给到各个微应用去使用</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://qiankun.umijs.org/zh" target="_blank" rel="noopener">qiankun官网</a></li><li></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;之前有写过专门一篇关于微前端架构的基础知识——&lt;a href=&quot;https://qborfy.com/framework/frontend-microapp-1.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《前端架构成长之路——微前端架构理论篇》&lt;/a&gt;，但是里面主要讲几个点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;微前端是什么，具体能做些什么&lt;/li&gt;
&lt;li&gt;微前端的一些主流框架&lt;/li&gt;
&lt;li&gt;微前端拆分项目的一些原则&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么其实对于微前端应用还是有些不太清楚，下面就用微前端架构去对某个古老项目进行框架升级，这其实也是微前端架构主要特性之一，对项目升级的方案之一。&lt;/p&gt;</summary>
    
    
    
    
    <category term="技术分享" scheme="https://www.qborfy.com/tags/技术分享/"/>
    
    <category term="架构系列" scheme="https://www.qborfy.com/tags/架构系列/"/>
    
  </entry>
  
  <entry>
    <title>前端架构——利用chatgpt成为架构师（1）</title>
    <link href="https://www.qborfy.com/framework/framework-with-chatgpt-1.html"/>
    <id>https://www.qborfy.com/framework/framework-with-chatgpt-1.html</id>
    <published>2023-05-26T10:00:01.000Z</published>
    <updated>2023-05-25T05:07:48.718Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“有时我对 ChatGPT 的理解能力感到惊讶，但是更多时候，我不得不拼命推动它，朝着我想要的方向前进。它有时会产生意料之外的结果，让我感到非常沮丧。”</p><p>“它像一个吸收了所有人类知识、但需要别人帮忙才能把这些知识串起来的应届毕业生。”</p><p>“看来我今年的工作是安全的。但是，我需要好好学习 ChatGPT，精通它的使用，让我明年也是安全的。”</p><p>最适用现在AI技术的一句话 —— <strong>AI 与人类不是竞争关系，它未必会减少机会，反而可能带来更多的机会。</strong></p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;“有时我对 ChatGPT 的理解能力感到惊讶，但是更多时候，我不得不拼命推动它，朝着我想要的方向前进。它有时会产生意料之外的结果，让我感到非常沮丧。”&lt;/p&gt;
&lt;p&gt;“它像一个吸收了所有人类知识、但需要别人帮忙才能把这些知识串起来的应届毕业生。”</summary>
      
    
    
    
    
    <category term="技术分享" scheme="https://www.qborfy.com/tags/技术分享/"/>
    
    <category term="每日更新" scheme="https://www.qborfy.com/tags/每日更新/"/>
    
    <category term="架构系列" scheme="https://www.qborfy.com/tags/架构系列/"/>
    
  </entry>
  
  <entry>
    <title>前端面试100道手写题（4）—— 深浅拷贝</title>
    <link href="https://www.qborfy.com/face100/4-deep-clone.html"/>
    <id>https://www.qborfy.com/face100/4-deep-clone.html</id>
    <published>2023-05-15T14:00:00.000Z</published>
    <updated>2023-05-24T03:22:02.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>深浅拷贝经典前端面试题，不仅仅只是实现逻辑，更加是对整个Javascript语言的实现背后一套理论，从基础数据类型到原型链一整套知识体系的熟悉程度，下面我们就从简单到困难一一实现。</p><p>手写难度：⭐️⭐️⭐️</p><p>涉及知识点：</p><ul><li>数据类型在内存空间的存储</li><li>原型以及原型链（这是实现拷贝一个重要知识点，如何拷贝自定义的类实例对象）<ul><li>如何拷贝一个原型对象 如： <code>a = {}; clone(a.__proto__)</code></li></ul></li><li>数组的判断</li><li>日期/正则等其他内置对象的拷贝</li><li>函数的拷贝</li></ul><a id="more"></a><h1 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h1><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>凡是遇到问题，多问一次自己为什么？—— 为什么在Javascript中会有【深拷贝】｜ 【浅拷贝】 区分的操作呢？</p><p>首先，我们回想一下，一开始我们学习语言的第一件事是什么（Hello World除外），是数据类型，Javascript中数据类型有以下几种：</p><ul><li>基础数据类型：number, string, boolean等</li><li>引用数据类型：object, array, date等</li></ul><p>然后，就是变量赋值，如： a = 1，b = new Date()，在 JavaScript 中分为两种：</p><ol><li>基础数据类型，值都有固定的大小，保存在栈内存中，由系统自动分配存储空间在栈内存空间的值，我们可以直接进行操作，因此基础数据类型都是按照值访问</li><li>复杂数据类型，值都保存在堆内存中的对象，引用类型的值都是按引用访问的，所以在操作对象时，实际上是操作对象的引用而不是实际的对象。引用可以理解为保存在栈内存中的一个地址，该地址指向堆内存中的一个实际对象</li></ol><p>因此，在复制值的时候，两种类型操作不一样，如下：</p><ol><li>基础类型复制，会在栈空间新建一个空间去进行复制</li><li>引用类型复制，系统会为新的变量自动分配一个新的栈内存空间这个栈内存空间保存着与被复制变量相同的指针，尽管他们在栈内存中的内存空间的位置互相独立但是在堆内存中访问到的对象实际上是同一个，因此，当我们改变其中一个对象的值时，实际上就是改变原来的对象</li></ol><p>简单的总结一下：</p><ol><li>基础类型的值长度是固定的，所以可以在栈空间分配存储空间，当进行复制的时候，可以直接在栈空间内新建一个存储空间进行赋值</li><li>引用类型的值长度是不固定的，所以需要在栈空间分配一个指针，然后在堆内存空间分配一个对象，将指针指向改对象，当进行复制的时候，需要在栈空间新建一个指针，然后指向之前在堆内存建的对象</li></ol><p>了解完为什么后，再去实现浅拷贝和深拷贝就会理所当然了。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>浅拷贝和深拷贝，在了解完【为什么】后，就很容易理解两者的区别：</p><ul><li>浅拷贝只会对引用类型的值做第一层堆内存进行拷贝</li><li>深拷贝除了会复制新建栈空间的值，同时还在将指向堆内存中对象进行新建</li></ul><p>那么为什么不都用深拷贝去实现就好了，那是因为在浅拷贝机制可以有效利用存储空间，同时浅拷贝的也存在一定应用场景：</p><ul><li>当需要统一管理引用值的变化时候，如：当 fetch 一个请求返回 json 数据后，当我们对其做修改调整后，其实不需要做深拷贝的</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>实现原理：只对引用类型数据做第一层值进行拷贝</p><p>步骤：</p><ol><li>判断数据类型，需要将所有引用类型数据判断一次</li><li>根据不同引用类型，将引用类型数据值进行复制新建一次，利用<code>Object.assign</code>或 <code>new +     return new obj.constructor(obj);</code> 进行复制进行</li><li>其中针对自定义类，如：<code>new A()</code>，需要通过继承其原型链，利用 <code>Object.getPrototypeOf</code></li><li>基础类型直接返回</li></ol><p>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型判断 主要基于 Object.prototype.toString.call</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Object]'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Array]'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为原型对象 如 a = new A();  a.__proto__ === A.prototype</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrototype</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Ctor = obj &amp;&amp; obj.constructor;</span><br><span class="line">    <span class="keyword">const</span> proto = (<span class="keyword">typeof</span> Ctor === <span class="string">'function'</span> &amp;&amp; Ctor.prototype) || <span class="built_in">Object</span>.prototype;</span><br><span class="line">    <span class="keyword">return</span> obj === proto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果不是对象类型 直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(obj === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isArray(obj) || isArrayBuffer(obj)) &#123;</span><br><span class="line">        <span class="keyword">return</span>  obj.slice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isObject(obj)) &#123;</span><br><span class="line">        <span class="comment">// 区分是内置 Object  还是自定义的类</span></span><br><span class="line">        <span class="keyword">if</span>(obj.constructor === <span class="built_in">Object</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrototype(obj)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">new</span> obj.constructor());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 自定义类新建实例化对象 保留原型链 从而保留原型方法或属性</span></span><br><span class="line">            <span class="keyword">const</span> newObj = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj));</span><br><span class="line">            <span class="comment">// 获取对象的所有属性</span></span><br><span class="line">            <span class="keyword">const</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(obj);</span><br><span class="line">            keys.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">                newObj[key] = obj[key];</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> newObj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他类型可以通过 new + constructor 来实现浅拷贝</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> obj.constructor(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>实现原理： 需要对整个对象的进行深度遍历赋复制新建，从而实现修改新建值不会影响到原有的值</p><p>步骤：</p><ol><li>数据类型判断和浅拷贝一致</li><li>针对不同引用类型需要遍历+递归实现值的拷贝新建</li></ol><p>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj, map = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果不是对象类型 直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(obj === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是 WeakMap 直接抛出异常 因为 WeakMap 无法遍历</span></span><br><span class="line">    <span class="keyword">if</span>(isWeakMap(obj)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'WeakMap can not be cloned'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isPrototype(obj)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">new</span> obj.constructor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相互引用的对象会导致死循环</span></span><br><span class="line">    <span class="keyword">if</span>(map.has(obj)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isArrayBuffer(obj)) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj.slice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isArray(obj)) &#123;</span><br><span class="line">        <span class="keyword">const</span> newArr = [];</span><br><span class="line">        map.set(obj, newArr);</span><br><span class="line">        obj.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            newArr.push(deepClone(item, map));</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isSet(obj)) &#123;</span><br><span class="line">        <span class="keyword">const</span> newSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        map.set(obj, newSet);</span><br><span class="line">        obj.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            newSet.add(deepClone(item, map));</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> newSet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isMap(obj)) &#123;</span><br><span class="line">        <span class="keyword">const</span> newMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">        map.set(obj, newMap);</span><br><span class="line">        obj.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">            newMap.set(key, deepClone(value, map));</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> newMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isRegx(obj)) &#123;</span><br><span class="line">        <span class="keyword">const</span> newRegx = <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj.source, obj.flags);</span><br><span class="line">        map.set(obj, newRegx);</span><br><span class="line">        <span class="keyword">return</span> newRegx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isDate(obj)) &#123;</span><br><span class="line">        <span class="keyword">const</span> newDate = <span class="keyword">new</span> <span class="built_in">Date</span>(obj.getTime());</span><br><span class="line">        map.set(obj, newDate);</span><br><span class="line">        <span class="keyword">return</span> newDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isError(obj)) &#123;</span><br><span class="line">        <span class="keyword">const</span> newError = <span class="keyword">new</span> <span class="built_in">Error</span>(obj.message);</span><br><span class="line">        map.set(obj, newError);</span><br><span class="line">        <span class="keyword">return</span> newError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isObject(obj)) &#123;</span><br><span class="line">        <span class="comment">// 区分是内置 Object  还是自定义的类</span></span><br><span class="line">        <span class="keyword">if</span>(obj.constructor === <span class="built_in">Object</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> newObj = &#123;&#125;;</span><br><span class="line">            map.set(obj, newObj);</span><br><span class="line">            <span class="comment">// 获取对象的所有属性 包括不可枚举属性</span></span><br><span class="line">            <span class="built_in">Reflect</span>.ownKeys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">                newObj[key] = deepClone(obj[key], map);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> newObj;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrototype(obj)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">new</span> obj.constructor());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 自定义类新建实例化对象 保留原型链 从而保留原型方法或属性</span></span><br><span class="line">            <span class="keyword">const</span> newObj = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj));</span><br><span class="line">            map.set(obj, newObj);</span><br><span class="line">            <span class="comment">// 获取对象的所有属性</span></span><br><span class="line">            <span class="keyword">const</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(obj);</span><br><span class="line">            keys.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">                newObj[key] = deepClone(obj[key], map);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> newObj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他类型可以通过 new + constructor 来实现拷贝返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> obj.constructor(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>浅拷贝和深拷贝作为前端面试经常会出现的题目，在做这篇题目之前，我对浅拷贝和深拷贝的其实是缺失的，即使网上的答案也只是做了一部分，当我深入阅读<code>lodash.Clone</code>和<code>lodash.deepClone</code>的源码才发现这里面隐藏的一些知识点，这里做一个阅读前和阅读后：</p><p>阅读源码前：</p><ul><li>浅拷贝只需要通过 Object.assigin就可以实现拷贝，但是从来没想过数据类型判断的重要性，包括自定义类对应实例的拷贝</li><li>深拷贝只需要解决数组遍历，以及解决循环依赖问题即可，忘记了还有Map/Set等新一代数据类型的遍历</li></ul><p>阅读源码后：</p><ul><li>数据类型判断才是拷贝的重要依据，根据不同类型需要做不同逻辑拷贝，而且 JavaScript 中的数据类型真的有很多，不仅只有 array object，还有常见Date，Regexp，或者冷门的 ArrayBuffer等</li><li>自定义类的拷贝也很复杂，同时也引出了原型对象(<strong>proto</strong> prototype)的拷贝，这里也加深我对JavaScript 原型的理解</li></ul><p>JavaScript 数据实例拷贝背后的原理，其实是 JavaScript 中不同数据类型存储值的方式需要去做不一样的处理，而引用类型最终在 JavaScript 中的实现就是依赖于原型和原型链去实现的。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://github.com/lodash/lodash/blob/master/.internal/baseClone.js#L236" target="_blank" rel="noopener">lodash baseClone 浅拷贝和深拷贝的基础实现方法</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;深浅拷贝经典前端面试题，不仅仅只是实现逻辑，更加是对整个Javascript语言的实现背后一套理论，从基础数据类型到原型链一整套知识体系的熟悉程度，下面我们就从简单到困难一一实现。&lt;/p&gt;
&lt;p&gt;手写难度：⭐️⭐️⭐️&lt;/p&gt;
&lt;p&gt;涉及知识点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据类型在内存空间的存储&lt;/li&gt;
&lt;li&gt;原型以及原型链（这是实现拷贝一个重要知识点，如何拷贝自定义的类实例对象）&lt;ul&gt;
&lt;li&gt;如何拷贝一个原型对象 如： &lt;code&gt;a = {}; clone(a.__proto__)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数组的判断&lt;/li&gt;
&lt;li&gt;日期/正则等其他内置对象的拷贝&lt;/li&gt;
&lt;li&gt;函数的拷贝&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/学习总结/"/>
    
    <category term="前端面试" scheme="https://www.qborfy.com/tags/前端面试/"/>
    
  </entry>
  
  <entry>
    <title>前端面试100道手写题（3）—— EventBus</title>
    <link href="https://www.qborfy.com/face100/3-event-bus.html"/>
    <id>https://www.qborfy.com/face100/3-event-bus.html</id>
    <published>2023-05-06T14:00:00.000Z</published>
    <updated>2023-07-13T08:27:01.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>EventBus作为发布订阅设计模式的经典应用场景，很值得我们去学习研究它的实现原理。</p><p>手写难度：⭐️⭐️</p><a id="more"></a><p>可以直接去看完整源码地址（记得给个star），地址如下：</p><p><a href="https://github.com/qiubohong/hundred-interview-questions/tree/main/3-event-bus" target="_blank" rel="noopener">https://github.com/qiubohong/hundred-interview-questions/tree/main/3-event-bus</a></p><h1 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>EventBus其实是一个技术概念，主要是通过事件订阅方式解决不同情况下消息通讯问题，不仅仅在前端，还在Native（Android）等各个地方都有在使用。</p><p>EventBus 可以分成下面四个部分：</p><ul><li>订阅者 Subscriber： 监听某类事件，当发布者触发该类事件后执行所需要的事件。</li><li>发布者 Publisher：当满足某些条件，发布触发订阅者的事件。</li><li>消息 Event：其实就需要传递的消息或事件本身。</li><li>消息中心 EventStore: 负责存储消息与订阅者的对应关系，有消息触发时，负责通知订阅者。</li></ul><p>几者的关系如下图所示：</p><div class="mxgraph-container">    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/event-bus.drawio&quot;}"></div></div><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>上面是讲了一些概念性，但是在实际开发中，EventBus其实已经很多地方在使用了，如：</p><ul><li>Vue2中的<code>$emit</code> <code>$on</code>其实就是利用EventBus实现的，同时还可以使用去实现跨组件实现通讯</li><li>Node.js中的的<code>EventEmitter</code>，支持<code>on</code> <code>emit</code>，可以利用其解决<code>回调地狱</code>问题</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>EventBus主要有几个方法：</p><ul><li><code>on(event, func)</code> 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。</li><li><code>emit(event, ...args)</code> 按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false。</li><li><code>once(event, func)</code> 为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。</li><li><code>off(event, func)</code> 移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。</li><li><code>offAll(event)</code> 移除所有事件的所有监听器</li></ul><p>下面是实现代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventBus</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// 消息队列 存储事件和回调</span></span><br><span class="line">        <span class="keyword">this</span>.listeners = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订阅事件</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; event </span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; callback </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    on(event, callback) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.listeners[event]) &#123;</span><br><span class="line">            <span class="keyword">this</span>.listeners[event] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.listeners[event].push(callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注销事件</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; event </span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; callback </span></span><br><span class="line"><span class="comment">     * @returns </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    off(event, callback) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.listeners[event]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.listeners[event] = <span class="keyword">this</span>.listeners[event].filter(<span class="function"><span class="params">listener</span> =&gt;</span> listener !== callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发布触发事件</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; event </span></span><br><span class="line"><span class="comment">     * @param  &#123;...any&#125; args </span></span><br><span class="line"><span class="comment">     * @returns </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    emit(event, ...args) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.listeners[event]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.listeners[event].forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener(...args));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只触发一次的事件</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; event </span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; callback </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    once(event, callback) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.listeners[event]) &#123;</span><br><span class="line">            <span class="keyword">this</span>.listeners[event] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> onceCallback = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">            callback(...args);</span><br><span class="line">            <span class="keyword">this</span>.off(event, onceCallback);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.listeners[event].push(onceCallback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注销某个事件的所有回调</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; event </span></span><br><span class="line"><span class="comment">     * @returns </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    offAll(event) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.listeners[event]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.listeners[event] = [];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> eventBus = <span class="keyword">new</span> EventBus();</span><br><span class="line">    eventBus.on(<span class="string">'test'</span>, (a, b) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a, b);</span><br><span class="line">    &#125;);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        eventBus.emit(<span class="string">'test'</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>EventBus模式使用上需要注意的问题：</p><ul><li>如果<code>on</code>注册多次，可能会导致一次<code>emit</code>就会执行多次函数，导致无法定位到哪里注册多，因此使用的时候，需要考虑什么时候把事件<code>off</code></li><li><code>off</code>需要明确指出函数对象，所以我们的注册函数建议都通过声明函数去实现，而不是匿名函数，减少注销事件的麻烦</li><li><code>on</code>注册事件，事件名建议使用静态常量，而不是字符串，更加容易管理事件中心</li></ul><h1 id="额外知识"><a href="#额外知识" class="headerlink" title="额外知识"></a>额外知识</h1><h2 id="为什么Vue3实例不再支持-emit-on"><a href="#为什么Vue3实例不再支持-emit-on" class="headerlink" title="为什么Vue3实例不再支持 emit on"></a>为什么Vue3实例不再支持 <code>emit</code> <code>on</code></h2><p>官方解释如下：</p><ul><li>Vue 1.x的时候是实现类似Angular的组件事件系统，利用<code>$dispatch</code>与<code>$broadcast</code>实现向上和向下发送事件来进行通信</li><li>在Vue 2中，取消了<code>$dispatch</code>与<code>$broadcast</code>，从而能更多状态驱动的数据流，其实就是单向数据流的状态扭转，</li><li>Vue2中， <code>$emit</code>用于触发由父组件的声明事件，<code>$on</code> <code>$off</code> <code>$once</code>都是这类事件的扩展，但是这仅仅是一个过程，且很少被使用</li><li>因此，没有充分的理由去让它们暴露在组件实例上，所以最终决定将删除<code>$on</code> <code>$off</code> <code>$once</code>等实例方法</li></ul><p>解决方案：</p><ol><li>使用<code>vue3-bus</code>，基于Vue插件机制</li><li>不借助Vue插件实现的，官方推荐的<a href="https://github.com/developit/mitt" target="_blank" rel="noopener">mitt</a></li></ol><p>原文地址：<a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0020-events-api-change.md" target="_blank" rel="noopener">active-rfcs/0020-events-api-change.md</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://juejin.cn/post/6844904101331877895" target="_blank" rel="noopener">从发布订阅模式入手读懂Node.js的EventEmitter源码</a></li><li><a href="https://www.runoob.com/nodejs/nodejs-event.html" target="_blank" rel="noopener">Node.js EventEmitter</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;EventBus作为发布订阅设计模式的经典应用场景，很值得我们去学习研究它的实现原理。&lt;/p&gt;
&lt;p&gt;手写难度：⭐️⭐️&lt;/p&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/学习总结/"/>
    
    <category term="前端面试" scheme="https://www.qborfy.com/tags/前端面试/"/>
    
  </entry>
  
  <entry>
    <title>前端面试100道手写题（2）—— throttle与debounce</title>
    <link href="https://www.qborfy.com/face100/2-throttle-debouce.html"/>
    <id>https://www.qborfy.com/face100/2-throttle-debouce.html</id>
    <published>2023-04-19T14:00:00.000Z</published>
    <updated>2023-04-26T13:48:53.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前端面试100道手写题第二篇《throttle与debounce》，说一下为什么选这两个，其实大家都有在用，我们先来了解一下两个函数的作用：</p><ul><li>debounce 防抖，用于减少函数触发的频率，在一个delay时间内，如果触发delay时间归零，直到delay时间到才会触发函数</li><li>throttle 节流，用于限制函数触发的频率，每个delay时间间隔，最多只能执行函数一次</li></ul><p>选这两个手写的原因其实很简单，就是面试频率高，而且项目实战会经常用到，同时里面还会隐藏一些知识点和目前公共库的一些问题（见文章末尾）。</p><p>接下来就让我们开始手写撸代码吧！</p><p>手写难度：⭐️⭐️⭐️</p><a id="more"></a><p>不想看啰里吧嗦的文字，可以直接去看完整源码地址（记得给个star），地址如下：</p><p><a href="https://github.com/qiubohong/hundred-interview-questions/tree/main/2-debouce-throttle" target="_blank" rel="noopener">https://github.com/qiubohong/hundred-interview-questions/tree/main/2-debouce-throttle</a></p><h1 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h1><p>很多功能函数只要搞清楚他们的功能设计，基本上你就可以手写出完整的代码。<br>以<a href="https://github.com/lodash/lodash/blob/master/debounce.js" target="_blank" rel="noopener">lodash.debounce</a>为参考，接下来我们来拆解一下完整的debounce的功能具体有哪些：</p><ul><li>构造函数 <code>debounce(func, waitTime, maxWait, leading, trailing)</code><ul><li>func (Function): 要防抖的函数。</li><li>[wait=0] (number): 需要防抖的毫秒。</li><li>[leading=false] (boolean): 指定调用在防抖开始前。</li><li>[trailing=true] (boolean): 指定是否在最大等待时间过期后直接调用，简单点的当超过等待时间，则会触发函数</li><li>[maxWait=wait] (number): 设置最大等待时间过期。</li></ul></li><li>取消函数 <code>debounceReturn.cancel()</code> ， <code>debounceReturn</code>是执行完debounce函数返回的对象</li><li>状态函数 <code>debounceReturn.pending()</code></li><li>立即调用函数 <code>debounceReturn.flush()</code></li></ul><p>上面是<code>lodash</code>给出debounce的完整功能，但是如果是我们仅仅需要简易版本的throttle，应该如何实现呢？</p><p>拆解步骤一：实现一个简单版</p><p><code>debounce()</code>函数最简单功能就是，希望能在wait时间段禁止重复触发某个事件，第一个简易版如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce_easy</span>(<span class="params">func, waitTime</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 用于存储定时器</span></span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="comment">// 存储返回结果</span></span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="comment">// 如果定时器存在，就清除定时器</span></span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        <span class="comment">// 重新设置定时器</span></span><br><span class="line">        timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 执行函数，将当前作用域绑定的this和参数传递过去</span></span><br><span class="line">            result = func.apply(context, args);</span><br><span class="line">        &#125;, waitTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单元测试</span></span><br><span class="line"><span class="keyword">const</span> debounced = debounce_easy(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'debounce_easy:'</span>, value)</span><br><span class="line">    ++callCount;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;, <span class="number">32</span>);</span><br><span class="line"><span class="comment">// 这里等同于快速触发4次，只有最后一次生效 输出 debounce_easy: d</span></span><br><span class="line"><span class="keyword">const</span> results = [debounced(<span class="string">'a'</span>), debounced(<span class="string">'b'</span>), debounced(<span class="string">'c'</span>), debounced(<span class="string">'d'</span>)];</span><br><span class="line"><span class="keyword">let</span> lodashResults = [lodashDebouce(<span class="string">'a'</span>), lodashDebouce(<span class="string">'b'</span>), lodashDebouce(<span class="string">'c'</span>), lodashDebouce(<span class="string">'d'</span>)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// callCount: 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'callCount:'</span>, callCount)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// callCount: 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'callCount:'</span>, callCount)</span><br><span class="line">&#125;, <span class="number">160</span>);</span><br></pre></td></tr></table></figure><p>拆解步骤二：leading参数希望可以先执行一次函数，再进行防抖， 具体代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其实就是在定时器之前判断 leading和 timeout定期器是否不为空即可 关键代码如下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果leading为true，就立即执行函数</span></span><br><span class="line"><span class="keyword">if</span> (leading) &#123;</span><br><span class="line">    <span class="comment">// 如果定时器不存在，就执行函数，从而避免重复执行</span></span><br><span class="line">    <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">        invokeFunc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拆解步骤三：加上cancel等函数实现，这里能实现完基本上手写题就80分了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取消防抖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> cancel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(timeout)</span><br><span class="line">    lastArgs = lastThis = timeout = <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拆解步骤四：加上参数 <code>traling+maxWait</code> 函数，作用在当超过maxWait等待时间后，函数会</p><p>重点在于判断是否过了等待时间，所以需要记录每次执行的时间，当超过的时候判断是否有传参数<code>traling+maxWait</code></p><p>实现步骤如下流程所示：</p><div class="mxgraph-container">    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/debounce.drawio&quot;}"></div></div><p>参数解释：</p><ul><li>lastArgs,  // 上一次调用时的参数</li><li>lastThis,  // 上一次调用时的this</li><li>result,  // 上一次调用的返回值</li><li>lastCallTime,  // 上一次调用的时间</li><li>lastInvokeTime = 0,  // 上一次执行的时间</li><li>leading = false,  // 是否立即执行</li><li>maxing = false,  // 是否有最大等待时间</li><li>trailing = true; // 是否在最后一次调用后执行</li></ul><h1 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h1><p><code>throttle</code>节流函数定义：就是无论频率多快，每过一段时间就执行一次。</p><p>在实现逻辑上其实是可以看做<code>debounce</code>的一种升级版，只需要保证debounce函数在超时后执行一次函数即可</p><p>只要针对debouonce函数设置一下参数即可，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait, leading = true</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> debounce(func, wait, &#123;</span><br><span class="line">        leading,</span><br><span class="line">        trailing: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">'maxWait'</span>: wait <span class="comment">// 超时时间和控制时间一致就可以了</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然我们也可以实现一个快速简单版，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle_eazy</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> lastInvokeTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">const</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">invokeFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            lastInvokeTime = <span class="built_in">Date</span>.now();</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        wait = +wait || <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 计算剩余时间</span></span><br><span class="line">        <span class="keyword">let</span> remainTime = wait;</span><br><span class="line">        <span class="comment">// 如果上次执行时间大于0，说明已经执行过了，计算剩余时间</span></span><br><span class="line">        <span class="keyword">if</span>(lastInvokeTime &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            remainTime = wait - (<span class="built_in">Date</span>.now() - lastInvokeTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果剩余时间小于等于0，说明可以执行了，重置上次执行时间</span></span><br><span class="line">        <span class="keyword">if</span> (remainTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            invokeFunc();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经开始计时，说明已经有定时器了，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则，开始计时</span></span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            invokeFunc();</span><br><span class="line">        &#125;, remainTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单元测试</span></span><br><span class="line">; (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> throttled = throttle(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello'</span>, count);</span><br><span class="line">    &#125;, <span class="number">200</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'触发i~'</span>, i * <span class="number">100</span>)</span><br><span class="line">            throttled();</span><br><span class="line">        &#125;, <span class="number">100</span> * i);</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 正确输出10</span></span><br><span class="line">        <span class="built_in">console</span>.log(count);</span><br><span class="line">    &#125;, <span class="number">2200</span>);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h1 id="额外知识点"><a href="#额外知识点" class="headerlink" title="额外知识点"></a>额外知识点</h1><h2 id="TDD开发模式"><a href="#TDD开发模式" class="headerlink" title="TDD开发模式"></a>TDD开发模式</h2><p>一般写这些工具函数，都需要提前想好单元测试怎么写，这就是涉及一种开发模式<a href="https://juejin.cn/post/6844903780970921991" target="_blank" rel="noopener">测试驱动开发（TDD）</a>，主要遵循以下两个原则：</p><ul><li>仅在自动测试失败时才编写新代码。</li><li>消除重复设计（去除不必要的依赖关系），优化设计结构（逐渐使代码一般化）。</li></ul><p>TDD的研发流程如下：</p><div class="mxgraph-container">    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/tdd.drawio&quot;}"></div></div><h2 id="lodash的缺陷"><a href="#lodash的缺陷" class="headerlink" title="lodash的缺陷"></a>lodash的缺陷</h2><p>如果你正在使用lodash，你应该关注一下，因为lodash的github最后一次更新2021年4月24号，到目前为止已经有两年的时间没有更新，已经堆积很多issues，从上面解读源码的时候就发现一个<code>lodash.throttle</code>的一个bug，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> changeInput = throttle(<span class="function">(<span class="params">value: string</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;, <span class="number">1000</span>, &#123;</span><br><span class="line">  leading: <span class="literal">false</span>,</span><br><span class="line">  trailing: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 上述防抖函数将不会按照我们所设想的每隔1秒触发，而是会出现各种异常情况，如果触发频率够高可能会执行，如果触发频率低于1秒则不会执行，因为leading和trailing都设置为false，lodash源码没有针对这一情况进行处理，或者不支持trailing参数设置即可</span></span><br></pre></td></tr></table></figure><p>同时，lodash还有其他一些缺陷：</p><ul><li>lodash是支持tree shaking，但是这么写<code>import {throttle} from &#39;lodash&#39;</code> 会将整个lodash包都引入， 必须这么写<code>import throttle from &#39;lodash/throttle&#39;</code>才能做到按需加载</li><li>进入 npm 上的 lodash 包，它被列为 v4.17.21，并且已经 2 年多没有发布了：<a href="https://www.npmjs.com/package/lodash" target="_blank" rel="noopener">https://www.npmjs.com/package/lodash</a></li></ul><p>当然作为一个工具库lodash确实可以让我们少写很多代码，但是已经很长时间没有维护的问题还是需要关注的。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>Lodash源码：<a href="https://github.com/lodash/lodash/" target="_blank" rel="noopener">https://github.com/lodash/lodash/</a></li><li><a href="https://juejin.cn/post/6844903780970921991" target="_blank" rel="noopener">测试驱动开发（TDD）总结——原理篇</a></li><li><a href="https://news.ycombinator.com/item?id=35056136" target="_blank" rel="noopener">Hacker News——不要再使用的Lodash</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前端面试100道手写题第二篇《throttle与debounce》，说一下为什么选这两个，其实大家都有在用，我们先来了解一下两个函数的作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;debounce 防抖，用于减少函数触发的频率，在一个delay时间内，如果触发delay时间归零，直到delay时间到才会触发函数&lt;/li&gt;
&lt;li&gt;throttle 节流，用于限制函数触发的频率，每个delay时间间隔，最多只能执行函数一次&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;选这两个手写的原因其实很简单，就是面试频率高，而且项目实战会经常用到，同时里面还会隐藏一些知识点和目前公共库的一些问题（见文章末尾）。&lt;/p&gt;
&lt;p&gt;接下来就让我们开始手写撸代码吧！&lt;/p&gt;
&lt;p&gt;手写难度：⭐️⭐️⭐️&lt;/p&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/学习总结/"/>
    
    <category term="前端面试" scheme="https://www.qborfy.com/tags/前端面试/"/>
    
  </entry>
  
  <entry>
    <title>《高效能人士的7个习惯》，怎么做才能提高做事效率？</title>
    <link href="https://www.qborfy.com/study/seven-habbit.html"/>
    <id>https://www.qborfy.com/study/seven-habbit.html</id>
    <published>2023-04-19T05:00:00.000Z</published>
    <updated>2023-07-27T05:30:59.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高效能人士的7个习惯"><a href="#高效能人士的7个习惯" class="headerlink" title="高效能人士的7个习惯"></a>高效能人士的7个习惯</h1><p>不管是工作还是学习，有些人做事的效率很高，而有些做事的效率就很低，那么有什么方式可以提高自己的工作效率，这本书主要就是讲如何去培养自己高效能的习惯，改变自己的做事和思考的方式。</p><a id="more"></a><h1 id="阅读摘要"><a href="#阅读摘要" class="headerlink" title="阅读摘要"></a>阅读摘要</h1><ul><li>如何使用本书<ul><li>不要浅尝即止，而是需要针对每个习惯去不断做练习，做到知行合一</li><li>结合每个章节末尾中行动指引，需要付诸行动，方便实战统计</li><li>有了新的体会或者实践了，需要去做分享，把自己当成老师</li><li>前三个习惯是培养自己的独立与自信</li><li>后三个习惯是扩大自己的影响力与搭建人际关系</li><li>最后一个习惯，是将前六个习惯加强，不断充电</li></ul></li><li>7个习惯的简要定义与架构图<ul><li>7个习惯的简要定义如下：<ul><li>习惯一：积极主动，采取主动，为过去、现在以及未来的选择负责，主动选择，摈弃被动（受害者），创造自己的人生</li><li>习惯二：以终为始，做事情基本上都需要有目标，并根据这个目标，全身心投入，同时领导工作的核心就是基于共有的使命、愿景和价值观，创造文化</li><li>习惯三：要事第一，需要明白什么是要事，不论其他的事情多紧迫，要事都是要排在第一位的</li><li>习惯四：双赢思维，基于互敬、互惠的思考框架，目的是分享资源，而不是敌对竞争，从互赖式的角度思考问题，重点是协助或者找人快速解决问题</li><li>习惯五：知彼解己，耐心倾听别人，坦诚对待别人，平衡两者，提高沟通效率</li><li>习惯六：统合综效，创造性合作，制造1+1&gt;2的效果</li><li>习惯七：不断更新，如何在四个生活基本面（身体、精神、智力、社会/情感）中，不断更新自己。</li></ul></li><li>7个习惯分为三个时期：<ul><li>依赖期：没有独立，没任何高效的习惯</li><li>独立期：拥有积极主动、以终为始，要事第一的习惯</li><li>互赖期：拥有双赢思维、知彼解己、统合综效的习惯</li></ul></li></ul></li><li>第1部分 思维方式与原则<ul><li>第一章 由内到外全面造就自己<ul><li>没有正确的生活，就没有真正卓越的人生。 —— 戴维·斯塔·乔丹（David Starr Jordan） ｜ 美国生物学家及教育家<ul><li>表达的是，如果你没有选择正确的生活方式，你就不可能会成功</li></ul></li><li>现实中的问题，协调工作与生活，总结如下：<ul><li>事业成功，牺牲家庭生活</li><li>很忙，不知道工作有什么意义</li><li>无法找到高效的员工，即使很多管理课程也无法回答我的问题</li><li>要做的事太多，时间不够用</li><li>嫉妒别人的成就</li><li>个性要强，希望能控制整个过程</li><li>婚姻变得平淡无趣，没有再有爱情的感觉</li><li>孩子不听话</li><li>教育孩子有自己的主动去工作，但是又不希望主动提醒</li><li>不断减肥，不断失败</li></ul></li><li>思维方式是如何影响我们的观点，进而影响我们的做出种种行为<ul><li>期望理论</li><li>自我实现预言</li><li>皮格马利翁效应</li></ul></li><li>要改变现在的生活，就要改变自己，最重要是改变自己对问题的看法</li><li>品德与魅力，孰轻孰重<ul><li>现在社会宣传个人魅力可以速成，往往忽略了品德的重要性，从而导致我们花很多在花言巧语，玩弄手段，拍马屁去速成魅力</li><li>其实这就是两种思维模式，但是却影响了很多人的选择</li></ul></li><li>思维模式是我们每个人基本的东西，可以比作人生地图，它会指引我们走向哪里</li><li>每个人的大脑中有两张地图：<ul><li>一张是反应现实中的地图，如：颜色、物质等</li><li>一张是依据思维模式的地方，如：价值观、世界观等</li></ul></li><li>所以个人魅力论只是改变一个人表面现象，而品德成功论则是从本质思维模式上去发生改变</li><li>一个人的思维方式越符合这些原则或者自然法则，就越能正确而高效地生活。原则如下：<ul><li>公平原则，平等与正义来源于此</li><li>诚信与正直，人类相互信任的基础</li><li>服务原则，就是贡献自我，从而到讲求品质和追求卓越</li><li>潜能原则，人类可以不断进步成长，再到释放潜能与施展才华</li></ul></li><li>我们不了解自己，也不理解自己，但是知道别人眼中的自己应该是什么样子的，不再健谈而是闲谈，不再开怀大笑而是挤出笑容，不再痛苦而是绝望，而这种缺陷让他们沦陷，与芸芸大众无所区别，丧失自己的独立性</li><li>教导孩子也要因时而异。在关系和气氛紧张的时候，教导会被视为一种评判与否定；关系融洽的时候，在私下里对孩子循循善诱效果会加倍。</li><li>我们需要新的、更深层次的思想水平，即基于原则的思维方式，它能正确引导我们实现高效能，改善人际关系，解决深层问题。</li><li>本书的核心思想：<ul><li>强调以原则为中心，以品德为基础，要求“由内而外”地实现个人效能和人际效能。</li></ul></li><li>实践测试：<ul><li>是否曾经做过推测发现自己判断过于武断？请描述该段经历</li><li>当时的推测是什么？</li><li>做过其他推测，将某一项采取什么行动？</li></ul></li><li>检验你的思维方式<ul><li>你是否到过其他地区？有没有觉得很奇怪的行为?</li><li>人们的行为是否是你的预期？你对他们的行为有什么看法？</li><li>回想你的旅游经历，认为当地人对你的看法？是否认为他们对你的看法与你对他们的看法很类似？</li><li>如果你在旅游中有机会认识当地人？你对他们的看法或推测会有什么改变？</li></ul></li><li>转换思维方式<ul><li>去上班的路径有分哪几种？是否有些路径比其他路径更加复杂？是否有一条路径比较方便？为什么方便、为什么不方便？</li><li>你是否发现过一条你以前不知道的路径？走不同路径的的新鲜感如何？</li><li>现在想一下你与他人打交道的方式，是否有好几种？你还会尝试哪些新的方式？</li></ul></li><li>影响你生活的五个原则<ul><li>请列出影响生活的五个原则？分别以什么样的方式影响？是积极的还是消极的<ul><li>影响我生活的五个原则，<ul><li>睡眠时间一定要够，如果不够的话很可能会导致接下来一段时间非常难受</li><li></li></ul></li></ul></li></ul></li></ul></li><li>第二章 七个习惯概论<ul><li>习惯对我们的生活有极大的影响，因为它是一贯的，在不知不觉中，经年累月影响着我们的品德，暴露出我们的本性，左右着我们的成败。人的行为总是一再重复。因此卓越不是一时的行为，而是习惯。 —— 亚里士多德（Aristotle） ｜ 古希腊哲学家、文艺理论家<ul><li>表达的是习惯就是我们的生活方式，将会影响我们的方方面面，所以我们需要更加重视培养我们一些好的习惯。</li></ul></li><li>思想决定行动，行动决定习惯，习惯决定品德，品德决定命运。</li><li>习惯是由“知识”、“技巧”与“意愿”相互交织的结果。<ul><li>知识，是理论范畴，指点做什么、为什么这么做</li><li>技巧，是告诉我们怎么做</li><li>意愿，是推荐我们去做的动力源</li></ul></li><li>改变习惯是一个痛苦的过程，这往往需要我们有更高的目标，面对未来更美好的目标去牺牲当下的一些享受</li><li>7个习惯并不是分散开，而是一个系统养成习惯，会成螺旋上升的，从摆脱依赖到独立到互相依赖，最后利用更新学习去加强前面<ul><li>依赖期，以你为核心</li><li>独立期，以我为核心</li><li>互赖期，以我们为核心</li><li>自我更新，将上面的人生3个阶段包含起来，形成不断更新，螺旋上升的成长过程</li></ul></li><li>效能的定义，其实就是遵循”产出/产能平衡“原则<ul><li>鹅下金蛋的故事，金蛋是产出，而鹅才是资产或者产能，”重蛋轻鹅“则会失去资产最终无法获得可持续产出，”重鹅轻蛋“则会因为没有产出而饿死</li></ul></li><li>如何做到让女儿可以心甘情愿去打扫房间，其实就是打扫房间是产出，而女儿是能打扫房间的产能<ul><li>如果用强迫的方式让女儿打扫卫生，则会失去女儿的幸福，就是产能</li><li>如果不打扫，则没有产出</li><li>如果我们增加女儿的幸福感，如：答应她去一次她想去的地方，就是产能，从而促进她去打扫的动力</li></ul></li><li>效能是7个习惯的基础，只有搞明白效能的核心=产出/产能的平衡，才能更好的去培养习惯</li><li>7个习惯的评分项<ul><li>情感账户<ul><li>信守承诺</li><li>待人和蔼、体谅对方</li><li>不在背后说坏话</li></ul></li><li>产出、产能平衡<ul><li>在生活、工作保持适当的平衡</li><li>致力于某个项目，总是想着雇主的需求和厉害关系</li><li>努力工作，但是不会把自己搞的太疲惫</li></ul></li><li>积极主动<ul><li>能掌控自己的生活</li><li>注意力集中在能有所为的事情上，而不是集中在我无法控制的事情上</li><li>为情绪负责，而不是埋怨周围</li></ul></li><li>以终为始<ul><li>明白对生活的追求</li><li>生活和工作井然有序，很少陷入危机</li><li>每周都一个清晰的计划，注明我想完成的事情</li></ul></li><li>要事第一<ul><li>致力于完成自己的事情，不延误</li><li>不让日常琐事埋没真正重要的事务</li><li>每天做的事情都是有意义的，有利于我的生活目标</li></ul></li><li>双赢思维<ul><li>关心别人的成功，就像关心自己的成功一样</li><li>能与别人合作</li><li>遇到矛盾的时候，努力寻求有利于各方的解决方案</li></ul></li><li>知彼解己<ul><li>对他人的感觉很敏感</li><li>尽力理解别人的观点</li><li>试图从对方的角度，而不是从自己的角度看待问题</li></ul></li><li>统合综效<ul><li>赞赏别人的见解</li><li>寻求新的解决方案</li><li>鼓励别人表达他们的观点</li></ul></li><li>不断更新<ul><li>珍惜身体健康</li><li>建立和改善他人的人际关系</li><li>花时间和钱追求生活的意义和乐趣</li></ul></li></ul></li><li>实践问题<ul><li>列出一个好习惯和坏习惯<ul><li>好习惯：开始坚持每天记录事情和坚持学习</li><li>坏习惯：晚睡</li></ul></li><li>打破坏习惯的一切努力，立即行动的事情和过程<ul><li>打破晚睡的习惯的行为，就是早点上床，丢掉手机</li></ul></li><li>你处于人生哪个节点（依赖、独立、互赖），是什么行为或原因让你处于这个节点，你开始看到自己需要在哪方面需要努力吗？<ul><li>处于独立时期，往互赖期去走</li><li>人际关系，与人合作上在花时间去努力</li></ul></li></ul></li></ul></li></ul></li><li>第2部分 个人领域的成功：从依赖到独立<ul><li>第三章 习惯一 积极主动 —— 个人愿景的原则<ul><li>人性的本质是主动而非被动的，人类不仅能针对特定环境选择回应方式，更能主动创造有利的环境。</li><li>采取主动不等于胆大妄为、惹是生非或滋事挑衅，而是要让人们充分认识到自己有责任创造条件。</li><li>最令人鼓舞的事实，莫过于人类确实能主动努力以提升生命价值。——亨利·戴维·梭罗（Henry David Thoreau） ｜ 美国文学家及哲学家<ul><li>表达的是，主动是人类最大的优点，主动创造有利于自己的环境的从而提升生命的价值</li></ul></li><li>将自己从自己剥离出来，如在房间内，把自己想成一个灯，用心观察自己的，看看自己的状态是什么样子的？这就是客观的看待自己</li><li>社会之镜，从周边的对自己看法进行自我认知，这就等于面对哈哈镜看自己，看的不是真正的自己</li><li>环境与条件对我们影响巨大，但是不是决定性作用，可以决定我们的命运，目前主流三种外部因素决定论<ul><li>基因决定论，认为人的性格都是祖宗流传下来的，就是命由天定</li><li>心理决定论，认为人的性格是受父母言行决定，从童年培养的心理一直影响到现在</li><li>环境决定论，环境决定人的本性，例如公司、家庭甚至国家政策，社会环境等，都会影响到人</li></ul></li><li>其实外部因素决定论的基础是”刺激-回应“，有点像狗狗的实验，每天给定时按铃给狗狗吃饭，等过了一段时间后哪怕狗狗吃饱了，再次按铃它也会吃下饭</li><li>但是人类不只是动物，还有自由的思想，会在刺激-回应，选择是否回应</li><li>实际案例：维克多·弗兰克尔在二战被囚禁，遭遇各种刺激（如：侮辱、伤痛），通过脑子自我想象，超越肉体的禁锢，用独有的自我意识，发掘人类根本原则，就是人有选择的自由。</li><li>人类选择的自由，有四种特有的天赋：<ul><li>自我意识，知道自己是自己</li><li>想象力，超越现实，进行创造</li><li>良知，坚持自己的原则，判断对与错</li><li>独立意志，基于自我意识，不受外力自行其是的能力</li></ul></li><li>而环境决定论基本上源自于集体意识，集体意识是动物的本能，而人类与动物的区别，在于集体意识之上，拥有我们自由选择的能力</li><li>积极主动的定义：不仅仅是做事的态度，还是意味着要对自己的人生负责</li><li>积极主动应该要做的，营造有利的外部环境的积极性和责任感<ul><li>责任感，其实就是要回应，根据价值观去做不同选择回应</li></ul></li><li>积极主动要做的事情：<ul><li>不受外界影响，拥有自己的价值观去行事</li><li>理智胜于冲动，价值观是内在动力</li><li>昨日的选择决定了今日的我</li></ul></li><li>伤害并非是我们遭遇了悲痛的事情，而是我们对悲痛事情的回应</li><li>人生的三种价值观：<ul><li>经验价值观，来自自身经历</li><li>创造价值观，源于个人独创</li><li>态度价值观，面对绝境的回应，而这个恰恰是最重要的价值观</li></ul></li><li>逆境和困境往往能激发人的思维转换，从换个角度和观点看待世界、人、事情，重新审视生命的意义</li><li>采取主动的方式<ul><li>面试，可以采取主动去帮忙公司解决问题，这就是”解决方案式推销自己“，是事业成功的重要诀窍之一</li><li>培养责任感，主动积极去做自己的事情</li><li>变被动为主动，面对所有的事情提前去做</li></ul></li><li>积极行动与积极思考，不仅要面对现实，还要面对未来，需要有足够积极态度和能力去面对未来可能发生的一切</li><li>聆听自己的语言，判断是否自己是积极，还是消极的<ul><li>积极的人会说，有没有其他可能性？做不同的选择，控制情绪，有效的表达，选择恰当的回应，我选择，我更愿意，我打算？</li><li>消极的人会说，无能为力，气疯了，我就是这样，只能这么做，不能，不得不，要是。。。就好了</li></ul></li><li>积极主动更多的是行动，而不是想想而已</li><li>关注圈与影响圈，是判断一个人是否积极的标准<ul><li>关注圈，关注感兴趣的事情，如：家庭、技术、健康、子女等</li><li>影响圈，是能在自己控制范围内的事情</li></ul></li><li>积极主动的人会专注自己的影响圈，专心做自己能力所及的事情，使得影响圈不断扩大</li><li>消极被动的人会专注关注圈，关注周围的人和环境问题，抓住超出能力范围外的事情不放，怨天尤人，从而不断压缩自己的影响圈</li><li>关注圈与影响圈真正平衡点，关注圈不小于影响圈</li><li>什么才是自己能控制的事情呢？分为三种：<ul><li>直接控制，问题与自己有关系，可以通过培养良好的习惯去解决</li><li>间接控制，问题与他人有关系，通过改进施加影响去解决</li><li>无法控制，无能为力或无法解决，如：过去的问题，和现实的环境，以微笑面对现实，纵使有太多不满，也要泰然处之</li></ul></li><li>怎么做才能扩大影响圈？<ul><li>专注于自己的影响圈内的事情，积极主动去处理相关事宜</li><li>多说自己可以，由内到外去做事情，先改变个人行为，更充实，更具创造力，再施加影响去改变环境</li></ul></li><li>面对错误的选择，怎么处理？<ul><li>应该承认错误，改正并从中吸取教训，做到”失败是成功之母“</li></ul></li><li>影响圈的核心，就是做出承诺与信守承诺的能力，说到做到</li><li>掌控人生的途径：<ul><li>做出承诺，然后遵守承诺</li><li>确定目标，付诸实践</li></ul></li><li>知识、技巧和意愿都在影响圈内，改善任何一者都同时提升三者的平衡，当三者交集越大，那么习惯和原则就越完善，就越容易实现高效的人生</li><li>30天实践，按照下面的积极主动原则去生活<ul><li>全部精力都放到影响圈内</li><li>从各种小事做起，说到做到</li><li>学会照亮他人的蜡烛，而不是评判对错的判官</li><li>解决问题，而不是制造事端</li></ul></li><li>行动建议<ul><li>写下本周面临的挑战和问题，分别归入哪个圈子，回想一下你的回应是什么？<ul><li>挑战/问题    圈子（关注、影响）  回应（积极 or 消极）</li></ul></li><li>设法扩大自己的影响圈，做出了什么改变，克服了什么困难？</li><li>找一个难以解决的问题，判断是属于直接控制、间接控制，还是无法控制的问题，然后在影响圈内找到解决问题的第一步，然后付诸行动</li><li>有什么事情一直想做，但是缺乏时间，天赋或能力，为了克服这些弱点或痛点，你应当做什么？新的一周又能为其做什么事呢？</li><li>开发一项新的功能，你希望是什么？</li><li>能到世界某一个地方旅行，你希望是哪里？</li><li>改变生活中的某件事情，想改变哪个？</li><li>制定上面三个愿望的计划</li></ul></li></ul></li><li>第四章 习惯二 以终为始 —— 自我领导的原则<ul><li>和内在力量相比，身外之物显得微不足道。—— 奥利弗·温德尔·霍姆斯<ul><li>这句话表达的是，内心真正的需求和力量才是真正你所依靠的东西，所有外面的东西都无法影响到你。</li></ul></li><li>一个案例，如果你正在参加自己的葬礼，大家都在评论你的一生，那么需要你扪心自问，你准备过怎么样的一生</li><li>以终为始的定义<ul><li>做任何事情前，都要认清方向，避免在做事情的过程误入歧途</li><li>明确目标是比做事情还要重要的事情</li><li>只有明确的目标才能更加高效的工作</li></ul></li><li>以终为始的原则 —— 任何事情都是两次创造而成<ul><li>第一次创造，在头脑构思，是智力上的创造</li><li>第二次创造，是付诸实践，是体力上的创造</li></ul></li><li>问题：很多时候，我们的第一次创造都是被社会/环境/父母被动创造出来的， 这与我们主动设计的第一次创造是不同的</li><li>以终为始的原则 —— 自我领导<ul><li>自我领导是以终为始的基础</li><li>领导是第一次创造，是思想，怎么才能有效的把事情做好</li><li>领导是做正确的事情，管理是正确的做事</li></ul></li><li>有效的领导和有效的管理，是高效做事不可避免两个因素，其中有效的领导往往比有效的管理还要重要</li><li>改变人生剧本：成为自己的第一次创造者<ul><li>赢自己，才是真正赢得人生，每天都比昨天的自己做的更加好一点</li><li>教育孩子，不要忘记目的，不是为了教训，而是希望通过教训去教育孩子学会一些东西</li></ul></li><li>以终为始的需要树立正确的价值观，等同于个人宣言或个人承诺，如何树立：<ul><li>利用自我意识检查我们的地图或思维方式是否符合实际，是否基于正确原则</li><li>利用良知作为罗盘审视我们的行为</li><li>利用想象力制定我们的人生目标</li></ul></li><li>以终为始的做法，是以影响圈的核心 —— 观察世界的眼镜 ，去驱动我们人生四个成长方向：<ul><li>安全感，价值观，认同，情感归属，是自尊自重，与人生的基本能力</li><li>人生方向，是地图和内心的原则，是做事的决策原则</li><li>智慧，对生命认知，对平衡的感知，对事物间联系的理解，包括：判断力，洞察力，理解力</li><li>力量，行动力，达成目标的能力，培育有效的习惯代替顽固旧习</li></ul></li><li>生活重心=人生方向，每个人的生活重心都不一样，如：以家庭，以工作，以金钱等</li><li>选择不同的重心，导致生活方式和结果都不一样</li><li>识别自己的生活重心 —— 从上面几个方向可以识别出来</li><li>正确的生活重心 —— 以原则为重心，所有的选择都源自自己内心真正想要的<ul><li>需要编写的人生宣言</li></ul></li><li>左右脑的作用<ul><li>左脑，逻辑与语言能力，文字</li><li>右脑，创造与直觉能力，图像</li><li>整个大脑去解决问题，扩宽思路</li></ul></li><li>开发右脑的两种途径<ul><li>意外刺激打击，从左脑思维转换为右脑思维</li><li>自觉转换，通过想象一些场景，如：退休生活，给自己写死亡悼词，开动脑筋，尽最大的热情去想象和情感，以及每一个细节</li><li>心灵演练，就是开发右脑的一种方式</li></ul></li><li>如何撰写个人宣言，也就是人生目标<ul><li>确定正确行为，五个基本要素<ul><li>个人</li><li>积极</li><li>果断</li><li>可视</li><li>情感</li><li>例子，发现子女行为不当时，我（个人 ）能以智慧、爱心、坚定的立场与自制力（积极 ）及时应对（果断 ），结果让我深感欣慰（情感 ）。</li></ul></li></ul></li><li>心灵演练，是要做可视的，每天抽几分钟时间去想象自己可能面临的场景，越详细越好，然后身临其境的去体会那种感觉，最终让自己想出面对这种场景，应该遵循自己的价值观和人生诺言去做出选择</li><li>心灵演练的可视化和确认步骤是一个完整体系，具体包括如下：<ul><li>潜意识，也叫阈下意识，就是人无意识的行为</li><li>神经语言，</li><li>放松</li><li>自我谈话</li></ul></li><li>在做人生目标的时候，应该按照不同角色去思考，尽量兼顾全局，如：生活中的父母/丈夫等</li><li>人生目标案例：<ul><li>我的的使命是堂堂正正地生活，并且对他人有所影响，对社会有所贡献。</li><li>为完成这一使命，我会要求自己：</li><li>有慈悲心——亲近人群，不分贵贱，热爱每一个人。</li><li>甘愿牺牲——为人生使命奉献时间、才智和金钱。</li><li>激励他人——以身作则，证明人为万物之长，可以克服一切困难。</li><li>施加影响——用实际行动改善他人的生活。</li><li>为了完成人生使命，我将优先考虑以下角色：</li><li>丈夫——妻子是我这一生中最重要的人，我们同甘共苦，携手前行。</li><li>父亲——我要帮助子女体验乐趣无穷的人生。</li><li>儿子/兄弟——我不忘父子、手足的亲情，随时对他们施以援手。</li><li>基督徒——我信守对上帝的誓言，并为他的子民服务。</li><li>邻居——我要学习像耶稣一样爱和善待他人。</li><li>变革者——我能激发和催化团队成员的优异表现。</li><li>学者——我每天都学习很多重要的新知识。</li></ul></li><li>不管是个人/家庭/企业，都需要有自己的使命宣言</li></ul></li><li>第五章 习惯三 要事第一 —— 自我管理的原则<ul><li>重要之事决不可接受芝麻绿豆小事牵绊 —— 歌德<ul><li>表达的是，当你在做重要的事情的时候，不要被其他无关小事影响到你的注意力和时间</li></ul></li><li>如何分析哪些事是重要的？<ul><li>哪些事情能够彻底改变你的个人生活，但一直没做</li><li>哪些事情能够彻底改变你的工作局面，但一直没做</li></ul></li><li>习惯三是习惯一/二的具体实践<ul><li>习惯一 积极主动，告诉你需要掌控你自己的人生，自我意识的觉醒</li><li>习惯二 以终为始，去创造属于自己想要的东西，设定自己真正想要的东西</li><li>习惯三 要事第一，是让积极主动和以终为始的想法落地真正现实中，去努力实现自己想要的生活</li></ul></li><li>左脑进行管理，右脑进行领导</li><li>独立意志：有效管理的先决条件<ul><li>独立意志指的是做出决定和主动选择，并根据这些决定和选择采取具体行动的能力</li></ul></li><li>自我管理的实质就是自律和条理，是对计划的实施。</li><li>成功者能为失败者所不能为，纵使并非心甘情愿，但为了理想和目标，仍可以凭毅力克服心理障碍</li><li>时间管理理论演进<ul><li>第一代，利用便条和备忘录，在忙碌中调配时间与精力</li><li>第儿代，强调事项与日程表，反映时间管理已经注意到未来规划的重要性</li><li>第三代，讲求优先顺序的观念，依据轻重缓急四象限去制定短/中/长期目标，再逐日订制每日计划，有效时间获得更高效率</li><li>第四代，不再讲时间管理，而是注重个人管理，将重心从时间与事务中迁移到产出与产能的平衡中</li></ul></li><li>第四代时间管理实战，按照重要/紧急四象限去对事情分级：<ul><li>I类，重要紧急，如：危机/迫切问题/在限定时间内必须完成任务</li><li>II类，重要不紧急，如：预防性事情/建立关系/明确新的发展机会</li><li>III类，紧急不重要，如：接待访客/会议/迫切需要解决的事务/公共活动</li><li>IV 类，不紧急不重要，如：琐碎事情/信息/电话/消磨时间的活动/令人愉悦的活动</li></ul></li><li>上面四类事件，应该是平衡发展的，不管将重点倾向哪一方，忽略哪一方都形成很大的问题<ul><li>只处理重要紧急的问题，那么就会压力大，筋疲力尽，被危机牵着鼻子走</li><li>只处理紧急不重要问题，那么就会急功近利，巧言令色，轻视目标和计划，人际关系肤浅</li></ul></li><li>高效能的做法是：<ul><li>避免陷入第三类和第四类事情，不管是否紧急</li><li>花费更多时间在第二类事情上，去减少第一类事情的数量</li></ul></li><li>第二类事情包括：<ul><li>建立人际关系</li><li>建立人生目标</li><li>规划长期目标</li><li>原则：防患于未然</li></ul></li><li>用于对琐事说不，因为你要专注于主要事情，如果不说“不”，你将永远无法完成主要事情</li><li>自制力，源自于确定目标，只有确定目标后，确定以目标为中心去做主要事情，才能拥有独立意志</li><li>集大成的时间管理理论，强调产出与产能的平衡，着重第二类事务，以原则目标为中心</li><li>时间管理的六大标准<ul><li>和谐一致 个人理想/角色/目标/工作重点/计划/欲望/自制力，必须一致的</li><li>平衡功能 需要平衡不同角色的不同时间安排</li><li>围绕中心 不以时间的紧迫来的定优先级 而是通过事情的重要性定优先级，以一周为周期</li><li>以人为本 个人管理在于人，不在事，有效的管理有时候需要迁就别人，牺牲效率</li><li>灵活变通 管理方法并非一成不变，随环境或个人调整</li><li>便于携带 管理工具便于携带，随时可调整</li></ul></li><li>自我管理，安排第二类事情的的四个步骤<ul><li>确认角色，确定你的关键角色，记录你在下一周应该要角色和任务，</li><li>选择目标，按照不同角色确定你下一周要做的事情，同时确定哪些事是第二类事情（与长期目标关联）</li><li>安排进度，为每一项确定具体时间表，一般是周末两天开始制定</li><li>每日调整，每天不断更新和调整自己的时间表，根据突发事件/人际关系等，每天清晨审视自己的时间表</li></ul></li><li>所有事情都要付出实践，只有正在去做才能知道行不行</li><li>高效秘诀 —— 授权， 将责任分配给其他熟练的人，是管理上最大的成长</li><li>授权类型：<ul><li>指令型授权，关注重点是方法，为最后的结果负责，简单点说，就是怕别人做的不如自己做的好，还是希望按照自己的想法去做</li><li>责任型授权，关注最终的结果，给别人最大的自由，虽然过程很难，但是却能获得更好的结果，下面从五个方面达成共识<ul><li>预期成果，以结果为中心，详细描述结果和最终结果时间</li><li>指导方针，确定评估标准，避免成为指令型授权，从主导变成协助</li><li>可用资源，告知对方可以利用的资源，如：人力/技术/财务等</li><li>责任归属，制定业绩标准，评估最终结果</li><li>明确奖惩，评估结果后，确定好与不好的奖励与惩罚</li></ul></li></ul></li><li>信任是促进人进步最大动力</li><li>授权的大原则不变，但是要因人而异<ul><li>不成熟的人，目标不高，指示要详细，监督要频繁</li><li>成熟的人，目标要有挑战性，精简指示，减少监督</li></ul></li><li>以要事为中心的思维定式，是从重要性而不是紧迫性去观察一切事务</li><li>付诸行动，练习<ul><li>名人名言：成功的人习惯去做失败者不喜欢做的事，他们当然也不喜欢做，但是他们让这种不喜欢服从于对自己目标的追求</li><li>我的时间是怎么度过的</li><li></li></ul></li></ul></li></ul></li><li>第3部分 公众领域的成功：从独立到互赖<ul><li>第六章 人际关系的本质<ul><li>没有信任就谈不上友谊，没有诚实也谈不上信任。 —— “塞缪尔·约翰逊”<ul><li>这就是人际关系的本质就是信任，只有双方建立良好的信任，那么就可以维持互相的关系</li></ul></li><li>良好人际关系的基础是自制与自知之明。<ul><li>爱人之前，先爱自己</li><li>独立是建立良好关系的基础</li><li>修身是公众领域成功的基础</li></ul></li><li>“情感账户”，将人际关系中产出与产能平衡的原理<ul><li>增加情感账户存款的行为：<ul><li>礼貌，诚实，仁慈与信用</li></ul></li><li>减少情感账户存款的行为：<ul><li>粗鲁，轻蔑，威逼与失信</li></ul></li></ul></li><li>越是持久的关系，越需要不断的储蓄，就是需要不断维护关系，增加双方的信任感</li><li>孩子的教育就是最经典的例子，需要平时不断与其沟通，如下：<ul><li>聆听他的反馈</li><li>理解他的行为</li><li>在乎他，尊敬他</li></ul></li><li>速战速决是不切实际的，建立和维护关系都需要时间</li><li>建立和维护人际关系是一种长期的投资行为</li><li>7种投资人际关系的行为<ol><li>理解他人，是一切关系的基础，可以这么做：<ul><li>重视一个人，必须重视他所重视的事情</li><li>了解一个人的实际需求，给予帮助和支持</li></ul></li><li>注意细节，人际关系中，最重要的就是这些细节，如：忽视礼貌，不经意的失言等<ul><li>无论年龄和资历，哪怕最坚强和冷漠的外表下，都有一颗脆弱的心</li></ul></li><li>信守承诺，守信是获取信任的第一步，一次失信的代价是巨大的</li><li>明确期望，人际关系的障碍都源于角色和目标期望不一致<ul><li>正确的行为是明确提出要求，让相关的人都了解</li><li>要做到这一点需要投入很多时间和精力，但是却能减少后面很多麻烦和周折</li></ul></li><li>正直诚信，是其他感情投资的基础，有一说一，信守承诺，具体行为：<ul><li>避免背后攻击他人，同时维护不在场的人，如：别人正在批评某个人的问题，我们可以去寻找解决问题的方式</li><li>诚信意味着不欺骗，不使诈，不冒犯</li></ul></li><li>勇于道歉，诚心道歉会增加人与人之间的信任<ul><li>弱者才会残忍，只有强者才懂得温柔</li><li>一再道歉会显得不真诚，错误是人不可避免的，但是一直道歉反而会让你的诚信不断降低</li></ul></li><li>无条件的爱或者付出，有原则，有限度，有是非观念的爱，才是无条件的爱和付出<ul><li>成熟的人往往会无条件的付出，而不成熟的心理往往期望付出有所收获，叫有条件的付出</li></ul></li></ol></li><li>一对一的人际关系才是真正维护关系的正确认知，名人名言：“为一个人完全奉献自己，胜过拯救全世界而拼命。”<ul><li>其重点，一对一人际关系的维护，需要你有高尚的品格，而不是管理众人的技巧是完全不同的</li></ul></li><li>在互相依赖的关系，问题就代表机会，增加双方感情的机会</li><li>只有真正独立的人才能有效的相互依赖</li><li>付诸行动，实践互相依赖的行为<ul><li>正如身体经常需要食物以保持健康一样，人际关系也同样需要营养。</li></ul></li></ul></li><li>第七章 习惯四：双赢思维——人际领导的原则<ul><li>双赢者把生活看作一个合作的舞台，而不是角斗场，并不是：非强即弱，非弱即强</li><li>什么是双赢思维？就是利己利人，让大家有福同享，皆大欢喜。而不是以下其他思维：<ul><li>损人利己，目前大部分竞争模式所导致的，但是破解方法就是选择合适的双赢对象</li><li>舍己为人，还是遵循输赢模式，当一个和事佬，你赢了我认输，从而导致压抑自己，永远无法往前走</li><li>两败俱伤，价格战就是其中一种经典思维，但是往往不得好果</li><li>独善其身，是大部分人最终会选择的一种处理方式</li></ul></li><li>“如果实在无法达成共识，实现双赢，就不如好聚好散”</li><li>怎么做到双赢？五个要点：<ul><li>双赢品德是基础，就是双方的人品要信得过<ul><li>诚信</li><li>成熟</li><li>知足</li></ul></li><li>搭建双赢关系<ul><li>就是让双方搭建一个信任环境，有互相的情感，比如：喝酒聚餐等</li><li>“和赢/输模式的人打交道是对双赢的最大考验”</li><li>“交往过程本身就是很棒的投资”</li></ul></li><li>确定双赢协议，明确双方合作的职责，主要有以下几个点：<ul><li>预期结果，确定目标</li><li>指导方针，实现目标的方式</li><li>可用资源，人/财/时间等</li><li>任务考核，目标评估标准和时间</li><li>奖惩制度，根据考核确定奖惩</li><li>双赢管理培训/绩效协议，是培养双赢的明确指向灯</li></ul></li><li>需要双赢体系，创建一个好的双赢环境<ul><li>鼓励什么就会得到什么</li><li>从各个体系（培训/规划/预算/信息）去建立双赢</li><li>要为双赢协议创建有利的环境</li></ul></li><li>完成双赢过程，其实从互相为对方考虑，从而实现双赢<ul><li>从对方角度看问题</li><li>认清主要问题和顾虑</li><li>确定大家可以接受的结果</li><li>找到实现结果的各种可能途径</li></ul></li></ul></li><li>付诸行动，当你培养自己的双赢心态，发现一件美妙的事情，人际关系变得更加容易了。</li></ul></li><li>第八章 习惯五：知彼解己——移情沟通的原则<ul><li>寻找了解对方，然后争取对方了解自己，这个原则是人际交流有效的关键。</li><li>如何真正的了解对方？<ul><li>沟通的方式：读写听说，所以需要掌握好</li><li>倾听训练，是了解对方重中之重</li></ul></li><li>倾听训练，移情倾听，是要在情感和理智上深入理解对方<ul><li>先要同意对方的说法，理解对方的价值观，简单的说就是被对方影响，然后再去影响对方</li><li>这里需要你拥有一颗独立的心，所以习惯 1/2/3 是你独立的基础</li></ul></li><li>适时扮演知音，理解和感知对方，在不同时间和场景下，不同人在对待同一个事情会有不同的看法<ul><li>虽然有时候会费时间，但是人人都渴望知音，这方面的投资是值得</li></ul></li><li>表达也要技巧，要获得对方理解，品德&gt;感情&gt;理性<ul><li>表达自己不代表自吹自擂，而是根据对方的理解诉说自己的意见</li><li>知彼解己的习惯能帮你提升表达的准确度和连贯性</li></ul></li><li>一对一沟通，是需要不断练习，从而实现影响圈不断从内到外的扩大</li><li>练习沟通，需要做到：<ul><li>不要过于心急，要有耐心</li><li>尊重对方，理解对方</li></ul></li><li>当真正做到知彼解己的时候，你已经打开了通向创造性解决问题的大门</li><li>付诸行动<ul><li>如果你真的想寻求理解，就要丢掉诡计和伪善。</li></ul></li></ul></li><li>第九章 习惯六：统合综效——创造性合作的原则<ul><li>统合综效的心态，就是当有人和我意见不和，那么他肯定有我想不到的地方，值得我去琢磨，与所见略同的人沟通，有分歧才有收获</li><li>统合综效就是整体大于部分之和，简单点说就是 1+1&gt;=3</li><li>统合综效就是判断和尊重差异，取长补短，具体行为可以分为以下几点：<ul><li>敞开胸怀，博采众议</li><li>有担当，不怕失败，不断尝试</li></ul></li><li>课堂上的统合综效，要做到：<ul><li>鼓起勇气，诚恳交流，说别人不敢说的话，从而形成热切的交流氛围</li></ul></li><li>商业领域的统合综效，要做到：<ul><li>在相互尊重的基础上，去自由发言，各抒己见</li></ul></li><li>沟通三层次：<ul><li>相互提防</li><li>相互尊重</li><li>统合综效</li></ul></li><li>寻求第三条路，怎么在不放弃和不能做到统合综效之间去努力？<ul><li>在意见不合的时候，为了两个选择而争吵，其实还可以有第三个选择，就是大家一起努力去寻找第三个选择</li></ul></li><li>消极协作会导致1+1&lt;2的结果<ul><li>消极协作，就是大家彼此提防，玩弄权术，把对方踩在脚下才觉得自己胜利</li></ul></li><li>避免消极协作，就是无论做什么事都以原则为中心</li><li>统合综效最重要的一点，就是尊重差异<ul><li>重视不同个体的不同心理，情绪与智能，以及每个看到的世界都是不一样的</li></ul></li><li>化阻力为动力，这句话可以理解成两个：<ul><li>一是要化解阻力，</li><li>二是要增加动力，</li><li>两者缺一不可，只针对某一方面都达不到自己想要的结果</li></ul></li><li>以习惯四（双赢）为目标，以习惯五（知彼解己）为技巧，以习惯六（统合综效）为交往方式，就可以营造出一个可以畅所欲言的环境</li><li>不一定要表示赞同，而是表达肯定，以及理解对方的观点</li><li>付诸行动</li></ul></li></ul></li><li>第4部分 自我提升和完善<ul><li>第十章 习惯七：不断更新——平衡的自我提升原则<ul><li>人生最值得投资的就是磨练自己，因为生活和工作需要靠自己。</li><li>工作赚钱本身并不能带来经济上的安全感，具备良好的学习/思考/创造与适应能力，才能利于不败之地<ul><li>摆脱焦虑的做法，就是不断学习，让自己变得更加强大和自信</li></ul></li><li>不断更新，是从以下四个层面去更新<ul><li>身体，锻炼，营养，压力调节，如：健康饮食，充足休息和定期锻炼，有一个好的身体（耐性，韧性，力量等）才能应付每个星期繁重的工作压力</li><li>精神，实现价值，忠诚，学习与冥想，如：指引人生方向，是自己内心本质，核心和价值观的坚持，只有足够的信念，才能坚持去做正确的事情</li><li>智力，阅读，想象，写作与规划，如：要坚持学习（阅读优秀作品），要经常正确的表达自己能力和想法（写作），只有不断学习才能不断成为更好的自己，去面对更难的挑战</li><li>社会/情感，服务，移情，统合综效，内在安全感，如：理解和聆听别人，去做一些创造性合作，坚守原则和肯定自我，只有去搭建自己的社交网络，才能扩大自己的影响圈，最终实现自己的目标</li></ul></li><li>如何从负面情绪中走出来？<ul><li>找一个自己呆着比较舒服的地方，什么都不管，听 3 个小时自然的声音</li><li>回忆自己美好的时光，那些快乐的时光，点点滴滴的细节</li><li>找到正确的动机，做一些事情的动机，动机不纯（只为了自己的私欲）就会诸事不顺</li><li>最后把忧愁的情绪放飞掉，只保留积极的一面</li></ul></li><li>如何改变他人？<ul><li>以一个人的现有表现期许之，他不会有所长进。以他的潜能和应有成就期许之，他定能不负所望。</li></ul></li><li>四个层面应该平衡更新，哪一个都不需要落下，否则会形成致命的缺陷，从而无法实现最终目标</li><li>7 个习惯的的逻辑：<ul><li>当你变得积极主动，就可以自我领导和管理自己</li><li>当你越来越有效管理自己，就可以不断自我提升和完善自己</li><li>当你不断提升，你就能越来越理解其他人</li><li>当你越来越理解他人，那么就越有可能找到双赢的解决方案</li><li>当你在不断学习，那么上面就进入一个螺旋上升的趋势</li></ul></li><li>良知是一种天赋，帮助我们自己是否背离了正确的原则，然后引导我们向这些原则靠拢。</li><li>如何做到自律？<ul><li>远离垃圾食品，坚持锻炼</li><li>远离淫秽/粗俗/色情的东西</li><li>定期阅读励志文学作品</li><li>培养自己的良知</li></ul></li><li>付诸行动</li></ul></li><li>第十一章 再论由内而外造就自己<ul><li>七个习惯浇灌出来最高级的，最美好和最甘甜的果实，就是齐心协力，就是把自己，爱人，朋友和同事合力而为一。</li><li>刺激与回应之间存在一段距离，成长和幸福的关键在于如何处理这段距离</li><li>找一个可以大家坐下来沟通的地方，然后大家说出心中真正的想法，去真正理解大家</li><li>由内而外的努力才能让大家真正建立充满信任和坦诚的关系</li><li>把基于正确的原则的精神遗产传给后世子孙</li><li>付诸行动</li></ul></li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;高效能人士的7个习惯&quot;&gt;&lt;a href=&quot;#高效能人士的7个习惯&quot; class=&quot;headerlink&quot; title=&quot;高效能人士的7个习惯&quot;&gt;&lt;/a&gt;高效能人士的7个习惯&lt;/h1&gt;&lt;p&gt;不管是工作还是学习，有些人做事的效率很高，而有些做事的效率就很低，那么有什么方式可以提高自己的工作效率，这本书主要就是讲如何去培养自己高效能的习惯，改变自己的做事和思考的方式。&lt;/p&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/学习总结/"/>
    
  </entry>
  
  <entry>
    <title>前端面试100道手写题（1）—— 手写Promise实现</title>
    <link href="https://www.qborfy.com/face100/1-promise-face.html"/>
    <id>https://www.qborfy.com/face100/1-promise-face.html</id>
    <published>2023-04-16T07:00:00.000Z</published>
    <updated>2023-04-16T09:01:38.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>今年的金三银四面试，遇到了很多新的面试八股文，其实心里对手写题或者算法题有一定抵触，因为实际工作中基本上就不会用到这些东西，但是正因为这些基础八股文，才能真正验证一个人对技术有多热爱的程度。<br>也有可能近几年没有对这些基础知识进行巩固，所以干脆一狠心，先立个flag, 准备完成100道手写题。</p><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>Promise 对象用于表示一个异步操作的最终完成（或失败）及其结果值。  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">MDN Promise</a></p></blockquote><p>下面有一张图用来显示Promise的基本流程图（源自MDN）：</p><p><img src="/assets/img/promises.png" alt></p><p>如何快速理解Promise呢？就是必须给出一个最终结果的状态处理机制函数。</p><p>可以想象Promise是一个排队买奶茶的操作，当你进入排队中处于pending，轮到你的时候成功买到奶茶则是fulfilled，如果中途你走开了或者轮到你的时候没买奶茶，则是买奶茶失败rejected，最后则是无论如何你都离开奶茶店，这就是finally。</p><p>因此Promise的有三种状态：</p><ul><li>待定（pending）:  初始状态</li><li>已兑现（fulfilled）: 操作成功完成</li><li>已拒绝（rejected）：操作失败</li></ul><p>同时Promise在成功执行后完成执行注册在自身的Promise.prototype.then函数，如果失败后会调用Promise.prototype.catch。</p><p><strong>重要知识点：Promise其实是通过微任务队列(Microtasks)<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/queueMicrotask" target="_blank" rel="noopener">queueMicrotask()</a>的去实现的，所以会比setTimeout等定时器任务要优先，这一点在网上很多手写Promise都忘记去实现了。</strong></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol><li>内置函数，需要实例化对象后才能调用</li></ol><ul><li>构建函数 <code>Promise(resolve, reject)</code> 创建一个Promise对象</li><li><code>Promise.prototype.then()</code> 为 promise 添加被兑现状态的回调函数，其以回调函数的返回值兑现 promise。若回调函数被调用，则兑现其返回值，否则兑现原来的 promise 兑现的值。  </li><li><code>Promise.prototype.catch()</code> 为 promise 添加一个被拒绝状态的回调函数，并返回一个新的 promise，若回调函数被调用，则兑现其返回值，否则兑现原来的 promise 兑现的值。  </li><li><code>Promise.prototype.finally()</code> 为 promise 添加一个回调函数，并返回一个新的 promise，这个promise的值将为原来promise的值。而传入的回调函数将在原 promise 被敲定（无论被兑现还是被拒绝）时被调用，同时需要等待then或catch执行完后才会被执行。</li></ul><ol start="2"><li>静态函数，可以直接调用的</li></ol><ul><li><code>Promise.all(iterable)</code> 返回一个新的 <code>Promise</code> 对象，等到传入所有的 <code>Promise</code> 对象都成功，则表示成功，返回值的顺序与传入顺序一致，如果有任意一个 <code>Promise</code>则表示失败</li><li><code>Promise.allSettled(iterable)</code> 等到所有 <code>Promise</code> 都已敲定（每个 <code>Promise</code> 都已兑现或已拒绝），与all不同在于传入每个<code>Promise</code>都会被执行一次</li><li><code>Promise.any(iterable)</code> 当其中的任意一个 <code>Promise</code> 成功，就返回那个成功的 <code>Promise</code> 的值，与all相反</li><li><code>Promise.race(iterable)</code> 无论传入的 <code>Promise</code> 是执行成功或失败，都直接返回其结果</li><li><code>Promise.resolve(value)</code> 返回一个状态有value决定的Promise，如果value(带有then(resolve, reject)的对象)，则会执行then方法去判断状态，如果没有则将value直接返回成功调用的值</li><li><code>Promise.reject(reason)</code> 返回一个状态为已拒绝的 Promise 对象，其错误信息为reason</li></ul><p>以上就是Promise的全部基础知识点，接下来我们就来实现，同时业界内也有一个<a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise/A+规范</a>，大家也可以按照其规范去实现自己的Promise。</p><h1 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h1><p>在手写代码之前，我们需要明白<code>Promise</code>实现的基本原理：</p><ul><li>发布订阅模式，解决<code>Promise</code>的state发生变化后需要触发的事件，如：then 或 catch</li><li>链式调用，<code>Promise</code>所有的方法调后都会返回一个新的<code>Promise</code>对象</li></ul><p>其中关键代码在<code>then</code>函数的实现，主要是返回一个新的<code>Promise</code>对象，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Promise的三种状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> StatusType = &#123;</span><br><span class="line">    PENDING: <span class="string">'pending'</span>,</span><br><span class="line">    FULFILLED: <span class="string">'fulfilled'</span>,</span><br><span class="line">    REJECTED: <span class="string">'rejected'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 手写Promise</span></span><br><span class="line"><span class="comment"> * @author: Qborfy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; executor 为一个函数，该函数接受两个参数，分别是resolve和reject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">        <span class="comment">// 初始化状态为pending</span></span><br><span class="line">        <span class="keyword">this</span>.status = StatusType.PENDING;</span><br><span class="line">        <span class="comment">// 初始化成功的值</span></span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="comment">// 初始化失败的原因</span></span><br><span class="line">        <span class="keyword">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="comment">// 成功的回调函数</span></span><br><span class="line">        <span class="keyword">this</span>.onFulfilledCallbacks = [];</span><br><span class="line">        <span class="comment">// 失败的回调函数</span></span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 成功的回调函数</span></span><br><span class="line">        <span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 状态只能从pending到fulfilled或者rejected</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === StatusType.PENDING) &#123;</span><br><span class="line">                <span class="keyword">this</span>.status = StatusType.FULFILLED;</span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">                <span class="comment">// 依次执行成功的回调函数 使用queueMicrotask()去执行</span></span><br><span class="line">                <span class="keyword">this</span>.onFulfilledCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">                    queueMicrotask(fn(<span class="keyword">this</span>.value));</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 失败的回调函数</span></span><br><span class="line">        <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 状态只能从pending到fulfilled或者rejected</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === StatusType.PENDING) &#123;</span><br><span class="line">                <span class="keyword">this</span>.status = StatusType.REJECTED;</span><br><span class="line">                <span class="keyword">this</span>.reason = reason;</span><br><span class="line">                <span class="comment">// 依次执行失败的回调函数 使用queueMicrotask()去执行</span></span><br><span class="line">                <span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">                    queueMicrotask(fn(<span class="keyword">this</span>.reason));</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 立即执行executor函数</span></span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="comment">// 如果执行executor函数出错，直接执行reject</span></span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将then方法返回的promise的resolve和reject传入</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; onFulfilled </span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; onRejected </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="comment">// onFulfilled和onRejected都是可选参数</span></span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="keyword">throw</span> err &#125;;</span><br><span class="line">        <span class="comment">// 判断结果是否为promise，如果是promise，直接返回该promise，如果不是则返回一个新的promise</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">result, resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                result.then(resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> newPromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 如果状态完成，直接执行onFulfilled</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === StatusType.FULFILLED) &#123;</span><br><span class="line">                <span class="keyword">const</span> result = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">                resolvePromise(result, resolve, reject);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果状态失败，直接执行onRejected</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === StatusType.REJECTED) &#123;</span><br><span class="line">                <span class="keyword">const</span> result = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">                resolvePromise(result, resolve, reject);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果状态为pending，将onFulfilled和onRejected存入对应的回调函数数组中</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === StatusType.PENDING) &#123;</span><br><span class="line">                <span class="comment">// 同时将resolve和reject传入对应函数中</span></span><br><span class="line">                <span class="keyword">this</span>.onFulfilledCallbacks.push(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> result = onFulfilled(value)</span><br><span class="line">                    resolvePromise(result, resolve, reject)</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> result = onRejected(reason)</span><br><span class="line">                    resolvePromise(result, resolve, reject)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newPromise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行catch方法，返回一个新的promise</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; onRejected </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不管是成功还是失败，最终会执行finally方法，返回一个原来promise的结果</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; onFinally </span></span><br><span class="line"><span class="comment">     * @returns </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">finally</span>(onFinally) &#123;</span><br><span class="line">        <span class="comment">// 这里要将原来的value或reason返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">            onFinally()</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;, (reason)=&gt;&#123;</span><br><span class="line">            onFinally()</span><br><span class="line">            <span class="keyword">return</span> reason;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> resolve() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> reject() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> all() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> allSettled() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> any() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> race() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="number">1</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'then:'</span>, res)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'finally'</span>)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'then2:'</span>, res)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'then3:'</span>, res)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(p)</span><br><span class="line">    <span class="comment">// const p2 = new MyPromise((resolve, reject) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     JSON.parse('&#123;a&#125;')</span></span><br><span class="line">    <span class="comment">// &#125;).catch((res) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     console.log('catch:', res)</span></span><br><span class="line">    <span class="comment">// &#125;).finally(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     console.log('finally2')</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>这里就不粘贴完整源码了，完整源码请到github中查看，想看更多八股文手写题可以给个star收藏一下，Github会给你推送更新信息，地址如下：</p><p><a href="https://github.com/qiubohong/hundred-interview-questions/blob/main/1-promise/mypromise.js" target="_blank" rel="noopener">https://github.com/qiubohong/hundred-interview-questions/blob/main/1-promise/mypromise.js</a></p><h1 id="Promise在开发中遇到的问题"><a href="#Promise在开发中遇到的问题" class="headerlink" title="Promise在开发中遇到的问题"></a>Promise在开发中遇到的问题</h1><ul><li>并发Promise，用Promise.all，那么如何实现限制并发数呢?</li><li>await去等待Promise的结果，如果是reject结果，如何catch，或者用其他方式避免await的错误？</li><li>Promise的调用时机，即是一个非异步的Promise函数什么时候会被执行，为什么会比setTimeout等定时器优先更高？</li></ul><h1 id="额外知识点"><a href="#额外知识点" class="headerlink" title="额外知识点"></a>额外知识点</h1><h2 id="微任务（Microtasks）和任务（tasks）的区别"><a href="#微任务（Microtasks）和任务（tasks）的区别" class="headerlink" title="微任务（Microtasks）和任务（tasks）的区别"></a>微任务（Microtasks）和任务（tasks）的区别</h2><p>JavaScript中的<code>任务</code>指的是将代码按照下面的标准机制去形成一个个任务，加入到<strong>任务队列</strong>中，去等待被<strong>事件循环</strong>驱动调度。</p><ul><li>一段代码被直接执行时</li><li>触发了一个事件，将其回调函数添加到任务队列时</li><li>执行到一个由 setTimeout() 或 setInterval() 创建的 timeout 或 interval，以致相应的回调函数被添加到任务队列时</li></ul><p>而<code>微任务</code>则是通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/queueMicrotask" target="_blank" rel="noopener">queueMicrotask()</a>加入微任务队列中，在事件循环之前的安全时间执行的（当前事件循环无任何需要执行任务），同时事件循环会持续调用微任务直至队列中没有留存的，即使是在有更多微任务持续被加入的情况下。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;headerlink&quot; title=&quot;原因&quot;&gt;&lt;/a&gt;原因&lt;/h1&gt;&lt;p&gt;今年的金三银四面试，遇到了很多新的面试八股文，其实心里对手写题或者算法题有一定抵触，因为实际工作中基本上就不会用到这些东西，但是正因为这些基础八股文，才能真正验证一个人对技术有多热爱的程度。&lt;br&gt;也有可能近几年没有对这些基础知识进行巩固，所以干脆一狠心，先立个flag, 准备完成100道手写题。&lt;/p&gt;
&lt;h1 id=&quot;Promise&quot;&gt;&lt;a href=&quot;#Promise&quot; class=&quot;headerlink&quot; title=&quot;Promise&quot;&gt;&lt;/a&gt;Promise&lt;/h1&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/学习总结/"/>
    
    <category term="前端面试" scheme="https://www.qborfy.com/tags/前端面试/"/>
    
  </entry>
  
  <entry>
    <title>工具收集</title>
    <link href="https://www.qborfy.com/ideas/20230621.html"/>
    <id>https://www.qborfy.com/ideas/20230621.html</id>
    <published>2023-04-08T13:51:01.000Z</published>
    <updated>2023-06-22T14:57:18.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bark语音生成引擎"><a href="#Bark语音生成引擎" class="headerlink" title="Bark语音生成引擎"></a><a href="https://github.com/suno-ai/bark" target="_blank" rel="noopener">Bark语音生成引擎</a></h1><p>一个语音生成引擎，效果不错，可以在朗读的同时，发出大笑、叹息和哭泣，还可以生成音乐。</p><p>地址： <a href="https://github.com/suno-ai/bark" target="_blank" rel="noopener">https://github.com/suno-ai/bark</a></p><h1 id="STDF-移动端组件库"><a href="#STDF-移动端组件库" class="headerlink" title="STDF 移动端组件库"></a><a href="https://stdf.design/#/" target="_blank" rel="noopener">STDF 移动端组件库</a></h1><p>基于 Svelte 与 Tailwind 的移动页面组件库。</p><p>地址： <a href="https://github.com/dufu1991/stdf" target="_blank" rel="noopener">https://github.com/dufu1991/stdf</a></p><h1 id="MockingBird-AI合成语音"><a href="#MockingBird-AI合成语音" class="headerlink" title="MockingBird AI合成语音"></a><a href="https://github.com/babysor/MockingBird" target="_blank" rel="noopener">MockingBird AI合成语音</a></h1><p>给出语音，合成属于自己的语音包</p><p>地址： <a href="https://github.com/babysor/MockingBird" target="_blank" rel="noopener">https://github.com/babysor/MockingBird</a></p><p>适用教程： <a href="https://www.youtube.com/watch?v=eHRHfYeoZ3g" target="_blank" rel="noopener">https://www.youtube.com/watch?v=eHRHfYeoZ3g</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Bark语音生成引擎&quot;&gt;&lt;a href=&quot;#Bark语音生成引擎&quot; class=&quot;headerlink&quot; title=&quot;Bark语音生成引擎&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/suno-ai/bark&quot; target=&quot;_blank</summary>
      
    
    
    
    
    <category term="奇思妙想" scheme="https://www.qborfy.com/tags/奇思妙想/"/>
    
  </entry>
  
  <entry>
    <title>ChatGPT工具收集</title>
    <link href="https://www.qborfy.com/ideas/20230408.html"/>
    <id>https://www.qborfy.com/ideas/20230408.html</id>
    <published>2023-04-08T13:51:01.000Z</published>
    <updated>2023-04-08T14:54:54.984Z</updated>
    
    <content type="html"><![CDATA[<h1 id="chatGPT工具收集"><a href="#chatGPT工具收集" class="headerlink" title="chatGPT工具收集"></a>chatGPT工具收集</h1><ol><li>chatgpt-i18n: AI自动翻译i18n.json</li></ol><p>Github地址： <a href="https://github.com/ObservedObserver/chatgpt-i18n" target="_blank" rel="noopener">https://github.com/ObservedObserver/chatgpt-i18n</a></p><a id="more"></a><ol start="2"><li>cli-gpt: 用 ChatGPT 开发一个能听懂人话的命令行工具</li></ol><p>Github地址： <a href="https://github.com/MagicCube/cli-gpt" target="_blank" rel="noopener">https://github.com/MagicCube/cli-gpt</a></p><ol start="3"><li>通过可组合性⚡使用LLMS构建应用程序</li></ol><p>Github地址： <a href="https://github.com/hwchase17/langchain?utm_source=gold_browser_extension" target="_blank" rel="noopener">https://github.com/hwchase17/langchain?utm_source=gold_browser_extension</a></p><ol start="4"><li>自己创建中文GPT</li></ol><p>Github地址： <a href="https://github.com/ymcui/Chinese-LLaMA-Alpaca?utm_source=gold_browser_extension" target="_blank" rel="noopener">https://github.com/ymcui/Chinese-LLaMA-Alpaca?utm_source=gold_browser_extension</a></p><h1 id="创业箴言"><a href="#创业箴言" class="headerlink" title="创业箴言"></a>创业箴言</h1><ol><li>5年独立开发者总结</li></ol><ul><li>激情是把双刃剑，能让你更加干活充满精力，但是却无法带来更多资产，反而更像一种赚钱的障碍</li><li>无法远离人情世故，创业或独立都需要自己去面对更多的人群，如：客户、供应商等</li><li>社区真正的价值<ul><li><strong>”你不知道你不知道什么“</strong>，这句话需要经常记住</li><li>社区带来的是知识，是一种宝贵的学习资源，还有一起创业时候的人脉</li><li>听听某人的故事或关于他们项目的一般性玩笑，可能会让我接触到新的营销策略、更好的入职策略或有助于加快我的开发工作流程的工具。当我遇到新问题时，它也给了我更广泛的经验来借鉴。</li></ul></li><li>创业选择值得吗？没有可观的收入和花费很多时间，后续怎么走等等</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;chatGPT工具收集&quot;&gt;&lt;a href=&quot;#chatGPT工具收集&quot; class=&quot;headerlink&quot; title=&quot;chatGPT工具收集&quot;&gt;&lt;/a&gt;chatGPT工具收集&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;chatgpt-i18n: AI自动翻译i18n.json&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Github地址： &lt;a href=&quot;https://github.com/ObservedObserver/chatgpt-i18n&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/ObservedObserver/chatgpt-i18n&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="奇思妙想" scheme="https://www.qborfy.com/tags/奇思妙想/"/>
    
  </entry>
  
  <entry>
    <title>如何用vite+vue-next快速开发chrome插件</title>
    <link href="https://www.qborfy.com/today/20230227.html"/>
    <id>https://www.qborfy.com/today/20230227.html</id>
    <published>2023-04-06T14:00:01.000Z</published>
    <updated>2023-04-06T15:14:06.484Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前写过一篇文章<a href="https://qborfy.com/today/20230224.html" target="_blank" rel="noopener">《从开发chrome插件到插件系统设计》</a>，主要讲述了如何开发一个chrome插件和chrome插件设计，感兴趣的同学可以再去看看。</p><p>目前主流web应用都是基于Vue、React等现代框架去开发，Chrome插件本身而言其实也是一个web应用，看它的组成部分<code>popup.html</code> + <code>contentscript</code> + <code>background.js</code> ，只需要在开发的时候调整一下构建脚本基本上就可以利用Vue、React等现代框架去开发了。</p><p>接下来，我们就一步步开始实战。</p><a id="more"></a><h1 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>利用<code>vite</code>初始化项目命令快速搭建，具体如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pnpm create vite</span><br></pre></td></tr></table></figure><ol><li>在public目录下新建manifest.json</li></ol><p>内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"ngptcommit"</span>,</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"1.0"</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"ngptcommit自动生成git commit信息"</span>,</span><br><span class="line">    <span class="attr">"manifest_version"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"browser_action"</span>: &#123;</span><br><span class="line">        <span class="attr">"default_popup"</span>: <span class="string">"index.html"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"icons"</span>: &#123;</span><br><span class="line">        <span class="attr">"16"</span>: <span class="string">"images/favicon-16x16.png"</span>,</span><br><span class="line">        <span class="attr">"48"</span>: <span class="string">"images/favicon-32x32.png"</span>,</span><br><span class="line">        <span class="attr">"64"</span>: <span class="string">"images/android-chrome-192x192.png"</span>,</span><br><span class="line">        <span class="attr">"128"</span>: <span class="string">"images/android-chrome-192x192.png"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"background"</span>: &#123;</span><br><span class="line">        <span class="attr">"scripts"</span>: [</span><br><span class="line">            <span class="string">"background/background.js"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"permissions"</span>: [</span><br><span class="line">        <span class="string">"tabs"</span>,</span><br><span class="line">        <span class="string">"storage"</span>,</span><br><span class="line">        <span class="string">"http://*/*"</span>,</span><br><span class="line">        <span class="string">"https://*/*"</span>,</span><br><span class="line">        <span class="string">"activeTab"</span>,</span><br><span class="line">        <span class="string">"contextMenus"</span>,</span><br><span class="line">        <span class="string">"notifications"</span>,</span><br><span class="line">        <span class="string">"webRequest"</span>,</span><br><span class="line">        <span class="string">"webRequestBlocking"</span>,</span><br><span class="line">        <span class="string">"cookies"</span>,</span><br><span class="line">        <span class="string">"unlimitedStorage"</span>,</span><br><span class="line">        <span class="string">"webNavigation"</span>,</span><br><span class="line">        <span class="string">"identity"</span>,</span><br><span class="line">        <span class="string">"identity.email"</span>,</span><br><span class="line">        <span class="string">"identity.read"</span>,</span><br><span class="line">        <span class="string">"identity.write"</span>,</span><br><span class="line">        <span class="string">"identity.launch.webauthn"</span>,</span><br><span class="line">        <span class="string">"identity.launch.webauthn"</span>,</span><br><span class="line">        <span class="string">"identity.manage.accounts"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增插件必须的文件，如：<code>manifest.json</code>和 <code>background.ts</code> ，完整目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">chrome-extension</span><br><span class="line">├── README.md</span><br><span class="line">├── index.html</span><br><span class="line">├── package.json</span><br><span class="line">├── public</span><br><span class="line">|  ├── images</span><br><span class="line">|  └── manifest.json</span><br><span class="line">├── src</span><br><span class="line">|  ├── App.vue</span><br><span class="line">|  ├── background.ts</span><br><span class="line">|  ├── components</span><br><span class="line">|  ├── main.ts</span><br><span class="line">|  ├── style.css</span><br><span class="line">|  └── vite-env.d.ts</span><br><span class="line">├── tsconfig.json</span><br><span class="line">├── tsconfig.node.json</span><br><span class="line">└── vite.config.ts</span><br></pre></td></tr></table></figure><h2 id="调整编译"><a href="#调整编译" class="headerlink" title="调整编译"></a>调整编译</h2><p>由于vite初始化项目只针对web应用设计，但是我们开发chrome插件还需要针对<code>background.ts</code> 去做编译，就是要做多入口编译，而且vite本身就是基于rollup为基础去实现的少量配置即可完成一个web应用打包。</p><blockquote><p>一套构建指令，它使用<strong><a href="https://rollupjs.org/" target="_blank" rel="noopener"><code>Rollup</code></a></strong> 打包你的代码，并且它是预配置的，可输出用于生产环境的高度优化过的静态资源。—— Vite官网介绍</p></blockquote><p>所以我们其实可以使用<code>Rollup</code>去打包我们的<code>background.ts</code> ，就是增加多一个入口文件，具体如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import &#123; defineConfig &#125; from &apos;vite&apos;</span><br><span class="line">import vue from &apos;@vitejs/plugin-vue&apos;</span><br><span class="line">import path from &apos;path&apos;</span><br><span class="line"></span><br><span class="line">// https://vitejs.dev/config/</span><br><span class="line">export default defineConfig(&#123;</span><br><span class="line">  plugins: [vue()],</span><br><span class="line">  build: &#123;</span><br><span class="line">    rollupOptions: &#123;</span><br><span class="line">      input: &#123;</span><br><span class="line">        index: path.resolve(__dirname, &apos;index.html&apos;),</span><br><span class="line">        background: &apos;src/background.ts&apos;,</span><br><span class="line">      &#125;,</span><br><span class="line">      output: &#123;</span><br><span class="line">        entryFileNames: `[name].js`,</span><br><span class="line">        assetFileNames: `[name].[ext]`,</span><br><span class="line">        chunkFileNames: `[name].js`,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其中有几个地方需要说明一下：</p><ul><li><code>output</code>： 设置不加<code>hash</code>值，后续调试的时候插件不会出现加载不到文件的错误</li><li><code>rollupOptions</code>：基本上和<code>Rollup</code>的配置项一模一样，所以有<code>Rollup</code>基础的基本上可以直接上手配置，而且也完全兼容<code>Rollup</code>的插件生态</li></ul><p>接下来就是调整<code>package.json</code>中<code>scripts</code>命令，需要针对background新增两个命令，具体如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"@node-gptcommit/chrome-extension"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.0"</span>,</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"rimraf dist &amp;&amp; vite"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"vue-tsc &amp;&amp; vite build"</span>,</span><br><span class="line">    <span class="attr">"preview"</span>: <span class="string">"vite preview"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>dev:background</code> 代表开发模式</li><li><code>build:background</code> 代表生产模式</li></ul><p>到了这里基本上就完成了项目的搭建，接下来就进入开发阶段。</p><h1 id="项目开发"><a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h1><h2 id="UI开发"><a href="#UI开发" class="headerlink" title="UI开发"></a>UI开发</h2><ol><li>引入ui库 <code>tdesign-vue-next</code> ，tdesign是腾讯出品的全端组件库，从桌面到移动，再到小程序，应有尽有，大家可以去尝尝鲜<a href="https://tdesign.tencent.com/" target="_blank" rel="noopener">https://tdesign.tencent.com/</a></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm add tdesign-vue-next</span><br></pre></td></tr></table></figure><ol><li>开发UI，这里就直接撸代码就行，就不展开来讲，主要需要注意的是，需要和background.js通讯的部分，比如需要和chatgpt发送信息，获取返回内容，具体如下:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const getSummary = () =&gt; &#123;</span><br><span class="line">    // 发送通讯，获取总结</span><br><span class="line">    chrome.runtime.sendMessage(</span><br><span class="line">        &#123;</span><br><span class="line">            type: &apos;summary&apos;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                diffs: []</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        (response) =&gt; &#123;</span><br><span class="line">            console.log(response)</span><br><span class="line">        &#125;,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写background-ts"><a href="#编写background-ts" class="headerlink" title="编写background.ts"></a>编写background.ts</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; getSummary &#125; from &apos;@node-gptcommit/summarize&apos;</span><br><span class="line">// 监听收到通讯，发起总结请求</span><br><span class="line">chrome.runtime.onMessage.addListener(async (request: any, sender: any, sendResponse: any) =&gt; &#123;</span><br><span class="line">    const &#123; type = &apos;fetch&apos;, data &#125; = request;</span><br><span class="line">    if (type === &apos;summary&apos;) &#123;</span><br><span class="line">        getSummary(data).then(res=&gt;&#123;</span><br><span class="line">sendResponse(res);</span><br><span class="line">&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>在开发中遇到一个问题，就是如何快速调试chrome插件：</p><ol><li><code>build</code>后会，构建完的文件会有带<code>hash</code>值，如：<code>index.33addf.js</code>，导致chrome重新加载插件的时候出错，如：</li></ol><p><img src="/assets/img/20230227.png" alt="20230227"></p><p>解决方案很简单，就是利用rollupOptions设置输出文件不带hash值即可。</p><ol start="2"><li>没法实时调试插件，每次都需要<code>build</code>后才能去调试，这里需要更改构建方式，因为我们build出来的页面才是我们需要的，所以我们需要在<code>build</code>时候增加<code>--watch</code>，然后真正发布构建的时候关闭<code>watch</code>，调整后，<code>package.json</code>内容如下：</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"@node-gptcommit/chrome-extension"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.0"</span>,</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"vue-tsc &amp;&amp; vite build --watch"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"rimraf dist &amp;&amp; vue-tsc &amp;&amp; vite build"</span>,</span><br><span class="line">    <span class="attr">"preview"</span>: <span class="string">"vite preview"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目源码Github地址：<a href="https://github.com/qiubohong/node-gptcommit" target="_blank" rel="noopener">node-ngptcommit</a>，觉得有帮助的同学帮忙给个star给鼓励一下~❤️</p><p>后面基本上就是按照正常项目去开发即可，本文总结几个要点：</p><ul><li>chrome插件开发和正常web应用不太应用，既包括了html页面，也包括background.js的js库开发模式</li><li>Vite的核心点其实是Rollup，如果掌握Rollup基本上对vite做二次配置也很容易入手</li><li>为什么使用Vue，因为有大量的UI库和相关生态可以使用，能提高开发效率</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;之前写过一篇文章&lt;a href=&quot;https://qborfy.com/today/20230224.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《从开发chrome插件到插件系统设计》&lt;/a&gt;，主要讲述了如何开发一个chrome插件和chrome插件设计，感兴趣的同学可以再去看看。&lt;/p&gt;
&lt;p&gt;目前主流web应用都是基于Vue、React等现代框架去开发，Chrome插件本身而言其实也是一个web应用，看它的组成部分&lt;code&gt;popup.html&lt;/code&gt; + &lt;code&gt;contentscript&lt;/code&gt; + &lt;code&gt;background.js&lt;/code&gt; ，只需要在开发的时候调整一下构建脚本基本上就可以利用Vue、React等现代框架去开发了。&lt;/p&gt;
&lt;p&gt;接下来，我们就一步步开始实战。&lt;/p&gt;</summary>
    
    
    
    
    <category term="技术分享" scheme="https://www.qborfy.com/tags/技术分享/"/>
    
    <category term="每日更新" scheme="https://www.qborfy.com/tags/每日更新/"/>
    
  </entry>
  
  <entry>
    <title>2023年读书计划</title>
    <link href="https://www.qborfy.com/study/2023-read-plan.html"/>
    <id>https://www.qborfy.com/study/2023-read-plan.html</id>
    <published>2023-04-03T14:00:00.000Z</published>
    <updated>2023-04-06T15:17:17.150Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2023年读书计划"><a href="#2023年读书计划" class="headerlink" title="2023年读书计划"></a>2023年读书计划</h1><p>今年给自己的制定的计划，主要读书目标有以下几类：</p><ul><li>给自己的创业带来理论帮助</li><li>给自己的职业带来成长</li><li>给自己的更加开阔的视野</li><li>解答一些人生疑惑</li><li>提高自己的做事效率</li><li>提高自己的表达能力或演讲能力</li><li>搭建自己的股市交易系统<a id="more"></a></li></ul><h2 id="个人发展"><a href="#个人发展" class="headerlink" title="个人发展"></a>个人发展</h2><ul><li>已读<ul><li>百万富翁快车道，待写阅读后总结</li></ul></li><li>在读<ul><li>每周工作4小时，需要再次阅读后写总结</li><li>致所有疯狂的家伙：维珍创始人自传，需要再次阅读后写总结</li><li>高效人士的7个习惯，需快速阅读一遍后，再精读一遍</li></ul></li><li>待读<ul><li>金字塔表达力：用麦肯锡方法提升写作力和演讲力（实战图解版）</li><li>人性的弱点</li><li>乌合之众</li><li>王阳明心学——知行合一</li></ul></li></ul><h2 id="经济学"><a href="#经济学" class="headerlink" title="经济学"></a>经济学</h2><ul><li>已读</li><li>在读</li><li>待读<ul><li></li></ul></li></ul><h2 id="股市交易"><a href="#股市交易" class="headerlink" title="股市交易"></a>股市交易</h2><ul><li>已读</li><li>在读</li><li>待读<ul><li>思考的框架</li><li>海龟交易法则</li><li>投资的原则</li><li>我如何从股市赚了200万</li><li>股市投资的24堂必修课</li><li>我来教你变富</li></ul></li></ul><h2 id="技能类"><a href="#技能类" class="headerlink" title="技能类"></a>技能类</h2><ul><li>已读</li><li>在读<ul><li>Vue源码</li></ul></li><li>待读<ul><li>领域驱动设计</li></ul></li></ul><h2 id="人文类"><a href="#人文类" class="headerlink" title="人文类"></a>人文类</h2><ul><li>在读<ul><li>天道</li></ul></li><li>待读<ul><li>三体</li><li>人类简史</li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;2023年读书计划&quot;&gt;&lt;a href=&quot;#2023年读书计划&quot; class=&quot;headerlink&quot; title=&quot;2023年读书计划&quot;&gt;&lt;/a&gt;2023年读书计划&lt;/h1&gt;&lt;p&gt;今年给自己的制定的计划，主要读书目标有以下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给自己的创业带来理论帮助&lt;/li&gt;
&lt;li&gt;给自己的职业带来成长&lt;/li&gt;
&lt;li&gt;给自己的更加开阔的视野&lt;/li&gt;
&lt;li&gt;解答一些人生疑惑&lt;/li&gt;
&lt;li&gt;提高自己的做事效率&lt;/li&gt;
&lt;li&gt;提高自己的表达能力或演讲能力&lt;/li&gt;
&lt;li&gt;搭建自己的股市交易系统</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/学习总结/"/>
    
  </entry>
  
  <entry>
    <title>Typescript基础：如何更好的生成Typescript声明文件.d.ts</title>
    <link href="https://www.qborfy.com/today/20230226.html"/>
    <id>https://www.qborfy.com/today/20230226.html</id>
    <published>2023-03-30T10:00:01.000Z</published>
    <updated>2023-03-30T13:13:32.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Typescript已经被前端广泛使用，如果你的项目还没有使用，建议赶紧使用起来，真的会对你的项目有足够的提升：</p><ul><li>让你的每个变量都有变量声明</li><li>让你的每个方法找到其源头</li><li>让你能提前使用一些超前的JavaScript语法，如：注解(装饰器)<code>@controller</code> 等语法糖</li></ul><p>但是使用的过程也会带来一些痛苦，比如你要做一个js lib库，如果用<code>Typescript</code> 开发确实可以帮助其他者快速使用，但是如果你没有注意Typescript的声明文件规范，很容易出现以下使用情况：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会直接从src目录去寻找</span></span><br><span class="line"><span class="keyword">import</span> &#123; IClient &#125; <span class="keyword">from</span> <span class="string">'xxx-lib/src/client.d.ts'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 而我们所期待的使用是</span></span><br><span class="line"><span class="keyword">import</span> &#123; IClient&#125; <span class="keyword">from</span> <span class="string">'xxx-lib'</span></span><br></pre></td></tr></table></figure><p>所以我们需要学习一下，如何更好的生成我们的Typescript声明文件。</p><a id="more"></a><h1 id="Typescript声明文件"><a href="#Typescript声明文件" class="headerlink" title="Typescript声明文件"></a>Typescript声明文件</h1><blockquote><p>声明文件：当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。</p></blockquote><p>从官网定义而言，<code>声明文件.d.ts</code>就是用来给IDE编辑器解析<code>Typescript</code>代码声明的地方。</p><h2 id="学习声明"><a href="#学习声明" class="headerlink" title="学习声明"></a>学习声明</h2><p>目前Typescript提供各种类型，我们常用的有以下几种：</p><ul><li><code>declare var</code> 声明全局变量，如：<code>declare var jQuery: (selector: string) =&gt; any;</code> ，我们就可以在全局中使用<code>jQuery</code> 变量而不会报错</li><li><code>declare function</code> 声明全局方法</li><li><code>declare class</code> 声明全局类</li><li><code>declare enum</code> 声明全局枚举类型</li><li><code>declare namespace</code> 声明（含有子属性的）全局对象</li><li><code>interface</code> 和 <code>type</code> 声明全局类型</li></ul><p>其中，<code>declare</code>基本上都根据<code>Typescript</code> 中会自动生成，而<code>interface</code>和<code>type</code>则需要我们自己声明，自己使用。</p><h2 id="生成声明文件"><a href="#生成声明文件" class="headerlink" title="生成声明文件"></a>生成声明文件</h2><p>当你完成一个lib库开发，这个时候需要对外提供你声明文件，如：<code>import foo from &#39;foo&#39;</code></p><p>如果你需要对自己的<code>npm包</code>制作声明文件，具体有以下几个步骤：</p><ol><li>在<code>package.json</code>中的<code>types</code>和<code>typings</code> ，如：<code>&quot;types&quot;:&quot;dist/typings/index.d.ts&quot;</code></li><li>在项目根目录创建<code>typings</code> ，新建一个<code>index.d.ts</code> 用来暴露你lib库相关的声明</li><li>在<code>typescript.json</code>配置文件中，添加入口，如：<code>&quot;includes&quot;:[&quot;./typings/index.d.ts&quot;]</code></li></ol><p><strong>PS:</strong> <code>types</code>和<code>typings</code> 两者在package.json具有相同意义</p><p><code>package.json</code>示例如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"@node-gptcommit/git-utils"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"关于git的一些工具函数"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"dist/index.js"</span>,</span><br><span class="line">  <span class="attr">"types"</span>: <span class="string">"./dist/typings/index.d.ts"</span>,</span><br><span class="line">  <span class="attr">"typings"</span>: <span class="string">"./dist/typings/index.d.ts"</span>,</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"tsc -p tsconfig.release.json --outDir dist &amp;&amp; cp -r typings dist"</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line"><span class="attr">"@types/node"</span>: <span class="string">"^16"</span>,</span><br><span class="line"><span class="attr">"tslib"</span>: <span class="string">"^2.2.0"</span>,</span><br><span class="line"><span class="attr">"typescript"</span>: <span class="string">"^4.7.2"</span></span><br><span class="line">&#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"simple-git"</span>: <span class="string">"^3.17.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"qborfy"</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"MIT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>typescript.json</code> 示例如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"include"</span>: [</span><br><span class="line">    <span class="string">"src/*"</span>,</span><br><span class="line">    <span class="string">"typings/index.d.ts"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"baseUrl"</span>: <span class="string">"."</span>,</span><br><span class="line">    <span class="attr">"rootDir"</span>: <span class="string">"."</span>,</span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"ES2019"</span>,</span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"ESNext"</span>,</span><br><span class="line">    <span class="attr">"moduleResolution"</span>: <span class="string">"node"</span>,</span><br><span class="line">    <span class="attr">"strict"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"esModuleInterop"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"noImplicitOverride"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"noUnusedLocals"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"useUnknownInCatchVariables"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"declaration"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"declarationDir"</span>: <span class="string">"dist"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"exclude"</span>: [<span class="string">"node_modules"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="index-d-ts实现"><a href="#index-d-ts实现" class="headerlink" title="index.d.ts实现"></a>index.d.ts实现</h2><p>前面基本知道Typescript声明和如何在package.json标注好当前npm包会使用哪个声明文件，那么接下来，我们应该如何一个index.d.ts，主要靠以下几个：</p><ul><li><code>export</code> 导出变量</li><li><code>export namespace</code> 导出（含有子属性的）对象</li><li><code>export default</code> ES6 默认导出</li><li><code>export =</code> commonjs 导出模块</li></ul><p><strong>PS:</strong> 只有只有 <code>function</code>、<code>class</code>和 <code>interface</code> 支持<code>export default</code> </p><p><code>index.d.ts</code>示范：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// index.d.ts</span><br><span class="line">// 将src中的声明文件引入过来</span><br><span class="line">export * from &apos;../src/index&apos;;</span><br><span class="line"></span><br><span class="line">// 导出声明的函数</span><br><span class="line">export declare function bar(): string;</span><br></pre></td></tr></table></figure><p>使用<code>demo.js</code>示范：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//demo.js</span><br><span class="line">// 使用就如下 bar就是一个函数</span><br><span class="line">import &#123; bar &#125; from &apos;libs&apos;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>发布声明文件一般有两种做法：</p><ul><li>一种是发布到<code>@types/xxx</code> ，在<code>types</code>目录下新建一个<code>package.json</code>去维护，不推荐</li><li>另外一种是和<code>npm包</code>一起发布，目前基本上大多数都采用这种，本文也使用采用这种</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html" target="_blank" rel="noopener">《Typescript官网：声明文件》</a></li><li><a href="https://ts.xcatliu.com/basics/declaration-files.html" target="_blank" rel="noopener">《Typescript中文教程》</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;Typescript已经被前端广泛使用，如果你的项目还没有使用，建议赶紧使用起来，真的会对你的项目有足够的提升：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;让你的每个变量都有变量声明&lt;/li&gt;
&lt;li&gt;让你的每个方法找到其源头&lt;/li&gt;
&lt;li&gt;让你能提前使用一些超前的JavaScript语法，如：注解(装饰器)&lt;code&gt;@controller&lt;/code&gt; 等语法糖&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是使用的过程也会带来一些痛苦，比如你要做一个js lib库，如果用&lt;code&gt;Typescript&lt;/code&gt; 开发确实可以帮助其他者快速使用，但是如果你没有注意Typescript的声明文件规范，很容易出现以下使用情况：&lt;/p&gt;
&lt;figure class=&quot;highlight jsx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 会直接从src目录去寻找&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &amp;#123; IClient &amp;#125; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;xxx-lib/src/client.d.ts&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 而我们所期待的使用是&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &amp;#123; IClient&amp;#125; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;xxx-lib&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;所以我们需要学习一下，如何更好的生成我们的Typescript声明文件。&lt;/p&gt;</summary>
    
    
    
    
    <category term="技术分享" scheme="https://www.qborfy.com/tags/技术分享/"/>
    
    <category term="每日更新" scheme="https://www.qborfy.com/tags/每日更新/"/>
    
  </entry>
  
  <entry>
    <title>MonoRepo实战：pnpm+nx搭建MonoRepo项目</title>
    <link href="https://www.qborfy.com/today/20230225.html"/>
    <id>https://www.qborfy.com/today/20230225.html</id>
    <published>2023-03-29T10:00:01.000Z</published>
    <updated>2023-03-29T15:19:14.764Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MonoRepo实战：pnpm-nx搭建MonoRepo项目"><a href="#MonoRepo实战：pnpm-nx搭建MonoRepo项目" class="headerlink" title="MonoRepo实战：pnpm+nx搭建MonoRepo项目"></a>MonoRepo实战：pnpm+nx搭建MonoRepo项目</h1><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前有写过几篇关于monorepo的文章，具体如下：</p><ul><li><a href="https://qborfy.com/today/20230107.html" target="_blank" rel="noopener">从npm版本依赖到Monorepo大仓项目</a></li><li><a href="https://qborfy.com/today/20230119.html" target="_blank" rel="noopener">从lerna到初步了解和使用Nx(一)</a></li><li><a href="https://qborfy.com/today/20230219.html" target="_blank" rel="noopener">从pnpm工具了解整个npm包核心管理原理</a></li></ul><p>再次复习一下<code>MonoRepo</code>的概念：</p><blockquote><p>Monorepo是包含多个不同项目的单一存储库，且不同项目之间具有明确定义的关系。</p></blockquote><p>之前大多数是理论知识，能让我们知道<code>pnpm</code> 和<code>nx</code> 是什么，但是具体要到项目实战就有点懵，不知道从而下手，下面我们就一步步开始搭建<code>pnpm</code>+<code>nx</code>的Monorepo仓库。</p><p>PS：这里将会从已有项目中去开始踩坑，这里用的是之前做一个<a href="https://github.com/qiubohong/node-gptcommit.git" target="_blank" rel="noopener">node-gptcommit</a>命令行工具+一个chrome插件，将两个项目放到一个Monorepo仓库去管理。 </p><a id="more"></a><h1 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h1><h2 id="第一步，项目结构调整"><a href="#第一步，项目结构调整" class="headerlink" title="第一步，项目结构调整"></a>第一步，项目结构调整</h2><p>先来看看原先<code>node-gptcommit</code> 项目结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">node-gptcommit</span><br><span class="line">├── bin</span><br><span class="line">|  └── ngptcommit.js</span><br><span class="line">├── dist</span><br><span class="line">|  ├── ...</span><br><span class="line">├── src</span><br><span class="line">|  ├── ...</span><br><span class="line">├── test</span><br><span class="line">|  ├── ...</span><br><span class="line">├── jest.config.js</span><br><span class="line">├── babel.config.js</span><br><span class="line">├── package.json</span><br><span class="line">├── pnpm-lock.yaml</span><br><span class="line">├── rollup.config.ts</span><br><span class="line">├── tsconfig.json</span><br><span class="line">└── tslint.json</span><br><span class="line">├── README.en.md</span><br><span class="line">├── README.md</span><br></pre></td></tr></table></figure><p>再看一下<code>node-gptcommit-chrome</code>项目的目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">node-gptcommit-chrome</span><br><span class="line">├── dist</span><br><span class="line">|  ├── ...</span><br><span class="line">├── src</span><br><span class="line">|  ├── ...</span><br><span class="line">├── test</span><br><span class="line">|  ├── ...</span><br><span class="line">├── index.html</span><br><span class="line">├── package.json</span><br><span class="line">├── public</span><br><span class="line">├── tsconfig.json</span><br><span class="line">├── tsconfig.node.json</span><br><span class="line">└── vite.config.ts</span><br><span class="line">├── README.md</span><br></pre></td></tr></table></figure><p>接下来我们把项目结构做一下调整，将两个项目的代码挪到<code>packages</code>目录下，同时在新项目中初始化<code>npm init</code> ，大概结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">node-gptcommit</span><br><span class="line">├── apps # 应用层</span><br><span class="line">|  ├── chrome-extension # chrome插件</span><br><span class="line">|  |  ├── ...</span><br><span class="line">|  └── node-cli # 命令行工具</span><br><span class="line">|     ├── ...</span><br><span class="line">├── libs # 封装好的lib库</span><br><span class="line">|  └── summarize # 总结AI客户端 </span><br><span class="line">|     ├── ...</span><br><span class="line">├── README.md</span><br><span class="line">├── package.json</span><br></pre></td></tr></table></figure><h2 id="第二步，项目初始化"><a href="#第二步，项目初始化" class="headerlink" title="第二步，项目初始化"></a>第二步，项目初始化</h2><p>前提条件准备：</p><ul><li>安装全局<code>pnpm</code></li><li>升级node版本到16.19.0+，这里可以通过pnpm去管理node版本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先安装全局pnpm 后续需要根据pnpm + workplace去管理</span></span><br><span class="line">npm install pnpm -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换node版本</span></span><br><span class="line">pnpm env use --global 16</span><br></pre></td></tr></table></figure><h3 id="2-1-创建pnpm-workplace"><a href="#2-1-创建pnpm-workplace" class="headerlink" title="2.1 创建pnpm workplace"></a>2.1 创建pnpm workplace</h3><ol><li>新建<code>pnpm workplace</code>工作空间文件<code>pnpm-workspace.yaml</code> ，具体如下:</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">packages:</span></span><br><span class="line">  <span class="comment"># 会将packages下面归纳给到pnpm工作空间进行管理</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'packages/*'</span></span><br><span class="line"><span class="comment"># 排除下面的目录</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'!**/test/**'</span></span><br></pre></td></tr></table></figure><ol start="2"><li>子项目互相依赖的时候，可以通过<code>workplace:</code> 协议去设置依赖，支持一下几种写法：</li></ol><ul><li><code>“npm_name”: “workplace: *”</code>  所有版本都依赖本地工作空间</li><li><code>“npm_name”: “workplace: npm_name@1.0.0”</code> 指定版本写法</li><li><code>“npm_name”: “workplace: ../npm_name”</code>  相对路径写法</li></ul><p>因此<code>apps</code> 中的应用层加入对公共库<code>libs</code>的依赖，如在<code>apps/node-cli</code> 将</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">"dependencies": &#123;</span><br><span class="line">    "@node-gptcommit/summarize": "workplace: *",</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>子项目中需要对<code>package.json</code> 中的<code>scripts</code> 中做统一管理，如下：</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">"scripts": &#123;</span><br><span class="line">    "build": "xxx", //按照各自的项目填写对应的构建脚本</span><br><span class="line">    "dev": "xxx",</span><br><span class="line">    "test": "xxx"</span><br><span class="line">  &#125;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-引入nx，实现按序打包"><a href="#2-2-引入nx，实现按序打包" class="headerlink" title="2.2 引入nx，实现按序打包"></a>2.2 引入<code>nx</code>，实现按序打包</h3><ol><li>全局安装和在项目根目录下安装 <code>nx</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局安装方便后面调试项目使用</span></span><br><span class="line">pnpm install nx -g</span><br><span class="line"><span class="comment"># 项目nx初始化 注意目录不能已经安装nx或者有nx.json</span></span><br><span class="line">npx nx@latest init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 官网里 npx nx@latest init 一直有问题，回头去定位看看</span></span><br></pre></td></tr></table></figure><p><code>nx</code>在<code>monorepo</code> 架构中里主要解决几个问题：</p><ul><li>解决项目中互相依赖问题，就是构建顺序问题，其任务流有点像管道的概念</li><li>解决项目中打包缓存问题，比如：一些公共包没有多大变动，就不需要再次打包</li><li>提供一些快捷工具快速引入一个子项目或公共包</li></ul><p>还需要转变一个观点：</p><p><strong>重要提示：nx会接手项目的所有打包流程，因此所有相关的命令都由nx进行触发</strong></p><ol start="2"><li>自动生成的 <code>nx.json</code> 解析认知 ，</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">"workspaceLayout": &#123; // 工作空间配置</span><br><span class="line">    "appsDir": "apps", // 应用层文件夹</span><br><span class="line">    "libsDir": "libs" // 公共库文件夹</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">  "targetDefaults": &#123; // 统一的配置项，用于覆盖每个项目中的project.json配置</span><br><span class="line">    "build": &#123; // 统一构建选项</span><br><span class="line">      "dependsOn": ["^build"], // 当构建的时会自动将依赖的其他子项目也进行构建build</span><br><span class="line">      "inputs": ["production", "^production"] // 构建</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "tasksRunnerOptions": &#123; // 任务执行器选项</span><br><span class="line">    "default": &#123; // 默认的任务执行器的选项</span><br><span class="line">      "runner": "nx/tasks-runners/default", // 任务执行器</span><br><span class="line">      "options": &#123;</span><br><span class="line">      "parallel": 5, // 构建并发线程个数</span><br><span class="line">        "cacheableOperations": ["build", "lint", "test"] // 可缓存的操作</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>nx.json</code> 主要用来配置子项目的构建顺序和控制缓存，比如：</p><ul><li>构建顺序：在项目中<code>apps</code>进行<code>build</code>操作时候会依赖<code>libs</code>项目中的<code>build</code> ，就可以在<code>targetDefaults</code>中配置<code>&quot;dependsOn&quot;: [&quot;^build&quot;]</code>，举个例子：<ul><li>当<code>apps</code>的子项目<code>node-cli</code>在运行build操作</li><li>会提前将依赖的<code>libs</code>中的<code>summarize</code>子项目也进行<code>build</code></li></ul></li><li>控制缓存：提高构建速度，利用缓存，但是有时候我们并不需要每个构建命令都去缓存，这个时候就可以用<code>tasksRunnerOptions</code>中的<code>cacheableOperations</code>去控制</li></ul><p><code>nx.json</code> 的其他详细配置可以到官网中查看<a href="https://nx.dev/reference/nx-json" target="_blank" rel="noopener">nx.json</a>。</p><ol start="3"><li>调整根目录<code>package.json</code>中<code>scripts</code>，后续将采用<code>nx</code>去进行分发构建任务： </li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "scripts": &#123;</span><br><span class="line">    "build": "nx run-many --target=build",</span><br><span class="line">    "dev": "nx run-many --target=dev",</span><br><span class="line">    "test": "nx run-many --target=test"</span><br><span class="line">  &#125;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>nx一些命令工具，如使用<code>nx graph</code> 可以看到Monorepo中子项目相互依赖情况，如下图所示：<br><img src="/assets/img/2023-03-29.png" alt="Untitled"><br>更多使用命令，可以到官网查看：<a href="https://nx.dev/reference/commands" target="_blank" rel="noopener">nx命令脚本</a></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到了这里，我们完成Monorepo基本架构的搭建，后续工作就依据不同的业务或代码进行重设计代码结构。</p><p>Monorepo架构有个很明显好处，就当你的项目需要新增一个子项目或者依据现有的功能进行剥离成功公共组件，将会很轻松就实现。比如说，当我的node-gptcommit需要新增一个桌面端，那么我就可以根据现有的libs库快速开发完成。</p><p>在<code>pnpm</code>+<code>nx</code> 搭建Monorepo项目中，我们可以学习到几个点：</p><ul><li>使用<code>pnpm</code> 替代<code>yarn</code>或<code>npm</code> 管理<code>node_modules</code> ，不仅快，而且会比较稳定，因为它不允许代码引入一些未在<code>package.json</code>使用的<code>npm</code>包</li><li>使用<code>pnpm</code> 同时支持一些<code>libs</code> 被其他apps的子应用依赖，如: <code>&quot;@node-gptcommit/git-utils&quot;: &quot;workplace: *”</code></li><li><code>nx</code> 在使用上会需要一些门槛，尤其需要理解其中几个点：<ul><li>第一，子项目互相依赖，<code>nx</code>可以在build构建的时候将另外一个包也同时build构建</li><li>第二，<code>nx</code>会取代掉我们平时在根目录使用<code>yarn build</code>或<code>npm build</code> 的习惯，而是采用<code>nx build</code></li><li>第三，<code>nx</code> 提供一些常用的命令行，如：<code>nx graph</code> 能让我们快速解决Monorepo架构常见的依赖问题</li></ul></li></ul><p>本博文项目Github源码地址： <a href="https://github.com/qiubohong/node-gptcommit" target="_blank" rel="noopener">node-gptcommit</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://nx.dev/recipes/adopting-nx/adding-to-monorepo#installing-nx" target="_blank" rel="noopener">nx官方教程：在yarn/npm/pnpm的workplace项目中添加nx</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;MonoRepo实战：pnpm-nx搭建MonoRepo项目&quot;&gt;&lt;a href=&quot;#MonoRepo实战：pnpm-nx搭建MonoRepo项目&quot; class=&quot;headerlink&quot; title=&quot;MonoRepo实战：pnpm+nx搭建MonoRepo项目&quot;&gt;&lt;/a&gt;MonoRepo实战：pnpm+nx搭建MonoRepo项目&lt;/h1&gt;&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;之前有写过几篇关于monorepo的文章，具体如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://qborfy.com/today/20230107.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;从npm版本依赖到Monorepo大仓项目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://qborfy.com/today/20230119.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;从lerna到初步了解和使用Nx(一)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://qborfy.com/today/20230219.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;从pnpm工具了解整个npm包核心管理原理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再次复习一下&lt;code&gt;MonoRepo&lt;/code&gt;的概念：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Monorepo是包含多个不同项目的单一存储库，且不同项目之间具有明确定义的关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前大多数是理论知识，能让我们知道&lt;code&gt;pnpm&lt;/code&gt; 和&lt;code&gt;nx&lt;/code&gt; 是什么，但是具体要到项目实战就有点懵，不知道从而下手，下面我们就一步步开始搭建&lt;code&gt;pnpm&lt;/code&gt;+&lt;code&gt;nx&lt;/code&gt;的Monorepo仓库。&lt;/p&gt;
&lt;p&gt;PS：这里将会从已有项目中去开始踩坑，这里用的是之前做一个&lt;a href=&quot;https://github.com/qiubohong/node-gptcommit.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;node-gptcommit&lt;/a&gt;命令行工具+一个chrome插件，将两个项目放到一个Monorepo仓库去管理。 &lt;/p&gt;</summary>
    
    
    
    
    <category term="技术分享" scheme="https://www.qborfy.com/tags/技术分享/"/>
    
    <category term="每日更新" scheme="https://www.qborfy.com/tags/每日更新/"/>
    
  </entry>
  
  <entry>
    <title>从开发chrome插件到插件系统设计</title>
    <link href="https://www.qborfy.com/today/20230224.html"/>
    <id>https://www.qborfy.com/today/20230224.html</id>
    <published>2023-03-22T10:00:01.000Z</published>
    <updated>2023-03-22T14:59:05.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近ChatGPT的技术概念很火热，我开发了一个<a href="https://github.com/qiubohong/node-gptcommit" target="_blank" rel="noopener">node-gptcommit</a>开源项目，主要利用GPT用来自动生成git commit的信息。</p><p>但是通过命令行工具来生成preview感觉有点不太友好，因此在想有没有另外一种可能将其变得更加好用，然后想到一个场景：</p><ul><li>在合mr的时候，以及代码review，很多git commit 文件，需要一一个看</li></ul><p>在这个时刻，自动生成commit信息就显得很有用，因此我的方案就是将<code>node-gptcommit</code>做成chrome插件，然后帮助MR的开发者能够快速了解此次MR的所有内容。</p><p>当然仅仅是开发一个chrome插件大家上网随便搜一下就知道怎么开发，因此为了本文更加有干货，需要更加深入的知识，所以本文分为两部分：</p><ul><li>Chrome插件开发，如何快速开发一个插件</li><li>Chrome插件架构设计，了解Chrome插件背后的架构设计，以及前端插件架构体系</li></ul><a id="more"></a><h1 id="Chrome插件开发"><a href="#Chrome插件开发" class="headerlink" title="Chrome插件开发"></a>Chrome插件开发</h1><p>Chrome插件是一种浏览器扩展程序，可以增强浏览器的功能和用户体验。Chrome插件可以添加新的工具栏、菜单、快捷键、热键等，还可以修改网页的行为和外观，以及与网页交互，实现各种功能。常见的Chrome插件包括广告拦截器、翻译插件、下载管理器、音乐播放器等。</p><p>开发Chrome插件其实很简单，因为Chrome的插件主要描述文件<code>mainfest.json</code>，还有包含在里面的一些其他文件，具体如下：</p><ul><li>manifest.json文件，用于指定插件的名称、版本号、描述等信息，以及指定插件的各种权限和资源</li><li>popup.html文件，主要用于显示插件的弹出窗口，提供用户界面和交互功能</li><li>content scripts文件，用于向网页注入JavaScript代码，从而实现与网页的交互。这些脚本可以访问网页的DOM和JavaScript对象，并且可以向网页发送消息和接收来自网页的消息。</li><li>background scripts文件，用于在Chrome插件的后台运行JavaScript代码，可以与popup、contentscript等通讯，可以实现发起网络请求、拦截用户访问请求等操作</li></ul><p>一个标准的Chrome插件目录结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">my-extension/</span><br><span class="line">├── _locales/</span><br><span class="line">│   ├── en/</span><br><span class="line">│   │   └── messages.json</span><br><span class="line">│   └── zh/</span><br><span class="line">│       └── messages.json</span><br><span class="line">├── css/</span><br><span class="line">│   └── popup.css</span><br><span class="line">├── img/</span><br><span class="line">│   ├── icon128.png</span><br><span class="line">│   ├── icon48.png</span><br><span class="line">│   └── icon16.png</span><br><span class="line">├── js/</span><br><span class="line">│   ├── background.js</span><br><span class="line">│   ├── content.js</span><br><span class="line">│   └── popup.js</span><br><span class="line">├── popup.html</span><br><span class="line">├── manifest.json</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure><p>其中，各个文件夹和文件的作用如下：</p><ul><li><code>_locales/</code>：存放插件的本地化文件，用于支持不同语言版本的插件。</li><li><code>css/</code>：存放插件的CSS样式文件。</li><li><code>img/</code>：存放插件的图标文件。</li><li><code>js/</code>：存放插件的JavaScript文件，包括background scripts、content scripts和popup scripts等。</li><li><code>popup.html</code>：插件的popup页面。</li><li><code>manifest.json</code>：插件的配置文件，用于指定插件的名称、版本号、描述等信息，以及指定插件的各种权限和资源。</li><li><code>README.md</code>：插件的说明文档，用于介绍插件的功能和使用方法等。</li></ul><h2 id="manifest-json"><a href="#manifest-json" class="headerlink" title="manifest.json"></a>manifest.json</h2><p>manifest.json是Chrome插件的配置文件，用于指定插件的名称、版本号、描述等信息，以及指定插件的各种权限和资源。</p><p>下面是一个完整的<code>manifest.json</code>文件的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;manifest_version&quot;: 2,</span><br><span class="line">  &quot;name&quot;: &quot;My Chrome Extension&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;This is a description of my Chrome extension.&quot;,</span><br><span class="line">  &quot;icons&quot;: &#123;</span><br><span class="line">    &quot;16&quot;: &quot;icon16.png&quot;,</span><br><span class="line">    &quot;48&quot;: &quot;icon48.png&quot;,</span><br><span class="line">    &quot;128&quot;: &quot;icon128.png&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;background&quot;: &#123;</span><br><span class="line">    &quot;scripts&quot;: [&quot;background.js&quot;]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;content_scripts&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;matches&quot;: [&quot;*://*.example.com/*&quot;],</span><br><span class="line">      &quot;js&quot;: [&quot;content.js&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;permissions&quot;: [</span><br><span class="line">    &quot;tabs&quot;,</span><br><span class="line">    &quot;*://*.example.com/*&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>manifest_version：指定manifest.json文件的版本号，一般为2</li><li>name：指定插件的名称</li><li>version：指定插件的版本号</li><li>description：指定插件的描述</li><li>icons：指定插件的图标，这里16、 48、128指的是需要展示在不同场景插件的图标</li><li>browser_action：可以配置的popup页面和图标</li><li>permissions：插件需要的权限，例如访问浏览器标签页，以及只允许在<code>*://.example.com/</code>域名才有效</li></ul><p>还有两个相对复杂配置项：</p><ul><li>content_scripts: content_scripts指定插件需要向<code>*://.example.com/</code>注入JavaScript代码，代码位于<code>content.js</code>文件中</li><li>background：指定插件的<code>background.js</code>文件为background scripts</li></ul><h2 id="popup-html"><a href="#popup-html" class="headerlink" title="popup.html"></a>popup.html</h2><p>就是一个简单html文件，里面需要插件的UI展示，demo如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>My Chrome Extension<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"popup.css"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"popup.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is my first Chrome extension.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"myButton"</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>popup.html文件可以包含任何HTML、CSS和JavaScript代码，用于构建插件的用户界面和交互功能。在上面的例子中，popup.html文件包含一个标题、一段文本和一个按钮，按钮的点击事件可以在popup.js文件中进行处理。需要注意的是，popup.html文件的UI通常比较简单，因为其主要作用是提供与用户的交互和反馈。</p><p>除了HTML、CSS和JavaScript代码外，popup.html文件还可以包含其他类型的资源文件，例如图片、音频或视频文件等。这些资源文件可以放置在相应的目录下，并在HTML代码中使用相应的路径引用。在实际开发中，可以根据需要对popup.html文件进行扩展和修改，以实现更复杂的用户界面和交互功能。</p><h2 id="content-scripts"><a href="#content-scripts" class="headerlink" title="content_scripts"></a>content_scripts</h2><p><code>content_scripts</code>你可以当成用户页面内的js，Content scripts常用于修改网页的行为和外观，以及与网页交互，实现各种功能。例如，可以通过content scripts实现自动填充表单、隐藏广告、添加自定义菜单等功能。下面是一个简单的content_scripts的例子，使得当用户进入Google搜索页面时，输入框默认输入“Hello World!”：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// manifest.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"My Content Script"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0"</span>,</span><br><span class="line">  <span class="string">"manifest_version"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">"content_scripts"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"matches"</span>: [<span class="string">"&lt;https://www.google.com/*&gt;"</span>],</span><br><span class="line">      <span class="string">"js"</span>: [<span class="string">"content.js"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// content.js</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'input[name="q"]'</span>).value = <span class="string">'Hello World!'</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们在manifest.json文件中指定了一个content_scripts，用于在用户进入<code>https://www.google.com/*</code>网页时自动向Google搜索框中输入<code>“Hello World!”</code>。具体实现的代码在content.js文件中，使用document.querySelector()函数获取到输入框，并将其value属性设置为“Hello World!”。</p><p>需要注意的是，<code>content_scripts</code>只能访问网页的DOM和JavaScript对象，并不能直接访问插件的资源和API。如果插件需要向网页发送消息或从网页接收消息，可以使用<code>chrome.runtime.sendMessage()</code>和<code>chrome.runtime.onMessage()</code>等API实现。</p><h2 id="backgroundjs"><a href="#backgroundjs" class="headerlink" title="backgroundjs"></a>backgroundjs</h2><p><code>backgroundjs</code>是运行在后台的一个js文件，里面可以实现各种监听，如：tab监听、插件初始化、sendmessage、onmessage等事件，下面我们来实现一个简单的发送网络请求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">chrome.runtime.onMessage.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">request, sender, sendResponse</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (request.type === <span class="string">'fetch'</span>) &#123;</span><br><span class="line">    fetch(request.url)</span><br><span class="line">      .then(<span class="function"><span class="params">response</span> =&gt;</span> response.text())</span><br><span class="line">      .then(<span class="function"><span class="params">data</span> =&gt;</span> sendResponse(&#123; <span class="attr">success</span>: <span class="literal">true</span>, data &#125;))</span><br><span class="line">      .catch(<span class="function"><span class="params">error</span> =&gt;</span> sendResponse(&#123; <span class="attr">success</span>: <span class="literal">false</span>, error &#125;));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>常用的监听事件有：</p><ul><li><code>chrome.runtime.onMessage.addListener()</code>, 监听插件传递过来的的消息事件</li><li><code>chrome.runtime.onInstalled.addListener()</code>, 监听插件的安装事件</li><li><code>chrome.runtime.onStartup.addListener()</code>, 监听插件的启动事件</li><li><code>chrome.tabs.onUpdated.addListener()</code>, 监听浏览器标签页更新事件</li></ul><p>当然对应的事件都需要在<code>manifest.json</code>中<code>permissions</code>去配置才能开启。</p><h1 id="Chrome插件设计架构"><a href="#Chrome插件设计架构" class="headerlink" title="Chrome插件设计架构"></a>Chrome插件设计架构</h1><p>既然弄明白了如何开发一个Chrome插件，那么作为一个合格的程序员，我们不仅要知道是什么，还要知道为什么，这才能让你不断地进步。</p><p>我们回头再来思考一下，插件有什么用，以及为什么要有插件？</p><blockquote><p>插件最大的作用就是扩展主应用App的功能，同时支持可插拔特性，就是有没有插件，都不会影响现有主应用功能正常使用。</p></blockquote><p>接下来我们来思考，如何我来开发一个chrome插件系统，我应该如何设计呢？下面是简易Chrome插件系统的架构图：</p><div class="mxgraph-container">    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/chrome-extends.drawio&quot;}"></div></div><p>有了上面的架构，我们可以大概知道实现一个插件系统需要几个功能点：</p><ul><li>插件管理，需要有插件上传、加载、版本机制等功能</li><li>暴露能力，需要确定暴露哪些API能力，同时还需要展示插件的UI</li><li>隔离环境，需要确保插件的隔离性，不影响主应用的运行，这里就需要我们去用iframe的模式去执行</li></ul><h2 id="插件系统设计"><a href="#插件系统设计" class="headerlink" title="插件系统设计"></a>插件系统设计</h2><p>有了对chrome的插件架构有一定了解后，如果这个时候需要我们需要对某个平台去实现一个插件系统，我们应当如何入手以及设计？</p><p>在做插件系统之前，我们需要再明确一下插件的定义：</p><blockquote><p>插件是平台核心功能的一种扩展，是在平台生命周期流程中的不同节点去扩展或调整功能</p></blockquote><p>接下来，我们按照几个步骤去实现插件：</p><h3 id="插件系统的定位"><a href="#插件系统的定位" class="headerlink" title="插件系统的定位"></a>插件系统的定位</h3><p>我们的插件肯定依附于某个平台或应用上的，因此我们需要先对平台能力做一个定位，就以Chrome为例子，chrome浏览器作为展示网页为核心功能。</p><p>那么如果去设计一个插件系统，肯定是围绕着网页展示的扩展功能去做插件系统设计。</p><h3 id="插件系统的基础能力"><a href="#插件系统的基础能力" class="headerlink" title="插件系统的基础能力"></a>插件系统的基础能力</h3><p>插件系统的基础能力包括以下几点：</p><ul><li>插件管理，需要插件管理界面，面对开发者：，提供上传、版本管理等功能，面对使用者：需要提供安装、查询、删除等功能</li><li>插件开发，需要给开发者提供工具、文档、规范、发布流程等方便的信息</li></ul><h3 id="插件系统架构设计"><a href="#插件系统架构设计" class="headerlink" title="插件系统架构设计"></a>插件系统架构设计</h3><p>针对不同平台，可能需要插件架构是不一样的，如：Chrome，采用的并行机制，不同插件可以在同一时间加载、输出。</p><p>前端领域很多有插件实现架构，按照执行顺序可以大概分为如下几种：</p><table><thead><tr><th align="left">插件架构</th><th align="left">描述</th><th align="left">适⽤场景</th><th align="left">框架或应用</th></tr></thead><tbody><tr><td align="left">顺序执行</td><td align="left">显然就是从头执行到尾，不断对内容做修改</td><td align="left">⼤多数场景</td><td align="left">babel plugin</td></tr><tr><td align="left">瀑布流</td><td align="left">上一层输出就是下一层输入，这里就是管道概念</td><td align="left">管道</td><td align="left">Gulp</td></tr><tr><td align="left">洋葱</td><td align="left">不仅关注输入，而且关心输出，还可以随时直接输出</td><td align="left">进出</td><td align="left">Koa</td></tr><tr><td align="left">并发执⾏</td><td align="left">多个输入，对多个插件输出做一个总结输出</td><td align="left">⽆序任务</td><td align="left">webpack complier</td></tr></tbody></table><p><strong><em>(这里参考自<a href="https://www.zaozao.run/video/c61/c61-4" target="_blank" rel="noopener">前端早早聊 2023年前端插件设计专场 【洋葱：插件化设计在前端领域的应用】</a>)</em></strong></p><p>同时，从架构上还需要考虑以下几点：</p><ul><li>插件接口，指的是哪些平台哪些接口Hook，允许插件访问或改变</li><li>插件管理器，指的平台如何管理插件，包括更新、审核、插件的文件模式等。</li><li>插件加载器，指的平台如何加载插件，是在加载过程需要如何塞入暴露能力等。</li><li>插件生命周期，指的是一个插件有哪些生命周期节点，如：安装、加载、运行、卸载、禁用等</li></ul><h3 id="插件系统的安全和稳定性"><a href="#插件系统的安全和稳定性" class="headerlink" title="插件系统的安全和稳定性"></a>插件系统的安全和稳定性</h3><p>我们不仅要考虑插件功能实现，还需要考虑插件的安全和稳定性，主要从以下几方面入手：</p><ul><li>插件的安全验证，指的是如何限制非法插件的使用</li><li>插件的权限控制，指的是如何限制插件的权限</li><li>插件的资源隔离，指的是如何确保插件其运行环境不可以访问平台其他非暴露资源</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过本文，我们不仅学会了Chrome插件的开发，还对插件系统的设计有一定的认知，我们回顾一下：</p><ul><li>Chrome插件开发，主要组成部分为：manifest.json，popup.html，content_scripts和background.js</li><li>插件系统设计，主要考虑的点：管理、开发工具和文档、暴露能力、安全与稳定</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://chrome.google.com/webstore/category/extensions?hl=zh-CN" target="_blank" rel="noopener">Chrome应用商店</a></li><li><a href="https://developer.chrome.com/docs/extensions/mv3/getstarted/" target="_blank" rel="noopener">Chrome插件开发文档</a></li><li><a href="https://www.zaozao.run/video/c61" target="_blank" rel="noopener">前端早早聊 2023年前端插件专场</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近ChatGPT的技术概念很火热，我开发了一个&lt;a href=&quot;https://github.com/qiubohong/node-gptcommit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;node-gptcommit&lt;/a&gt;开源项目，主要利用GPT用来自动生成git commit的信息。&lt;/p&gt;
&lt;p&gt;但是通过命令行工具来生成preview感觉有点不太友好，因此在想有没有另外一种可能将其变得更加好用，然后想到一个场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在合mr的时候，以及代码review，很多git commit 文件，需要一一个看&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这个时刻，自动生成commit信息就显得很有用，因此我的方案就是将&lt;code&gt;node-gptcommit&lt;/code&gt;做成chrome插件，然后帮助MR的开发者能够快速了解此次MR的所有内容。&lt;/p&gt;
&lt;p&gt;当然仅仅是开发一个chrome插件大家上网随便搜一下就知道怎么开发，因此为了本文更加有干货，需要更加深入的知识，所以本文分为两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Chrome插件开发，如何快速开发一个插件&lt;/li&gt;
&lt;li&gt;Chrome插件架构设计，了解Chrome插件背后的架构设计，以及前端插件架构体系&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="技术分享" scheme="https://www.qborfy.com/tags/技术分享/"/>
    
    <category term="每日更新" scheme="https://www.qborfy.com/tags/每日更新/"/>
    
  </entry>
  
  <entry>
    <title>不要再使用轮询了，请用SSE服务端推送完成页面实时更新</title>
    <link href="https://www.qborfy.com/today/20230223.html"/>
    <id>https://www.qborfy.com/today/20230223.html</id>
    <published>2023-03-17T10:00:01.000Z</published>
    <updated>2023-03-17T12:38:05.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近开发一个页面碰到一个需求，需要对部分数据需要实时更新状态，面对这样子的场景，我们通常有以下几个方案：</p><ul><li>轮询，利用setTimeout定时轮询</li><li>WebSocket，利用长链接保持与服务通讯</li><li>SSE，服务端推送机制</li></ul><a id="more"></a><h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>我们先简单认识一下这三者的区别：</p><h2 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h2><p>轮询就是利用setTimeout的定时器，定时向服务器发起请求，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timeout = <span class="number">0</span>;</span><br><span class="line">functon rollRequest(requestFunc, times, immediately)&#123;</span><br><span class="line">    <span class="keyword">if</span>(timeout !== <span class="number">0</span>)&#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(immediately)&#123;</span><br><span class="line">        requestFunc &amp;&amp; requestFunc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        requestFunc &amp;&amp; requestFunc();</span><br><span class="line">        rollRequest(requestFunc, times, <span class="literal">false</span>);</span><br><span class="line">    &#125;, times);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>无用请求过多，可能每次请求返回的内容都是相同</li><li>实时性不可控，如果内容更新了，但是页面无法及时更新</li></ul><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>针对上面轮询的缺点，WebSokcet长链接就能很好解决，如：</p><ul><li>建立链接后，当服务器发现数据发生变化后才返回</li><li>可控性高，客户端和服务端都可以互相通信</li></ul><p>具体实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">`wss://127.0.0.1:8081`</span>);</span><br><span class="line"></span><br><span class="line">ws.send(<span class="string">"这是一条消息："</span> + count);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听消息</span></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line">ws.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="keyword">var</span> WebSocketServer = <span class="built_in">require</span>(<span class="string">'ws'</span>).Server,</span><br><span class="line">wss = <span class="keyword">new</span> WebSocketServer(&#123; <span class="attr">port</span>: <span class="number">8181</span> &#125;);</span><br><span class="line">wss.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ws</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'client connected'</span>);</span><br><span class="line">    ws.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(message);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>可能实现方案对于一个页面数据更新有点太重了，主要包括以下几点：</p><ul><li>需要有完整链路认证，如：鉴权、登录等</li><li>心跳机制实现，前后端都需要设置</li><li>前后端需要规定数据返回规范</li><li>服务端需要日志记录</li></ul><h2 id="SSE服务端推送"><a href="#SSE服务端推送" class="headerlink" title="SSE服务端推送"></a>SSE服务端推送</h2><p>SSE全称Server-sent Events，是HTML 5 规范的一个组成部分，它主要由两部分组成：</p><ul><li>第一部分是服务端和浏览器的通讯协议</li><li>第二部分是前端需要利用<code>EventSource</code>去监听返回数据</li></ul><p>对比WebSocket：</p><table><thead><tr><th>SSE</th><th>WebSocket</th></tr></thead><tbody><tr><td>单向：仅服务端能发送消息</td><td>双向：客户端、服务端双向发送</td></tr><tr><td>仅文本数据</td><td>二进制、文本都可</td></tr><tr><td>常规HTTP协议</td><td>WebSocket协议</td></tr></tbody></table><p>实现一个SSE代码如下：<br><strong>浏览器：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>SSE Demo测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>SSE返回内容<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> eventSource = <span class="keyword">new</span> EventSource(<span class="string">'http://localhost:3000/sse'</span>);</span></span><br><span class="line"><span class="javascript">        eventSource.onmessage = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>).innerHTML = <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>).innerHTML + <span class="string">`&lt;p&gt;<span class="subst">$&#123;event.data&#125;</span>&lt;/p&gt;`</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>服务端：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a server</span></span><br><span class="line"><span class="keyword">const</span> server = http.createServer()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听路由</span></span><br><span class="line">server.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'request'</span>, req.url)</span><br><span class="line">    <span class="keyword">if</span> (req.url === <span class="string">'/sse'</span>) &#123;</span><br><span class="line">        <span class="comment">// Set CORS headers</span></span><br><span class="line">        res.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>)</span><br><span class="line">        res.setHeader(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'GET, OPTIONS'</span>)</span><br><span class="line">        res.setHeader(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Content-Type'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set SSE headers</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/event-stream'</span>)</span><br><span class="line">        res.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'no-cache'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Send a ping approx every 2 seconds</span></span><br><span class="line">        res.write(<span class="string">"retry: 10000\n\n"</span>);</span><br><span class="line">        res.write(<span class="string">"event: connecttime\n\n"</span>);</span><br><span class="line">        res.write(<span class="string">"data: 第一次发送:"</span> + (<span class="keyword">new</span> <span class="built_in">Date</span>()) + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟收到消息推送给客户端</span></span><br><span class="line">        interval = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            res.write(<span class="string">"data: 后续更新"</span> + (<span class="keyword">new</span> <span class="built_in">Date</span>()) + <span class="string">"\n\n"</span>);</span><br><span class="line">        &#125;, <span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (req.url === <span class="string">'/index.html'</span> || req.url === <span class="string">'/'</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果是html文件，返回html文件</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>)</span><br><span class="line">        <span class="keyword">const</span> html = fs.readFileSync(<span class="string">'./public/index.html'</span>);</span><br><span class="line">        res.end(html)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listen</span></span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Server started on port 3000'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul><li><p>兼容性问题，但是目前绝大部分浏览器是支持的，如果不支持可以采用降级方案——轮询</p></li><li><p>会长期占用一个http链接，</p><ul><li>可能会导致浏览器(chrome最大http请求数是6)无法发起其他请求，这里注意是一个坑，需要设置一个超时时间，如果长时间无返回数据更新可以关闭链接</li><li>解决方案，升级到http2协议可解决http请求数限制问题，放到后面《如何搭建http2网站》讲解</li></ul></li><li><p>客户端无法主动向服务器发起请求，可能造成后续问题定位难点</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>前端实时更新需求，有多个解决方案，下面进行总结：</p></li><li><p>目前最常用的轮询，是最稳定的，但是却无法做到实时</p></li><li><p>WebSocket可以实时，但是需要服务端和客服端长期保持一致，如果哪一方断了将无法继续</p></li><li><p>SSE是服务推送，可以满足大部分场景，但是也需要谨慎使用，避免占用过多链接导致其他无法发送请求</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://mp.weixin.qq.com/s/K8g2PNO4Ixc1LrUafXunPQ" target="_blank" rel="noopener">数据不够实时：试试长连接？</a></p></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近开发一个页面碰到一个需求，需要对部分数据需要实时更新状态，面对这样子的场景，我们通常有以下几个方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;轮询，利用setTimeout定时轮询&lt;/li&gt;
&lt;li&gt;WebSocket，利用长链接保持与服务通讯&lt;/li&gt;
&lt;li&gt;SSE，服务端推送机制&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="技术分享" scheme="https://www.qborfy.com/tags/技术分享/"/>
    
    <category term="每日更新" scheme="https://www.qborfy.com/tags/每日更新/"/>
    
  </entry>
  
</feed>
