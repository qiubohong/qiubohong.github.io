<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>qborfy知识库</title>
  
  
  <link href="https://www.qborfy.com/atom.xml" rel="self"/>
  
  <link href="https://www.qborfy.com/"/>
  <updated>2023-05-25T05:07:48.718Z</updated>
  <id>https://www.qborfy.com/</id>
  
  <author>
    <name>qborfy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端架构——利用chatgpt成为架构师（1）</title>
    <link href="https://www.qborfy.com/framework/framework-with-chatgpt-1.html"/>
    <id>https://www.qborfy.com/framework/framework-with-chatgpt-1.html</id>
    <published>2023-05-26T10:00:01.000Z</published>
    <updated>2023-05-25T05:07:48.718Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“有时我对 ChatGPT 的理解能力感到惊讶，但是更多时候，我不得不拼命推动它，朝着我想要的方向前进。它有时会产生意料之外的结果，让我感到非常沮丧。”</p><p>“它像一个吸收了所有人类知识、但需要别人帮忙才能把这些知识串起来的应届毕业生。”</p><p>“看来我今年的工作是安全的。但是，我需要好好学习 ChatGPT，精通它的使用，让我明年也是安全的。”</p><p>最适用现在AI技术的一句话 —— <strong>AI 与人类不是竞争关系，它未必会减少机会，反而可能带来更多的机会。</strong></p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;“有时我对 ChatGPT 的理解能力感到惊讶，但是更多时候，我不得不拼命推动它，朝着我想要的方向前进。它有时会产生意料之外的结果，让我感到非常沮丧。”&lt;/p&gt;
&lt;p&gt;“它像一个吸收了所有人类知识、但需要别人帮忙才能把这些知识串起来的应届毕业生。”</summary>
      
    
    
    
    
    <category term="技术分享" scheme="https://www.qborfy.com/tags/技术分享/"/>
    
    <category term="每日更新" scheme="https://www.qborfy.com/tags/每日更新/"/>
    
    <category term="架构系列" scheme="https://www.qborfy.com/tags/架构系列/"/>
    
  </entry>
  
  <entry>
    <title>前端面试100道手写题（5）—— 循环滚动图片</title>
    <link href="https://www.qborfy.com/face100/7-loop-pic.html"/>
    <id>https://www.qborfy.com/face100/7-loop-pic.html</id>
    <published>2023-05-15T14:00:00.000Z</published>
    <updated>2023-06-01T12:18:16.408Z</updated>
    
    <content type="html"><![CDATA[<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;script type=&quot;text&amp;#x2F;javascript&quot; src=&quot;https://unpkg.com/kity@2.0.4/dist/kity.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text&amp;#x2F;javascript&quot; src=&quot;ht</summary>
      
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/学习总结/"/>
    
    <category term="前端面试" scheme="https://www.qborfy.com/tags/前端面试/"/>
    
  </entry>
  
  <entry>
    <title>前端面试100道手写题（5）—— Router路由</title>
    <link href="https://www.qborfy.com/face100/5-router-component.html"/>
    <id>https://www.qborfy.com/face100/5-router-component.html</id>
    <published>2023-05-15T14:00:00.000Z</published>
    <updated>2023-05-26T15:03:02.462Z</updated>
    
    <content type="html"><![CDATA[<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;script type=&quot;text&amp;#x2F;javascript&quot; src=&quot;https://unpkg.com/kity@2.0.4/dist/kity.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text&amp;#x2F;javascript&quot; src=&quot;ht</summary>
      
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/学习总结/"/>
    
    <category term="前端面试" scheme="https://www.qborfy.com/tags/前端面试/"/>
    
  </entry>
  
  <entry>
    <title>前端面试100道手写题（4）—— 深浅拷贝</title>
    <link href="https://www.qborfy.com/face100/4-deep-clone.html"/>
    <id>https://www.qborfy.com/face100/4-deep-clone.html</id>
    <published>2023-05-15T14:00:00.000Z</published>
    <updated>2023-05-24T03:22:02.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>深浅拷贝经典前端面试题，不仅仅只是实现逻辑，更加是对整个Javascript语言的实现背后一套理论，从基础数据类型到原型链一整套知识体系的熟悉程度，下面我们就从简单到困难一一实现。</p><p>手写难度：⭐️⭐️⭐️</p><p>涉及知识点：</p><ul><li>数据类型在内存空间的存储</li><li>原型以及原型链（这是实现拷贝一个重要知识点，如何拷贝自定义的类实例对象）<ul><li>如何拷贝一个原型对象 如： <code>a = {}; clone(a.__proto__)</code></li></ul></li><li>数组的判断</li><li>日期/正则等其他内置对象的拷贝</li><li>函数的拷贝</li></ul><a id="more"></a><h1 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h1><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>凡是遇到问题，多问一次自己为什么？—— 为什么在Javascript中会有【深拷贝】｜ 【浅拷贝】 区分的操作呢？</p><p>首先，我们回想一下，一开始我们学习语言的第一件事是什么（Hello World除外），是数据类型，Javascript中数据类型有以下几种：</p><ul><li>基础数据类型：number, string, boolean等</li><li>引用数据类型：object, array, date等</li></ul><p>然后，就是变量赋值，如： a = 1，b = new Date()，在 JavaScript 中分为两种：</p><ol><li>基础数据类型，值都有固定的大小，保存在栈内存中，由系统自动分配存储空间在栈内存空间的值，我们可以直接进行操作，因此基础数据类型都是按照值访问</li><li>复杂数据类型，值都保存在堆内存中的对象，引用类型的值都是按引用访问的，所以在操作对象时，实际上是操作对象的引用而不是实际的对象。引用可以理解为保存在栈内存中的一个地址，该地址指向堆内存中的一个实际对象</li></ol><p>因此，在复制值的时候，两种类型操作不一样，如下：</p><ol><li>基础类型复制，会在栈空间新建一个空间去进行复制</li><li>引用类型复制，系统会为新的变量自动分配一个新的栈内存空间这个栈内存空间保存着与被复制变量相同的指针，尽管他们在栈内存中的内存空间的位置互相独立但是在堆内存中访问到的对象实际上是同一个，因此，当我们改变其中一个对象的值时，实际上就是改变原来的对象</li></ol><p>简单的总结一下：</p><ol><li>基础类型的值长度是固定的，所以可以在栈空间分配存储空间，当进行复制的时候，可以直接在栈空间内新建一个存储空间进行赋值</li><li>引用类型的值长度是不固定的，所以需要在栈空间分配一个指针，然后在堆内存空间分配一个对象，将指针指向改对象，当进行复制的时候，需要在栈空间新建一个指针，然后指向之前在堆内存建的对象</li></ol><p>了解完为什么后，再去实现浅拷贝和深拷贝就会理所当然了。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>浅拷贝和深拷贝，在了解完【为什么】后，就很容易理解两者的区别：</p><ul><li>浅拷贝只会对引用类型的值做第一层堆内存进行拷贝</li><li>深拷贝除了会复制新建栈空间的值，同时还在将指向堆内存中对象进行新建</li></ul><p>那么为什么不都用深拷贝去实现就好了，那是因为在浅拷贝机制可以有效利用存储空间，同时浅拷贝的也存在一定应用场景：</p><ul><li>当需要统一管理引用值的变化时候，如：当 fetch 一个请求返回 json 数据后，当我们对其做修改调整后，其实不需要做深拷贝的</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>实现原理：只对引用类型数据做第一层值进行拷贝</p><p>步骤：</p><ol><li>判断数据类型，需要将所有引用类型数据判断一次</li><li>根据不同引用类型，将引用类型数据值进行复制新建一次，利用<code>Object.assign</code>或 <code>new +     return new obj.constructor(obj);</code> 进行复制进行</li><li>其中针对自定义类，如：<code>new A()</code>，需要通过继承其原型链，利用 <code>Object.getPrototypeOf</code></li><li>基础类型直接返回</li></ol><p>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型判断 主要基于 Object.prototype.toString.call</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Object]'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Array]'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为原型对象 如 a = new A();  a.__proto__ === A.prototype</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrototype</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Ctor = obj &amp;&amp; obj.constructor;</span><br><span class="line">    <span class="keyword">const</span> proto = (<span class="keyword">typeof</span> Ctor === <span class="string">'function'</span> &amp;&amp; Ctor.prototype) || <span class="built_in">Object</span>.prototype;</span><br><span class="line">    <span class="keyword">return</span> obj === proto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果不是对象类型 直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(obj === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isArray(obj) || isArrayBuffer(obj)) &#123;</span><br><span class="line">        <span class="keyword">return</span>  obj.slice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isObject(obj)) &#123;</span><br><span class="line">        <span class="comment">// 区分是内置 Object  还是自定义的类</span></span><br><span class="line">        <span class="keyword">if</span>(obj.constructor === <span class="built_in">Object</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrototype(obj)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">new</span> obj.constructor());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 自定义类新建实例化对象 保留原型链 从而保留原型方法或属性</span></span><br><span class="line">            <span class="keyword">const</span> newObj = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj));</span><br><span class="line">            <span class="comment">// 获取对象的所有属性</span></span><br><span class="line">            <span class="keyword">const</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(obj);</span><br><span class="line">            keys.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">                newObj[key] = obj[key];</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> newObj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他类型可以通过 new + constructor 来实现浅拷贝</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> obj.constructor(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>实现原理： 需要对整个对象的进行深度遍历赋复制新建，从而实现修改新建值不会影响到原有的值</p><p>步骤：</p><ol><li>数据类型判断和浅拷贝一致</li><li>针对不同引用类型需要遍历+递归实现值的拷贝新建</li></ol><p>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj, map = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果不是对象类型 直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(obj === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是 WeakMap 直接抛出异常 因为 WeakMap 无法遍历</span></span><br><span class="line">    <span class="keyword">if</span>(isWeakMap(obj)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'WeakMap can not be cloned'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isPrototype(obj)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">new</span> obj.constructor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相互引用的对象会导致死循环</span></span><br><span class="line">    <span class="keyword">if</span>(map.has(obj)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isArrayBuffer(obj)) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj.slice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isArray(obj)) &#123;</span><br><span class="line">        <span class="keyword">const</span> newArr = [];</span><br><span class="line">        map.set(obj, newArr);</span><br><span class="line">        obj.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            newArr.push(deepClone(item, map));</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isSet(obj)) &#123;</span><br><span class="line">        <span class="keyword">const</span> newSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        map.set(obj, newSet);</span><br><span class="line">        obj.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            newSet.add(deepClone(item, map));</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> newSet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isMap(obj)) &#123;</span><br><span class="line">        <span class="keyword">const</span> newMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">        map.set(obj, newMap);</span><br><span class="line">        obj.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">            newMap.set(key, deepClone(value, map));</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> newMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isRegx(obj)) &#123;</span><br><span class="line">        <span class="keyword">const</span> newRegx = <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj.source, obj.flags);</span><br><span class="line">        map.set(obj, newRegx);</span><br><span class="line">        <span class="keyword">return</span> newRegx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isDate(obj)) &#123;</span><br><span class="line">        <span class="keyword">const</span> newDate = <span class="keyword">new</span> <span class="built_in">Date</span>(obj.getTime());</span><br><span class="line">        map.set(obj, newDate);</span><br><span class="line">        <span class="keyword">return</span> newDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isError(obj)) &#123;</span><br><span class="line">        <span class="keyword">const</span> newError = <span class="keyword">new</span> <span class="built_in">Error</span>(obj.message);</span><br><span class="line">        map.set(obj, newError);</span><br><span class="line">        <span class="keyword">return</span> newError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isObject(obj)) &#123;</span><br><span class="line">        <span class="comment">// 区分是内置 Object  还是自定义的类</span></span><br><span class="line">        <span class="keyword">if</span>(obj.constructor === <span class="built_in">Object</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> newObj = &#123;&#125;;</span><br><span class="line">            map.set(obj, newObj);</span><br><span class="line">            <span class="comment">// 获取对象的所有属性 包括不可枚举属性</span></span><br><span class="line">            <span class="built_in">Reflect</span>.ownKeys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">                newObj[key] = deepClone(obj[key], map);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> newObj;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrototype(obj)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">new</span> obj.constructor());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 自定义类新建实例化对象 保留原型链 从而保留原型方法或属性</span></span><br><span class="line">            <span class="keyword">const</span> newObj = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj));</span><br><span class="line">            map.set(obj, newObj);</span><br><span class="line">            <span class="comment">// 获取对象的所有属性</span></span><br><span class="line">            <span class="keyword">const</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(obj);</span><br><span class="line">            keys.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">                newObj[key] = deepClone(obj[key], map);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> newObj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他类型可以通过 new + constructor 来实现拷贝返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> obj.constructor(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>浅拷贝和深拷贝作为前端面试经常会出现的题目，在做这篇题目之前，我对浅拷贝和深拷贝的其实是缺失的，即使网上的答案也只是做了一部分，当我深入阅读<code>lodash.Clone</code>和<code>lodash.deepClone</code>的源码才发现这里面隐藏的一些知识点，这里做一个阅读前和阅读后：</p><p>阅读源码前：</p><ul><li>浅拷贝只需要通过 Object.assigin就可以实现拷贝，但是从来没想过数据类型判断的重要性，包括自定义类对应实例的拷贝</li><li>深拷贝只需要解决数组遍历，以及解决循环依赖问题即可，忘记了还有Map/Set等新一代数据类型的遍历</li></ul><p>阅读源码后：</p><ul><li>数据类型判断才是拷贝的重要依据，根据不同类型需要做不同逻辑拷贝，而且 JavaScript 中的数据类型真的有很多，不仅只有 array object，还有常见Date，Regexp，或者冷门的 ArrayBuffer等</li><li>自定义类的拷贝也很复杂，同时也引出了原型对象(<strong>proto</strong> prototype)的拷贝，这里也加深我对JavaScript 原型的理解</li></ul><p>JavaScript 数据实例拷贝背后的原理，其实是 JavaScript 中不同数据类型存储值的方式需要去做不一样的处理，而引用类型最终在 JavaScript 中的实现就是依赖于原型和原型链去实现的。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://github.com/lodash/lodash/blob/master/.internal/baseClone.js#L236" target="_blank" rel="noopener">lodash baseClone 浅拷贝和深拷贝的基础实现方法</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;深浅拷贝经典前端面试题，不仅仅只是实现逻辑，更加是对整个Javascript语言的实现背后一套理论，从基础数据类型到原型链一整套知识体系的熟悉程度，下面我们就从简单到困难一一实现。&lt;/p&gt;
&lt;p&gt;手写难度：⭐️⭐️⭐️&lt;/p&gt;
&lt;p&gt;涉及知识点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据类型在内存空间的存储&lt;/li&gt;
&lt;li&gt;原型以及原型链（这是实现拷贝一个重要知识点，如何拷贝自定义的类实例对象）&lt;ul&gt;
&lt;li&gt;如何拷贝一个原型对象 如： &lt;code&gt;a = {}; clone(a.__proto__)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数组的判断&lt;/li&gt;
&lt;li&gt;日期/正则等其他内置对象的拷贝&lt;/li&gt;
&lt;li&gt;函数的拷贝&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/学习总结/"/>
    
    <category term="前端面试" scheme="https://www.qborfy.com/tags/前端面试/"/>
    
  </entry>
  
  <entry>
    <title>前端面试100道手写题（5）—— 虚拟滚动</title>
    <link href="https://www.qborfy.com/face100/6-visual-scroll.html"/>
    <id>https://www.qborfy.com/face100/6-visual-scroll.html</id>
    <published>2023-05-15T14:00:00.000Z</published>
    <updated>2023-06-02T02:41:07.421Z</updated>
    
    <content type="html"><![CDATA[<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;script type=&quot;text&amp;#x2F;javascript&quot; src=&quot;https://unpkg.com/kity@2.0.4/dist/kity.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text&amp;#x2F;javascript&quot; src=&quot;ht</summary>
      
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/学习总结/"/>
    
    <category term="前端面试" scheme="https://www.qborfy.com/tags/前端面试/"/>
    
  </entry>
  
  <entry>
    <title>前端面试100道手写题（3）—— EventBus</title>
    <link href="https://www.qborfy.com/face100/3-event-bus.html"/>
    <id>https://www.qborfy.com/face100/3-event-bus.html</id>
    <published>2023-05-06T14:00:00.000Z</published>
    <updated>2023-05-06T08:48:34.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>EventBus作为发布订阅设计模式的经典应用场景，很值得我们去学习研究它的实现原理。</p><p>手写难度：⭐️⭐️</p><a id="more"></a><p>可以直接去看完整源码地址（记得给个star），地址如下：</p><p><a href="https://github.com/qiubohong/hundred-interview-questions/tree/main/3-event-bus" target="_blank" rel="noopener">https://github.com/qiubohong/hundred-interview-questions/tree/main/3-event-bus</a></p><h1 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>EventBus其实是一个技术概念，主要是通过事件订阅方式解决不同情况下消息通讯问题，不仅仅在前端，还在Native（Android）等各个地方都有在使用。</p><p>EventBus 可以分成下面四个部分：</p><ul><li>订阅者 Subscriber： 监听某类事件，当发布者触发该类事件后执行所需要的事件。</li><li>发布者 Publisher：当满足某些条件，发布触发订阅者的事件。</li><li>消息 Event：其实就需要传递的消息或事件本身。</li><li>消息中心 EventStore: 负责存储消息与订阅者的对应关系，有消息触发时，负责通知订阅者。</li></ul><p>几者的关系如下图所示：</p><div class="mxgraph-container">    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/event-bus.drawio&quot;}"></div></div><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>上面是讲了一些概念性，但是在实际开发中，EventBus其实已经很多地方在使用了，如：</p><ul><li>Vue2中的<code>$emit</code> <code>$on</code>其实就是利用EventBus实现的，同时还可以使用去实现跨组件实现通讯</li><li>Node.js中的的<code>EventEmitter</code>，支持<code>on</code> <code>emit</code>，可以利用其解决<code>回调地狱</code>问题</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>EventBus主要有几个方法：</p><ul><li><code>on(event, func)</code> 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。</li><li><code>emit(event, ...args)</code> 按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false。</li><li><code>once(event, func)</code> 为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。</li><li><code>off(event, func)</code> 移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。</li><li><code>offAll(event)</code> 移除所有事件的所有监听器</li></ul><p>下面是实现代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventBus</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// 消息队列 存储事件和回调</span></span><br><span class="line">        <span class="keyword">this</span>.listeners = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订阅事件</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; event </span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; callback </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    on(event, callback) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.listeners[event]) &#123;</span><br><span class="line">            <span class="keyword">this</span>.listeners[event] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.listeners[event].push(callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注销事件</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; event </span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; callback </span></span><br><span class="line"><span class="comment">     * @returns </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    off(event, callback) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.listeners[event]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.listeners[event] = <span class="keyword">this</span>.listeners[event].filter(<span class="function"><span class="params">listener</span> =&gt;</span> listener !== callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发布触发事件</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; event </span></span><br><span class="line"><span class="comment">     * @param  &#123;...any&#125; args </span></span><br><span class="line"><span class="comment">     * @returns </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    emit(event, ...args) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.listeners[event]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.listeners[event].forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener(...args));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只触发一次的事件</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; event </span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; callback </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    once(event, callback) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.listeners[event]) &#123;</span><br><span class="line">            <span class="keyword">this</span>.listeners[event] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> onceCallback = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">            callback(...args);</span><br><span class="line">            <span class="keyword">this</span>.off(event, onceCallback);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.listeners[event].push(onceCallback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注销某个事件的所有回调</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; event </span></span><br><span class="line"><span class="comment">     * @returns </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    offAll(event) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.listeners[event]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.listeners[event] = [];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> eventBus = <span class="keyword">new</span> EventBus();</span><br><span class="line">    eventBus.on(<span class="string">'test'</span>, (a, b) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a, b);</span><br><span class="line">    &#125;);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        eventBus.emit(<span class="string">'test'</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>EventBus模式使用上需要注意的问题：</p><ul><li>如果<code>on</code>注册多次，可能会导致一次<code>emit</code>就会执行多次函数，导致无法定位到哪里注册多，因此使用的时候，需要考虑什么时候把事件<code>off</code></li><li><code>off</code>需要明确指出函数对象，所以我们的注册函数建议都通过声明函数去实现，而不是匿名函数，减少注销事件的麻烦</li><li><code>on</code>注册事件，事件名建议使用静态常量，而不是字符串，更加容易管理事件中心</li></ul><h1 id="额外知识"><a href="#额外知识" class="headerlink" title="额外知识"></a>额外知识</h1><h2 id="为什么Vue3实例不再支持-emit-on"><a href="#为什么Vue3实例不再支持-emit-on" class="headerlink" title="为什么Vue3实例不再支持 emit on"></a>为什么Vue3实例不再支持 <code>emit</code> <code>on</code></h2><p>官方解释如下：</p><ul><li>Vue 1.x的时候是实现类似Angular的组件事件系统，利用<code>$dispatch</code>与<code>$broadcast</code>实现向上和向下发送事件来进行通信</li><li>在Vue 2中，取消了<code>$dispatch</code>与<code>$broadcast</code>，从而能更多状态驱动的数据流，其实就是单向数据流的状态扭转，</li><li>Vue2中， <code>$emit</code>用于触发由父组件的声明事件，<code>$on</code> <code>$off</code> <code>$once</code>都是这类事件的扩展，但是这仅仅是一个过程，且很少被使用</li><li>因此，没有充分的理由去让它们暴露在组件实例上，所以最终决定将删除<code>$on</code> <code>$off</code> <code>$once</code>等实例方法</li></ul><p>解决方案：</p><ol><li>使用<code>vue3-bus</code>，基于Vue插件机制</li><li>不借助Vue插件实现的，官方推荐的<a href="https://github.com/developit/mitt" target="_blank" rel="noopener">mitt</a></li></ol><p>原文地址：<a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0020-events-api-change.md" target="_blank" rel="noopener">active-rfcs/0020-events-api-change.md</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://juejin.cn/post/6844904101331877895" target="_blank" rel="noopener">从发布订阅模式入手读懂Node.js的EventEmitter源码</a></li><li><a href="https://www.runoob.com/nodejs/nodejs-event.html" target="_blank" rel="noopener">Node.js EventEmitter</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;EventBus作为发布订阅设计模式的经典应用场景，很值得我们去学习研究它的实现原理。&lt;/p&gt;
&lt;p&gt;手写难度：⭐️⭐️&lt;/p&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/学习总结/"/>
    
    <category term="前端面试" scheme="https://www.qborfy.com/tags/前端面试/"/>
    
  </entry>
  
  <entry>
    <title>前端面试100道手写题（2）—— throttle与debounce</title>
    <link href="https://www.qborfy.com/face100/2-throttle-debouce.html"/>
    <id>https://www.qborfy.com/face100/2-throttle-debouce.html</id>
    <published>2023-04-19T14:00:00.000Z</published>
    <updated>2023-04-26T13:48:53.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前端面试100道手写题第二篇《throttle与debounce》，说一下为什么选这两个，其实大家都有在用，我们先来了解一下两个函数的作用：</p><ul><li>debounce 防抖，用于减少函数触发的频率，在一个delay时间内，如果触发delay时间归零，直到delay时间到才会触发函数</li><li>throttle 节流，用于限制函数触发的频率，每个delay时间间隔，最多只能执行函数一次</li></ul><p>选这两个手写的原因其实很简单，就是面试频率高，而且项目实战会经常用到，同时里面还会隐藏一些知识点和目前公共库的一些问题（见文章末尾）。</p><p>接下来就让我们开始手写撸代码吧！</p><p>手写难度：⭐️⭐️⭐️</p><a id="more"></a><p>不想看啰里吧嗦的文字，可以直接去看完整源码地址（记得给个star），地址如下：</p><p><a href="https://github.com/qiubohong/hundred-interview-questions/tree/main/2-debouce-throttle" target="_blank" rel="noopener">https://github.com/qiubohong/hundred-interview-questions/tree/main/2-debouce-throttle</a></p><h1 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h1><p>很多功能函数只要搞清楚他们的功能设计，基本上你就可以手写出完整的代码。<br>以<a href="https://github.com/lodash/lodash/blob/master/debounce.js" target="_blank" rel="noopener">lodash.debounce</a>为参考，接下来我们来拆解一下完整的debounce的功能具体有哪些：</p><ul><li>构造函数 <code>debounce(func, waitTime, maxWait, leading, trailing)</code><ul><li>func (Function): 要防抖的函数。</li><li>[wait=0] (number): 需要防抖的毫秒。</li><li>[leading=false] (boolean): 指定调用在防抖开始前。</li><li>[trailing=true] (boolean): 指定是否在最大等待时间过期后直接调用，简单点的当超过等待时间，则会触发函数</li><li>[maxWait=wait] (number): 设置最大等待时间过期。</li></ul></li><li>取消函数 <code>debounceReturn.cancel()</code> ， <code>debounceReturn</code>是执行完debounce函数返回的对象</li><li>状态函数 <code>debounceReturn.pending()</code></li><li>立即调用函数 <code>debounceReturn.flush()</code></li></ul><p>上面是<code>lodash</code>给出debounce的完整功能，但是如果是我们仅仅需要简易版本的throttle，应该如何实现呢？</p><p>拆解步骤一：实现一个简单版</p><p><code>debounce()</code>函数最简单功能就是，希望能在wait时间段禁止重复触发某个事件，第一个简易版如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce_easy</span>(<span class="params">func, waitTime</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 用于存储定时器</span></span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="comment">// 存储返回结果</span></span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="comment">// 如果定时器存在，就清除定时器</span></span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        <span class="comment">// 重新设置定时器</span></span><br><span class="line">        timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 执行函数，将当前作用域绑定的this和参数传递过去</span></span><br><span class="line">            result = func.apply(context, args);</span><br><span class="line">        &#125;, waitTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单元测试</span></span><br><span class="line"><span class="keyword">const</span> debounced = debounce_easy(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'debounce_easy:'</span>, value)</span><br><span class="line">    ++callCount;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;, <span class="number">32</span>);</span><br><span class="line"><span class="comment">// 这里等同于快速触发4次，只有最后一次生效 输出 debounce_easy: d</span></span><br><span class="line"><span class="keyword">const</span> results = [debounced(<span class="string">'a'</span>), debounced(<span class="string">'b'</span>), debounced(<span class="string">'c'</span>), debounced(<span class="string">'d'</span>)];</span><br><span class="line"><span class="keyword">let</span> lodashResults = [lodashDebouce(<span class="string">'a'</span>), lodashDebouce(<span class="string">'b'</span>), lodashDebouce(<span class="string">'c'</span>), lodashDebouce(<span class="string">'d'</span>)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// callCount: 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'callCount:'</span>, callCount)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// callCount: 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'callCount:'</span>, callCount)</span><br><span class="line">&#125;, <span class="number">160</span>);</span><br></pre></td></tr></table></figure><p>拆解步骤二：leading参数希望可以先执行一次函数，再进行防抖， 具体代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其实就是在定时器之前判断 leading和 timeout定期器是否不为空即可 关键代码如下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果leading为true，就立即执行函数</span></span><br><span class="line"><span class="keyword">if</span> (leading) &#123;</span><br><span class="line">    <span class="comment">// 如果定时器不存在，就执行函数，从而避免重复执行</span></span><br><span class="line">    <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">        invokeFunc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拆解步骤三：加上cancel等函数实现，这里能实现完基本上手写题就80分了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取消防抖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> cancel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(timeout)</span><br><span class="line">    lastArgs = lastThis = timeout = <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拆解步骤四：加上参数 <code>traling+maxWait</code> 函数，作用在当超过maxWait等待时间后，函数会</p><p>重点在于判断是否过了等待时间，所以需要记录每次执行的时间，当超过的时候判断是否有传参数<code>traling+maxWait</code></p><p>实现步骤如下流程所示：</p><div class="mxgraph-container">    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/debounce.drawio&quot;}"></div></div><p>参数解释：</p><ul><li>lastArgs,  // 上一次调用时的参数</li><li>lastThis,  // 上一次调用时的this</li><li>result,  // 上一次调用的返回值</li><li>lastCallTime,  // 上一次调用的时间</li><li>lastInvokeTime = 0,  // 上一次执行的时间</li><li>leading = false,  // 是否立即执行</li><li>maxing = false,  // 是否有最大等待时间</li><li>trailing = true; // 是否在最后一次调用后执行</li></ul><h1 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h1><p><code>throttle</code>节流函数定义：就是无论频率多快，每过一段时间就执行一次。</p><p>在实现逻辑上其实是可以看做<code>debounce</code>的一种升级版，只需要保证debounce函数在超时后执行一次函数即可</p><p>只要针对debouonce函数设置一下参数即可，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait, leading = true</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> debounce(func, wait, &#123;</span><br><span class="line">        leading,</span><br><span class="line">        trailing: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">'maxWait'</span>: wait <span class="comment">// 超时时间和控制时间一致就可以了</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然我们也可以实现一个快速简单版，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle_eazy</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> lastInvokeTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">const</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">invokeFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            lastInvokeTime = <span class="built_in">Date</span>.now();</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        wait = +wait || <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 计算剩余时间</span></span><br><span class="line">        <span class="keyword">let</span> remainTime = wait;</span><br><span class="line">        <span class="comment">// 如果上次执行时间大于0，说明已经执行过了，计算剩余时间</span></span><br><span class="line">        <span class="keyword">if</span>(lastInvokeTime &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            remainTime = wait - (<span class="built_in">Date</span>.now() - lastInvokeTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果剩余时间小于等于0，说明可以执行了，重置上次执行时间</span></span><br><span class="line">        <span class="keyword">if</span> (remainTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            invokeFunc();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经开始计时，说明已经有定时器了，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则，开始计时</span></span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            invokeFunc();</span><br><span class="line">        &#125;, remainTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单元测试</span></span><br><span class="line">; (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> throttled = throttle(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello'</span>, count);</span><br><span class="line">    &#125;, <span class="number">200</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'触发i~'</span>, i * <span class="number">100</span>)</span><br><span class="line">            throttled();</span><br><span class="line">        &#125;, <span class="number">100</span> * i);</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 正确输出10</span></span><br><span class="line">        <span class="built_in">console</span>.log(count);</span><br><span class="line">    &#125;, <span class="number">2200</span>);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h1 id="额外知识点"><a href="#额外知识点" class="headerlink" title="额外知识点"></a>额外知识点</h1><h2 id="TDD开发模式"><a href="#TDD开发模式" class="headerlink" title="TDD开发模式"></a>TDD开发模式</h2><p>一般写这些工具函数，都需要提前想好单元测试怎么写，这就是涉及一种开发模式<a href="https://juejin.cn/post/6844903780970921991" target="_blank" rel="noopener">测试驱动开发（TDD）</a>，主要遵循以下两个原则：</p><ul><li>仅在自动测试失败时才编写新代码。</li><li>消除重复设计（去除不必要的依赖关系），优化设计结构（逐渐使代码一般化）。</li></ul><p>TDD的研发流程如下：</p><div class="mxgraph-container">    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/tdd.drawio&quot;}"></div></div><h2 id="lodash的缺陷"><a href="#lodash的缺陷" class="headerlink" title="lodash的缺陷"></a>lodash的缺陷</h2><p>如果你正在使用lodash，你应该关注一下，因为lodash的github最后一次更新2021年4月24号，到目前为止已经有两年的时间没有更新，已经堆积很多issues，从上面解读源码的时候就发现一个<code>lodash.throttle</code>的一个bug，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> changeInput = throttle(<span class="function">(<span class="params">value: string</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;, <span class="number">1000</span>, &#123;</span><br><span class="line">  leading: <span class="literal">false</span>,</span><br><span class="line">  trailing: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 上述防抖函数将不会按照我们所设想的每隔1秒触发，而是会出现各种异常情况，如果触发频率够高可能会执行，如果触发频率低于1秒则不会执行，因为leading和trailing都设置为false，lodash源码没有针对这一情况进行处理，或者不支持trailing参数设置即可</span></span><br></pre></td></tr></table></figure><p>同时，lodash还有其他一些缺陷：</p><ul><li>lodash是支持tree shaking，但是这么写<code>import {throttle} from &#39;lodash&#39;</code> 会将整个lodash包都引入， 必须这么写<code>import throttle from &#39;lodash/throttle&#39;</code>才能做到按需加载</li><li>进入 npm 上的 lodash 包，它被列为 v4.17.21，并且已经 2 年多没有发布了：<a href="https://www.npmjs.com/package/lodash" target="_blank" rel="noopener">https://www.npmjs.com/package/lodash</a></li></ul><p>当然作为一个工具库lodash确实可以让我们少写很多代码，但是已经很长时间没有维护的问题还是需要关注的。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>Lodash源码：<a href="https://github.com/lodash/lodash/" target="_blank" rel="noopener">https://github.com/lodash/lodash/</a></li><li><a href="https://juejin.cn/post/6844903780970921991" target="_blank" rel="noopener">测试驱动开发（TDD）总结——原理篇</a></li><li><a href="https://news.ycombinator.com/item?id=35056136" target="_blank" rel="noopener">Hacker News——不要再使用的Lodash</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前端面试100道手写题第二篇《throttle与debounce》，说一下为什么选这两个，其实大家都有在用，我们先来了解一下两个函数的作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;debounce 防抖，用于减少函数触发的频率，在一个delay时间内，如果触发delay时间归零，直到delay时间到才会触发函数&lt;/li&gt;
&lt;li&gt;throttle 节流，用于限制函数触发的频率，每个delay时间间隔，最多只能执行函数一次&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;选这两个手写的原因其实很简单，就是面试频率高，而且项目实战会经常用到，同时里面还会隐藏一些知识点和目前公共库的一些问题（见文章末尾）。&lt;/p&gt;
&lt;p&gt;接下来就让我们开始手写撸代码吧！&lt;/p&gt;
&lt;p&gt;手写难度：⭐️⭐️⭐️&lt;/p&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/学习总结/"/>
    
    <category term="前端面试" scheme="https://www.qborfy.com/tags/前端面试/"/>
    
  </entry>
  
  <entry>
    <title>《高效能人士的7个习惯》，怎么做才能提高做事效率？</title>
    <link href="https://www.qborfy.com/study/seven-habbit.html"/>
    <id>https://www.qborfy.com/study/seven-habbit.html</id>
    <published>2023-04-19T05:00:00.000Z</published>
    <updated>2023-05-26T07:58:33.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高效能人士的7个习惯"><a href="#高效能人士的7个习惯" class="headerlink" title="高效能人士的7个习惯"></a>高效能人士的7个习惯</h1><p>不管是工作还是学习，有些人做事的效率很高，而有些做事的效率就很低，那么有什么方式可以提高自己的工作效率，这本书主要就是讲如何去培养自己高效能的习惯，改变自己的做事和思考的方式。</p><a id="more"></a><h1 id="阅读摘要"><a href="#阅读摘要" class="headerlink" title="阅读摘要"></a>阅读摘要</h1><ul><li>如何使用本书<ul><li>不要浅尝即止，而是需要针对每个习惯去不断做练习，做到知行合一</li><li>结合每个章节末尾中行动指引，需要付诸行动，方便实战统计</li><li>有了新的体会或者实践了，需要去做分享，把自己当成老师</li><li>前三个习惯是培养自己的独立与自信</li><li>后三个习惯是扩大自己的影响力与搭建人际关系</li><li>最后一个习惯，是将前六个习惯加强，不断充电</li></ul></li><li>7个习惯的简要定义与架构图<ul><li>7个习惯的简要定义如下：<ul><li>习惯一：积极主动，采取主动，为过去、现在以及未来的选择负责，主动选择，摈弃被动（受害者），创造自己的人生</li><li>习惯二：以终为始，做事情基本上都需要有目标，并根据这个目标，全身心投入，同时领导工作的核心就是基于共有的使命、愿景和价值观，创造文化</li><li>习惯三：要事第一，需要明白什么是要事，不论其他的事情多紧迫，要事都是要排在第一位的</li><li>习惯四：双赢思维，基于互敬、互惠的思考框架，目的是分享资源，而不是敌对竞争，从互赖式的角度思考问题，重点是协助或者找人快速解决问题</li><li>习惯五：知彼解己，耐心倾听别人，坦诚对待别人，平衡两者，提高沟通效率</li><li>习惯六：统合综效，创造性合作，制造1+1&gt;2的效果</li><li>习惯七：不断更新，如何在四个生活基本面（身体、精神、智力、社会/情感）中，不断更新自己。</li></ul></li><li>7个习惯分为三个时期：<ul><li>依赖期：没有独立，没任何高效的习惯</li><li>独立期：拥有积极主动、以终为始，要事第一的习惯</li><li>互赖期：拥有双赢思维、知彼解己、统合综效的习惯</li></ul></li></ul></li><li>第1部分 思维方式与原则<ul><li>第一章 由内到外全面造就自己<ul><li>没有正确的生活，就没有真正卓越的人生。 —— 戴维·斯塔·乔丹（David Starr Jordan） ｜ 美国生物学家及教育家<ul><li>表达的是，如果你没有选择正确的生活方式，你就不可能会成功</li></ul></li><li>现实中的问题，协调工作与生活，总结如下：<ul><li>事业成功，牺牲家庭生活</li><li>很忙，不知道工作有什么意义</li><li>无法找到高效的员工，即使很多管理课程也无法回答我的问题</li><li>要做的事太多，时间不够用</li><li>嫉妒别人的成就</li><li>个性要强，希望能控制整个过程</li><li>婚姻变得平淡无趣，没有再有爱情的感觉</li><li>孩子不听话</li><li>教育孩子有自己的主动去工作，但是又不希望主动提醒</li><li>不断减肥，不断失败</li></ul></li><li>思维方式是如何影响我们的观点，进而影响我们的做出种种行为<ul><li>期望理论</li><li>自我实现预言</li><li>皮格马利翁效应</li></ul></li><li>要改变现在的生活，就要改变自己，最重要是改变自己对问题的看法</li><li>品德与魅力，孰轻孰重<ul><li>现在社会宣传个人魅力可以速成，往往忽略了品德的重要性，从而导致我们花很多在花言巧语，玩弄手段，拍马屁去速成魅力</li><li>其实这就是两种思维模式，但是却影响了很多人的选择</li></ul></li><li>思维模式是我们每个人基本的东西，可以比作人生地图，它会指引我们走向哪里</li><li>每个人的大脑中有两张地图：<ul><li>一张是反应现实中的地图，如：颜色、物质等</li><li>一张是依据思维模式的地方，如：价值观、世界观等</li></ul></li><li>所以个人魅力论只是改变一个人表面现象，而品德成功论则是从本质思维模式上去发生改变</li><li>一个人的思维方式越符合这些原则或者自然法则，就越能正确而高效地生活。原则如下：<ul><li>公平原则，平等与正义来源于此</li><li>诚信与正直，人类相互信任的基础</li><li>服务原则，就是贡献自我，从而到讲求品质和追求卓越</li><li>潜能原则，人类可以不断进步成长，再到释放潜能与施展才华</li></ul></li><li>我们不了解自己，也不理解自己，但是知道别人眼中的自己应该是什么样子的，不再健谈而是闲谈，不再开怀大笑而是挤出笑容，不再痛苦而是绝望，而这种缺陷让他们沦陷，与芸芸大众无所区别，丧失自己的独立性</li><li>教导孩子也要因时而异。在关系和气氛紧张的时候，教导会被视为一种评判与否定；关系融洽的时候，在私下里对孩子循循善诱效果会加倍。</li><li>我们需要新的、更深层次的思想水平，即基于原则的思维方式，它能正确引导我们实现高效能，改善人际关系，解决深层问题。</li><li>本书的核心思想：<ul><li>强调以原则为中心，以品德为基础，要求“由内而外”地实现个人效能和人际效能。</li></ul></li><li>实践测试：<ul><li>是否曾经做过推测发现自己判断过于武断？请描述该段经历</li><li>当时的推测是什么？</li><li>做过其他推测，将某一项采取什么行动？</li></ul></li><li>检验你的思维方式<ul><li>你是否到过其他地区？有没有觉得很奇怪的行为?</li><li>人们的行为是否是你的预期？你对他们的行为有什么看法？</li><li>回想你的旅游经历，认为当地人对你的看法？是否认为他们对你的看法与你对他们的看法很类似？</li><li>如果你在旅游中有机会认识当地人？你对他们的看法或推测会有什么改变？</li></ul></li><li>转换思维方式<ul><li>去上班的路径有分哪几种？是否有些路径比其他路径更加复杂？是否有一条路径比较方便？为什么方便、为什么不方便？</li><li>你是否发现过一条你以前不知道的路径？走不同路径的的新鲜感如何？</li><li>现在想一下你与他人打交道的方式，是否有好几种？你还会尝试哪些新的方式？</li></ul></li><li>影响你生活的五个原则<ul><li>请列出影响生活的五个原则？分别以什么样的方式影响？是积极的还是消极的<ul><li>影响我生活的五个原则，<ul><li>睡眠时间一定要够，如果不够的话很可能会导致接下来一段时间非常难受</li><li></li></ul></li></ul></li></ul></li></ul></li><li>第二章 七个习惯概论<ul><li>习惯对我们的生活有极大的影响，因为它是一贯的，在不知不觉中，经年累月影响着我们的品德，暴露出我们的本性，左右着我们的成败。人的行为总是一再重复。因此卓越不是一时的行为，而是习惯。 —— 亚里士多德（Aristotle） ｜ 古希腊哲学家、文艺理论家<ul><li>表达的是习惯就是我们的生活方式，将会影响我们的方方面面，所以我们需要更加重视培养我们一些好的习惯。</li></ul></li><li>思想决定行动，行动决定习惯，习惯决定品德，品德决定命运。</li><li>习惯是由“知识”、“技巧”与“意愿”相互交织的结果。<ul><li>知识，是理论范畴，指点做什么、为什么这么做</li><li>技巧，是告诉我们怎么做</li><li>意愿，是推荐我们去做的动力源</li></ul></li><li>改变习惯是一个痛苦的过程，这往往需要我们有更高的目标，面对未来更美好的目标去牺牲当下的一些享受</li><li>7个习惯并不是分散开，而是一个系统养成习惯，会成螺旋上升的，从摆脱依赖到独立到互相依赖，最后利用更新学习去加强前面<ul><li>依赖期，以你为核心</li><li>独立期，以我为核心</li><li>互赖期，以我们为核心</li><li>自我更新，将上面的人生3个阶段包含起来，形成不断更新，螺旋上升的成长过程</li></ul></li><li>效能的定义，其实就是遵循”产出/产能平衡“原则<ul><li>鹅下金蛋的故事，金蛋是产出，而鹅才是资产或者产能，”重蛋轻鹅“则会失去资产最终无法获得可持续产出，”重鹅轻蛋“则会因为没有产出而饿死</li></ul></li><li>如何做到让女儿可以心甘情愿去打扫房间，其实就是打扫房间是产出，而女儿是能打扫房间的产能<ul><li>如果用强迫的方式让女儿打扫卫生，则会失去女儿的幸福，就是产能</li><li>如果不打扫，则没有产出</li><li>如果我们增加女儿的幸福感，如：答应她去一次她想去的地方，就是产能，从而促进她去打扫的动力</li></ul></li><li>效能是7个习惯的基础，只有搞明白效能的核心=产出/产能的平衡，才能更好的去培养习惯</li><li>7个习惯的评分项<ul><li>情感账户<ul><li>信守承诺</li><li>待人和蔼、体谅对方</li><li>不在背后说坏话</li></ul></li><li>产出、产能平衡<ul><li>在生活、工作保持适当的平衡</li><li>致力于某个项目，总是想着雇主的需求和厉害关系</li><li>努力工作，但是不会把自己搞的太疲惫</li></ul></li><li>积极主动<ul><li>能掌控自己的生活</li><li>注意力集中在能有所为的事情上，而不是集中在我无法控制的事情上</li><li>为情绪负责，而不是埋怨周围</li></ul></li><li>以终为始<ul><li>明白对生活的追求</li><li>生活和工作井然有序，很少陷入危机</li><li>每周都一个清晰的计划，注明我想完成的事情</li></ul></li><li>要事第一<ul><li>致力于完成自己的事情，不延误</li><li>不让日常琐事埋没真正重要的事务</li><li>每天做的事情都是有意义的，有利于我的生活目标</li></ul></li><li>双赢思维<ul><li>关心别人的成功，就像关心自己的成功一样</li><li>能与别人合作</li><li>遇到矛盾的时候，努力寻求有利于各方的解决方案</li></ul></li><li>知彼解己<ul><li>对他人的感觉很敏感</li><li>尽力理解别人的观点</li><li>试图从对方的角度，而不是从自己的角度看待问题</li></ul></li><li>统合综效<ul><li>赞赏别人的见解</li><li>寻求新的解决方案</li><li>鼓励别人表达他们的观点</li></ul></li><li>不断更新<ul><li>珍惜身体健康</li><li>建立和改善他人的人际关系</li><li>花时间和钱追求生活的意义和乐趣</li></ul></li></ul></li><li>实践问题<ul><li>列出一个好习惯和坏习惯<ul><li>好习惯：开始坚持每天记录事情和坚持学习</li><li>坏习惯：晚睡</li></ul></li><li>打破坏习惯的一切努力，立即行动的事情和过程<ul><li>打破晚睡的习惯的行为，就是早点上床，丢掉手机</li></ul></li><li>你处于人生哪个节点（依赖、独立、互赖），是什么行为或原因让你处于这个节点，你开始看到自己需要在哪方面需要努力吗？<ul><li>处于独立时期，往互赖期去走</li><li>人际关系，与人合作上在花时间去努力</li></ul></li></ul></li></ul></li></ul></li><li>第2部分 个人领域的成功：从依赖到独立<ul><li>第三章 习惯一 积极主动 —— 个人愿景的原则<ul><li>人性的本质是主动而非被动的，人类不仅能针对特定环境选择回应方式，更能主动创造有利的环境。</li><li>采取主动不等于胆大妄为、惹是生非或滋事挑衅，而是要让人们充分认识到自己有责任创造条件。</li><li>最令人鼓舞的事实，莫过于人类确实能主动努力以提升生命价值。——亨利·戴维·梭罗（Henry David Thoreau） ｜ 美国文学家及哲学家<ul><li>表达的是，主动是人类最大的优点，主动创造有利于自己的环境的从而提升生命的价值</li></ul></li><li>将自己从自己剥离出来，如在房间内，把自己想成一个灯，用心观察自己的，看看自己的状态是什么样子的？这就是客观的看待自己</li><li>社会之镜，从周边的对自己看法进行自我认知，这就等于面对哈哈镜看自己，看的不是真正的自己</li><li>环境与条件对我们影响巨大，但是不是决定性作用，可以决定我们的命运，目前主流三种外部因素决定论<ul><li>基因决定论，认为人的性格都是祖宗流传下来的，就是命由天定</li><li>心理决定论，认为人的性格是受父母言行决定，从童年培养的心理一直影响到现在</li><li>环境决定论，环境决定人的本性，例如公司、家庭甚至国家政策，社会环境等，都会影响到人</li></ul></li><li>其实外部因素决定论的基础是”刺激-回应“，有点像狗狗的实验，每天给定时按铃给狗狗吃饭，等过了一段时间后哪怕狗狗吃饱了，再次按铃它也会吃下饭</li><li>但是人类不只是动物，还有自由的思想，会在刺激-回应，选择是否回应</li><li>实际案例：维克多·弗兰克尔在二战被囚禁，遭遇各种刺激（如：侮辱、伤痛），通过脑子自我想象，超越肉体的禁锢，用独有的自我意识，发掘人类根本原则，就是人有选择的自由。</li><li>人类选择的自由，有四种特有的天赋：<ul><li>自我意识，知道自己是自己</li><li>想象力，超越现实，进行创造</li><li>良知，坚持自己的原则，判断对与错</li><li>独立意志，基于自我意识，不受外力自行其是的能力</li></ul></li><li>而环境决定论基本上源自于集体意识，集体意识是动物的本能，而人类与动物的区别，在于集体意识之上，拥有我们自由选择的能力</li><li>积极主动的定义：不仅仅是做事的态度，还是意味着要对自己的人生负责</li><li>积极主动应该要做的，营造有利的外部环境的积极性和责任感<ul><li>责任感，其实就是要回应，根据价值观去做不同选择回应</li></ul></li><li>积极主动要做的事情：<ul><li>不受外界影响，拥有自己的价值观去行事</li><li>理智胜于冲动，价值观是内在动力</li><li>昨日的选择决定了今日的我</li></ul></li><li>伤害并非是我们遭遇了悲痛的事情，而是我们对悲痛事情的回应</li><li>人生的三种价值观：<ul><li>经验价值观，来自自身经历</li><li>创造价值观，源于个人独创</li><li>态度价值观，面对绝境的回应，而这个恰恰是最重要的价值观</li></ul></li><li>逆境和困境往往能激发人的思维转换，从换个角度和观点看待世界、人、事情，重新审视生命的意义</li><li>采取主动的方式<ul><li>面试，可以采取主动去帮忙公司解决问题，这就是”解决方案式推销自己“，是事业成功的重要诀窍之一</li><li>培养责任感，主动积极去做自己的事情</li><li>变被动为主动，面对所有的事情提前去做</li></ul></li><li>积极行动与积极思考，不仅要面对现实，还要面对未来，需要有足够积极态度和能力去面对未来可能发生的一切</li><li>聆听自己的语言，判断是否自己是积极，还是消极的<ul><li>积极的人会说，有没有其他可能性？做不同的选择，控制情绪，有效的表达，选择恰当的回应，我选择，我更愿意，我打算？</li><li>消极的人会说，无能为力，气疯了，我就是这样，只能这么做，不能，不得不，要是。。。就好了</li></ul></li><li>积极主动更多的是行动，而不是想想而已</li><li>关注圈与影响圈，是判断一个人是否积极的标准<ul><li>关注圈，关注感兴趣的事情，如：家庭、技术、健康、子女等</li><li>影响圈，是能在自己控制范围内的事情</li></ul></li><li>积极主动的人会专注自己的影响圈，专心做自己能力所及的事情，使得影响圈不断扩大</li><li>消极被动的人会专注关注圈，关注周围的人和环境问题，抓住超出能力范围外的事情不放，怨天尤人，从而不断压缩自己的影响圈</li><li>关注圈与影响圈真正平衡点，关注圈不小于影响圈</li><li>什么才是自己能控制的事情呢？分为三种：<ul><li>直接控制，问题与自己有关系，可以通过培养良好的习惯去解决</li><li>间接控制，问题与他人有关系，通过改进施加影响去解决</li><li>无法控制，无能为力或无法解决，如：过去的问题，和现实的环境，以微笑面对现实，纵使有太多不满，也要泰然处之</li></ul></li><li>怎么做才能扩大影响圈？<ul><li>专注于自己的影响圈内的事情，积极主动去处理相关事宜</li><li>多说自己可以，由内到外去做事情，先改变个人行为，更充实，更具创造力，再施加影响去改变环境</li></ul></li><li>面对错误的选择，怎么处理？<ul><li>应该承认错误，改正并从中吸取教训，做到”失败是成功之母“</li></ul></li><li>影响圈的核心，就是做出承诺与信守承诺的能力，说到做到</li><li>掌控人生的途径：<ul><li>做出承诺，然后遵守承诺</li><li>确定目标，付诸实践</li></ul></li><li>知识、技巧和意愿都在影响圈内，改善任何一者都同时提升三者的平衡，当三者交集越大，那么习惯和原则就越完善，就越容易实现高效的人生</li><li>30天实践，按照下面的积极主动原则去生活<ul><li>全部精力都放到影响圈内</li><li>从各种小事做起，说到做到</li><li>学会照亮他人的蜡烛，而不是评判对错的判官</li><li>解决问题，而不是制造事端</li></ul></li><li>行动建议<ul><li>写下本周面临的挑战和问题，分别归入哪个圈子，回想一下你的回应是什么？<ul><li>挑战/问题    圈子（关注、影响）  回应（积极 or 消极）</li></ul></li><li>设法扩大自己的影响圈，做出了什么改变，克服了什么困难？</li><li>找一个难以解决的问题，判断是属于直接控制、间接控制，还是无法控制的问题，然后在影响圈内找到解决问题的第一步，然后付诸行动</li><li>有什么事情一直想做，但是缺乏时间，天赋或能力，为了克服这些弱点或痛点，你应当做什么？新的一周又能为其做什么事呢？</li><li>开发一项新的功能，你希望是什么？</li><li>能到世界某一个地方旅行，你希望是哪里？</li><li>改变生活中的某件事情，想改变哪个？</li><li>制定上面三个愿望的计划</li></ul></li></ul></li><li>第四章 习惯二 以终为始 —— 自我领导的原则<ul><li>和内在力量相比，身外之物显得微不足道。—— 奥利弗·温德尔·霍姆斯<ul><li>这句话表达的是，内心真正的需求和力量才是真正你所依靠的东西，所有外面的东西都无法影响到你。</li></ul></li><li>一个案例，如果你正在参加自己的葬礼，大家都在评论你的一生，那么需要你扪心自问，你准备过怎么样的一生</li><li>以终为始的定义<ul><li>做任何事情前，都要认清方向，避免在做事情的过程误入歧途</li><li>明确目标是比做事情还要重要的事情</li><li>只有明确的目标才能更加高效的工作</li></ul></li><li>以终为始的原则 —— 任何事情都是两次创造而成<ul><li>第一次创造，在头脑构思，是智力上的创造</li><li>第二次创造，是付诸实践，是体力上的创造</li></ul></li><li>问题：很多时候，我们的第一次创造都是被社会/环境/父母被动创造出来的， 这与我们主动设计的第一次创造是不同的</li><li>以终为始的原则 —— 自我领导<ul><li>自我领导是以终为始的基础</li><li>领导是第一次创造，是思想，怎么才能有效的把事情做好</li><li>领导是做正确的事情，管理是正确的做事</li></ul></li><li>有效的领导和有效的管理，是高效做事不可避免两个因素，其中有效的领导往往比有效的管理还要重要</li><li>改变人生剧本：成为自己的第一次创造者<ul><li>赢自己，才是真正赢得人生，每天都比昨天的自己做的更加好一点</li><li>教育孩子，不要忘记目的，不是为了教训，而是希望通过教训去教育孩子学会一些东西</li></ul></li><li>以终为始的需要树立正确的价值观，等同于个人宣言或个人承诺，如何树立：<ul><li>利用自我意识检查我们的地图或思维方式是否符合实际，是否基于正确原则</li><li>利用良知作为罗盘审视我们的行为</li><li>利用想象力制定我们的人生目标</li></ul></li><li>以终为始的做法，是以影响圈的核心 —— 观察世界的眼镜 ，去驱动我们人生四个成长方向：<ul><li>安全感，价值观，认同，情感归属，是自尊自重，与人生的基本能力</li><li>人生方向，是地图和内心的原则，是做事的决策原则</li><li>智慧，对生命认知，对平衡的感知，对事物间联系的理解，包括：判断力，洞察力，理解力</li><li>力量，行动力，达成目标的能力，培育有效的习惯代替顽固旧习</li></ul></li><li>生活重心=人生方向，每个人的生活重心都不一样，如：以家庭，以工作，以金钱等</li><li>选择不同的重心，导致生活方式和结果都不一样</li><li>识别自己的生活重心 —— 从上面几个方向可以识别出来</li><li>正确的生活重心 —— 以原则为重心，所有的选择都源自自己内心真正想要的<ul><li>需要编写的人生宣言</li></ul></li><li>左右脑的作用<ul><li>左脑，逻辑与语言能力，文字</li><li>右脑，创造与直觉能力，图像</li><li>整个大脑去解决问题，扩宽思路</li></ul></li><li>开发右脑的两种途径<ul><li>意外刺激打击，从左脑思维转换为右脑思维</li><li>自觉转换，通过想象一些场景，如：退休生活，给自己写死亡悼词，开动脑筋，尽最大的热情去想象和情感，以及每一个细节</li><li>心灵演练，就是开发右脑的一种方式</li></ul></li><li>如何撰写个人宣言，也就是人生目标<ul><li>确定正确行为，五个基本要素<ul><li>个人</li><li>积极</li><li>果断</li><li>可视</li><li>情感</li><li>例子，发现子女行为不当时，我（个人 ）能以智慧、爱心、坚定的立场与自制力（积极 ）及时应对（果断 ），结果让我深感欣慰（情感 ）。</li></ul></li></ul></li><li>心灵演练，是要做可视的，每天抽几分钟时间去想象自己可能面临的场景，越详细越好，然后身临其境的去体会那种感觉，最终让自己想出面对这种场景，应该遵循自己的价值观和人生诺言去做出选择</li><li>心灵演练的可视化和确认步骤是一个完整体系，具体包括如下：<ul><li>潜意识，也叫阈下意识，就是人无意识的行为</li><li>神经语言，</li><li>放松</li><li>自我谈话</li></ul></li><li>在做人生目标的时候，应该按照不同角色去思考，尽量兼顾全局，如：生活中的父母/丈夫等</li><li>人生目标案例：<ul><li>我的的使命是堂堂正正地生活，并且对他人有所影响，对社会有所贡献。</li><li>为完成这一使命，我会要求自己：</li><li>有慈悲心——亲近人群，不分贵贱，热爱每一个人。</li><li>甘愿牺牲——为人生使命奉献时间、才智和金钱。</li><li>激励他人——以身作则，证明人为万物之长，可以克服一切困难。</li><li>施加影响——用实际行动改善他人的生活。</li><li>为了完成人生使命，我将优先考虑以下角色：</li><li>丈夫——妻子是我这一生中最重要的人，我们同甘共苦，携手前行。</li><li>父亲——我要帮助子女体验乐趣无穷的人生。</li><li>儿子/兄弟——我不忘父子、手足的亲情，随时对他们施以援手。</li><li>基督徒——我信守对上帝的誓言，并为他的子民服务。</li><li>邻居——我要学习像耶稣一样爱和善待他人。</li><li>变革者——我能激发和催化团队成员的优异表现。</li><li>学者——我每天都学习很多重要的新知识。</li></ul></li><li>不管是个人/家庭/企业，都需要有自己的使命宣言</li></ul></li><li>第五章 习惯三 要是第一 —— 自我管理的原则<ul><li>重要之事决不可接受芝麻绿豆小事牵绊 —— 歌德<ul><li>表达的是，当你在做重要的事情的时候，不要被其他无关小事影响到你的注意力和时间</li></ul></li><li>如何分析哪些事是重要的？<ul><li>哪些事情能够彻底改变你的个人生活，但一直没做</li><li>哪些事情能够彻底改变你的工作局面，但一直没做</li></ul></li><li>习惯三是习惯一/二的具体实践<ul><li>习惯一 积极主动，告诉你需要掌控你自己的人生，自我意识的觉醒</li><li>习惯二 以终为始，去创造属于自己想要的东西，设定自己真正想要的东西</li><li>习惯三 要事第一，是让积极主动和以终为始的想法落地真正现实中，去努力实现自己想要的生活</li></ul></li><li>左脑进行管理，右脑进行领导</li><li>独立意志：有效管理的先决条件<ul><li>独立意志指的是做出决定和主动选择，并根据这些决定和选择采取具体行动的能力</li></ul></li><li>自我管理的实质就是自律和条理，是对计划的实施。</li><li>成功者能为失败者所不能为，纵使并非心甘情愿，但为了理想和目标，仍可以凭毅力克服心理障碍</li><li>时间管理理论演进<ul><li>第一代，利用便条和备忘录，在忙碌中调配时间与精力</li><li>第儿代，强调事项与日程表，反映时间管理已经注意到未来规划的重要性</li><li>第三代，讲求优先顺序的观念，依据轻重缓急四象限去制定短/中/长期目标，再逐日订制每日计划，有效时间获得更高效率</li><li>第四代，不再讲时间管理，而是注重个人管理，将重心从时间与事务中迁移到产出与产能的平衡中</li></ul></li><li>第四代时间管理实战，按照重要/紧急四象限去对事情分级：<ul><li>I类，重要紧急，如：危机/迫切问题/在限定时间内必须完成任务</li><li>II类，重要不紧急，如：预防性事情/建立关系/明确新的发展机会</li><li>III类，紧急不重要，如：接待访客/会议/迫切需要解决的事务/公共活动</li><li>IV 类，不紧急不重要，如：琐碎事情/信息/电话/消磨时间的活动/令人愉悦的活动</li></ul></li><li>上面四类事件，应该是平衡发展的，不管将重点倾向哪一方，忽略哪一方都形成很大的问题<ul><li>只处理重要紧急的问题，那么就会压力大，筋疲力尽，被危机牵着鼻子走</li><li>只处理紧急不重要问题，那么就会急功近利，巧言令色，轻视目标和计划，人际关系肤浅</li></ul></li><li>高效能的做法是：<ul><li>避免陷入第三类和第四类事情，不管是否紧急</li><li>花费更多时间在第二类事情上，去减少第一类事情的数量</li></ul></li><li>第二类事情包括：<ul><li>建立人际关系</li><li>建立人生目标</li><li>规划长期目标</li><li>原则：防患于未然</li></ul></li><li>用于对琐事说不，因为你要专注于主要事情，如果不说“不”，你将永远无法完成主要事情</li><li>自制力，源自于确定目标，只有确定目标后，确定以目标为中心去做主要事情，才能拥有独立意志</li><li>集大成的时间管理理论，强调产出与产能的平衡，着重第二类事务，以原则目标为中心</li><li>时间管理的六大标准<ul><li>和谐一致 个人理想/角色/目标/工作重点/计划/欲望/自制力，必须一致的</li><li>平衡功能 需要平衡不同角色的不同时间安排</li><li>围绕中心 不以时间的紧迫来的定优先级 而是通过事情的重要性定优先级，以一周为周期</li><li>以人为本 个人管理在于人，不在事，有效的管理有时候需要迁就别人，牺牲效率</li><li>灵活变通 管理方法并非一成不变，随环境或个人调整</li><li>便于携带 管理工具便于携带，随时可调整</li></ul></li><li>自我管理，安排第二类事情的的四个步骤<ul><li>确认角色，确定你的关键角色，记录你在下一周应该要角色和任务，</li><li>选择目标，按照不同角色确定你下一周要做的事情，同时确定哪些事是第二类事情（与长期目标关联）</li><li>安排进度，为每一项确定具体时间表，一般是周末两天开始制定</li><li>每日调整，每天不断更新和调整自己的时间表，根据突发事件/人际关系等，每天清晨审视自己的时间表</li></ul></li><li>所有事情都要付出实践，只有正在去做才能知道行不行</li><li>高效秘诀 —— 授权， 将责任分配给其他熟练的人，是管理上最大的成长</li><li>授权类型：<ul><li>指令型授权，关注重点是方法，为最后的结果负责，简单点说，就是怕别人做的不如自己做的好，还是希望按照自己的想法去做</li><li>责任型授权，关注最终的结果，给别人最大的自由，虽然过程很难，但是却能获得更好的结果，下面从五个方面达成共识<ul><li>预期成果，以结果为中心，详细描述结果和最终结果时间</li><li>指导方针，确定评估标准，避免成为指令型授权，从主导变成协助</li><li>可用资源，告知对方可以利用的资源，如：人力/技术/财务等</li><li>责任归属，制定业绩标准，评估最终结果</li><li>明确奖惩，评估结果后，确定好与不好的奖励与惩罚</li></ul></li></ul></li><li>信任是促进人进步最大动力</li><li>授权的大原则不变，但是要因人而异<ul><li>不成熟的人，目标不高，指示要详细，监督要频繁</li><li>成熟的人，目标要有挑战性，精简指示，减少监督</li></ul></li><li>以要事为中心的思维定式，是从重要性而不是紧迫性去观察一切事务</li><li>付诸行动，练习<ul><li>名人名言：成功的人习惯去做失败者不喜欢做的事，他们当然也不喜欢做，但是他们让这种不喜欢服从于对自己目标的追求</li><li>我的时间是怎么度过的</li><li></li></ul></li></ul></li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;高效能人士的7个习惯&quot;&gt;&lt;a href=&quot;#高效能人士的7个习惯&quot; class=&quot;headerlink&quot; title=&quot;高效能人士的7个习惯&quot;&gt;&lt;/a&gt;高效能人士的7个习惯&lt;/h1&gt;&lt;p&gt;不管是工作还是学习，有些人做事的效率很高，而有些做事的效率就很低，那么有什么方式可以提高自己的工作效率，这本书主要就是讲如何去培养自己高效能的习惯，改变自己的做事和思考的方式。&lt;/p&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/学习总结/"/>
    
  </entry>
  
  <entry>
    <title>前端面试100道手写题（1）—— 手写Promise实现</title>
    <link href="https://www.qborfy.com/face100/1-promise-face.html"/>
    <id>https://www.qborfy.com/face100/1-promise-face.html</id>
    <published>2023-04-16T07:00:00.000Z</published>
    <updated>2023-04-16T09:01:38.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>今年的金三银四面试，遇到了很多新的面试八股文，其实心里对手写题或者算法题有一定抵触，因为实际工作中基本上就不会用到这些东西，但是正因为这些基础八股文，才能真正验证一个人对技术有多热爱的程度。<br>也有可能近几年没有对这些基础知识进行巩固，所以干脆一狠心，先立个flag, 准备完成100道手写题。</p><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>Promise 对象用于表示一个异步操作的最终完成（或失败）及其结果值。  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">MDN Promise</a></p></blockquote><p>下面有一张图用来显示Promise的基本流程图（源自MDN）：</p><p><img src="/assets/img/promises.png" alt></p><p>如何快速理解Promise呢？就是必须给出一个最终结果的状态处理机制函数。</p><p>可以想象Promise是一个排队买奶茶的操作，当你进入排队中处于pending，轮到你的时候成功买到奶茶则是fulfilled，如果中途你走开了或者轮到你的时候没买奶茶，则是买奶茶失败rejected，最后则是无论如何你都离开奶茶店，这就是finally。</p><p>因此Promise的有三种状态：</p><ul><li>待定（pending）:  初始状态</li><li>已兑现（fulfilled）: 操作成功完成</li><li>已拒绝（rejected）：操作失败</li></ul><p>同时Promise在成功执行后完成执行注册在自身的Promise.prototype.then函数，如果失败后会调用Promise.prototype.catch。</p><p><strong>重要知识点：Promise其实是通过微任务队列(Microtasks)<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/queueMicrotask" target="_blank" rel="noopener">queueMicrotask()</a>的去实现的，所以会比setTimeout等定时器任务要优先，这一点在网上很多手写Promise都忘记去实现了。</strong></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol><li>内置函数，需要实例化对象后才能调用</li></ol><ul><li>构建函数 <code>Promise(resolve, reject)</code> 创建一个Promise对象</li><li><code>Promise.prototype.then()</code> 为 promise 添加被兑现状态的回调函数，其以回调函数的返回值兑现 promise。若回调函数被调用，则兑现其返回值，否则兑现原来的 promise 兑现的值。  </li><li><code>Promise.prototype.catch()</code> 为 promise 添加一个被拒绝状态的回调函数，并返回一个新的 promise，若回调函数被调用，则兑现其返回值，否则兑现原来的 promise 兑现的值。  </li><li><code>Promise.prototype.finally()</code> 为 promise 添加一个回调函数，并返回一个新的 promise，这个promise的值将为原来promise的值。而传入的回调函数将在原 promise 被敲定（无论被兑现还是被拒绝）时被调用，同时需要等待then或catch执行完后才会被执行。</li></ul><ol start="2"><li>静态函数，可以直接调用的</li></ol><ul><li><code>Promise.all(iterable)</code> 返回一个新的 <code>Promise</code> 对象，等到传入所有的 <code>Promise</code> 对象都成功，则表示成功，返回值的顺序与传入顺序一致，如果有任意一个 <code>Promise</code>则表示失败</li><li><code>Promise.allSettled(iterable)</code> 等到所有 <code>Promise</code> 都已敲定（每个 <code>Promise</code> 都已兑现或已拒绝），与all不同在于传入每个<code>Promise</code>都会被执行一次</li><li><code>Promise.any(iterable)</code> 当其中的任意一个 <code>Promise</code> 成功，就返回那个成功的 <code>Promise</code> 的值，与all相反</li><li><code>Promise.race(iterable)</code> 无论传入的 <code>Promise</code> 是执行成功或失败，都直接返回其结果</li><li><code>Promise.resolve(value)</code> 返回一个状态有value决定的Promise，如果value(带有then(resolve, reject)的对象)，则会执行then方法去判断状态，如果没有则将value直接返回成功调用的值</li><li><code>Promise.reject(reason)</code> 返回一个状态为已拒绝的 Promise 对象，其错误信息为reason</li></ul><p>以上就是Promise的全部基础知识点，接下来我们就来实现，同时业界内也有一个<a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise/A+规范</a>，大家也可以按照其规范去实现自己的Promise。</p><h1 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h1><p>在手写代码之前，我们需要明白<code>Promise</code>实现的基本原理：</p><ul><li>发布订阅模式，解决<code>Promise</code>的state发生变化后需要触发的事件，如：then 或 catch</li><li>链式调用，<code>Promise</code>所有的方法调后都会返回一个新的<code>Promise</code>对象</li></ul><p>其中关键代码在<code>then</code>函数的实现，主要是返回一个新的<code>Promise</code>对象，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Promise的三种状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> StatusType = &#123;</span><br><span class="line">    PENDING: <span class="string">'pending'</span>,</span><br><span class="line">    FULFILLED: <span class="string">'fulfilled'</span>,</span><br><span class="line">    REJECTED: <span class="string">'rejected'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 手写Promise</span></span><br><span class="line"><span class="comment"> * @author: Qborfy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; executor 为一个函数，该函数接受两个参数，分别是resolve和reject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">        <span class="comment">// 初始化状态为pending</span></span><br><span class="line">        <span class="keyword">this</span>.status = StatusType.PENDING;</span><br><span class="line">        <span class="comment">// 初始化成功的值</span></span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="comment">// 初始化失败的原因</span></span><br><span class="line">        <span class="keyword">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="comment">// 成功的回调函数</span></span><br><span class="line">        <span class="keyword">this</span>.onFulfilledCallbacks = [];</span><br><span class="line">        <span class="comment">// 失败的回调函数</span></span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 成功的回调函数</span></span><br><span class="line">        <span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 状态只能从pending到fulfilled或者rejected</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === StatusType.PENDING) &#123;</span><br><span class="line">                <span class="keyword">this</span>.status = StatusType.FULFILLED;</span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">                <span class="comment">// 依次执行成功的回调函数 使用queueMicrotask()去执行</span></span><br><span class="line">                <span class="keyword">this</span>.onFulfilledCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">                    queueMicrotask(fn(<span class="keyword">this</span>.value));</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 失败的回调函数</span></span><br><span class="line">        <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 状态只能从pending到fulfilled或者rejected</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === StatusType.PENDING) &#123;</span><br><span class="line">                <span class="keyword">this</span>.status = StatusType.REJECTED;</span><br><span class="line">                <span class="keyword">this</span>.reason = reason;</span><br><span class="line">                <span class="comment">// 依次执行失败的回调函数 使用queueMicrotask()去执行</span></span><br><span class="line">                <span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">                    queueMicrotask(fn(<span class="keyword">this</span>.reason));</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 立即执行executor函数</span></span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="comment">// 如果执行executor函数出错，直接执行reject</span></span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将then方法返回的promise的resolve和reject传入</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; onFulfilled </span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; onRejected </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="comment">// onFulfilled和onRejected都是可选参数</span></span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="keyword">throw</span> err &#125;;</span><br><span class="line">        <span class="comment">// 判断结果是否为promise，如果是promise，直接返回该promise，如果不是则返回一个新的promise</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">result, resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                result.then(resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> newPromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 如果状态完成，直接执行onFulfilled</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === StatusType.FULFILLED) &#123;</span><br><span class="line">                <span class="keyword">const</span> result = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">                resolvePromise(result, resolve, reject);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果状态失败，直接执行onRejected</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === StatusType.REJECTED) &#123;</span><br><span class="line">                <span class="keyword">const</span> result = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">                resolvePromise(result, resolve, reject);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果状态为pending，将onFulfilled和onRejected存入对应的回调函数数组中</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === StatusType.PENDING) &#123;</span><br><span class="line">                <span class="comment">// 同时将resolve和reject传入对应函数中</span></span><br><span class="line">                <span class="keyword">this</span>.onFulfilledCallbacks.push(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> result = onFulfilled(value)</span><br><span class="line">                    resolvePromise(result, resolve, reject)</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> result = onRejected(reason)</span><br><span class="line">                    resolvePromise(result, resolve, reject)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newPromise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行catch方法，返回一个新的promise</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; onRejected </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不管是成功还是失败，最终会执行finally方法，返回一个原来promise的结果</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; onFinally </span></span><br><span class="line"><span class="comment">     * @returns </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">finally</span>(onFinally) &#123;</span><br><span class="line">        <span class="comment">// 这里要将原来的value或reason返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">            onFinally()</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;, (reason)=&gt;&#123;</span><br><span class="line">            onFinally()</span><br><span class="line">            <span class="keyword">return</span> reason;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> resolve() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> reject() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> all() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> allSettled() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> any() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> race() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="number">1</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'then:'</span>, res)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'finally'</span>)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'then2:'</span>, res)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'then3:'</span>, res)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(p)</span><br><span class="line">    <span class="comment">// const p2 = new MyPromise((resolve, reject) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     JSON.parse('&#123;a&#125;')</span></span><br><span class="line">    <span class="comment">// &#125;).catch((res) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     console.log('catch:', res)</span></span><br><span class="line">    <span class="comment">// &#125;).finally(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     console.log('finally2')</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>这里就不粘贴完整源码了，完整源码请到github中查看，想看更多八股文手写题可以给个star收藏一下，Github会给你推送更新信息，地址如下：</p><p><a href="https://github.com/qiubohong/hundred-interview-questions/blob/main/1-promise/mypromise.js" target="_blank" rel="noopener">https://github.com/qiubohong/hundred-interview-questions/blob/main/1-promise/mypromise.js</a></p><h1 id="Promise在开发中遇到的问题"><a href="#Promise在开发中遇到的问题" class="headerlink" title="Promise在开发中遇到的问题"></a>Promise在开发中遇到的问题</h1><ul><li>并发Promise，用Promise.all，那么如何实现限制并发数呢?</li><li>await去等待Promise的结果，如果是reject结果，如何catch，或者用其他方式避免await的错误？</li><li>Promise的调用时机，即是一个非异步的Promise函数什么时候会被执行，为什么会比setTimeout等定时器优先更高？</li></ul><h1 id="额外知识点"><a href="#额外知识点" class="headerlink" title="额外知识点"></a>额外知识点</h1><h2 id="微任务（Microtasks）和任务（tasks）的区别"><a href="#微任务（Microtasks）和任务（tasks）的区别" class="headerlink" title="微任务（Microtasks）和任务（tasks）的区别"></a>微任务（Microtasks）和任务（tasks）的区别</h2><p>JavaScript中的<code>任务</code>指的是将代码按照下面的标准机制去形成一个个任务，加入到<strong>任务队列</strong>中，去等待被<strong>事件循环</strong>驱动调度。</p><ul><li>一段代码被直接执行时</li><li>触发了一个事件，将其回调函数添加到任务队列时</li><li>执行到一个由 setTimeout() 或 setInterval() 创建的 timeout 或 interval，以致相应的回调函数被添加到任务队列时</li></ul><p>而<code>微任务</code>则是通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/queueMicrotask" target="_blank" rel="noopener">queueMicrotask()</a>加入微任务队列中，在事件循环之前的安全时间执行的（当前事件循环无任何需要执行任务），同时事件循环会持续调用微任务直至队列中没有留存的，即使是在有更多微任务持续被加入的情况下。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;headerlink&quot; title=&quot;原因&quot;&gt;&lt;/a&gt;原因&lt;/h1&gt;&lt;p&gt;今年的金三银四面试，遇到了很多新的面试八股文，其实心里对手写题或者算法题有一定抵触，因为实际工作中基本上就不会用到这些东西，但是正因为这些基础八股文，才能真正验证一个人对技术有多热爱的程度。&lt;br&gt;也有可能近几年没有对这些基础知识进行巩固，所以干脆一狠心，先立个flag, 准备完成100道手写题。&lt;/p&gt;
&lt;h1 id=&quot;Promise&quot;&gt;&lt;a href=&quot;#Promise&quot; class=&quot;headerlink&quot; title=&quot;Promise&quot;&gt;&lt;/a&gt;Promise&lt;/h1&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/学习总结/"/>
    
    <category term="前端面试" scheme="https://www.qborfy.com/tags/前端面试/"/>
    
  </entry>
  
  <entry>
    <title>ChatGPT工具收集</title>
    <link href="https://www.qborfy.com/ideas/20230408.html"/>
    <id>https://www.qborfy.com/ideas/20230408.html</id>
    <published>2023-04-08T13:51:01.000Z</published>
    <updated>2023-04-08T14:54:54.984Z</updated>
    
    <content type="html"><![CDATA[<h1 id="chatGPT工具收集"><a href="#chatGPT工具收集" class="headerlink" title="chatGPT工具收集"></a>chatGPT工具收集</h1><ol><li>chatgpt-i18n: AI自动翻译i18n.json</li></ol><p>Github地址： <a href="https://github.com/ObservedObserver/chatgpt-i18n" target="_blank" rel="noopener">https://github.com/ObservedObserver/chatgpt-i18n</a></p><a id="more"></a><ol start="2"><li>cli-gpt: 用 ChatGPT 开发一个能听懂人话的命令行工具</li></ol><p>Github地址： <a href="https://github.com/MagicCube/cli-gpt" target="_blank" rel="noopener">https://github.com/MagicCube/cli-gpt</a></p><ol start="3"><li>通过可组合性⚡使用LLMS构建应用程序</li></ol><p>Github地址： <a href="https://github.com/hwchase17/langchain?utm_source=gold_browser_extension" target="_blank" rel="noopener">https://github.com/hwchase17/langchain?utm_source=gold_browser_extension</a></p><ol start="4"><li>自己创建中文GPT</li></ol><p>Github地址： <a href="https://github.com/ymcui/Chinese-LLaMA-Alpaca?utm_source=gold_browser_extension" target="_blank" rel="noopener">https://github.com/ymcui/Chinese-LLaMA-Alpaca?utm_source=gold_browser_extension</a></p><h1 id="创业箴言"><a href="#创业箴言" class="headerlink" title="创业箴言"></a>创业箴言</h1><ol><li>5年独立开发者总结</li></ol><ul><li>激情是把双刃剑，能让你更加干活充满精力，但是却无法带来更多资产，反而更像一种赚钱的障碍</li><li>无法远离人情世故，创业或独立都需要自己去面对更多的人群，如：客户、供应商等</li><li>社区真正的价值<ul><li><strong>”你不知道你不知道什么“</strong>，这句话需要经常记住</li><li>社区带来的是知识，是一种宝贵的学习资源，还有一起创业时候的人脉</li><li>听听某人的故事或关于他们项目的一般性玩笑，可能会让我接触到新的营销策略、更好的入职策略或有助于加快我的开发工作流程的工具。当我遇到新问题时，它也给了我更广泛的经验来借鉴。</li></ul></li><li>创业选择值得吗？没有可观的收入和花费很多时间，后续怎么走等等</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;chatGPT工具收集&quot;&gt;&lt;a href=&quot;#chatGPT工具收集&quot; class=&quot;headerlink&quot; title=&quot;chatGPT工具收集&quot;&gt;&lt;/a&gt;chatGPT工具收集&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;chatgpt-i18n: AI自动翻译i18n.json&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Github地址： &lt;a href=&quot;https://github.com/ObservedObserver/chatgpt-i18n&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/ObservedObserver/chatgpt-i18n&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="奇思妙想" scheme="https://www.qborfy.com/tags/奇思妙想/"/>
    
  </entry>
  
  <entry>
    <title>如何用vite+vue-next快速开发chrome插件</title>
    <link href="https://www.qborfy.com/today/20230227.html"/>
    <id>https://www.qborfy.com/today/20230227.html</id>
    <published>2023-04-06T14:00:01.000Z</published>
    <updated>2023-04-06T15:14:06.484Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前写过一篇文章<a href="https://qborfy.com/today/20230224.html" target="_blank" rel="noopener">《从开发chrome插件到插件系统设计》</a>，主要讲述了如何开发一个chrome插件和chrome插件设计，感兴趣的同学可以再去看看。</p><p>目前主流web应用都是基于Vue、React等现代框架去开发，Chrome插件本身而言其实也是一个web应用，看它的组成部分<code>popup.html</code> + <code>contentscript</code> + <code>background.js</code> ，只需要在开发的时候调整一下构建脚本基本上就可以利用Vue、React等现代框架去开发了。</p><p>接下来，我们就一步步开始实战。</p><a id="more"></a><h1 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>利用<code>vite</code>初始化项目命令快速搭建，具体如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pnpm create vite</span><br></pre></td></tr></table></figure><ol><li>在public目录下新建manifest.json</li></ol><p>内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"ngptcommit"</span>,</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"1.0"</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"ngptcommit自动生成git commit信息"</span>,</span><br><span class="line">    <span class="attr">"manifest_version"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"browser_action"</span>: &#123;</span><br><span class="line">        <span class="attr">"default_popup"</span>: <span class="string">"index.html"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"icons"</span>: &#123;</span><br><span class="line">        <span class="attr">"16"</span>: <span class="string">"images/favicon-16x16.png"</span>,</span><br><span class="line">        <span class="attr">"48"</span>: <span class="string">"images/favicon-32x32.png"</span>,</span><br><span class="line">        <span class="attr">"64"</span>: <span class="string">"images/android-chrome-192x192.png"</span>,</span><br><span class="line">        <span class="attr">"128"</span>: <span class="string">"images/android-chrome-192x192.png"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"background"</span>: &#123;</span><br><span class="line">        <span class="attr">"scripts"</span>: [</span><br><span class="line">            <span class="string">"background/background.js"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"permissions"</span>: [</span><br><span class="line">        <span class="string">"tabs"</span>,</span><br><span class="line">        <span class="string">"storage"</span>,</span><br><span class="line">        <span class="string">"http://*/*"</span>,</span><br><span class="line">        <span class="string">"https://*/*"</span>,</span><br><span class="line">        <span class="string">"activeTab"</span>,</span><br><span class="line">        <span class="string">"contextMenus"</span>,</span><br><span class="line">        <span class="string">"notifications"</span>,</span><br><span class="line">        <span class="string">"webRequest"</span>,</span><br><span class="line">        <span class="string">"webRequestBlocking"</span>,</span><br><span class="line">        <span class="string">"cookies"</span>,</span><br><span class="line">        <span class="string">"unlimitedStorage"</span>,</span><br><span class="line">        <span class="string">"webNavigation"</span>,</span><br><span class="line">        <span class="string">"identity"</span>,</span><br><span class="line">        <span class="string">"identity.email"</span>,</span><br><span class="line">        <span class="string">"identity.read"</span>,</span><br><span class="line">        <span class="string">"identity.write"</span>,</span><br><span class="line">        <span class="string">"identity.launch.webauthn"</span>,</span><br><span class="line">        <span class="string">"identity.launch.webauthn"</span>,</span><br><span class="line">        <span class="string">"identity.manage.accounts"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增插件必须的文件，如：<code>manifest.json</code>和 <code>background.ts</code> ，完整目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">chrome-extension</span><br><span class="line">├── README.md</span><br><span class="line">├── index.html</span><br><span class="line">├── package.json</span><br><span class="line">├── public</span><br><span class="line">|  ├── images</span><br><span class="line">|  └── manifest.json</span><br><span class="line">├── src</span><br><span class="line">|  ├── App.vue</span><br><span class="line">|  ├── background.ts</span><br><span class="line">|  ├── components</span><br><span class="line">|  ├── main.ts</span><br><span class="line">|  ├── style.css</span><br><span class="line">|  └── vite-env.d.ts</span><br><span class="line">├── tsconfig.json</span><br><span class="line">├── tsconfig.node.json</span><br><span class="line">└── vite.config.ts</span><br></pre></td></tr></table></figure><h2 id="调整编译"><a href="#调整编译" class="headerlink" title="调整编译"></a>调整编译</h2><p>由于vite初始化项目只针对web应用设计，但是我们开发chrome插件还需要针对<code>background.ts</code> 去做编译，就是要做多入口编译，而且vite本身就是基于rollup为基础去实现的少量配置即可完成一个web应用打包。</p><blockquote><p>一套构建指令，它使用<strong><a href="https://rollupjs.org/" target="_blank" rel="noopener"><code>Rollup</code></a></strong> 打包你的代码，并且它是预配置的，可输出用于生产环境的高度优化过的静态资源。—— Vite官网介绍</p></blockquote><p>所以我们其实可以使用<code>Rollup</code>去打包我们的<code>background.ts</code> ，就是增加多一个入口文件，具体如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import &#123; defineConfig &#125; from &apos;vite&apos;</span><br><span class="line">import vue from &apos;@vitejs/plugin-vue&apos;</span><br><span class="line">import path from &apos;path&apos;</span><br><span class="line"></span><br><span class="line">// https://vitejs.dev/config/</span><br><span class="line">export default defineConfig(&#123;</span><br><span class="line">  plugins: [vue()],</span><br><span class="line">  build: &#123;</span><br><span class="line">    rollupOptions: &#123;</span><br><span class="line">      input: &#123;</span><br><span class="line">        index: path.resolve(__dirname, &apos;index.html&apos;),</span><br><span class="line">        background: &apos;src/background.ts&apos;,</span><br><span class="line">      &#125;,</span><br><span class="line">      output: &#123;</span><br><span class="line">        entryFileNames: `[name].js`,</span><br><span class="line">        assetFileNames: `[name].[ext]`,</span><br><span class="line">        chunkFileNames: `[name].js`,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其中有几个地方需要说明一下：</p><ul><li><code>output</code>： 设置不加<code>hash</code>值，后续调试的时候插件不会出现加载不到文件的错误</li><li><code>rollupOptions</code>：基本上和<code>Rollup</code>的配置项一模一样，所以有<code>Rollup</code>基础的基本上可以直接上手配置，而且也完全兼容<code>Rollup</code>的插件生态</li></ul><p>接下来就是调整<code>package.json</code>中<code>scripts</code>命令，需要针对background新增两个命令，具体如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"@node-gptcommit/chrome-extension"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.0"</span>,</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"rimraf dist &amp;&amp; vite"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"vue-tsc &amp;&amp; vite build"</span>,</span><br><span class="line">    <span class="attr">"preview"</span>: <span class="string">"vite preview"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>dev:background</code> 代表开发模式</li><li><code>build:background</code> 代表生产模式</li></ul><p>到了这里基本上就完成了项目的搭建，接下来就进入开发阶段。</p><h1 id="项目开发"><a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h1><h2 id="UI开发"><a href="#UI开发" class="headerlink" title="UI开发"></a>UI开发</h2><ol><li>引入ui库 <code>tdesign-vue-next</code> ，tdesign是腾讯出品的全端组件库，从桌面到移动，再到小程序，应有尽有，大家可以去尝尝鲜<a href="https://tdesign.tencent.com/" target="_blank" rel="noopener">https://tdesign.tencent.com/</a></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm add tdesign-vue-next</span><br></pre></td></tr></table></figure><ol><li>开发UI，这里就直接撸代码就行，就不展开来讲，主要需要注意的是，需要和background.js通讯的部分，比如需要和chatgpt发送信息，获取返回内容，具体如下:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const getSummary = () =&gt; &#123;</span><br><span class="line">    // 发送通讯，获取总结</span><br><span class="line">    chrome.runtime.sendMessage(</span><br><span class="line">        &#123;</span><br><span class="line">            type: &apos;summary&apos;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                diffs: []</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        (response) =&gt; &#123;</span><br><span class="line">            console.log(response)</span><br><span class="line">        &#125;,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写background-ts"><a href="#编写background-ts" class="headerlink" title="编写background.ts"></a>编写background.ts</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; getSummary &#125; from &apos;@node-gptcommit/summarize&apos;</span><br><span class="line">// 监听收到通讯，发起总结请求</span><br><span class="line">chrome.runtime.onMessage.addListener(async (request: any, sender: any, sendResponse: any) =&gt; &#123;</span><br><span class="line">    const &#123; type = &apos;fetch&apos;, data &#125; = request;</span><br><span class="line">    if (type === &apos;summary&apos;) &#123;</span><br><span class="line">        getSummary(data).then(res=&gt;&#123;</span><br><span class="line">sendResponse(res);</span><br><span class="line">&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>在开发中遇到一个问题，就是如何快速调试chrome插件：</p><ol><li><code>build</code>后会，构建完的文件会有带<code>hash</code>值，如：<code>index.33addf.js</code>，导致chrome重新加载插件的时候出错，如：</li></ol><p><img src="/assets/img/20230227.png" alt="20230227"></p><p>解决方案很简单，就是利用rollupOptions设置输出文件不带hash值即可。</p><ol start="2"><li>没法实时调试插件，每次都需要<code>build</code>后才能去调试，这里需要更改构建方式，因为我们build出来的页面才是我们需要的，所以我们需要在<code>build</code>时候增加<code>--watch</code>，然后真正发布构建的时候关闭<code>watch</code>，调整后，<code>package.json</code>内容如下：</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"@node-gptcommit/chrome-extension"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.0"</span>,</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"vue-tsc &amp;&amp; vite build --watch"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"rimraf dist &amp;&amp; vue-tsc &amp;&amp; vite build"</span>,</span><br><span class="line">    <span class="attr">"preview"</span>: <span class="string">"vite preview"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目源码Github地址：<a href="https://github.com/qiubohong/node-gptcommit" target="_blank" rel="noopener">node-ngptcommit</a>，觉得有帮助的同学帮忙给个star给鼓励一下~❤️</p><p>后面基本上就是按照正常项目去开发即可，本文总结几个要点：</p><ul><li>chrome插件开发和正常web应用不太应用，既包括了html页面，也包括background.js的js库开发模式</li><li>Vite的核心点其实是Rollup，如果掌握Rollup基本上对vite做二次配置也很容易入手</li><li>为什么使用Vue，因为有大量的UI库和相关生态可以使用，能提高开发效率</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;之前写过一篇文章&lt;a href=&quot;https://qborfy.com/today/20230224.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《从开发chrome插件到插件系统设计》&lt;/a&gt;，主要讲述了如何开发一个chrome插件和chrome插件设计，感兴趣的同学可以再去看看。&lt;/p&gt;
&lt;p&gt;目前主流web应用都是基于Vue、React等现代框架去开发，Chrome插件本身而言其实也是一个web应用，看它的组成部分&lt;code&gt;popup.html&lt;/code&gt; + &lt;code&gt;contentscript&lt;/code&gt; + &lt;code&gt;background.js&lt;/code&gt; ，只需要在开发的时候调整一下构建脚本基本上就可以利用Vue、React等现代框架去开发了。&lt;/p&gt;
&lt;p&gt;接下来，我们就一步步开始实战。&lt;/p&gt;</summary>
    
    
    
    
    <category term="技术分享" scheme="https://www.qborfy.com/tags/技术分享/"/>
    
    <category term="每日更新" scheme="https://www.qborfy.com/tags/每日更新/"/>
    
  </entry>
  
  <entry>
    <title>2023年读书计划</title>
    <link href="https://www.qborfy.com/study/2023-read-plan.html"/>
    <id>https://www.qborfy.com/study/2023-read-plan.html</id>
    <published>2023-04-03T14:00:00.000Z</published>
    <updated>2023-04-06T15:17:17.150Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2023年读书计划"><a href="#2023年读书计划" class="headerlink" title="2023年读书计划"></a>2023年读书计划</h1><p>今年给自己的制定的计划，主要读书目标有以下几类：</p><ul><li>给自己的创业带来理论帮助</li><li>给自己的职业带来成长</li><li>给自己的更加开阔的视野</li><li>解答一些人生疑惑</li><li>提高自己的做事效率</li><li>提高自己的表达能力或演讲能力</li><li>搭建自己的股市交易系统<a id="more"></a></li></ul><h2 id="个人发展"><a href="#个人发展" class="headerlink" title="个人发展"></a>个人发展</h2><ul><li>已读<ul><li>百万富翁快车道，待写阅读后总结</li></ul></li><li>在读<ul><li>每周工作4小时，需要再次阅读后写总结</li><li>致所有疯狂的家伙：维珍创始人自传，需要再次阅读后写总结</li><li>高效人士的7个习惯，需快速阅读一遍后，再精读一遍</li></ul></li><li>待读<ul><li>金字塔表达力：用麦肯锡方法提升写作力和演讲力（实战图解版）</li><li>人性的弱点</li><li>乌合之众</li><li>王阳明心学——知行合一</li></ul></li></ul><h2 id="经济学"><a href="#经济学" class="headerlink" title="经济学"></a>经济学</h2><ul><li>已读</li><li>在读</li><li>待读<ul><li></li></ul></li></ul><h2 id="股市交易"><a href="#股市交易" class="headerlink" title="股市交易"></a>股市交易</h2><ul><li>已读</li><li>在读</li><li>待读<ul><li>思考的框架</li><li>海龟交易法则</li><li>投资的原则</li><li>我如何从股市赚了200万</li><li>股市投资的24堂必修课</li><li>我来教你变富</li></ul></li></ul><h2 id="技能类"><a href="#技能类" class="headerlink" title="技能类"></a>技能类</h2><ul><li>已读</li><li>在读<ul><li>Vue源码</li></ul></li><li>待读<ul><li>领域驱动设计</li></ul></li></ul><h2 id="人文类"><a href="#人文类" class="headerlink" title="人文类"></a>人文类</h2><ul><li>在读<ul><li>天道</li></ul></li><li>待读<ul><li>三体</li><li>人类简史</li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;2023年读书计划&quot;&gt;&lt;a href=&quot;#2023年读书计划&quot; class=&quot;headerlink&quot; title=&quot;2023年读书计划&quot;&gt;&lt;/a&gt;2023年读书计划&lt;/h1&gt;&lt;p&gt;今年给自己的制定的计划，主要读书目标有以下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给自己的创业带来理论帮助&lt;/li&gt;
&lt;li&gt;给自己的职业带来成长&lt;/li&gt;
&lt;li&gt;给自己的更加开阔的视野&lt;/li&gt;
&lt;li&gt;解答一些人生疑惑&lt;/li&gt;
&lt;li&gt;提高自己的做事效率&lt;/li&gt;
&lt;li&gt;提高自己的表达能力或演讲能力&lt;/li&gt;
&lt;li&gt;搭建自己的股市交易系统</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/学习总结/"/>
    
  </entry>
  
  <entry>
    <title>Typescript基础：如何更好的生成Typescript声明文件.d.ts</title>
    <link href="https://www.qborfy.com/today/20230226.html"/>
    <id>https://www.qborfy.com/today/20230226.html</id>
    <published>2023-03-30T10:00:01.000Z</published>
    <updated>2023-03-30T13:13:32.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Typescript已经被前端广泛使用，如果你的项目还没有使用，建议赶紧使用起来，真的会对你的项目有足够的提升：</p><ul><li>让你的每个变量都有变量声明</li><li>让你的每个方法找到其源头</li><li>让你能提前使用一些超前的JavaScript语法，如：注解(装饰器)<code>@controller</code> 等语法糖</li></ul><p>但是使用的过程也会带来一些痛苦，比如你要做一个js lib库，如果用<code>Typescript</code> 开发确实可以帮助其他者快速使用，但是如果你没有注意Typescript的声明文件规范，很容易出现以下使用情况：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会直接从src目录去寻找</span></span><br><span class="line"><span class="keyword">import</span> &#123; IClient &#125; <span class="keyword">from</span> <span class="string">'xxx-lib/src/client.d.ts'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 而我们所期待的使用是</span></span><br><span class="line"><span class="keyword">import</span> &#123; IClient&#125; <span class="keyword">from</span> <span class="string">'xxx-lib'</span></span><br></pre></td></tr></table></figure><p>所以我们需要学习一下，如何更好的生成我们的Typescript声明文件。</p><a id="more"></a><h1 id="Typescript声明文件"><a href="#Typescript声明文件" class="headerlink" title="Typescript声明文件"></a>Typescript声明文件</h1><blockquote><p>声明文件：当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。</p></blockquote><p>从官网定义而言，<code>声明文件.d.ts</code>就是用来给IDE编辑器解析<code>Typescript</code>代码声明的地方。</p><h2 id="学习声明"><a href="#学习声明" class="headerlink" title="学习声明"></a>学习声明</h2><p>目前Typescript提供各种类型，我们常用的有以下几种：</p><ul><li><code>declare var</code> 声明全局变量，如：<code>declare var jQuery: (selector: string) =&gt; any;</code> ，我们就可以在全局中使用<code>jQuery</code> 变量而不会报错</li><li><code>declare function</code> 声明全局方法</li><li><code>declare class</code> 声明全局类</li><li><code>declare enum</code> 声明全局枚举类型</li><li><code>declare namespace</code> 声明（含有子属性的）全局对象</li><li><code>interface</code> 和 <code>type</code> 声明全局类型</li></ul><p>其中，<code>declare</code>基本上都根据<code>Typescript</code> 中会自动生成，而<code>interface</code>和<code>type</code>则需要我们自己声明，自己使用。</p><h2 id="生成声明文件"><a href="#生成声明文件" class="headerlink" title="生成声明文件"></a>生成声明文件</h2><p>当你完成一个lib库开发，这个时候需要对外提供你声明文件，如：<code>import foo from &#39;foo&#39;</code></p><p>如果你需要对自己的<code>npm包</code>制作声明文件，具体有以下几个步骤：</p><ol><li>在<code>package.json</code>中的<code>types</code>和<code>typings</code> ，如：<code>&quot;types&quot;:&quot;dist/typings/index.d.ts&quot;</code></li><li>在项目根目录创建<code>typings</code> ，新建一个<code>index.d.ts</code> 用来暴露你lib库相关的声明</li><li>在<code>typescript.json</code>配置文件中，添加入口，如：<code>&quot;includes&quot;:[&quot;./typings/index.d.ts&quot;]</code></li></ol><p><strong>PS:</strong> <code>types</code>和<code>typings</code> 两者在package.json具有相同意义</p><p><code>package.json</code>示例如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"@node-gptcommit/git-utils"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"关于git的一些工具函数"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"dist/index.js"</span>,</span><br><span class="line">  <span class="attr">"types"</span>: <span class="string">"./dist/typings/index.d.ts"</span>,</span><br><span class="line">  <span class="attr">"typings"</span>: <span class="string">"./dist/typings/index.d.ts"</span>,</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"tsc -p tsconfig.release.json --outDir dist &amp;&amp; cp -r typings dist"</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line"><span class="attr">"@types/node"</span>: <span class="string">"^16"</span>,</span><br><span class="line"><span class="attr">"tslib"</span>: <span class="string">"^2.2.0"</span>,</span><br><span class="line"><span class="attr">"typescript"</span>: <span class="string">"^4.7.2"</span></span><br><span class="line">&#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"simple-git"</span>: <span class="string">"^3.17.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"qborfy"</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"MIT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>typescript.json</code> 示例如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"include"</span>: [</span><br><span class="line">    <span class="string">"src/*"</span>,</span><br><span class="line">    <span class="string">"typings/index.d.ts"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"baseUrl"</span>: <span class="string">"."</span>,</span><br><span class="line">    <span class="attr">"rootDir"</span>: <span class="string">"."</span>,</span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"ES2019"</span>,</span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"ESNext"</span>,</span><br><span class="line">    <span class="attr">"moduleResolution"</span>: <span class="string">"node"</span>,</span><br><span class="line">    <span class="attr">"strict"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"esModuleInterop"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"noImplicitOverride"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"noUnusedLocals"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"useUnknownInCatchVariables"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"declaration"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"declarationDir"</span>: <span class="string">"dist"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"exclude"</span>: [<span class="string">"node_modules"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="index-d-ts实现"><a href="#index-d-ts实现" class="headerlink" title="index.d.ts实现"></a>index.d.ts实现</h2><p>前面基本知道Typescript声明和如何在package.json标注好当前npm包会使用哪个声明文件，那么接下来，我们应该如何一个index.d.ts，主要靠以下几个：</p><ul><li><code>export</code> 导出变量</li><li><code>export namespace</code> 导出（含有子属性的）对象</li><li><code>export default</code> ES6 默认导出</li><li><code>export =</code> commonjs 导出模块</li></ul><p><strong>PS:</strong> 只有只有 <code>function</code>、<code>class</code>和 <code>interface</code> 支持<code>export default</code> </p><p><code>index.d.ts</code>示范：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// index.d.ts</span><br><span class="line">// 将src中的声明文件引入过来</span><br><span class="line">export * from &apos;../src/index&apos;;</span><br><span class="line"></span><br><span class="line">// 导出声明的函数</span><br><span class="line">export declare function bar(): string;</span><br></pre></td></tr></table></figure><p>使用<code>demo.js</code>示范：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//demo.js</span><br><span class="line">// 使用就如下 bar就是一个函数</span><br><span class="line">import &#123; bar &#125; from &apos;libs&apos;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>发布声明文件一般有两种做法：</p><ul><li>一种是发布到<code>@types/xxx</code> ，在<code>types</code>目录下新建一个<code>package.json</code>去维护，不推荐</li><li>另外一种是和<code>npm包</code>一起发布，目前基本上大多数都采用这种，本文也使用采用这种</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html" target="_blank" rel="noopener">《Typescript官网：声明文件》</a></li><li><a href="https://ts.xcatliu.com/basics/declaration-files.html" target="_blank" rel="noopener">《Typescript中文教程》</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;Typescript已经被前端广泛使用，如果你的项目还没有使用，建议赶紧使用起来，真的会对你的项目有足够的提升：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;让你的每个变量都有变量声明&lt;/li&gt;
&lt;li&gt;让你的每个方法找到其源头&lt;/li&gt;
&lt;li&gt;让你能提前使用一些超前的JavaScript语法，如：注解(装饰器)&lt;code&gt;@controller&lt;/code&gt; 等语法糖&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是使用的过程也会带来一些痛苦，比如你要做一个js lib库，如果用&lt;code&gt;Typescript&lt;/code&gt; 开发确实可以帮助其他者快速使用，但是如果你没有注意Typescript的声明文件规范，很容易出现以下使用情况：&lt;/p&gt;
&lt;figure class=&quot;highlight jsx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 会直接从src目录去寻找&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &amp;#123; IClient &amp;#125; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;xxx-lib/src/client.d.ts&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 而我们所期待的使用是&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &amp;#123; IClient&amp;#125; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;xxx-lib&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;所以我们需要学习一下，如何更好的生成我们的Typescript声明文件。&lt;/p&gt;</summary>
    
    
    
    
    <category term="技术分享" scheme="https://www.qborfy.com/tags/技术分享/"/>
    
    <category term="每日更新" scheme="https://www.qborfy.com/tags/每日更新/"/>
    
  </entry>
  
  <entry>
    <title>MonoRepo实战：pnpm+nx搭建MonoRepo项目</title>
    <link href="https://www.qborfy.com/today/20230225.html"/>
    <id>https://www.qborfy.com/today/20230225.html</id>
    <published>2023-03-29T10:00:01.000Z</published>
    <updated>2023-03-29T15:19:14.764Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MonoRepo实战：pnpm-nx搭建MonoRepo项目"><a href="#MonoRepo实战：pnpm-nx搭建MonoRepo项目" class="headerlink" title="MonoRepo实战：pnpm+nx搭建MonoRepo项目"></a>MonoRepo实战：pnpm+nx搭建MonoRepo项目</h1><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前有写过几篇关于monorepo的文章，具体如下：</p><ul><li><a href="https://qborfy.com/today/20230107.html" target="_blank" rel="noopener">从npm版本依赖到Monorepo大仓项目</a></li><li><a href="https://qborfy.com/today/20230119.html" target="_blank" rel="noopener">从lerna到初步了解和使用Nx(一)</a></li><li><a href="https://qborfy.com/today/20230219.html" target="_blank" rel="noopener">从pnpm工具了解整个npm包核心管理原理</a></li></ul><p>再次复习一下<code>MonoRepo</code>的概念：</p><blockquote><p>Monorepo是包含多个不同项目的单一存储库，且不同项目之间具有明确定义的关系。</p></blockquote><p>之前大多数是理论知识，能让我们知道<code>pnpm</code> 和<code>nx</code> 是什么，但是具体要到项目实战就有点懵，不知道从而下手，下面我们就一步步开始搭建<code>pnpm</code>+<code>nx</code>的Monorepo仓库。</p><p>PS：这里将会从已有项目中去开始踩坑，这里用的是之前做一个<a href="https://github.com/qiubohong/node-gptcommit.git" target="_blank" rel="noopener">node-gptcommit</a>命令行工具+一个chrome插件，将两个项目放到一个Monorepo仓库去管理。 </p><a id="more"></a><h1 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h1><h2 id="第一步，项目结构调整"><a href="#第一步，项目结构调整" class="headerlink" title="第一步，项目结构调整"></a>第一步，项目结构调整</h2><p>先来看看原先<code>node-gptcommit</code> 项目结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">node-gptcommit</span><br><span class="line">├── bin</span><br><span class="line">|  └── ngptcommit.js</span><br><span class="line">├── dist</span><br><span class="line">|  ├── ...</span><br><span class="line">├── src</span><br><span class="line">|  ├── ...</span><br><span class="line">├── test</span><br><span class="line">|  ├── ...</span><br><span class="line">├── jest.config.js</span><br><span class="line">├── babel.config.js</span><br><span class="line">├── package.json</span><br><span class="line">├── pnpm-lock.yaml</span><br><span class="line">├── rollup.config.ts</span><br><span class="line">├── tsconfig.json</span><br><span class="line">└── tslint.json</span><br><span class="line">├── README.en.md</span><br><span class="line">├── README.md</span><br></pre></td></tr></table></figure><p>再看一下<code>node-gptcommit-chrome</code>项目的目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">node-gptcommit-chrome</span><br><span class="line">├── dist</span><br><span class="line">|  ├── ...</span><br><span class="line">├── src</span><br><span class="line">|  ├── ...</span><br><span class="line">├── test</span><br><span class="line">|  ├── ...</span><br><span class="line">├── index.html</span><br><span class="line">├── package.json</span><br><span class="line">├── public</span><br><span class="line">├── tsconfig.json</span><br><span class="line">├── tsconfig.node.json</span><br><span class="line">└── vite.config.ts</span><br><span class="line">├── README.md</span><br></pre></td></tr></table></figure><p>接下来我们把项目结构做一下调整，将两个项目的代码挪到<code>packages</code>目录下，同时在新项目中初始化<code>npm init</code> ，大概结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">node-gptcommit</span><br><span class="line">├── apps # 应用层</span><br><span class="line">|  ├── chrome-extension # chrome插件</span><br><span class="line">|  |  ├── ...</span><br><span class="line">|  └── node-cli # 命令行工具</span><br><span class="line">|     ├── ...</span><br><span class="line">├── libs # 封装好的lib库</span><br><span class="line">|  └── summarize # 总结AI客户端 </span><br><span class="line">|     ├── ...</span><br><span class="line">├── README.md</span><br><span class="line">├── package.json</span><br></pre></td></tr></table></figure><h2 id="第二步，项目初始化"><a href="#第二步，项目初始化" class="headerlink" title="第二步，项目初始化"></a>第二步，项目初始化</h2><p>前提条件准备：</p><ul><li>安装全局<code>pnpm</code></li><li>升级node版本到16.19.0+，这里可以通过pnpm去管理node版本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先安装全局pnpm 后续需要根据pnpm + workplace去管理</span></span><br><span class="line">npm install pnpm -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换node版本</span></span><br><span class="line">pnpm env use --global 16</span><br></pre></td></tr></table></figure><h3 id="2-1-创建pnpm-workplace"><a href="#2-1-创建pnpm-workplace" class="headerlink" title="2.1 创建pnpm workplace"></a>2.1 创建pnpm workplace</h3><ol><li>新建<code>pnpm workplace</code>工作空间文件<code>pnpm-workspace.yaml</code> ，具体如下:</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">packages:</span></span><br><span class="line">  <span class="comment"># 会将packages下面归纳给到pnpm工作空间进行管理</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'packages/*'</span></span><br><span class="line"><span class="comment"># 排除下面的目录</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'!**/test/**'</span></span><br></pre></td></tr></table></figure><ol start="2"><li>子项目互相依赖的时候，可以通过<code>workplace:</code> 协议去设置依赖，支持一下几种写法：</li></ol><ul><li><code>“npm_name”: “workplace: *”</code>  所有版本都依赖本地工作空间</li><li><code>“npm_name”: “workplace: npm_name@1.0.0”</code> 指定版本写法</li><li><code>“npm_name”: “workplace: ../npm_name”</code>  相对路径写法</li></ul><p>因此<code>apps</code> 中的应用层加入对公共库<code>libs</code>的依赖，如在<code>apps/node-cli</code> 将</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">"dependencies": &#123;</span><br><span class="line">    "@node-gptcommit/summarize": "workplace: *",</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>子项目中需要对<code>package.json</code> 中的<code>scripts</code> 中做统一管理，如下：</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">"scripts": &#123;</span><br><span class="line">    "build": "xxx", //按照各自的项目填写对应的构建脚本</span><br><span class="line">    "dev": "xxx",</span><br><span class="line">    "test": "xxx"</span><br><span class="line">  &#125;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-引入nx，实现按序打包"><a href="#2-2-引入nx，实现按序打包" class="headerlink" title="2.2 引入nx，实现按序打包"></a>2.2 引入<code>nx</code>，实现按序打包</h3><ol><li>全局安装和在项目根目录下安装 <code>nx</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局安装方便后面调试项目使用</span></span><br><span class="line">pnpm install nx -g</span><br><span class="line"><span class="comment"># 项目nx初始化 注意目录不能已经安装nx或者有nx.json</span></span><br><span class="line">npx nx@latest init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 官网里 npx nx@latest init 一直有问题，回头去定位看看</span></span><br></pre></td></tr></table></figure><p><code>nx</code>在<code>monorepo</code> 架构中里主要解决几个问题：</p><ul><li>解决项目中互相依赖问题，就是构建顺序问题，其任务流有点像管道的概念</li><li>解决项目中打包缓存问题，比如：一些公共包没有多大变动，就不需要再次打包</li><li>提供一些快捷工具快速引入一个子项目或公共包</li></ul><p>还需要转变一个观点：</p><p><strong>重要提示：nx会接手项目的所有打包流程，因此所有相关的命令都由nx进行触发</strong></p><ol start="2"><li>自动生成的 <code>nx.json</code> 解析认知 ，</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">"workspaceLayout": &#123; // 工作空间配置</span><br><span class="line">    "appsDir": "apps", // 应用层文件夹</span><br><span class="line">    "libsDir": "libs" // 公共库文件夹</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">  "targetDefaults": &#123; // 统一的配置项，用于覆盖每个项目中的project.json配置</span><br><span class="line">    "build": &#123; // 统一构建选项</span><br><span class="line">      "dependsOn": ["^build"], // 当构建的时会自动将依赖的其他子项目也进行构建build</span><br><span class="line">      "inputs": ["production", "^production"] // 构建</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "tasksRunnerOptions": &#123; // 任务执行器选项</span><br><span class="line">    "default": &#123; // 默认的任务执行器的选项</span><br><span class="line">      "runner": "nx/tasks-runners/default", // 任务执行器</span><br><span class="line">      "options": &#123;</span><br><span class="line">      "parallel": 5, // 构建并发线程个数</span><br><span class="line">        "cacheableOperations": ["build", "lint", "test"] // 可缓存的操作</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>nx.json</code> 主要用来配置子项目的构建顺序和控制缓存，比如：</p><ul><li>构建顺序：在项目中<code>apps</code>进行<code>build</code>操作时候会依赖<code>libs</code>项目中的<code>build</code> ，就可以在<code>targetDefaults</code>中配置<code>&quot;dependsOn&quot;: [&quot;^build&quot;]</code>，举个例子：<ul><li>当<code>apps</code>的子项目<code>node-cli</code>在运行build操作</li><li>会提前将依赖的<code>libs</code>中的<code>summarize</code>子项目也进行<code>build</code></li></ul></li><li>控制缓存：提高构建速度，利用缓存，但是有时候我们并不需要每个构建命令都去缓存，这个时候就可以用<code>tasksRunnerOptions</code>中的<code>cacheableOperations</code>去控制</li></ul><p><code>nx.json</code> 的其他详细配置可以到官网中查看<a href="https://nx.dev/reference/nx-json" target="_blank" rel="noopener">nx.json</a>。</p><ol start="3"><li>调整根目录<code>package.json</code>中<code>scripts</code>，后续将采用<code>nx</code>去进行分发构建任务： </li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "scripts": &#123;</span><br><span class="line">    "build": "nx run-many --target=build",</span><br><span class="line">    "dev": "nx run-many --target=dev",</span><br><span class="line">    "test": "nx run-many --target=test"</span><br><span class="line">  &#125;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>nx一些命令工具，如使用<code>nx graph</code> 可以看到Monorepo中子项目相互依赖情况，如下图所示：<br><img src="/assets/img/2023-03-29.png" alt="Untitled"><br>更多使用命令，可以到官网查看：<a href="https://nx.dev/reference/commands" target="_blank" rel="noopener">nx命令脚本</a></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到了这里，我们完成Monorepo基本架构的搭建，后续工作就依据不同的业务或代码进行重设计代码结构。</p><p>Monorepo架构有个很明显好处，就当你的项目需要新增一个子项目或者依据现有的功能进行剥离成功公共组件，将会很轻松就实现。比如说，当我的node-gptcommit需要新增一个桌面端，那么我就可以根据现有的libs库快速开发完成。</p><p>在<code>pnpm</code>+<code>nx</code> 搭建Monorepo项目中，我们可以学习到几个点：</p><ul><li>使用<code>pnpm</code> 替代<code>yarn</code>或<code>npm</code> 管理<code>node_modules</code> ，不仅快，而且会比较稳定，因为它不允许代码引入一些未在<code>package.json</code>使用的<code>npm</code>包</li><li>使用<code>pnpm</code> 同时支持一些<code>libs</code> 被其他apps的子应用依赖，如: <code>&quot;@node-gptcommit/git-utils&quot;: &quot;workplace: *”</code></li><li><code>nx</code> 在使用上会需要一些门槛，尤其需要理解其中几个点：<ul><li>第一，子项目互相依赖，<code>nx</code>可以在build构建的时候将另外一个包也同时build构建</li><li>第二，<code>nx</code>会取代掉我们平时在根目录使用<code>yarn build</code>或<code>npm build</code> 的习惯，而是采用<code>nx build</code></li><li>第三，<code>nx</code> 提供一些常用的命令行，如：<code>nx graph</code> 能让我们快速解决Monorepo架构常见的依赖问题</li></ul></li></ul><p>本博文项目Github源码地址： <a href="https://github.com/qiubohong/node-gptcommit" target="_blank" rel="noopener">node-gptcommit</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://nx.dev/recipes/adopting-nx/adding-to-monorepo#installing-nx" target="_blank" rel="noopener">nx官方教程：在yarn/npm/pnpm的workplace项目中添加nx</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;MonoRepo实战：pnpm-nx搭建MonoRepo项目&quot;&gt;&lt;a href=&quot;#MonoRepo实战：pnpm-nx搭建MonoRepo项目&quot; class=&quot;headerlink&quot; title=&quot;MonoRepo实战：pnpm+nx搭建MonoRepo项目&quot;&gt;&lt;/a&gt;MonoRepo实战：pnpm+nx搭建MonoRepo项目&lt;/h1&gt;&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;之前有写过几篇关于monorepo的文章，具体如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://qborfy.com/today/20230107.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;从npm版本依赖到Monorepo大仓项目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://qborfy.com/today/20230119.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;从lerna到初步了解和使用Nx(一)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://qborfy.com/today/20230219.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;从pnpm工具了解整个npm包核心管理原理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再次复习一下&lt;code&gt;MonoRepo&lt;/code&gt;的概念：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Monorepo是包含多个不同项目的单一存储库，且不同项目之间具有明确定义的关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前大多数是理论知识，能让我们知道&lt;code&gt;pnpm&lt;/code&gt; 和&lt;code&gt;nx&lt;/code&gt; 是什么，但是具体要到项目实战就有点懵，不知道从而下手，下面我们就一步步开始搭建&lt;code&gt;pnpm&lt;/code&gt;+&lt;code&gt;nx&lt;/code&gt;的Monorepo仓库。&lt;/p&gt;
&lt;p&gt;PS：这里将会从已有项目中去开始踩坑，这里用的是之前做一个&lt;a href=&quot;https://github.com/qiubohong/node-gptcommit.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;node-gptcommit&lt;/a&gt;命令行工具+一个chrome插件，将两个项目放到一个Monorepo仓库去管理。 &lt;/p&gt;</summary>
    
    
    
    
    <category term="技术分享" scheme="https://www.qborfy.com/tags/技术分享/"/>
    
    <category term="每日更新" scheme="https://www.qborfy.com/tags/每日更新/"/>
    
  </entry>
  
  <entry>
    <title>从开发chrome插件到插件系统设计</title>
    <link href="https://www.qborfy.com/today/20230224.html"/>
    <id>https://www.qborfy.com/today/20230224.html</id>
    <published>2023-03-22T10:00:01.000Z</published>
    <updated>2023-03-22T14:59:05.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近ChatGPT的技术概念很火热，我开发了一个<a href="https://github.com/qiubohong/node-gptcommit" target="_blank" rel="noopener">node-gptcommit</a>开源项目，主要利用GPT用来自动生成git commit的信息。</p><p>但是通过命令行工具来生成preview感觉有点不太友好，因此在想有没有另外一种可能将其变得更加好用，然后想到一个场景：</p><ul><li>在合mr的时候，以及代码review，很多git commit 文件，需要一一个看</li></ul><p>在这个时刻，自动生成commit信息就显得很有用，因此我的方案就是将<code>node-gptcommit</code>做成chrome插件，然后帮助MR的开发者能够快速了解此次MR的所有内容。</p><p>当然仅仅是开发一个chrome插件大家上网随便搜一下就知道怎么开发，因此为了本文更加有干货，需要更加深入的知识，所以本文分为两部分：</p><ul><li>Chrome插件开发，如何快速开发一个插件</li><li>Chrome插件架构设计，了解Chrome插件背后的架构设计，以及前端插件架构体系</li></ul><a id="more"></a><h1 id="Chrome插件开发"><a href="#Chrome插件开发" class="headerlink" title="Chrome插件开发"></a>Chrome插件开发</h1><p>Chrome插件是一种浏览器扩展程序，可以增强浏览器的功能和用户体验。Chrome插件可以添加新的工具栏、菜单、快捷键、热键等，还可以修改网页的行为和外观，以及与网页交互，实现各种功能。常见的Chrome插件包括广告拦截器、翻译插件、下载管理器、音乐播放器等。</p><p>开发Chrome插件其实很简单，因为Chrome的插件主要描述文件<code>mainfest.json</code>，还有包含在里面的一些其他文件，具体如下：</p><ul><li>manifest.json文件，用于指定插件的名称、版本号、描述等信息，以及指定插件的各种权限和资源</li><li>popup.html文件，主要用于显示插件的弹出窗口，提供用户界面和交互功能</li><li>content scripts文件，用于向网页注入JavaScript代码，从而实现与网页的交互。这些脚本可以访问网页的DOM和JavaScript对象，并且可以向网页发送消息和接收来自网页的消息。</li><li>background scripts文件，用于在Chrome插件的后台运行JavaScript代码，可以与popup、contentscript等通讯，可以实现发起网络请求、拦截用户访问请求等操作</li></ul><p>一个标准的Chrome插件目录结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">my-extension/</span><br><span class="line">├── _locales/</span><br><span class="line">│   ├── en/</span><br><span class="line">│   │   └── messages.json</span><br><span class="line">│   └── zh/</span><br><span class="line">│       └── messages.json</span><br><span class="line">├── css/</span><br><span class="line">│   └── popup.css</span><br><span class="line">├── img/</span><br><span class="line">│   ├── icon128.png</span><br><span class="line">│   ├── icon48.png</span><br><span class="line">│   └── icon16.png</span><br><span class="line">├── js/</span><br><span class="line">│   ├── background.js</span><br><span class="line">│   ├── content.js</span><br><span class="line">│   └── popup.js</span><br><span class="line">├── popup.html</span><br><span class="line">├── manifest.json</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure><p>其中，各个文件夹和文件的作用如下：</p><ul><li><code>_locales/</code>：存放插件的本地化文件，用于支持不同语言版本的插件。</li><li><code>css/</code>：存放插件的CSS样式文件。</li><li><code>img/</code>：存放插件的图标文件。</li><li><code>js/</code>：存放插件的JavaScript文件，包括background scripts、content scripts和popup scripts等。</li><li><code>popup.html</code>：插件的popup页面。</li><li><code>manifest.json</code>：插件的配置文件，用于指定插件的名称、版本号、描述等信息，以及指定插件的各种权限和资源。</li><li><code>README.md</code>：插件的说明文档，用于介绍插件的功能和使用方法等。</li></ul><h2 id="manifest-json"><a href="#manifest-json" class="headerlink" title="manifest.json"></a>manifest.json</h2><p>manifest.json是Chrome插件的配置文件，用于指定插件的名称、版本号、描述等信息，以及指定插件的各种权限和资源。</p><p>下面是一个完整的<code>manifest.json</code>文件的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;manifest_version&quot;: 2,</span><br><span class="line">  &quot;name&quot;: &quot;My Chrome Extension&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;This is a description of my Chrome extension.&quot;,</span><br><span class="line">  &quot;icons&quot;: &#123;</span><br><span class="line">    &quot;16&quot;: &quot;icon16.png&quot;,</span><br><span class="line">    &quot;48&quot;: &quot;icon48.png&quot;,</span><br><span class="line">    &quot;128&quot;: &quot;icon128.png&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;background&quot;: &#123;</span><br><span class="line">    &quot;scripts&quot;: [&quot;background.js&quot;]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;content_scripts&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;matches&quot;: [&quot;*://*.example.com/*&quot;],</span><br><span class="line">      &quot;js&quot;: [&quot;content.js&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;permissions&quot;: [</span><br><span class="line">    &quot;tabs&quot;,</span><br><span class="line">    &quot;*://*.example.com/*&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>manifest_version：指定manifest.json文件的版本号，一般为2</li><li>name：指定插件的名称</li><li>version：指定插件的版本号</li><li>description：指定插件的描述</li><li>icons：指定插件的图标，这里16、 48、128指的是需要展示在不同场景插件的图标</li><li>browser_action：可以配置的popup页面和图标</li><li>permissions：插件需要的权限，例如访问浏览器标签页，以及只允许在<code>*://.example.com/</code>域名才有效</li></ul><p>还有两个相对复杂配置项：</p><ul><li>content_scripts: content_scripts指定插件需要向<code>*://.example.com/</code>注入JavaScript代码，代码位于<code>content.js</code>文件中</li><li>background：指定插件的<code>background.js</code>文件为background scripts</li></ul><h2 id="popup-html"><a href="#popup-html" class="headerlink" title="popup.html"></a>popup.html</h2><p>就是一个简单html文件，里面需要插件的UI展示，demo如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>My Chrome Extension<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"popup.css"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"popup.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is my first Chrome extension.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"myButton"</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>popup.html文件可以包含任何HTML、CSS和JavaScript代码，用于构建插件的用户界面和交互功能。在上面的例子中，popup.html文件包含一个标题、一段文本和一个按钮，按钮的点击事件可以在popup.js文件中进行处理。需要注意的是，popup.html文件的UI通常比较简单，因为其主要作用是提供与用户的交互和反馈。</p><p>除了HTML、CSS和JavaScript代码外，popup.html文件还可以包含其他类型的资源文件，例如图片、音频或视频文件等。这些资源文件可以放置在相应的目录下，并在HTML代码中使用相应的路径引用。在实际开发中，可以根据需要对popup.html文件进行扩展和修改，以实现更复杂的用户界面和交互功能。</p><h2 id="content-scripts"><a href="#content-scripts" class="headerlink" title="content_scripts"></a>content_scripts</h2><p><code>content_scripts</code>你可以当成用户页面内的js，Content scripts常用于修改网页的行为和外观，以及与网页交互，实现各种功能。例如，可以通过content scripts实现自动填充表单、隐藏广告、添加自定义菜单等功能。下面是一个简单的content_scripts的例子，使得当用户进入Google搜索页面时，输入框默认输入“Hello World!”：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// manifest.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"My Content Script"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0"</span>,</span><br><span class="line">  <span class="string">"manifest_version"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">"content_scripts"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"matches"</span>: [<span class="string">"&lt;https://www.google.com/*&gt;"</span>],</span><br><span class="line">      <span class="string">"js"</span>: [<span class="string">"content.js"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// content.js</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'input[name="q"]'</span>).value = <span class="string">'Hello World!'</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们在manifest.json文件中指定了一个content_scripts，用于在用户进入<code>https://www.google.com/*</code>网页时自动向Google搜索框中输入<code>“Hello World!”</code>。具体实现的代码在content.js文件中，使用document.querySelector()函数获取到输入框，并将其value属性设置为“Hello World!”。</p><p>需要注意的是，<code>content_scripts</code>只能访问网页的DOM和JavaScript对象，并不能直接访问插件的资源和API。如果插件需要向网页发送消息或从网页接收消息，可以使用<code>chrome.runtime.sendMessage()</code>和<code>chrome.runtime.onMessage()</code>等API实现。</p><h2 id="backgroundjs"><a href="#backgroundjs" class="headerlink" title="backgroundjs"></a>backgroundjs</h2><p><code>backgroundjs</code>是运行在后台的一个js文件，里面可以实现各种监听，如：tab监听、插件初始化、sendmessage、onmessage等事件，下面我们来实现一个简单的发送网络请求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">chrome.runtime.onMessage.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">request, sender, sendResponse</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (request.type === <span class="string">'fetch'</span>) &#123;</span><br><span class="line">    fetch(request.url)</span><br><span class="line">      .then(<span class="function"><span class="params">response</span> =&gt;</span> response.text())</span><br><span class="line">      .then(<span class="function"><span class="params">data</span> =&gt;</span> sendResponse(&#123; <span class="attr">success</span>: <span class="literal">true</span>, data &#125;))</span><br><span class="line">      .catch(<span class="function"><span class="params">error</span> =&gt;</span> sendResponse(&#123; <span class="attr">success</span>: <span class="literal">false</span>, error &#125;));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>常用的监听事件有：</p><ul><li><code>chrome.runtime.onMessage.addListener()</code>, 监听插件传递过来的的消息事件</li><li><code>chrome.runtime.onInstalled.addListener()</code>, 监听插件的安装事件</li><li><code>chrome.runtime.onStartup.addListener()</code>, 监听插件的启动事件</li><li><code>chrome.tabs.onUpdated.addListener()</code>, 监听浏览器标签页更新事件</li></ul><p>当然对应的事件都需要在<code>manifest.json</code>中<code>permissions</code>去配置才能开启。</p><h1 id="Chrome插件设计架构"><a href="#Chrome插件设计架构" class="headerlink" title="Chrome插件设计架构"></a>Chrome插件设计架构</h1><p>既然弄明白了如何开发一个Chrome插件，那么作为一个合格的程序员，我们不仅要知道是什么，还要知道为什么，这才能让你不断地进步。</p><p>我们回头再来思考一下，插件有什么用，以及为什么要有插件？</p><blockquote><p>插件最大的作用就是扩展主应用App的功能，同时支持可插拔特性，就是有没有插件，都不会影响现有主应用功能正常使用。</p></blockquote><p>接下来我们来思考，如何我来开发一个chrome插件系统，我应该如何设计呢？下面是简易Chrome插件系统的架构图：</p><div class="mxgraph-container">    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/chrome-extends.drawio&quot;}"></div></div><p>有了上面的架构，我们可以大概知道实现一个插件系统需要几个功能点：</p><ul><li>插件管理，需要有插件上传、加载、版本机制等功能</li><li>暴露能力，需要确定暴露哪些API能力，同时还需要展示插件的UI</li><li>隔离环境，需要确保插件的隔离性，不影响主应用的运行，这里就需要我们去用iframe的模式去执行</li></ul><h2 id="插件系统设计"><a href="#插件系统设计" class="headerlink" title="插件系统设计"></a>插件系统设计</h2><p>有了对chrome的插件架构有一定了解后，如果这个时候需要我们需要对某个平台去实现一个插件系统，我们应当如何入手以及设计？</p><p>在做插件系统之前，我们需要再明确一下插件的定义：</p><blockquote><p>插件是平台核心功能的一种扩展，是在平台生命周期流程中的不同节点去扩展或调整功能</p></blockquote><p>接下来，我们按照几个步骤去实现插件：</p><h3 id="插件系统的定位"><a href="#插件系统的定位" class="headerlink" title="插件系统的定位"></a>插件系统的定位</h3><p>我们的插件肯定依附于某个平台或应用上的，因此我们需要先对平台能力做一个定位，就以Chrome为例子，chrome浏览器作为展示网页为核心功能。</p><p>那么如果去设计一个插件系统，肯定是围绕着网页展示的扩展功能去做插件系统设计。</p><h3 id="插件系统的基础能力"><a href="#插件系统的基础能力" class="headerlink" title="插件系统的基础能力"></a>插件系统的基础能力</h3><p>插件系统的基础能力包括以下几点：</p><ul><li>插件管理，需要插件管理界面，面对开发者：，提供上传、版本管理等功能，面对使用者：需要提供安装、查询、删除等功能</li><li>插件开发，需要给开发者提供工具、文档、规范、发布流程等方便的信息</li></ul><h3 id="插件系统架构设计"><a href="#插件系统架构设计" class="headerlink" title="插件系统架构设计"></a>插件系统架构设计</h3><p>针对不同平台，可能需要插件架构是不一样的，如：Chrome，采用的并行机制，不同插件可以在同一时间加载、输出。</p><p>前端领域很多有插件实现架构，按照执行顺序可以大概分为如下几种：</p><table><thead><tr><th align="left">插件架构</th><th align="left">描述</th><th align="left">适⽤场景</th><th align="left">框架或应用</th></tr></thead><tbody><tr><td align="left">顺序执行</td><td align="left">显然就是从头执行到尾，不断对内容做修改</td><td align="left">⼤多数场景</td><td align="left">babel plugin</td></tr><tr><td align="left">瀑布流</td><td align="left">上一层输出就是下一层输入，这里就是管道概念</td><td align="left">管道</td><td align="left">Gulp</td></tr><tr><td align="left">洋葱</td><td align="left">不仅关注输入，而且关心输出，还可以随时直接输出</td><td align="left">进出</td><td align="left">Koa</td></tr><tr><td align="left">并发执⾏</td><td align="left">多个输入，对多个插件输出做一个总结输出</td><td align="left">⽆序任务</td><td align="left">webpack complier</td></tr></tbody></table><p><strong><em>(这里参考自<a href="https://www.zaozao.run/video/c61/c61-4" target="_blank" rel="noopener">前端早早聊 2023年前端插件设计专场 【洋葱：插件化设计在前端领域的应用】</a>)</em></strong></p><p>同时，从架构上还需要考虑以下几点：</p><ul><li>插件接口，指的是哪些平台哪些接口Hook，允许插件访问或改变</li><li>插件管理器，指的平台如何管理插件，包括更新、审核、插件的文件模式等。</li><li>插件加载器，指的平台如何加载插件，是在加载过程需要如何塞入暴露能力等。</li><li>插件生命周期，指的是一个插件有哪些生命周期节点，如：安装、加载、运行、卸载、禁用等</li></ul><h3 id="插件系统的安全和稳定性"><a href="#插件系统的安全和稳定性" class="headerlink" title="插件系统的安全和稳定性"></a>插件系统的安全和稳定性</h3><p>我们不仅要考虑插件功能实现，还需要考虑插件的安全和稳定性，主要从以下几方面入手：</p><ul><li>插件的安全验证，指的是如何限制非法插件的使用</li><li>插件的权限控制，指的是如何限制插件的权限</li><li>插件的资源隔离，指的是如何确保插件其运行环境不可以访问平台其他非暴露资源</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过本文，我们不仅学会了Chrome插件的开发，还对插件系统的设计有一定的认知，我们回顾一下：</p><ul><li>Chrome插件开发，主要组成部分为：manifest.json，popup.html，content_scripts和background.js</li><li>插件系统设计，主要考虑的点：管理、开发工具和文档、暴露能力、安全与稳定</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://chrome.google.com/webstore/category/extensions?hl=zh-CN" target="_blank" rel="noopener">Chrome应用商店</a></li><li><a href="https://developer.chrome.com/docs/extensions/mv3/getstarted/" target="_blank" rel="noopener">Chrome插件开发文档</a></li><li><a href="https://www.zaozao.run/video/c61" target="_blank" rel="noopener">前端早早聊 2023年前端插件专场</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近ChatGPT的技术概念很火热，我开发了一个&lt;a href=&quot;https://github.com/qiubohong/node-gptcommit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;node-gptcommit&lt;/a&gt;开源项目，主要利用GPT用来自动生成git commit的信息。&lt;/p&gt;
&lt;p&gt;但是通过命令行工具来生成preview感觉有点不太友好，因此在想有没有另外一种可能将其变得更加好用，然后想到一个场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在合mr的时候，以及代码review，很多git commit 文件，需要一一个看&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这个时刻，自动生成commit信息就显得很有用，因此我的方案就是将&lt;code&gt;node-gptcommit&lt;/code&gt;做成chrome插件，然后帮助MR的开发者能够快速了解此次MR的所有内容。&lt;/p&gt;
&lt;p&gt;当然仅仅是开发一个chrome插件大家上网随便搜一下就知道怎么开发，因此为了本文更加有干货，需要更加深入的知识，所以本文分为两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Chrome插件开发，如何快速开发一个插件&lt;/li&gt;
&lt;li&gt;Chrome插件架构设计，了解Chrome插件背后的架构设计，以及前端插件架构体系&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="技术分享" scheme="https://www.qborfy.com/tags/技术分享/"/>
    
    <category term="每日更新" scheme="https://www.qborfy.com/tags/每日更新/"/>
    
  </entry>
  
  <entry>
    <title>不要再使用轮询了，请用SSE服务端推送完成页面实时更新</title>
    <link href="https://www.qborfy.com/today/20230223.html"/>
    <id>https://www.qborfy.com/today/20230223.html</id>
    <published>2023-03-17T10:00:01.000Z</published>
    <updated>2023-03-17T12:38:05.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近开发一个页面碰到一个需求，需要对部分数据需要实时更新状态，面对这样子的场景，我们通常有以下几个方案：</p><ul><li>轮询，利用setTimeout定时轮询</li><li>WebSocket，利用长链接保持与服务通讯</li><li>SSE，服务端推送机制</li></ul><a id="more"></a><h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>我们先简单认识一下这三者的区别：</p><h2 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h2><p>轮询就是利用setTimeout的定时器，定时向服务器发起请求，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timeout = <span class="number">0</span>;</span><br><span class="line">functon rollRequest(requestFunc, times, immediately)&#123;</span><br><span class="line">    <span class="keyword">if</span>(timeout !== <span class="number">0</span>)&#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(immediately)&#123;</span><br><span class="line">        requestFunc &amp;&amp; requestFunc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        requestFunc &amp;&amp; requestFunc();</span><br><span class="line">        rollRequest(requestFunc, times, <span class="literal">false</span>);</span><br><span class="line">    &#125;, times);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>无用请求过多，可能每次请求返回的内容都是相同</li><li>实时性不可控，如果内容更新了，但是页面无法及时更新</li></ul><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>针对上面轮询的缺点，WebSokcet长链接就能很好解决，如：</p><ul><li>建立链接后，当服务器发现数据发生变化后才返回</li><li>可控性高，客户端和服务端都可以互相通信</li></ul><p>具体实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">`wss://127.0.0.1:8081`</span>);</span><br><span class="line"></span><br><span class="line">ws.send(<span class="string">"这是一条消息："</span> + count);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听消息</span></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line">ws.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="keyword">var</span> WebSocketServer = <span class="built_in">require</span>(<span class="string">'ws'</span>).Server,</span><br><span class="line">wss = <span class="keyword">new</span> WebSocketServer(&#123; <span class="attr">port</span>: <span class="number">8181</span> &#125;);</span><br><span class="line">wss.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ws</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'client connected'</span>);</span><br><span class="line">    ws.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(message);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>可能实现方案对于一个页面数据更新有点太重了，主要包括以下几点：</p><ul><li>需要有完整链路认证，如：鉴权、登录等</li><li>心跳机制实现，前后端都需要设置</li><li>前后端需要规定数据返回规范</li><li>服务端需要日志记录</li></ul><h2 id="SSE服务端推送"><a href="#SSE服务端推送" class="headerlink" title="SSE服务端推送"></a>SSE服务端推送</h2><p>SSE全称Server-sent Events，是HTML 5 规范的一个组成部分，它主要由两部分组成：</p><ul><li>第一部分是服务端和浏览器的通讯协议</li><li>第二部分是前端需要利用<code>EventSource</code>去监听返回数据</li></ul><p>对比WebSocket：</p><table><thead><tr><th>SSE</th><th>WebSocket</th></tr></thead><tbody><tr><td>单向：仅服务端能发送消息</td><td>双向：客户端、服务端双向发送</td></tr><tr><td>仅文本数据</td><td>二进制、文本都可</td></tr><tr><td>常规HTTP协议</td><td>WebSocket协议</td></tr></tbody></table><p>实现一个SSE代码如下：<br><strong>浏览器：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>SSE Demo测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>SSE返回内容<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> eventSource = <span class="keyword">new</span> EventSource(<span class="string">'http://localhost:3000/sse'</span>);</span></span><br><span class="line"><span class="javascript">        eventSource.onmessage = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>).innerHTML = <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>).innerHTML + <span class="string">`&lt;p&gt;<span class="subst">$&#123;event.data&#125;</span>&lt;/p&gt;`</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>服务端：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a server</span></span><br><span class="line"><span class="keyword">const</span> server = http.createServer()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听路由</span></span><br><span class="line">server.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'request'</span>, req.url)</span><br><span class="line">    <span class="keyword">if</span> (req.url === <span class="string">'/sse'</span>) &#123;</span><br><span class="line">        <span class="comment">// Set CORS headers</span></span><br><span class="line">        res.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>)</span><br><span class="line">        res.setHeader(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'GET, OPTIONS'</span>)</span><br><span class="line">        res.setHeader(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Content-Type'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set SSE headers</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/event-stream'</span>)</span><br><span class="line">        res.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'no-cache'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Send a ping approx every 2 seconds</span></span><br><span class="line">        res.write(<span class="string">"retry: 10000\n\n"</span>);</span><br><span class="line">        res.write(<span class="string">"event: connecttime\n\n"</span>);</span><br><span class="line">        res.write(<span class="string">"data: 第一次发送:"</span> + (<span class="keyword">new</span> <span class="built_in">Date</span>()) + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟收到消息推送给客户端</span></span><br><span class="line">        interval = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            res.write(<span class="string">"data: 后续更新"</span> + (<span class="keyword">new</span> <span class="built_in">Date</span>()) + <span class="string">"\n\n"</span>);</span><br><span class="line">        &#125;, <span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (req.url === <span class="string">'/index.html'</span> || req.url === <span class="string">'/'</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果是html文件，返回html文件</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>)</span><br><span class="line">        <span class="keyword">const</span> html = fs.readFileSync(<span class="string">'./public/index.html'</span>);</span><br><span class="line">        res.end(html)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listen</span></span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Server started on port 3000'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul><li><p>兼容性问题，但是目前绝大部分浏览器是支持的，如果不支持可以采用降级方案——轮询</p></li><li><p>会长期占用一个http链接，</p><ul><li>可能会导致浏览器(chrome最大http请求数是6)无法发起其他请求，这里注意是一个坑，需要设置一个超时时间，如果长时间无返回数据更新可以关闭链接</li><li>解决方案，升级到http2协议可解决http请求数限制问题，放到后面《如何搭建http2网站》讲解</li></ul></li><li><p>客户端无法主动向服务器发起请求，可能造成后续问题定位难点</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>前端实时更新需求，有多个解决方案，下面进行总结：</p></li><li><p>目前最常用的轮询，是最稳定的，但是却无法做到实时</p></li><li><p>WebSocket可以实时，但是需要服务端和客服端长期保持一致，如果哪一方断了将无法继续</p></li><li><p>SSE是服务推送，可以满足大部分场景，但是也需要谨慎使用，避免占用过多链接导致其他无法发送请求</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://mp.weixin.qq.com/s/K8g2PNO4Ixc1LrUafXunPQ" target="_blank" rel="noopener">数据不够实时：试试长连接？</a></p></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近开发一个页面碰到一个需求，需要对部分数据需要实时更新状态，面对这样子的场景，我们通常有以下几个方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;轮询，利用setTimeout定时轮询&lt;/li&gt;
&lt;li&gt;WebSocket，利用长链接保持与服务通讯&lt;/li&gt;
&lt;li&gt;SSE，服务端推送机制&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="技术分享" scheme="https://www.qborfy.com/tags/技术分享/"/>
    
    <category term="每日更新" scheme="https://www.qborfy.com/tags/每日更新/"/>
    
  </entry>
  
  <entry>
    <title>Node冷门知识点—— node.js支持import语法</title>
    <link href="https://www.qborfy.com/share/nodejs-module.html"/>
    <id>https://www.qborfy.com/share/nodejs-module.html</id>
    <published>2023-03-16T11:21:01.000Z</published>
    <updated>2023-03-16T13:16:55.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="js模块化"><a href="#js模块化" class="headerlink" title="js模块化"></a>js模块化</h1><p>前端主流模块化规范，目前有以下几种：</p><ul><li>CommonJS， Node.js提出的规范</li><li>ECMAScript Module，ESM，由ECMAScript组织提出的JavaScript标准规范</li><li>已淘汰的有：CMD、AMD等，再就综合体UMD（支持各种规范的集合体）</li></ul><p>因此，主流有两种规范<code>CommonJS</code>和<code>ESM</code>两种规范，但是由于Node.js不支持<code>ESM</code>规范，导致很多时候我们的项目里面并存两种规范的代码，从而出现下面这种情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在node端执行构建的时候</span></span><br><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">'loadsh'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在浏览器端实现的时候</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'loadsh'</span>;</span><br></pre></td></tr></table></figure><p>这样子开发就很容易出现痛点，往往我们的解决方案就是通过各种构建工具去解决，如：<code>webpack</code> <code>vite</code>，尤其是我们在写项目中写node.js编译脚本，经常需要切换。</p><p>但是从Node.js V14+版本后，它开始支持ESM规范啦，你可以直接在Node.js中使用<code>import</code> <code>export</code>等语法了，终于等到这一天😭。</p><a id="more"></a><p>PS: 其实早在Node.js V8.5版本就已经加入该特性了，只不过一直需要通过全局变量<code>–experimental-modules</code>去开启这一特性，由于不稳定性大多数项目都没有开启，不过自从16+后，我们就可以大胆放心在项目中使用了，不过一些古老的项目建议暂时不用开启。</p><h1 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h1><p>我们先从官网上去看相关使用说明：</p><blockquote><p> Node.js 有两个模块规范：<code>CommonJS</code>模块规范 和 <code>ECMAScript</code>模块规范<br>开发者可以通过 <code>.mjs</code> 文件扩展名、<code>package.json</code>中设置<code>type=module</code>或<code>node xxx.js --input-type</code> 标志告诉 Node.js 使用 <code>ECMAScript</code>规范去执行代码。 如果没这些设置，Node.js 将使用 <code>CommonJS</code> 去执行。<a href="https://nodejs.org/docs/latest-v16.x/api/esm.html" target="_blank" rel="noopener">Node.js Modules: ECMAScript modules</a></p></blockquote><p>通过上述我们就可以知道几个使用方式：</p><ol><li>将文件后缀改为<code>.mjs</code>，node.js加载的时候自动会用<code>ESM</code>规范</li><li>在项目中<code>package.json</code>新增配置项<code>&quot;type&quot;:&quot;module&quot;</code>，那么整个项目中的.js文件都会按照<code>ESM</code>规范去执行</li><li>增加执行参数<code>--input-type</code>也可以实现相同效果</li></ol><h2 id="各种使用方式"><a href="#各种使用方式" class="headerlink" title="各种使用方式"></a>各种使用方式</h2><ol><li>常规方式：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; readFile &#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Demo <span class="keyword">from</span> <span class="string">'./Demo.mjs'</span>; <span class="comment">// 绝对路径或相对路径都可以</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> readFile;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> readFile;</span><br></pre></td></tr></table></figure><ol start="2"><li>带参数的使用：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于参数不同， 这个会让`foo.mjs`被加载两次，而不会利用缓存中的`foo.mjs`</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./foo.mjs?query=1'</span>; <span class="comment">// loads ./foo.mjs with query of "?query=1"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./foo.mjs?query=2'</span>; <span class="comment">// loads ./foo.mjs with query of "?query=2"</span></span><br></pre></td></tr></table></figure><ol start="3"><li>支持<code>data:</code>格式URL的形式</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'data:text/javascript,console.log("hello!");'</span>; <span class="comment">// text/javascript 会将后面的内容当成js模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; test &#125; <span class="keyword">from</span> <span class="string">'data:text/javascript,function test()&#123;console.log("test")&#125;;export &#123;test&#125;;'</span>; <span class="comment">// 这里我们是不是扩宽思路，直接加载在线js呢？</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'data:application/json,"world!"'</span> assert &#123; <span class="attr">type</span>: <span class="string">'json'</span> &#125;; <span class="comment">// application/json 则是json</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// application/wasm for Wasm</span></span><br></pre></td></tr></table></figure><ol start="4"><li>assert断言(实验特性)<br>将文件强制加载为某种格式内容，如：<code>json</code> <code>javascript</code> <code>webassembly</code>等</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fooData <span class="keyword">from</span> <span class="string">'./foo.json'</span> assert &#123; <span class="attr">type</span>: <span class="string">'json'</span> &#125;;</span><br></pre></td></tr></table></figure><ol start="5"><li>加载commonjs规范模块</li></ol><p>当然肯定也支持加载commonjs规范的模块，用法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> cjs &#125; <span class="keyword">from</span> <span class="string">'cjs'</span>; <span class="comment">// module.exports 导出</span></span><br><span class="line"><span class="keyword">import</span> cjsSugar <span class="keyword">from</span> <span class="string">'cjs'</span>; <span class="comment">// module.exports</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">'cjs'</span>;</span><br></pre></td></tr></table></figure><ol start="6"><li><p>import() 异步导入<br>这种用法就很正常，不需要实时加载，等到需要用的时候再加载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">default</span>: barData &#125; =</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'./bar.json'</span>, &#123; <span class="attr">assert</span>: &#123; <span class="attr">type</span>: <span class="string">'json'</span> &#125; &#125;);</span><br></pre></td></tr></table></figure></li><li><p>支持从http/https引入(实验特性)</p></li></ol><p>目前属于实验特性，有限制，比如：</p><ul><li>不支持http2/3协议</li><li>http协议只能用于127.0.0.1等本地ip地址</li><li>Cookie、Authorization等信息不会携带发送</li><li>只会加载执行远端的js文件，而不会加载远端中依赖其他文件</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> worker_threads <span class="keyword">from</span> <span class="string">'node:worker_threads'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; configure, resize &#125; <span class="keyword">from</span> <span class="string">'https://example.com/imagelib.mjs'</span>;</span><br><span class="line">configure(&#123; worker_threads &#125;);</span><br></pre></td></tr></table></figure><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>唯一的限制：当开启ESM规范后，你只允许填写<code>import</code>或<code>export</code>，不允许使用<code>require</code>或<code>module.exports</code>，会报一下错误:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const a  = require('a')</span><br><span class="line">           ^</span><br><span class="line">ReferenceError: require is not defined in ES module scope, you can use import instead</span><br><span class="line">    at file:///Users/borfyqiu/Desktop/study/github/qiubohong.github.io/code/demo-rollup/test.mjs:4:12</span><br><span class="line">    at ModuleJob.run (node:internal/modules/esm/module_job:193:25)</span><br><span class="line">    at async Promise.all (index 0)</span><br><span class="line">    at async ESMLoader.import (node:internal/modules/esm/loader:530:24)</span><br><span class="line">    at async loadESM (node:internal/process/esm_loader:91:5)</span><br><span class="line">    at async handleMainPromise (node:internal/modules/run_main:65:12)</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实这个也不算是冷门知识，只要稍微对Node.js有做持续关注，基本上都可以了解到该特性。</p><p>但是作为不关注的人，很容易就陷入自己的知识误区，会一直认为Node.js不支持ESM规范，甚至会吐槽Node.js为什么不支持呢？</p><p>所以这里有一句话需要提醒自己—— 【书山无路勤为径，学海无涯苦作舟】。</p><blockquote><p>做一个有温度的技术分享作家 —— qborfy</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://nodejs.org/docs/latest-v16.x/api/esm.html" target="_blank" rel="noopener">Node ESM官方说明文档</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;js模块化&quot;&gt;&lt;a href=&quot;#js模块化&quot; class=&quot;headerlink&quot; title=&quot;js模块化&quot;&gt;&lt;/a&gt;js模块化&lt;/h1&gt;&lt;p&gt;前端主流模块化规范，目前有以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CommonJS， Node.js提出的规范&lt;/li&gt;
&lt;li&gt;ECMAScript Module，ESM，由ECMAScript组织提出的JavaScript标准规范&lt;/li&gt;
&lt;li&gt;已淘汰的有：CMD、AMD等，再就综合体UMD（支持各种规范的集合体）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，主流有两种规范&lt;code&gt;CommonJS&lt;/code&gt;和&lt;code&gt;ESM&lt;/code&gt;两种规范，但是由于Node.js不支持&lt;code&gt;ESM&lt;/code&gt;规范，导致很多时候我们的项目里面并存两种规范的代码，从而出现下面这种情况：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 在node端执行构建的时候&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; _ = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;loadsh&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 在浏览器端实现的时候&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; _ &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;loadsh&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这样子开发就很容易出现痛点，往往我们的解决方案就是通过各种构建工具去解决，如：&lt;code&gt;webpack&lt;/code&gt; &lt;code&gt;vite&lt;/code&gt;，尤其是我们在写项目中写node.js编译脚本，经常需要切换。&lt;/p&gt;
&lt;p&gt;但是从Node.js V14+版本后，它开始支持ESM规范啦，你可以直接在Node.js中使用&lt;code&gt;import&lt;/code&gt; &lt;code&gt;export&lt;/code&gt;等语法了，终于等到这一天😭。&lt;/p&gt;</summary>
    
    
    
    
    <category term="技术分享" scheme="https://www.qborfy.com/tags/技术分享/"/>
    
  </entry>
  
  <entry>
    <title>《百万富翁快车道》，我们应该如何快速转到一百万呢？</title>
    <link href="https://www.qborfy.com/study/book-million.html"/>
    <id>https://www.qborfy.com/study/book-million.html</id>
    <published>2023-03-14T14:00:00.000Z</published>
    <updated>2023-04-11T07:46:36.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="百万富翁快车道"><a href="#百万富翁快车道" class="headerlink" title="百万富翁快车道"></a>百万富翁快车道</h1><p>讲述的作者从失业游民到百万富翁的经历的一些过程，可以帮人开阔一些思维模式，从人行道、慢车道、快车道的方式去讲述一个人如何转到一百万。</p><p>如果想要快速赚到一百万，这里没有教你实际的方案，但是告诉你一些思维模式，所以我这边简单通过思维导图去进行汇总。</p><a id="more"></a><h1 id="阅读摘要"><a href="#阅读摘要" class="headerlink" title="阅读摘要"></a>阅读摘要</h1><ul><li>百万富翁快车道<ul><li>第1篇 轮椅上的财富<ul><li>主流思想<ul><li>是通过定投基金去获取年收益或者打工赚钱升工资，存钱获得一百万</li><li>缺点：等到你老了，你才会富有</li></ul></li><li>第一章 伟大的欺骗<ul><li>平凡不是什么值得向往的事情，应该远离它。—— 朱迪.福斯特</li><li>缓慢致富是一场失败的游戏</li><li>重新定义退休，将年轻包括在内</li><li>真正的黄金岁月是你的青春、充满活力的岁月</li><li>个人总结：<ul><li>认识到目前通过工资赚钱存钱是一条缓慢的道路</li><li>疑问: 是否有其他道路可以实现快速致富呢？</li></ul></li></ul></li><li>第二章 怎么逆转缓慢致富<ul><li>人生的目的不是在芸芸众生中苟且偷生，而是要在疯狂中寻找自我。 —— 马可·奥勒留</li><li>觉醒的瞬间：看到一个年轻人开着昂贵的跑车，心想要嘛是富二代，要嘛是贷款买的，直到去咨询他是做什么工作的，但是他给我的答案告诉我，“我是一个发明家”</li><li>问自己的问题：如果不受任何约束，我会住在这个国家的何地？</li><li>用劳动时间换金钱，如果不劳动就没有金钱</li><li>快车道，寻找一条没有人认识到的路，去开发</li><li>假的“捷径”——卖掉这条路，换取一笔钱，然后用这笔钱去消费，这条捷径问题就是你只能拿到一笔钱，然后快速花完</li><li>真正的快车道——能持续赚钱，赚钱的速度会越来越快（赚钱速度是成指数型的），而且会让你工作时间越来越短</li><li>什么时候换道路——当你已经赚够了，或者不再需要这条路的时候</li><li>记住：变化可能发生在一瞬间</li></ul></li></ul></li><li>第2篇 财富不只是一条路，而是一场旅行<ul><li>第三章 旅行在财富之路上<ul><li>千里之行，始于足下 —— 老子</li><li>追足财富如同旅行，如果只专注于目的地，而忘记整个旅行过程所需要的东西和所看到的东西，你可能因为各种原因而而无法到达目的地，或者到了目的地却怀疑自己为什么要来这里？</li><li>要注重整个全局，而不是注重某些特定的方面，所以要进快车道，你需要对自己有一个完整的认知，以及这条道路可能涉及到方方面面</li><li>“财富是一个过程，而不是结果。” 如何理解这句话，书中拿烹饪作为例子，制作好吃的一道菜，重要的是过程，比如火候、配料多少、材料等等，财富就是制作的过程，而不是那道好吃的菜。正比如财富不是钱，而是赚钱的过程。“过程才是通往财富的路途，目的地作为结果虽光芒闪耀，但实现它全靠过程。”</li><li>财富之路实现的公式：<ul><li>路线图，目前有哪些道路可以到达财富</li><li>交通工具，就是自己，需要成为什么样的自己</li><li>财富道路，选择什么样的路，这条路可能很难走但是很快</li><li>速度，等于执行力，就是将想法付诸实践</li></ul></li><li>道路基本上都是收费，其实就是需要你承担风险和付出代价，比如创业踩坑，导致某些地方失败</li><li>关键是路要靠自己走，不能外包给其他人</li></ul></li><li>第四章 财富路线图<ul><li>如果你不知道去哪里，任何一条路都是你的选择 —— 刘易斯·卡罗尔</li><li>你目前的生活情况，是你现有的财富路线图的结果，因为这是你的信念导致，比如：你认为定投基金能给带你财富，那么你的行为就会反应这种信念</li><li>信念是推动行动的强大机制，所以我们要培养自己一些良好的信念系统，就是每个人选择走的路线和关键思维方式(=思维路标)</li><li>3个财务路线图：<ul><li>人行道，目的地=贫穷，</li><li>慢车道，目的地=平庸，</li><li>快车道，目的地=财富，</li></ul></li><li>财务路线图，主要由关键思维模式形成，也就是思维路标：<ul><li>对债务的看法，控制债务，还是债务控制你</li><li>对时间的看法，时间的重要性，你能自由控制时间吗</li><li>对教育的看法，教育在生活中有什么作用，你觉得还需要继续教育吗？</li><li>对金钱的看法，金钱在生活中有什么作用，是玩具还是工具，是不缺少还是缺少</li><li>对财富的看法，如何定义财富？是金钱、资产还是自由可控制的时间？</li><li>主要收入来源，收入来源是什么？工资，还是房租，还是创业的利润？</li><li>主要财富增长，如何增加财富？是升职，还是增加第二份收入?</li><li>财富公式，你的积累财富的公式是什么？是工资收入+投资理财收入？还是创业利润增加+固定理财收益？</li><li>责任与控制，生活和财富受你控制吗？</li><li>对人生的看法，你计划过人生吗？有未来十年甚至二十年的计划吗？为了理想会放弃现在的享受吗？</li></ul></li><li>升级路线，升级现有的信念系统，才能更好升级现有的生活</li></ul></li></ul></li><li>第3篇 贫穷：人行道路线图<ul><li>第五章 人行道：最多人走的路线<ul><li>当你是第一个信念有别于他人的人，你通常会说：“我是对的，其他的人是错的”。这种处境令人非常不愉快，这种想法在令人振奋的同时也会招致攻击。 —— 拉里·埃里森</li><li>走人行道的人的信念：享受当下，不考虑明天的安危，更加具体的思维路标如下：<ul><li>债务的看法：现在就要，哪怕是通过刷信用卡、贷款等</li><li>时间的看法：觉得时间不重要，上班多久无所谓，下班后就刷手机</li><li>教育的看法：毕业后就完成所有的学习，后面就不需要再继续学习了</li><li>金钱的看法：享受当下，金钱是生不带来死不带去，有一分钱花一分钱</li><li>收入的来源：追逐金钱，哪里钱多去哪里，没有未来计划</li><li>财富的增长：不知道什么是净资产？也不明白财富增长的意义是什么</li><li>财富的意义：没什么意义？只是死后的一堆玩具</li><li>财富的公式：财富=收入+债务</li><li>人生的目的：为今天而活，不为明天烦恼</li><li>责任与控制：全都是别人的错误，埋怨人生，埋怨社会，无任何责任心</li><li>生命的感悟：人生苦短，不去理会未来的事情，总期待中彩票发大财</li></ul></li><li>人行道的特征：大量贷款，消费享乐主义，透支未来，无任何存款，埋怨社会，期待运气</li><li>人行道的引力：正在拉你入贫穷深渊，让财务脱离控制，如：失业让你顿时没法维持生活，因为你净资产为0</li><li>如何脱离人行道？<ul><li>真正意识到你在人行道上，非常简单的判断：你不工作后，你剩余的钱能够支撑你一年的正常开销，比如：我个人一年正常开销需要20万</li><li>需要明白金钱解决不了金钱的问题，举个例子：你现在的美好生活绝大部分是依赖于贷款，如：买车、买衣服，你以为能靠工资收入达到收支平衡，但是一旦失业，你就无法维持现有的平衡，这就是人行道的所需要面临问题，因此你需要通过改变生活的方式让自己脱离人行道</li><li>人行道的“富人”，他们有很高的收入，但是他们的开销一样很大，因为他们坚信能够永远有持续的高收入，但是一旦经济危机爆发，他们将和贫穷的人一样没有任何抵抗力</li><li>想要脱离人行道唯一的途径，就是进行财务管理，提高财务自律，也就是提高自己对财务的控制力，怎么做？<ul><li>不透支未来的财富，如：刷信用卡、花呗等</li><li>控制消费欲望，拥有自己的消费观，如：衣服很好看，但是请确保自己使用它的场景有哪些？数码产品很新颖，但是请确保买它的意义是什么？</li><li>管理账单，不需要详细记录每天的消费，但是需要对大额消费有一定记录，比如：超过200元的消费记录</li><li>如果有大额贷款（&gt;1万），需要更加详细管理他们，包括：还款日期、利息，制定归还计划等</li></ul></li></ul></li></ul></li><li>第六章 你的财富中毒了吗<ul><li>财富是充分体验生活的能力。—— 亨利·戴维·梭罗<ul><li>理解的意思是说真正的财富是你拥有足够的时间去体验完整的生活，而不是指的单纯的物质，如：车、钱等</li></ul></li><li>社会对财富的定义：财富是由物质财产构成的，这是一个错误的观念</li><li>财富有三个部分组成(FFF):<ul><li>家庭或人际关系(Family Or Friend)，是与人构建紧密的关系，说的通俗一点，就是你的人脉</li><li>健康(Fitness)，是指的身体健康，拥有活力的身体和心态，身心健康才是你根本上的财富</li><li>自由(Freedom)，是指的从时间上、空间上的你用自由支配的权限，你拥有多少可以自由控制的时间你就拥有多少财富，用俗语说：一寸光阴一寸金，寸金难买寸光阴</li></ul></li><li>很富有的假象：<ul><li>拥有入门级的豪华轿车，出入一些高级餐厅</li><li>但是你却住在一个破烂的公寓，每天都得工作10几个小时</li></ul></li><li>虚假的财富是如何破坏真正的财富<ul><li>你购买很多物质这类虚假的财富，你以为自己很富有，但是其实你却需要每天工作10几个小时的时间去偿还这些债务，这破坏你的自由，也破坏了你的关系，同时还破坏了你的健康，让你距离真正的财富越来越远</li></ul></li></ul></li><li>第七章 你滥用金钱，金钱就会报复你<ul><li>金钱买不到幸福，但是当你痛苦的时候，它会让你感到非常的舒服。 —— 克莱尔·布思·卢斯<ul><li>这句话用很简单的语言就可以表达，钱不是万能的，但是没钱是万万不能</li></ul></li><li>金钱与幸福的关系，需要有一个平衡点，而这个平衡点可以FFF财富规则去进行执行</li><li>现代版的奴隶：<ul><li>社会定义的正常生活标准：8点起床上班，18点下班，周一到周五是工作日，周末是休息</li><li>而恰恰这个“正常”就是一个现代版奴隶的生活标准</li></ul></li><li>不要乱花钱，要正确的使用金钱，那么金钱就能给带来幸福，比如：<ul><li>金钱能买到自由去看着你的孩子长大</li><li>金钱能买到自由让你无拘无束</li><li>金钱是财富公式和自由的卫士，强有力地守护着财富的孪生兄弟——健康和社会关系</li></ul></li><li>不要乱花钱的就是不要陷入消费陷阱中，购买一些不需要的东西，如：豪华轿车、名贵手表和衣服等</li><li>人行道的恶性循环：工作收入&gt;偿还债务&gt;透支消费&gt;被迫工作</li><li>思考能不能负担起=负担不起，因为你这是在一个美好未来的假设去做透支，如：<ul><li>如果我涨薪了</li><li>如果我抵押贷款没有做调整</li><li>如果我的股票上涨了10%</li></ul></li><li>买的起不等于用得起，比如：买了一辆豪华轿车，你需要加油、保养、保险等开销，同时你还需要有时间可以出去旅游</li><li>如何逃离消费主义的诱惑呢？—— 财富与健康，两者都需要将生活方式从短期思维（即时享乐）转向长期思维（延迟享乐），这是唯一能够阻断生活方式被奴役的篱笆。</li><li>重复一次，从短期思维（即时享乐）转向长期思维（延迟享乐），做长期规划，并且长期坚持下去，获得成就感大于及时享乐</li><li>社会中充满了各种诱饵（及时享乐），一旦你吃了这个诱饵，你就会被鱼钩钓上从而难以脱身，鱼钩就是需要被债务缠身，被工作奴役</li></ul></li><li>第八章 幸运儿的游戏<ul><li>我相信运气，并且相信付出更多的努力，就会有更多的运气。 —— 托马斯·杰斐逊<ul><li>这句话的意思，是想告诉我们运气很重要，但是要获得运气你需要做很多努力的准备工作，否则即使运气来了，你也无法承担。</li></ul></li><li>“有钱人运气好”这种信念，是走人行道的信念，是一种消极的观念，可以不断打击的你意志<ul><li>虽然真的有人可以运气好中彩票或者遇到一只股票大涨，但是这不是可持续的财富收入源</li></ul></li><li>要想获得运气，就要更好地经营过程，因为只有过程才蕴含着机会。<ul><li>我们往往忽略过程，更加在意结果，运气是在努力的过程才会出现的，如果你不努力，运气是不会从你身边经过的</li></ul></li><li>如何脱离人行道呢? 这里有3个关键点<ul><li>赚钱不是靠运气，运气是需要你不断努力获取的一种结果</li><li>赚钱最重要的不是结果，而是赚钱的过程，你需要不断优化赚钱的思路或者模式</li><li>不要相信别人能给你带来赚钱的机会，因为赚钱思维需要靠自己去探索和思考，否则凭实力赚来的钱，会凭实力搞没有掉</li></ul></li><li>第九章 致富需要承担责任<ul><li>伟大的代价就是责任。 —— 温斯顿·丘吉尔<ul><li>这句话的意思，如果你要成为一个伟大的人，那么你所需要付出的代价就是你的责任心</li><li>通俗点讲，要想成功，你必须负责</li></ul></li><li>人行道的人的观念，相信别人，但是事情一旦出现意外就责怪别人，除了依靠运气和注重结果两个原因外，责怪他人是停留在人行道上的第三个原因</li><li>受害者法则：只要不放弃控制权，没有人能让你成为受害者。<ul><li>简单理解的话，当你把金钱交给基金经理，那么你很有可能成为承担损失的受害者</li><li>成为受害者的第一要素，就是逃避和放弃，不愿意争取主导权，将选择权放在其他人身上</li></ul></li><li>从不拿房地产作为致富工具，因为这里具备太多不可控的因素</li><li>致富需要先承担责任，然后才是问责<ul><li>承担责任，是你犯错后，需要承担错误的结果，如果还继续犯错，则表示你没有承担该责任</li><li>问责，是从犯错的过程吸取教训，调整行为</li></ul></li><li>什么是责任？分成两个步骤：<ul><li>责任在于，我的钱包被偷了，这是我的过错</li><li>问责则是，以后我会采取预防措施，确保它不会再次发生</li></ul></li><li>当你对自己开始问责的时候，就是你开始能自主控制自己生活的时候</li></ul></li></ul></li></ul></li><li>第4篇 平庸：慢车道路线<ul><li>第十章 你一直被谎言误导：慢车道<ul><li>一个普通人每周辛苦工作50小时，50年后被迫退休，然后被送进养老院，希望在病痛缠身之前有尊严地死去，这不算疯狂吗？ —— 史蒂夫·布西密<ul><li>普通人认为正确的选择，是辛苦工作，获得薪资，维持温饱，然后持续这样子生活直到退休</li><li>希望老年时光是没有任何病痛</li><li>这个观念如同希望这个世界一层不变那么疯狂</li></ul></li><li>慢车道的观点：牺牲今天的幸福，把希望寄托在未来</li><li>慢车道最大劣势<ul><li>需要等你老了，你才能买得起你想要的东西，如：豪车、旅游、自由</li><li>60岁的百万富翁远远比不上25岁的百万富翁</li></ul></li><li>转变思维：在年轻的时候就获得财富，趁你拥有健康、活力、能量的时候纵情享受</li><li>慢车道无法承担经济风险：<ul><li>失去工作，将无法继续人生计划，因为你没有其他收入来源</li><li>股票下跌，你的资产将缩水</li><li>房地产下跌，你的房子将无法给带来任何收益</li></ul></li><li>慢车道的思维路标：<ul><li>对债务的看法：避免一切债务</li><li>对时间的看法：工作时间越久，赚的钱越多</li><li>对教育的看法：教育很重要，因为能帮助获取更高的薪资</li><li>对金钱的看法：金钱很重要，要省着点花，还尽可能存钱</li><li>主要收入来源：工资</li><li>主要财富增长：投资收入，依赖时间去投入，如：定投基金、房地产的升值空间</li><li>对财富的看法：重复工作获取收入，加上投资，期待能早点退休</li><li>财富的公式：  = 工作+市场投资</li><li>对人生的目的：希望能在晚年享受舒适的退休生活</li><li>责任与控制：  责任是养家糊口，但是工作却依赖公司，希望经济环境良好</li><li>对人生的意义：放弃梦想和理想，不冒任何风险，只期待公司和经济环境能变得更好一点</li></ul></li><li>一个故事揭露上班一族的最大缺陷：你会为了一份工资，而忘记你本来是为了更好的生活而赚这份工资的<ul><li>故事讲得是一个著名小提琴家在地铁站用几百万的小提琴去演奏，而上班的人完全不会停下脚步来欣赏</li><li>现实就是：你为了赚钱，必须周一到周五全身心的投入工作，而忘了除了工作之外，还有很多美好的事物</li></ul></li><li>慢车道最大的痛点就是：时间不等人<ul><li>当你有了小孩，你为了赚钱无法陪小孩，而小孩是不会因为你赚钱而停止长大，所以你将会丢失掉大部分陪小孩子长大的时间，如：她第一次学会叫人、第一次学脚踏车等</li><li>而你需要等到周末才有时间去陪她，甚至有可能因为其他原因，周末也没时间陪</li></ul></li><li>生活会从各方面来展示对平庸的慢车道生活的谴责：<ul><li>需要过各种节俭的生活来存钱</li><li>没有自己自由的时间</li><li>变得越来越平庸，从而导致生活越来越痛苦</li><li>一场意外就会让生活失去控制</li></ul></li></ul></li><li>第十一章 不平等的交易：你的工作<ul><li>每天一心一意的工作8小时，你可能最终会成为老板，然后每天工作12小时。罗伯特·弗罗斯特<ul><li>这句话不要为了工作而工作，8小时，12小时，你用尽所有的时间都在工作上，你还能拥有其他东西吗？</li></ul></li><li>工作，就是将你驯服成，将工作当成常态，会让你受到控制，并且平衡你的心态</li><li>你的财务计划不应该以工作为中心，6个现象将表明你是否处于慢车道中：<ul><li>打工在吞噬你的时间，而且通过打工你将需要几十年的时间才能转到一百万</li><li>经验受限，你打工所获取的经验永远只能用在当前这份工作上，你只是公司机器上一个螺丝钉</li><li>无法控制，随时都有可能失去工作的可能性，而且打工只能维持你目前的生活水平</li><li>办公室政治，除了完成工作外，你需要面对各种人情世故，为的就是那份很少工资的工作</li><li>高额税收，你的工资要上缴社保、公积金、税收等，最后才轮到你</li><li>收入独裁，你的工资不是你说了算，没有一个老板愿意主动给员工加薪，哪怕加也只是10%，即使你跳槽也会因为当前的工资而收到限制涨幅</li></ul></li><li>所以打工是永远不可能致富的，只能维持你的日常生活，不能让你的生活上一个档次</li></ul></li><li>第十二章 慢车道为什么无法致富<ul><li>应该有人告诉我们，在我们的生命的开始，便已经走向死亡。我们可以将生命过得极致，充分利用生命中每一天每一分钟。就这样子做！无论你要做什么，现在就做！明天是有限的。 —— 米歇尔·兰顿<ul><li>这句话就是告诉我们，从我们生下来那天，我们的生命就已经在倒计时了，你必须享受当下的每一分每一秒，过你自己想要的生活，而不是为了打工而勉强自己。</li></ul></li><li>慢车道是无法致富的，因为你的财富增长公式=你的收入+投资收益，套入数学公式中，这两个变量完全没在你的控制范围内，那么你怎么做都无法提高你的财富</li><li>每天工作8个小时，只能50年后才能拥有100万，想一想是不是有点无法接受</li><li>你无法控制你的薪水，因为你无法控制你的雇主，你的公司，因为公司天生为了压榨劳动力，公司的本质就是为了控制你，利用你的低廉价值去创造更高的价值</li><li>慢车道中的“复利”其实就是利用时间制造一种假象，让你以为你的钱可以赚钱，但是这种赚钱的速度很慢，甚至比不上通胀的速度<ul><li>一万元能买一栋房子，利息5%，利用复利公式，到了50年后，你可以拿到300万，但是你已经70多岁，请问你拿这笔钱怎么办？</li><li>第二个问题就是如何保证每年都有5%的收益呢</li></ul></li><li>基金定投无法让你致富的原因：<ul><li>因为它无法控制收益，无法稳定收益，也无法快速收益</li><li>另外一个原因就是它很可能亏损</li></ul></li><li>任何窃取时间和无力带来时间自由的东西都是负债<ul><li>打工是在窃取你的时间，但是却无法带来给你足够的时间自由</li><li>基金定投也是一样，以时间为借口，牺牲足够多的时间，才能换来未来可能会收益的老年自由</li></ul></li><li>慢车道会削弱你的控制力，会让你将希望寄托在别人，如：你希望老板可以多涨薪，你希望股市能够上涨等</li></ul></li><li>第十三章 徒劳的抗争：教育<ul><li>妨碍我学习的唯一障碍就是我接受的教育。 —— 阿尔伯特·爱因斯坦<ul><li>从这句话可以看出，其实是当前我们接受的教育是让他不要学习超出范围内的知识，从而限制学习</li></ul></li><li>打工人唯一可以拿出来抗争的就是教育，就是学历，如：我们从本科、硕士、博士，对应的工资是不一样<ul><li>所以，我们打工就不断学习和接受教育，从而去获得更多的工资</li></ul></li><li>慢车道的观点：提升内在价值（就是我们能给公司带来什么价值），就能创造财富<ul><li>但是却忽略一点，教育所需要的时间以及金钱，比如助学贷款等，需要你后面花费大量时间去偿还</li></ul></li><li>教育的缺陷：如果你选择接受的教育是某个特定技能，你只能学习到这些，即使你的技能特别高升，但是没有公司愿意要，那么你所受的教育压根就无法创造财富<ul><li>举个例子，比如二十年前，大家都愿意去选土木专业，因为那个时候国家正在大兴基建，需要大量人才，但是现在土木出来只能去工地搬砖</li></ul></li><li>正如最近的例子，大部分大学生找不到工作，不愿意去做清洁、美甲、理发、工厂等工作，反而被讽刺为脱不下孔乙己的长袍，这就是你浪费了大量的时间在教育，而教育却无法给任何回报</li></ul></li><li>第十四章 大师们的虚伪<ul><li>以前都说笨人难聚财，现在每个人都这样子。 —— 阿德莱·史蒂文森<ul><li>这里想表达的是，你不愿意相信自己能赚钱，反而期待别人可以带你赚钱，目前社会中大部分的人都是这样子。</li></ul></li><li>实践悖论，大部分提供意见的人，自己本身都做不到，反而去指导别人</li><li>他们的说法就是，只照我说的做，别学我怎么做<ul><li>基金理财的骗局，就是这样子，让你们把钱交给他们，同时还收取你们的管理费，最终还有可能亏损，请问定投基金的你们是傻子吗？</li></ul></li><li>当你们遇到基金亏损的时候，基金经理给你的建议就只有希望经济不要再衰退，希望经济能反弹，这一切与他们没有任何关系</li><li>指引你走上慢车道的大师们，需要你相信慢车道，因为他们靠你发财</li></ul></li><li>第十五章 慢车道的胜利，一场关于希望的赌博<ul><li>我宁愿活在失败的后悔中，也不想后悔从未尝试过。 —— MJ·德马科<ul><li>这句话表达了，勇于尝试，而不是拘泥于现有的一切，等到老了才来后悔当初为什么没那么做。</li></ul></li><li>慢车道最危险的赌注，就是将你的时间赌上，然后消耗时间去等待一个可能的希望</li><li>慢车道的7个风险：<ul><li>健康风险，假如你在65岁成为了百万富翁，那个时候你是否是健康的，有精力去享受你想享受的？</li><li>工作风险，慢车道成功的前提条件是你接下来几十年里都拥有高薪，不会面临裁员、公司破产以及经济下滑等风险</li><li>房屋风险，希望房屋可能一直上涨</li><li>公司风险，没有几家公司能一直保持上涨的趋势，而将财富寄托在一家公司上，很有可能导致竹篮打水一场空</li><li>生活方式风险，慢车道的生活标准就不享受任何东西，希望你存足够的钱等到你退休</li><li>经济风险，希望你能每年保持8%的利润增长，相信买入并持有，但是在经济下滑大环境下压根不可能</li><li>人行道风险，慢车道的人很容易陷入人行道，因为当你的生活和工作不受控制，那么你会希望控制某些东西，从而陷入消费主义中</li></ul></li><li>慢车道，是一场漫长且充满不可控风险的赛道，它会慢慢吞噬掉你的时间、自由、健康、和人际关系等<ul><li>它让你慢慢变得平庸，因为你赚的钱就是平庸的</li><li>它是不可控的，因为它所依赖的变量：工资和投资，都不在你可控制的范围</li></ul></li><li>个人净收入=个人收入-个人支出，慢车道的缺点，在于它不要求你提高个人收入，而是希望你不断压缩个人支出达到净收入的增长，这显然是不符合人性的，而且也没法真正达到净收入得到增长<ul><li>真正的收入增长在于，你个人收入在快速增长，同时你控制个人正常支出，从而实现个人净收入达到增长</li></ul></li><li>战胜慢车道的“秘密出口”<ul><li>成为明星，提高名气或者影响力，能让你的工资成指数型上涨</li><li>加班到成为管理层，拥有公司期权，让你一夜暴富</li><li>熬时间，终于成为中产阶级</li></ul></li><li>慢车道和快车道百万富翁的区别<ul><li>慢车道需要30年或者更长时间才能累积100万，而快车道只需10年或者更少时间</li><li>慢车道住的房子是小区套房，而快车道则住豪宅</li><li>慢车道拥有MBA等各种学位，而快车道则是请MBA的工人</li><li>慢车道让市场控制他们的资产，如股票等，而快车道则可以自主控制自己的资产，且有能力提高自己的资产能力，如：公司的利润等</li><li>慢车道为了时间而工作，而快车道让时间为他们工作</li><li>慢车道是员工，快车道是老板</li><li>慢车道是买保险，快车道是提供保险的人</li><li>慢车道是利用基金和股票致富，而快车道则是利用股票保持他们的钱</li><li>慢车道让别人控制他们的财富，而快车道控制别人的财富</li><li>慢车道看重钱，快车道看重时间</li><li>慢车道将房产视为自己的资产，快车道将房子看为住处</li></ul></li></ul></li></ul></li><li>第5篇 财富：快车道路线图<ul><li>第十六章 财富的快捷：快车道<ul><li>如果知道得越多，你就会做的越好。 —— 吉米·罗恩<ul><li>这句话表达的意思是，你知道的知识越多，那么你离成功就越近，也就越能做成事。</li></ul></li><li>快车道是什么？（总算到正文了）<ul><li>快车道是一种商业和生活方式的策略，将工作和生活可以无限平衡，从而创造最佳的环境去实现快速致富和非凡的生活</li><li>按我理解，快车道是一种选择方式，当你在工作和生活做选择的时候，需要平衡两者，而快车道就是能无限平衡这两者的选择</li></ul></li><li>快车道的几个特征<ul><li>可控制的平衡，工作和生活的控制权都在你手上，你可以掌握他们而达到无限平衡的可能</li><li>业务上，你是管理者，你敬业，就好像你给老板打工一样，你需要拼命去工作，因为这是为了你自己</li><li>生活方式，你需要融合信念、过程和行动，就是知行合一，不可以再像打工那样子摸鱼</li><li>快速制造财富，能让你快速创建更多的财富</li></ul></li><li>投入创业，是快车道的一种方式，也是一种生活方式，前期需要全身心投入，然后进入高速路，快速抵达财富目的地，最终实现自由</li><li>快车道的思维路标：<ul><li>对债务的看法：对我建立的系统或发展系统有用的债务，是可以接受的</li><li>对时间的看法：时间是我最重要的资产，比金钱还重要</li><li>对教育的看法：停止学习就等于停止成长，就等于和财富说拜拜</li><li>对金钱的看法：金钱很重要，无处不在，但是它代表的是我所创造东西的价值仅此而已</li><li>主要收入来源：通过生意运转和投资得来</li><li>主要财富增长：创业获得价值资产（资产是可以不断赚钱的），然后利用现有的资产去不断增值</li><li>对财富的看法：建立现金流和资产评估的业务系统</li><li>财富的公式：  财富=净利润+资产价值</li><li>财富的策略：  付出越多，在时间、金钱和个人成就上就得到越多</li><li>人生目的地：  获得被动收入，即通过创业，也通过投资</li><li>责任与控制：  生活将是我自己控制的，财务计划也是我的责任，应该视情况而做出不同选择</li><li>人生的看法：  无论梦想如何与众不同，但是有钱会让梦想成真</li></ul></li><li>快车道，是财富的工业革命，就是从人类发展史而言，工业革命让人类快速发展，而快车道对于个人就是一场工业革命，能让你快速致富</li><li>快车道，是一个商业系统，而慢车道是一个工作<ul><li>通俗点，快车道是你的事业，而慢车道则是一份工作</li></ul></li></ul></li><li>第十七章 转换团队和剧本<ul><li>一个人只关心自己的人，只能做出很小的成就。 —— 本杰明·富兰克林<ul><li>这句话表达的是，一个人的力量终究有限，你需要结合团队的力量才能完成一个人不可能完成的事业</li></ul></li><li>快车道的核心思维：成为生产者，如：不要去买产品，而是成为生产产品的，不要去抵押贷款，而是成为能提供贷款的人等</li><li>生产者的思维：<ul><li>当你在看广告的时候，应该思考的是这个广告是如何宣传产品，以及诱惑消费者的</li><li>如果要提供这个商品会需要什么样子的流程？</li><li>这个公司盈利吗？盈利模式是什么？</li></ul></li><li>生产的模式：创新思维、利用系统处理业务<ul><li>远见的视野和创新的思维，怎么做到呢？你需要更多的知识领域，去提高你的知识边界</li><li>核心是生意，而不是工作，实现的是自我雇佣</li><li>形成一套商业系统=时间*金钱，随着时间的不断增加，你的资产会不断增加</li></ul></li></ul></li><li>第十八章 富人发财的真相<ul><li>只有那些甘愿冒险不断前行的人，才清楚自己能走多远。 —— 托马斯·艾略特<ul><li>这句话表达的是，愿意探索自己未知领域的人，并且不停的往前走，才能走得更远，离成功也就越来越近。</li></ul></li><li>要弄清楚如何致富或者发大财？大部分人的答案是：中彩票、成为明星、富二代等，但这些就仅仅只是想想而已的答案。</li><li>真正弄明白发财的真相，需要转变思维，将赚钱=工资+投资，转变成为：赚钱=净利润+资产价值<ul><li>净利润=销售数量*利润率，这个就比较简单理解了</li><li>资产价值=净利润*行业乘数，那么如何理解行业乘数呢？<ul><li>行业乘数，其实就是股票里的市盈率、市净率等公式表达，就是当前你公司的估值公式因子</li></ul></li></ul></li><li>最重要一点就是，净利润是可以由我们自己去控制的，我们通过各种方式去控制净利润的增长，而不是像工资完全不是我们所能控制的，因为老板是不会允许员工的工资上涨过快<ul><li>比如网站，我们可以提供访问量和转化率，从而实现净利润的增长</li></ul></li><li>财富的双刃剑，净收入和净利润的矛盾点，需要注意点是，不能一昧的追求净利润，要注重提高净收入后才去考虑净利润的提升</li><li>财富的变现，需要合适的时机，将你的资产变成现金流，这个是财富的最终目的地</li></ul></li><li>第十九章 破解财富和时间的联姻<ul><li>时间是你生命中的一枚硬币。这是你唯一的一枚硬币，只有你确定它如何花出去，你要注意不要让别人替你花掉它。 —— 卡尔·桑德堡<ul><li>这句话表达的是，你生命最重要的财产是你的时间，也是你生下来就唯一拥有的财产，你可以学会怎么花时间，以及要确保不要被其他人忽悠去花费大量时间做无意义的事情。</li></ul></li><li>真正的财富计划，是让你能够从时间中脱离出来，不是用时间换财富，而是当你不需要花时间在上面的时候，它依然能够源源不断在帮你制造财富，这就是工业化的财富，也可以叫被动收入计划。</li><li>摇钱树计划，你需要去种一下一颗能随时给你生成金钱果实的树，不管你此时此刻在做什么，它都依然在茂盛的成长。</li><li>摇钱树幼苗计划有哪些，具体以下作为参考:<ul><li>租赁系统，除了房子出租，还有其他租赁行业，如：音乐小说版权、汽车、专利发明、漫画等也是租赁的一种形式展示</li><li>计算机或软件系统，可以是一个网站，也可以是一个软件或者app，某些高质量的东西上架到强大的分销系统（应用商店）</li><li>内容系统，=信息系统，可以整合信息，也可以是写作，作曲等，结合互联网的分销系统去实现</li><li>分销系统，是一种将产品转移到消费者的系统，比如：星巴克、iphone中应用商店等</li><li>人力资源系统，雇佣更多的人产生更多的利润，但是也需注意可能产生更多的支出代价，如：亚马逊<ul><li>亚马逊为什么会是人力资源系统呢？</li><li>它是一个计算机系统支撑并有人力资源系统运营的分销系统，因为虽然做的是电商网站，其实管理的是开电商的人</li></ul></li></ul></li></ul></li><li>第二十章 招募你的自由战士<ul><li>摇钱树计划，最重要的种子，就是金钱，金钱本身就是摇钱树的种子</li><li>如果你要种一个摇钱树，你需要金钱这个种子<ul><li>通俗的讲，就是需要启动资金，需要去存储赚取人生的第一桶金</li><li>没有这个基础，所有的摇钱树计划都是浮空的，没有空手套白狼的做法</li></ul></li><li>如何积累你的人生第一桶金呢？<ul><li>改变你的消费观念，每花去的一笔钱，都有其意义所在</li><li>尽可能快的存储你的钱</li><li>同时要想尽一切办法，让钱生钱，哪怕是小钱</li></ul></li><li>复利，不是做定投基金，而是要把钱尽量投入到固定收益的地方，实现真正可以看得到的复利</li></ul></li><li>第二十一章 真正的财富定律——影响力<ul><li>与其努力成功，不如努力成为有价值的人。 —— 阿尔伯特·爱因斯坦<ul><li>表达的是，成功这个定义太广泛了，没有具体实际含义，而价值却能具体化，当你对他人有价值，那么其实你就是成功的。</li></ul></li><li>吸引力定律，就是一个虚假的神秘理论<ul><li>什么是吸引力定律，就是说当你想要成功，不断的想，那么成功就会靠近你</li></ul></li><li>真正成功的定律是影响力，而不是吸引力<ul><li>当你能影响百万人的时候，你就可以赚到一百万</li></ul></li><li>财富公式：净利润=销售单位（规模）+单位利润（等级）</li><li>规模造就百万富翁，等级也造就百万富翁。规模和等级相结合就会造就亿万富翁。</li><li>如果你不知道如何提高影响力，那么朝影响力大的人靠近，自然而然就会有影响力。</li><li>扩大规模，提高等级，这是快车道的精神核心，你越有办法做大数字，就越容易获得财富。<ul><li>这种模式，不仅仅适用于做生意，适用各方各面，包括工作上，当你做的事情影响范围越大，那么你的工作价值也就越高</li></ul></li></ul></li></ul></li><li>第6篇 获取财富的工具：自己<ul><li>第二十二章 首先管好你自己<ul><li>有果必有因，他们早就在春天就播下了种子。 —— 亨利·戴维·梭罗<ul><li>这句话表达的是，当某个结果发生在你身上，其实是你当初做的选择导致的，所以如果我们想要某种结果，需要我们在早期就做出选择=种下种子</li></ul></li><li>优先付钱给自己的理论是正确的，但是如果仅靠工资收入来做，等于要求残疾的人去爬楼梯一样不可能</li><li>因为你的工资是先给政府过一道，再到老板那边过一道，最终才轮到你，如果你还有房贷、车贷、信用卡等，可能压根就不会轮到你</li><li>做到优先付钱给自己，你需要先拥有自己，你需要拥有一家公司，可以自由控制你的时间和财务</li><li>如何做到拥有自己：<ul><li>创建一家有限责任公司，而不是个体户无限责任</li><li>选择一个实体，怎么选择，可以从下面几个点去考虑：<ul><li>业务退出策略是？上市？还是卖给私人投资者？</li><li>资产增长策略是什么?</li><li>最坏情况下，你的责任风险是什么?</li><li>现在就筹备资金，还是等到将来？</li><li>打算雇佣员工吗？</li><li>计划招募合作伙伴吗？</li><li>打算快速赚钱，还是等会再说？</li></ul></li></ul></li></ul></li><li>第二十三章 生活的方向盘——需要自己掌控<ul><li>如果你的生活结果是由你的选择造成的，不管你是有意识还是无意识的。如果你能控制选择的过程，你就能控制你的生活中的方方面面。你会发现自由其实就是来自掌控你自己。 —— 罗伯特·班尼特<ul><li>表达的是，目前的生活都是我们自己选择，有些是被动，有些是主动，如果你能将一些被动的选择转化为主动，就能控制你自己的生活，那么你就自由了。</li><li>当然第二层意思是，你要学会思考某些选择造成后果，每天都需要回顾一下今天的选择是导致后面哪些选择可以更加主动或者被动</li></ul></li><li>贫穷的主要原因，其实是来源于你错误的选择，比如：你花了很多钱买了一些不必要的东西导致贷款累累，你将时间花在无所谓的事情上，而不是去提升自己等</li><li>问题的核心，每次遇到问题，我们都需要抱着解决问题的态度去弄清楚此次问题的核心是什么？举几个例子<ul><li>由于暴饮暴食，胆固醇提高，处理问题：去医院开处方药，解决问题：不暴饮暴食</li><li>旅行中汽车漏油导致油不够，处理问题：去加油站加油，解决问题：修复漏油的地方</li></ul></li><li>快速致富不是一次偶然的选择可以成就，而是数百万次的选择而促成的，而贫穷也是一样的。</li><li>如果你不够快乐，那么你需要考虑重新选择。</li><li>没有人愿意选择贫穷，那么为什么会变得贫穷，是因为不断做出错误的选择，慢慢的陷入贫穷的泥潭中。</li><li>人生的方向盘，是你在手上，你要学会控制，而要理性的去选择方向，叛逆或者错误的选择很容易，但是也很容易让你陷入深渊。</li><li>今天的选择会影响终身，所以更加多思考人生的选择</li><li>哪怕是你在日常生活中所做的最小的选择，都会不断地改变你的生活习惯和生活方式。</li><li>无论哪个年龄段，你都要审视一下生活，分析一下你生活有哪些岔路，你选择哪条道，都会影响之后的生活。</li><li>随着时间的推移，能量会逐渐消退，因为那些旧的选择依然让你深陷泥潭难以自拔</li></ul></li><li>第二十四章 将你的挡风玻璃擦拭干净<ul><li>在我们看清楚自己之前，不能想当然地贸然行事。 —— 夏洛特·吉尔曼<ul><li>表达的是，如果我们连自己的想法都没有弄清楚，一头脑就往里冲，往往失败的就是最后的结果。</li></ul></li><li>什么东西会影响我们的选择：<ul><li>认知选择（思维模式），认知是指的你相信某个想法，可能会按照这种思维模式去做选择</li><li>行动选择（选择阅读），行动是指的你的执行力，虽然你相信某个选择，但是可能行动上缺乏导致无法执行</li></ul></li><li>认知选择是行动选择的动力，而是行动选择是认知选择的一种结果，先要培养认知选择，才能更好的行动选择</li><li>如何提高自己的认知选择或者擦拭我们的挡风玻璃(认知边界)：<ul><li>用肯定式的语言去确定我们的选择，如：<ul><li>将“从不”和“不能”的词汇从语言里剔除，</li><li>”我能“ ”这是有可能的“  ”我会超越“ ”我将“等肯定式语言填充自己的生活中</li></ul></li></ul></li><li>如何做更好的选择，可以参考的技巧如下：<ul><li>更坏情况分析，WCCA<ul><li>WCCA能帮你远离哪些错误（导致严重的后果）的选择</li></ul></li><li>加权平均决策矩阵，WADM<ul><li>WADM能帮你做出更好的选择</li></ul></li></ul></li><li>更坏情况分析WCCA，换个容易记名字，叫事前三思，怎么做：<ul><li>做出选择前，确定三个问题：<ul><li>选择最坏的后果是什么</li><li>后果的概率是多少</li><li>是可以承担的风险吗？</li></ul></li><li>基本上做一件事，在脑子快速过一遍，就可以避免一些错误的选择</li></ul></li><li>加权平均决策矩阵WADM，换个名字，叫分数判断，怎么做：<ul><li>确定使用的场景，是人生比较重要的场景，如：上哪个大学，报考哪个专业，是否辞职跳槽，是否创业等等</li><li>需要用笔+纸做详细记录</li><li>步骤一，罗列出所有的选择，如：上哪所大学</li><li>步骤二，做出这些选择的考虑的决定因素，如：大学里的食堂、住宿、师资、费用、地点等</li><li>步骤三，给这些决定性因素对做出选择影响权重有多少，可以设置1-10，如：食堂2，住宿5等</li><li>步骤四，给每个选择里的因素打分（1-10分），如：广州大学的食堂5分，暨南大学的食堂6分等</li><li>步骤五，将因素打分<em>权重得出分数，如：广州大学的食堂2</em>5=10，暨南大学的食堂得分是2*6=12等</li><li>步骤六，计算每个选择的得分，得出更好的选择，如：广州大学118分，暨南大学218（更好的选择）</li><li>在这个过程，最重要的是你要如实的给各个因素赋予权重和评分，否则这个判断就不准确</li></ul></li><li>世界不会记得你的过去，只有你自己记得和在乎你的过去，所以需要将注意力从过去（不管是荣耀还是失败）离开，转移到当下</li><li>不是忘记过去，而是要从过去吸取教训，主要从下面几点思考失败：<ul><li>从中学习到什么</li><li>将来我能改变什么</li><li>应该忘记什么</li></ul></li><li>如果你的过去定义了你的存在，那么你就不可能成为你未来要成为的人。</li></ul></li><li>第二十五章 排除阻碍你的绊脚石<ul><li>奚落是庸才对天才的颂歌。 —— 奥斯卡·王尔德<ul><li>表达的是，被人嘲笑是成功路上的最大障碍，但是我们面对这种嘲笑，因为这是对我们行为最大的肯定</li></ul></li><li>生活中的例子，幼儿园问谁会唱歌，大多数人都举手了，而中学里问谁会唱歌，大多数都没有举手，因为幼儿园没有人告诉他们不能，而中学大部分人都有人告诉他们不能</li><li>你追求的东西越非凡，那么越需要挣脱平凡的束缚就越大，如：奥维尔·莱特（Orville Wright）和威尔伯·莱特（Wilbur Wright）发明飞机时候受到的束缚，怎么可能飞行</li><li>你将会遇到一个阻碍和绊脚石：<ul><li>朋友和家人，因为他们不愿意相信有这么一条路可以快速致富</li><li>售卖慢车道的教育机构</li><li>认命的父母</li><li>房子是最好的投资的信念</li><li>定投基金的信念</li></ul></li><li>要避开那些不赋予你目标的绊脚石：<ul><li>觉得有些东西行不通，已经有人在做了</li><li>为什么要自寻烦恼</li></ul></li><li>逃离不利的环境：<ul><li>环境因素，包括：天气、文化等</li><li>你的工作，如果你正在做一项你十分讨厌，且浪费时间的工作</li><li>避免逆风行走，如果有，则逃离它</li></ul></li><li>制造顺风或加速的环境<ul><li>甄别当前的阻碍来自哪里因素，是否可以忽略、逃离等</li><li>靠近向往快车道或者已经在快车道的人</li><li>重要的另一半，你需要说服她，或者离开她</li></ul></li></ul></li><li>第二十六章 你的原始燃料：时间<ul><li>时间不是商品，不可以像一块蛋糕那样被传来传去。时间是生活中的一种存在。当有人想请你花点时间时，其实是在要你生活的一部分。 —— 安托瓦妮特·博斯科<ul><li>表达的是你的生活就是时间，如果你想拥有自己的生活，你就必须学会管理时间。</li></ul></li><li>现象：大家会为了某个优惠活动，而去排很长的队伍，他们认为自己的时间不值钱</li><li>时间对于所有人来说都是公平，你需要重视你自己的时间，不要浪费它</li><li>时间是有限的，而金钱是无限的，你用有限的东西，去排队去浪费3个小时时间，只为了那几块钱优惠吗？</li><li>你的生命公式：生命=可自由支配的时间+受到约束的时间</li><li>受到约束的时间：花在可以赚钱上的时间</li><li>可自由支配的时间：不花在赚钱上的时间</li><li>最理想的状态，在于你花在赚钱上的时间，赚来的钱可以让你拥有足够多的自由自配时间</li><li>最浪费时间的行为：就是你的寄生性债务<ul><li>简单的说，就是你在透支消费，比如：今天买了一件很好的手机，一件很好的衣服等等，但是需要你刷信用卡，从而导致你不得不为了它继续工作，偿还这笔债务</li></ul></li><li>如何避免，每次消费之前，先看一下，这笔钱需要你工作多少天才能赚回来</li><li>从源头控制自己的消费：<ul><li>巧克力饼干法则，如果饼干没有放入购物车，那么就不会到你家里，你不会吃了，而如果你没吃则不会变成脂肪，造成肥胖</li><li>控制债务最源头的地方，就是要控制你的即时满足感<ul><li>即时满足感就是当你需要购买的时候，你需要立即满足，会给人一种快感，但是没什么用，因此你要学会如何控制或者降低即时满足感</li><li>不要养成即时满足感的习惯</li></ul></li></ul></li><li>贫穷最大缺点：忽视自由可支配的时间</li><li>奉行快车道原则的人在决策时会优先考虑时间，因为这是我们最有价值的资产。</li><li>想要快速致富，改变观念，你的时间才是你最大的财富。</li></ul></li><li>第二十七章 换掉脏机油<ul><li>人们忘掉了在学校所学的东西之后，剩下的就是教育。 —— 阿尔伯特·爱因斯坦<ul><li>表达的是，学校教的知识在随着时间的流逝会忘记，但是你不能忘记的是你要持续的去学习，去教育。</li></ul></li><li>举个例子，你的汽车需要经常换机油，才能跑得更好更久，那么学习就是机油，知识在不断更新换代，那么只有不断学习才不会被社会淘汰</li><li>慢车道（打工的人）将教育用来提升自己的内在价值，简单的说，就是提升各种打工技能</li><li>快车道（当老板的）将教育用来搭建和发展自己的业务体系，简单的说，就是搭建自己的生意模式</li><li>如何去学习，主要有以下几个步骤：<ul><li>解决最大的问题，我不知道怎么去做？ 这是大多数人放弃的理由，但是只要坚持下去，没有什么事情是不会做的</li><li>无需天赋，只要坚定的信念和不断的努力，就可以成为某一领域的专家</li></ul></li><li>你能做的最好的投资就是投资你自己，应该勇敢为知识付费</li><li>在去学习的路上，还有一个大阻碍：我没有时间，那么如何利用时间呢，以下有几个常见的场景：<ul><li>堵车的时候，听有声书籍或财经新闻</li><li>运动的时候，看相关教育视频</li><li>等车的时候，可以读一些有用的书</li><li>洗手间的时候，可以学一些新的东西，这段时间是所有打工人最佳学习时间</li><li>上班的时候，利用工作休息时间段去学习</li><li>看电视或刷抖音或玩游戏，这段时间是不是可以直接利用起来，戒掉这些浪费时间的习惯</li></ul></li><li>设定学习目标，如：今年要完成12本书，那么一个月就是一本，做起来一点都不难吧</li><li>去参加各种论坛或沙龙会议，其实并没有什么用，同时还要花钱去听营销</li></ul></li><li>第二十八章 冲击红线<ul><li>如果事情看上去是受控的，就意味着你做得不够快。 —— 马里奥·安德莱逖<ul><li>表达的是，如果你是一步步的把控事情的进度，那么你就会落后人很多，有时候需要有勇气去快速前进，你才能超越很多人。</li></ul></li><li>红线，是底线，是承担责任，你必须要对你的系统和业务负责人，甚至付出一定代价。</li><li>负责任，指的是不是因为兴趣才来的，而是因为你要做出一些东西出来，你需要对此负责。</li><li>兴趣让你看上去富有，承担责任使你变得富有。</li><li>需要做好十足准备和马力，不断拉开与别人（大多数人）的距离</li><li>要走上快车道，快速致富，你必须学会以下几点：<ul><li>必须学会承担风险</li><li>必须学会经历痛苦与不适</li><li>必须学会面对恐惧，那种害怕失败的恐惧</li></ul></li><li>学会承担可控的风险，主要将做一件事的风险点都要想好，然后自己是否可以承担失败后果<ul><li>面临一个个失败，从中吸取教训，而不是因为恐惧而逃避</li></ul></li><li>学会识别风险：明智可控的风险、无谓失控的风险<ul><li>无谓失控的风险，最大一个特征就是赌博心理，你在没有做任何准备的情况去赌一个可能发生的概率性问题，你没有为提高概率而做努力</li><li>明智可控的风险，就是做一个事情，有一定运气成分在，但是你已经做好十足准备或已经做了很多事情去提高成功的概率</li></ul></li><li>禁止“明天做”，能让你不会被这一行为受限<ul><li>“明天做”这一理由让大多人一直停留在原地不动</li><li>不要等，等到哪些时候才可以做呢？永远不会有完美的时间</li></ul></li><li>机会就在身边，机会以变革和挑战的面目出现<ul><li>一个机会，就是最近IT行情不好，大家都找不到工作，所以需要一个面试小程序给到大家信心</li></ul></li><li>时机极少是完美的，等待会让人变得平庸，不要用一生的时间坐等完美时刻的来临。</li><li>现在就是走上快车道的时机，不要再犹豫了。</li></ul></li></ul></li><li>第7篇 通向财富之路<ul><li>第二十九章 通向财富的正确道路<ul><li>选择上哪条路，就会到达哪个地点。方法决定结果。—— 亨利·艾默生·福斯迪克<ul><li>表达的是，其实一开始就等于是终点，努力只是在于你能走多远，做事的方法才是事情的成败的因素。</li></ul></li><li>正确的快速致富的道路，并不是从路边摊开始，那么什么才是正确的财富之路?<ul><li>必须接近或者遵循影响力规律的路</li></ul></li><li>影响力规律：为了赚百万美元，你必须影响百万人</li><li>快车道创业的5条戒律，你需要经常用这几条戒律检查自身：<ul><li>需求戒律</li><li>进入戒律</li><li>控制戒律</li><li>规模戒律</li><li>时间戒律</li></ul></li></ul></li><li>第三十章 需求戒律<ul><li>如果我们不是为了生活变得更加容易，那又会是什么？ —— 乔治·艾略特<ul><li>表达的是，目前我们所做的和努力的，都是希望生活变得更加美好，请不要忘记这个宗旨。</li></ul></li><li>商业的胜利，最根本的就是为了解决需求，给用户提供有价值的的业务或商品，能解决问题的业务才会有利润，否则将不可持久。</li><li>消费者的思维是对我有什么好处，生产者的思维是对别人有什么好处，寻找他人的需求</li><li>转变做生意的想法，不是为了赚钱，而是为了解决需求，寻找做生意的机会，其实就是在寻找市场需求</li><li>改变思维模式，寻找需求、痛点、问题、服务缺陷和情绪，  而不是为了满足自己才去做某件事</li><li>市面上有大量追逐金钱者的成功案例，但他们已经失去了真正快速致富的通道，他们会为了钱不断改变自己，直到为了钱放弃自由和自己</li><li>改变做法，不要去追逐金钱，而是吸引金钱，只要你能满足大量需求，就可以吸引到大量金钱</li><li>如何做到满足需求呢，具体有以下几种做法：<ul><li>让他们感觉更好，服务</li><li>帮助他们解决问题，技能</li><li>教育他们，培训机构</li><li>让他们看起来更棒（健康、营养、衣着、装束），服装、理发</li><li>给他们安全感（住房、安全、健康），饮水机的安全设定</li><li>产生积极情绪（爱、快乐、欢乐、自信），游乐园、电影、小说</li><li>满足口腹之欲，好吃的餐饮店</li><li>让事情变得容易，咨询公司</li><li>给他们梦想和希望，孵化公司</li></ul></li><li>你喜欢做的事情，不一定是市场所需要，所以不能将你的爱好转变为事业，因为很容易陷入失败</li><li>喜欢做的事情一旦与赚钱挂上关系，就会失去本身的意义<ul><li>运动员喜欢运动，但是高峰期后就无法再参与</li><li>艺术家们画画会需要迎合市场需求，而失去对艺术的热爱</li></ul></li><li>激情与喜欢并没太多关系，激情来自最终目标和原因，它是驱动快车道的行动力</li><li>需求一个强大理由，来让自己充满激情面对每一天<ul><li>强大的理由，是不想一辈子碌碌无为，平凡打工过一生</li><li>强大的理由，看到一些平凡的人在一些事情上是多么的卑微，我不想太卑微，所以我需要成长</li><li>强大的理由，我需要一个安静且舒适的环境，能自由过自己想要的生活，这一切都需要钱</li></ul></li><li>激情源自梦想，你要为梦想寻找动机，找到一条能把梦想变为现实的路，这才是正确的路</li><li>如何寻找你的激情？<ul><li>首先，激情源于激动或不满</li><li>其次，保持住你对现在的激动或者不满的情绪</li><li>最后，将其转换去做某件的动力源，每当想放弃的时候，想一想当时的激动或不满</li></ul></li></ul></li><li>第三十一章 进入戒律<ul><li>我们的计划搞错了方向，因为没有设定目标。当人们不知道自己该驶向哪个港口时，任何方向的风都不合适。 —— 塞内卡（Seneca）民间谚语<ul><li>表达的是，如果我们的人生没有任何目标，或者做某件事没有任何目标，那么无论你怎么做，都是会走向失败的。</li></ul></li><li>进入戒律，第一条，记住进入任何领域都有壁垒，当领域竞争激烈那么致富效果就会减弱，同时如果壁垒够高，那么该领域可以走得更远更强大</li><li>低壁垒的行业，往往赚不到钱，如果想要赚到钱，就必须成为第一名</li><li>如何判断是否符合进入戒律：<ul><li>你所做的生意是不是一个过程，而不是一个结果，如：你购买一套电商平台，这是结果，以为可以开启电商但是却不是，真正电商是需要你去确定货源、用户群、购买意愿、售后等一系列过程</li><li>任何短时间可以完成的生意，都是不符合进入戒律的</li><li>大家都在做的事情的，或者这门生意很多人都在进入，就不应该进入，这也是进入戒律之一</li><li>容易做的生意，也不要去做，因为门槛低，容易失去控制</li></ul></li><li>如果你想快速致富，就不能像大家那样子去做</li></ul></li><li>第三十二章 控制戒律<ul><li>靠人不如靠自己 —— 约翰·盖伊<ul><li>表达的是，很多事情只有掌握在自己手里，事情才不会失控。</li></ul></li><li>要坐在驾驶位，而不是副驾驶位搭乘便车。</li><li>如何做到控制呢？举几个例子：<ul><li>创立公司，而不是去公司打工</li><li>创建出售连锁品牌，而不是加盟</li><li>管理对冲基金，而不是投资</li><li>出售股票，而不是购买股票</li><li>为别人提供直销，而不是做这个</li><li>出售使用权，而不是购买使用权</li></ul></li><li>乘客只能赚零头，而驾驶者却能赚大钱，大钱和零头的区别在于，一个赚2万，一个赚20万</li><li>乘客容易失去控制，如果驾驶者赶你下车，你将毫无办法，如：你是一个电商，在淘宝开店，万一哪天淘宝封你的店铺，那么你就会失去所有</li><li>训练鲨鱼思维，而不是孔雀鱼，就是吃别人，而不是被别人吃<ul><li>要的是更大的图景，而不是眼前的利润</li><li>深入思考自己的信念体系，改变思维模式</li><li>考虑全部，而不是局部</li><li>去引导，而不是跟随</li><li>思考如何创新，而不是复制</li><li>网络营销，是需要有自己的品牌后才需要的事情，而不是为了别人的品牌去参与网络营销</li><li>多层次的网络营销，包括：销售、激励、团队精神，和社交</li><li>你需要创建自己的品牌，控制它，创建属于自己的金字塔</li></ul></li></ul></li><li>第三十三章 规模戒律<ul><li>要想在商业上获得成功，你只需要做对一次。 —— 马克·库班<ul><li>表达的是你创业能够成功，在于你把握住了某一次机会，但是需要为了这次机会做好所有的准备，而这一次机会恰恰足够让你翻盘。</li></ul></li><li>思考，你希望在限速15的公路前进，还是限速150的公路上前进。</li><li>创业就要去做大规模的生意，就好比打棒球，要努力完成全垒打，而不是做一个次安打</li><li>规模是什么？<ul><li>规模是销售数量，如：你每个月固定销售量是多少，</li><li>规模是服务范围，如：你服务的范围是你的小区，还是你的街道，还是城市，全国甚至全球</li><li>规模是品牌影响力，如：兰博基尼和现代车的价格，你是做低端，还是高端</li></ul></li><li>规模就是杠杆，用你现在拥有的东西去撬动更大的范围的事业</li><li>判断是否违反规模戒律：<ul><li>净收入是否有上限，如：每月2000元~20万</li><li>这门生意的资产价值是多少？</li><li>生意可以影响多少人？客户群是谁？</li><li>生意模式是否可以复制，或者开连锁扩大销售范围？</li><li>最好的情况下可以销售多少件？</li><li>最好的情况下单件的最大利润是多少？是否有量级？</li></ul></li><li>规模戒律是影响力定律的一个因子，影响力定律则是快速致富的方法</li><li>影响力定律三大障碍：规模、量级和渠道<ul><li>最大的障碍是规模，如果你的行业规模不是给百万人提供服务，那么你无法影响到百万人</li><li>量级，指的是你能给多少人提供服务，通常如果规模够大，那么你就有足够大的量级</li><li>渠道，等于你的资源或者货源，如果你没有好的资源，你自然就无法做到影响到其他人</li></ul></li><li>如何运用影响力定律：<ul><li>选择一条可以打破规模或量级的道路，并掌握来源</li><li>如果无法掌控源头，那么就为源头服务</li><li>要从大处着眼，考虑规模和量级，分析财富公式并检查变量情况，如：最大销售量和最大利润是多少</li></ul></li></ul></li><li>第三十四章 时间戒律<ul><li>我有很多想法，却缺少时间。我希望我能活到百岁左右，我也就满足了。 —— 托马斯·爱迪生<ul><li>表达的是，想做的事情很多，唯一缺少的是时间，而时间则是许多事情能够做成功的重要因素。</li></ul></li><li>时间戒律，指的是快车道的生意是能让你从工作时间脱离出来，能够自主运行且开花结果，自主赚钱。</li><li>满足时间戒律的要点：<ul><li>当我不在场的时候，生意是否可以有序自动地运转</li><li>我的边际收益是否足够多，可以让我雇人去做<ul><li>边际收益：增加一单位产品所产生的利润</li></ul></li><li>我的经营是否得益于这是一颗摇钱树业务</li><li>如何让生意经营不占用自己的时间</li></ul></li><li>打工是用时间换钱，有些生意也是如此，比如：开水果店、餐饮等</li><li>时间戒律就是提高效率，让工作的时间尽可能的短，同时产生更多的效益</li></ul></li><li>第三十五章 快速致富的3条大道<ul><li>如果你为别人干活而得不到回报，你就无法过上好生活。 —— 约翰·伍登<ul><li>表达的是，如果你依赖别人而活，你就无法稳定的生活</li></ul></li><li>在快速致富的选择，使用WADM（权重分数判断）去考虑各个方面得分数，做出最适合的选择</li><li>快车道精髓：5条戒律<ul><li>不应该投资没有需求的生意</li><li>不应该用时间去交换金钱</li><li>不应该在一个有限的规模的行业做生意</li><li>不应该放弃控制权</li><li>不应该将一个初创的生意当成结果，而是运营它的过程才是结果</li></ul></li><li>3条高速路快车道<ul><li>互联网生意</li><li>创新产品或服务</li><li>创造规模效应</li></ul></li><li>互联网生意，规模天生就是全球且防止别人进入的门槛，有以下几种：<ul><li>提供订阅服务，提供服务、信息等付费订阅</li><li>提供内容服务，免费提供，增加广告收入</li><li>引导性销售，提供引导销售服务，如：携程、美团等</li><li>社交网络，利用搭建社交，形成网络依赖服务</li><li>中介系统，提供中间商服务收费，如：PayPal</li><li>广告联盟，提供广告渠道给广告商</li><li>电子商务，通过搭建平台，吸引商铺和消费者进行消费，如亚马逊和淘宝</li></ul></li><li>创新产品或服务，创新包括：制造或销售<ul><li>创新不是发明一个工具，而是对一个已有的产品进行改进和提高，并推进市场，如：净水器，可以思考做一些改进，与其他人不同，插座做的更好看和好用</li><li>创新双重挑战：制造和销售，如：写一本书是制造，而将它卖给人则是销售，需要市场营销、推广、演讲等扩大它的知名度</li></ul></li><li>创造规模效应，利用创造大规模实现快速致富的效果，比如：买一栋房子出租是有限的，但是买50栋就能快速致富<ul><li>连锁经营，可以开小便利店，但是利用规模效应，可以重复开很多所，就可以实现快速致富</li><li>因为一个小规模的生意并不能产生大的利润，如果不断叠加，就可以产生量级利润，这就是量变导致质变</li></ul></li></ul></li><li>第三十六章 找到你的金光大道<ul><li>开始时，人们拒绝相信一个新奇的事情，之后人们开始希望能够做到，然后他们看到那件事情确实可以做到，最终那件事做成了。所有人开始问，为何这件事几个世纪了都没人去做。—— 弗朗西斯·霍奇森·伯内特<ul><li>表达的是，人们一般不会愿意相信自己认知外的事情，直到开始动手去实现后，才发现确实是可以做到的。</li></ul></li><li>机遇是什么<ul><li>机遇，就像一个待满足的需求，正在那里等着别人去发现，如: 路边有人正在抱怨、论坛上正在争吵的事情</li><li>机遇，就是对一个”不方便“提出的解决方案，让人感觉到舒适</li><li>机遇，就是简化流程，提供更好的服务</li></ul></li><li>怎么做<ul><li>有人正在做这件事，那么你只需要比他做得更好</li><li>成功的生意往往不是因为新奇的创意，关键是要比别人做的更好</li><li>成功的生意可以采用已有的点子、服务和产品，只需要做得更好，或者采用新的做法</li></ul></li><li>找到大道的办法<ul><li>利用一些词汇，如：讨厌、不喜欢、烦恼、为什么、不得不、希望、试过、槽糕透了等，去收集需求和机遇</li><li>发现这些问题需求，向大家提出解决方案并确保赚钱，因为解决问题就等于解决了自己赚钱的问题</li></ul></li><li>在失败中开辟一条新路，失败并不可怕，重要的是要失败中吸取经验，或许你就能从中找到你真正走上财富的路</li><li>失败是经常的事情，但是不要忘记你自己的梦想</li></ul></li><li>第三十七章 为你的路设定终点<ul><li>悲剧不是你未能达到目标，而是你根本没有设定目标。 —— 本杰明·梅斯<ul><li>表达的是如果你没有设定目标，而一直努力的话，你的努力终究会白费掉。</li></ul></li><li>需要想清楚你的终点是什么，快车道致富是一种手段，如：你想要自由自在的生活在不缺钱的日子里，没有领导压迫，当老婆跟你要钱的时候你可以随时提供</li><li>再次确定金钱的重要性，你所想要的一切梦想，都需要付出代价，而这个代价就是金钱</li><li>实现自由享受符合你期望的生活方式的两个策略：<ul><li>一是一大笔钱，利息足够你日常开销</li><li>二是你的商业系统产生的被动收入能够支持你的生活，同时也能继续维持系统的运转</li></ul></li><li>设定终点的4个步骤：<ul><li>定义生活方式，就是你最理想的生活<ul><li>住多大的房子</li><li>想要多少辆汽车</li><li>一年多少次旅游</li><li>孩子的上什么学校等等</li></ul></li><li>评估这种生活的成本，大概需要多少钱<ul><li>一个一线城市的大平层，全款1000万，水电物业费费等一个月3000</li><li>3辆汽车，大概40万一辆 120万，每个月开销8千，</li><li>旅游，每个月1000</li><li>私立学校：每个月2000</li><li>生活成本：每个月3万</li><li>总计：每个月5万左右</li></ul></li><li>设定目标，建立金钱系统和生意收入目标<ul><li>创立一个商业系统，按照40%收入、40%返回给到商业系统维持，20%维持生活，那么商业系统至少每个月需要产生利润25万</li></ul></li><li>实现，找到方法并去做<ul><li>先定一个小目标，然后再换中目标，最后才换成大目标，一步步走才不会因为困难而无法前进</li><li>找指数基金做智能定投，实现每年5%的收益</li><li>创建自己的金钱系统，</li></ul></li></ul></li><li>快车道规则，必须拥有丰富的财务知识，从而避免不必要财富损失风险</li><li>为了财富稳定，必须学会金钱的规则，基本的财务和经济学知识</li><li>节流是慢车道，而是快车道是开源节流</li></ul></li></ul></li><li>第8篇 加速累积财富<ul><li>第三十八章 成功的速度<ul><li>创意只是神经速度，此处无他。 —— MJ·德马科<ul><li>表达的是，很多想法只是在大脑里经过，你没有去实现，那么它就只是大脑的一个神经细胞动了一下而已。</li></ul></li><li>速度的策略，是象棋，而不是跳棋<ul><li>速度是实现，是推进，是去操作，而不是想象</li><li>象棋的玩法是多维度的，而跳棋则是单维度的思考</li><li>如一款电商产品，大多数人认为价格低就可吸引消费者，但是从来没有想过其他方面，如：营销、质量、服务、售后、物流速度等</li><li>速度，就是快速将你的商业系统快速搭建起来，而不是单方面的去实现</li></ul></li><li>如果想真正获得成功，你需要加快速度将脑子里想法落地，而不是去看电视剧，同时需要坚持不懈，要控制进度</li><li>创意是结果，而执行是过程，过程是要牺牲、努力、纪律和坚持。</li><li>快车道的速度可以让生意按照指数倍增，使净收入和资产价值实现爆发式增长。</li></ul></li><li>第三十九章 烧掉商业计划，立即开始行动<ul><li>除非你立即采取行动，否则即便有全世界最棒的创意也没有用。想喝牛奶的人不能只是坐在养牛场的一把椅子上，等着奶牛过来喂奶。—— 柯蒂斯·格兰特<ul><li>表达的是，光有想法不行动，即使你是天才也没法成功</li></ul></li><li>只有将创意落地，你才知道创意是否行得通</li><li>世界会告诉你怎么走，哪条路是对的，但是前提需要你去行动起来</li><li>风险投资看重的是执行，而不是你的商业计划书写的多牛逼</li><li>当你的执行结果非常好，那么投资自然而然就会拥抱过来，从而获得更多资金</li></ul></li><li>第四十章 步行者会让你发财<ul><li>如果你做的不错，客户会口口相传。口碑很重要。 —— 杰夫·贝佐斯<ul><li>表达的是，当你的生意服务很好，形成了口碑，那么接下来你就继续保持原样，生意范围会越来越广。</li></ul></li><li>所有的生意客户服务目标只有一个，就是提供帮助、支持和解决方案。</li><li>积极面对客户投诉，及时处理投诉，是快速形成口碑的重要方式</li><li>如何识别投诉：<ul><li>变化，就是当你的产品发生变化，引起老用户不适应，这需要你去平衡，因为改变总会影起不适应</li><li>期望，当你的产品无法满足用户的期望，就会引起投诉，这个时候你需要紧急去处理</li><li>无效投诉，当你产品没有这类功能，用户不断提出来，你需要计算他们的次数，然后去增加该类功能</li><li>欺诈投诉，针对这类投诉，就是优雅回应，解释立场，然后继续处理自己的事情</li></ul></li><li>制作超越客户期望的服务，如何制作：<ul><li>收集客户的期望</li><li>告诉雇佣的员工，告诉他们给他们发工资是客户，而不是老板</li></ul></li><li>客户服务战略将影响公司的成长，必须满足客户期望，从而获得忠诚的客户</li><li>制作一个强大的公司品牌，让竞争对手不敢进来，打出气势，吓跑潜在对手</li></ul></li><li>第四十一章 把搭便车者扔出去<ul><li>人才是一家公司的最大资产，不管这家公司是造车的还是做化妆品的。一家公司的人有多好，这家公司就有多棒。 —— 玫琳凯·艾施<ul><li>表达的是，人才对公司来说是最重要的，拥有多少人才，就表示这家公司能走多远。</li></ul></li><li>管理公司，不仅仅有人才，还会有骗子，需要谨慎骗子，同时将其扔出去</li><li>找到一个互补的合伙人至关重要，然后要互相信任，相互理解，相互尊重</li><li>律师和会计师是第二重要的合作伙伴，需要谨慎再谨慎去选择，即使信任也要小心，这叫防人之心不可无</li><li>做法之一，就是先信任，再验证，需要花点心思去做筛选</li><li>必须雇佣能够遵循你商业模式定律的员工：<ul><li>员工必须落实你的客户服务理念</li><li>不管产品多好，如伟大的技术，都弥补不了糟糕的客服体验</li><li>不管服务多好，也无法遮盖产品的缺点</li></ul></li></ul></li><li>第四十二章 成为别人的救星<ul><li>市场不会因为一个好产品而被拯救，但是一个坏产品足以很快摧毁它。 —— 亨利·福特<ul><li>表达的是，一锅汤很容易被一颗老鼠屎弄坏，但是要做一个锅好汤不仅仅需要一个好食材就可以做到。</li></ul></li><li>平庸的产品无法创造足够利润，因为大家都在做同样的事情</li><li>做生意要有合适的理由，不能是因为不知道做啥才做这个，也不是因为喜欢才去做<ul><li>合适的理由是：解决一个问题或者满足某个需求</li></ul></li><li>做生意应该选择有差异化的产品或者某个行业问题的解决方案</li><li>有时候要忽略选择竞争对手的，不能把竞争对手在做什么当做自己的优先事项</li><li>什么时候需要留意竞争对手，需要留意的是竞争对手的弱点，然后将其作为自己产品的差异点</li><li>95%的注意力应该放在你的产品创新上</li></ul></li><li>第四十三章 打造品牌而不是生意<ul><li>每个人脖子上都挂着一个看不见的标牌，上面写着”让我觉得自己很重要“。在和人们打交道时候，千万不可忘记这件事。 —— 玫琳凯·艾施<ul><li>表达的是，每个人都有自己的品牌，希望别人看得见，所以品牌对于人或者商品而言都是很重要的。</li></ul></li><li>品牌是商品不会平庸化最佳策略，品牌是汇聚忠诚粉丝最有效的力量</li><li>品牌代表产品的形象，如：沃尔沃是安全，法拉利是速度等</li><li>品牌是需要独特的，在销售上需要一个独一无二的主张</li><li>如何开发独特的品牌<ul><li>发掘优点，比别人不一样的地方，解决或者更好解决别人的问题</li><li>独一无二，销售策略要足够独特，给消费者足够吸引力或者说服自己的能力，给消费者足够的选择</li><li>要具体，给出证据，你的产品有足够的优点，但是你需要给出证据证实这些优点</li><li>简短、清晰、明智，就是能被人快速记住</li><li>把你的销售主张放进所有的营销资料中</li><li>说到做到，商业的承诺要说到做到，否则没有人会给你第二次机会</li></ul></li><li>品牌首先要做到的引起注意，如何引起注意：<ul><li>极化，观点或者信息极端化，就是要表明你的态度，如：你坚持用Vue的原因是因为Vue的开源作者是中国人</li><li>冒风险，冒风险的策略之一是性吸引</li><li>调动情绪，能够与用户共鸣，触发他们的喜怒哀乐</li><li>鼓励互动，让用户投票或者选择，或者增加他们的评论</li><li>不落俗套，就是不大众化，新颖吸引人的注意力</li></ul></li><li>给消费者带来的，是这里有什么是我需要的，怎么做</li><li>就是把产品的特点翻译为好处<ul><li>调换角色，你把自己当成客户，是什么样的人群（CEO、学生、大妈等），确定他们真正的需求是什么</li><li>确定特点，确定需求后就是从产品分离出自己的特点</li><li>明确优势，然后确定这些特点有什么优势</li><li>将特点翻译成好处，最后将这些特点翻译成对用户有好处的东西</li></ul></li><li>用价格做品牌的武器，这也是目前大家都知道一个事情，就是原价999，现价499</li><li>价格代表不仅仅是成本，还是价值和用途的表现<ul><li>同时注意不要让价格毁掉你的品牌，低价格的东西会让你品牌变得廉价和大众化</li></ul></li><li>手提包的成本不到100元，却可以卖到1000元，因为它的品牌和营销做得好</li><li>控制消费者的大脑，同时也就获得客户</li></ul></li><li>第四十四章 选择”一夫一妻制“<ul><li>没有配马鞍，马儿就跑不远。没有加压力，蒸汽就无法推动任何东西。没有管道，尼亚加拉大瀑布的水就无法发电。专注、投入和自律，才能让生命更加伟大。 —— 哈里·艾默生·福斯迪克<ul><li>表达的是，成功的必需条件是，专注、投入和自律，如果这都做不到，那么你的成功就只是一次偶然，而不是必然，终究还是会失去。</li></ul></li><li>创业就和结婚一样，需要一夫一妻，而不是多撒网就可以多捕鱼，需要你的时间和精力都花在一个地方上</li><li>只有专注才有多样化，因为只有专注做一件事，才能把它做好</li><li>只有专注做一件事，成功之后，才会逐步衍生到其他方面，最后做成多样化</li></ul></li><li>第四十五章 为你的致富计划充满电<ul><li>选择可以马上做出，后果则伴随一生。 —— MJ·德马科<ul><li>表达的是我们每时每刻都在做出选择，而这些选择的结果则会形成我们的生活。</li></ul></li><li>如何给我们致富计划添加一个超级充电器：<ul><li>公式，财富是一个过程，而不是结果，是一个公式，结合了信仰、选择、行动、生活方式构成的系统性过程</li><li>认同，认同缓慢致富是完全错误的，认同快速致富是存在的，承认无计划不是一个好计划，认同运气是全心投入的结果</li><li>弃旧迎新，放弃原有的思维，停止我们一直在做的事情，重点是从消费者变成生产者</li><li>时间，时间是快车道宝贵的资产，尤其是自由可支配的时间，投资可产生自由可支配的时间的活动，把时间作为关键因素去搭建自己的商业系统</li><li>杠杆，可控制的杠杆=可控制的财务计划，能让你快速致富</li><li>资产和收入，财富是可以通过生意让收入和资产价值成指数型增长，同时不奢侈浪费消费，就可以打造出百万富翁</li><li>数字，赚钱的目标是什么，想要一个什么样的生活将其量化成数字，然后将相关目标放在自己随处可见的地方</li><li>影响力，记住影响力定律，你在能够控制的环境里，你影响几百万人，你就可以赚几百万元</li><li>导向，选择哪条路，选择快车道你就可以快速致富，拥有年轻的身体和更多的自由时间，现在做出改变，同时要对每个选择有责任心，要能承担责任</li><li>脱钩，你创业的东西必须具备自我成长性，能够与你的工作时间脱钩</li><li>激情和目的，激情能让你为了目的打满鸡血，同时也让你对一些不满的行为愤怒不已，不仅仅是因为喜欢而已</li><li>教育，不要停止学习，你现在所了解远远满不足了未来的目标，你需要不停的学习去加强你的业务系统的建设和运作。同时，学习信息也是你的财务之旅的燃油，抽出时间来学习。</li><li>道路，不要迷惑到底应该选择哪个行业，而是应该训练发现需求和问题的大脑，当你尝试去解决某个问题或者需求的时候，你就已经在走进一个行业里</li><li>控制，你需要有足够的掌控权，有完整的财务计划，才能做一条吃鱼的鲨鱼，而不是一条被吃的孔雀鱼</li><li>满足，要选需求，而不是选喜爱，要去解决问题，金钱才不断向你涌过来</li><li>自动化，让你的生意自动化成长，与你的时间脱钩</li><li>复制，你的商业模式应该是可以复制的，从而形成规模效应，能够快速影响数百万人</li><li>成长，你的业务可要从各方面去成长，而不是只有单一个特点，要做成品牌，同时需要聚焦某个业务，而不是多点开花</li><li>退出，制定一个退出策略，快车道的终点是实现被动收益系统，而释放这个系统最好的方式通过清算兑现巨大的财富</li><li>退休、回报或东山再起，好好放松一下，然后再选择去做什么</li></ul></li><li>不要让过去影响现在的选择，快车道上的人总是充满坎坷，如：背着贷款、每天都要上班没时间、我家人不太赞同我做这个等等</li><li>最后的答复是，不要因为这些借口影响到你，我们已经浪费太多时间了，我们需要行动，现在就行动。</li></ul></li><li>总结 回答一些直接的问题<ul><li>如何降低创业失败的风险<ul><li>找到市场的需求或者问题的空白区，再去做，即使有人已经做了，我们只要做的更好，花更多时间在上面，我们一样可以成功</li></ul></li><li>快车道指南，我着重采取几条我认为重要的<ul><li>不要为了节省钱而浪费时间</li><li>不要为了周末而工作五天</li><li>不要以为时间很充裕</li><li>不要停止学习</li><li>不要让生活被寄生性债务缠身，如：信用卡、花呗、分期贷款等</li><li>不要做消费者，而是生产者</li><li>不要追逐金钱，而不是追逐需求</li><li>不要相信每个人，要给他们证明自己的机会</li><li>不要轻易踏足低门槛或容易做的生意</li><li>不要做业务，而是做品牌</li><li>不要关注产品的营销信息，而是关注它能够用户带来的好处</li><li>不要做多头主义，要聚焦</li><li>不要做单一产品（如跳棋规则），要做从多方面思考产品（如象棋）</li><li>不要超前消费，而是寻找机会扩展自己能力范围</li><li>要具备基本的金融知识</li></ul></li></ul></li></ul></li></ul></li></ul><h1 id="阅读总结"><a href="#阅读总结" class="headerlink" title="阅读总结"></a>阅读总结</h1><p>读完《百万富翁快车道》，这是我第一本按照思维导图的方式去完整读完的书籍，收获颇丰，主要是从思维模式发生了改变，这一点是在学校里永远都不会有老师教给的思维模式。老师只会告诉你知识是什么，但是却不会告诉你知识是怎么用的，为什么要有知识，这个很难去讲，因为他们也不懂，他们所教的知识也是从上一代老师传下来，从师范学校里学的应该这么去教。</p><p>《快车道》这本书，给我们明确的指出了人生赚钱的三条路：</p><ul><li>人行道，有多少钱花多少钱，甚至超前预支消费，如：用贷款买车、买房、买奢侈品等等，然后你花完后发现根本就存不下任何钱，因为你已经掉入了社会给你设置好的消费陷阱，你需要不断消耗你的时间去赚钱填补超前消费这个坑，如果你不断挖坑（提前消费），那么你将无法抵抗任何风险，即使你是大明星（年入几百万）或者底层的农民（年入几百元），一旦失去收入，你就直接破产，面对人生的失败。</li><li>慢车道，尽量少花钱，然后相信定投基金这种谎言，依赖别人，靠打工赚钱和定期存储金钱，这是大部分普通人相信的道理，就是靠存钱或定投基金可以到老年退休后可以好好享受生活，但是这种思维是一种极大幸运概率的思维，因为你的收入控制权不在你手上，而是在很多人手上，比如领导每年都能给你加薪，公司不裁员，爸妈不要生大病花钱，孩子不需要额外的开销等等，这种选择你无法抵抗任何大一点的风险，因为一旦风险来临，你之前所做的一切（存钱计划）将灰飞烟灭，而且你的生活质量一直处于低水平，因为你不敢花钱。</li><li>快车道，尽量快的赚钱和尽可能的少花钱，这种选择可以在短时间快速赚钱，然后可以持续不断的赚钱思维，开始很难，但是后面就会越来越容易，因为你已经搭建完自己能控制的商业系统，它将同一个摇钱树一样不断给你提供越来越多的金钱，你只需要控制好它（财务计划）就好，当然这个选择需要遵循很多戒律，如：需求、进入、规模、控制、时间等，同时需要你去制造影响力，还要从消费者转化为生产者的思维。</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;百万富翁快车道&quot;&gt;&lt;a href=&quot;#百万富翁快车道&quot; class=&quot;headerlink&quot; title=&quot;百万富翁快车道&quot;&gt;&lt;/a&gt;百万富翁快车道&lt;/h1&gt;&lt;p&gt;讲述的作者从失业游民到百万富翁的经历的一些过程，可以帮人开阔一些思维模式，从人行道、慢车道、快车道的方式去讲述一个人如何转到一百万。&lt;/p&gt;
&lt;p&gt;如果想要快速赚到一百万，这里没有教你实际的方案，但是告诉你一些思维模式，所以我这边简单通过思维导图去进行汇总。&lt;/p&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/学习总结/"/>
    
  </entry>
  
  <entry>
    <title>可以从ChatGPT学到什么（二）—— 利用AI自动生成git commit信息</title>
    <link href="https://www.qborfy.com/today/20230221.html"/>
    <id>https://www.qborfy.com/today/20230221.html</id>
    <published>2023-03-12T10:00:01.000Z</published>
    <updated>2023-03-14T12:50:41.331Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>自从上一次写完<a href="https://qborfy.com/today/20230216.html" target="_blank" rel="noopener">可以从ChatGPT学到什么(一)</a>，简单对ChatGPT有一定了解后，其背后的技术原理是基于OpenAI GPT-3协议去实现的智能对话的。</p><p>再加上我看到国外有很多相关基于GPT开发的开源应用，因此萌生了自己动手搞一个，加上之前自己翻译了一篇文章<a href="https://qborfy.com/translate/use-gpt3-auto-git-commit.html" target="_blank" rel="noopener">有了GPT-3，再也不用手写commit message</a>，他是基于Rust语言写，想着直接对着他照搬一个到Node.js版本，通过这种小项目实践，我们可以学习到：</p><ul><li>OpenAI提供了哪些模型算法</li><li>不同模型算法分别可以应用到哪些场景</li><li>真正调用OpenAI需要注意哪些事项</li></ul><a id="more"></a><p>接下来我们开始动手吧！这里基本前提是你得拥有OpenAI API keys，可以到[OpenAI]。</p><p>首先我们先来看看<a href="https://github.com/qiubohong/node-gptcommit" target="_blank" rel="noopener">node-gptcommit</a>是做什么的。</p><h1 id="node-gptcommit"><a href="#node-gptcommit" class="headerlink" title="node-gptcommit"></a>node-gptcommit</h1><p><a href="https://github.com/qiubohong/node-gptcommit" target="_blank" rel="noopener">node-gptcommit</a>是基于<a href="https://github.com/zurawiki/gptcommit" target="_blank" rel="noopener">gptcommit</a>实现思路去开发的node版本工具命令，可以根据项目中git的diff文件列表去生成git commit信息。</p><p>具体效果可以参考以下步骤：</p><ol><li>安装</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install node-gptcommit -g</span><br></pre></td></tr></table></figure><ol start="2"><li>设置openai的apikey</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngptcommit config --set openai.apiKey=sk-xxxxx</span><br></pre></td></tr></table></figure><ol start="3"><li>开始使用</li></ol><p>请到某个git仓库的根目录使用，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd xxx</span><br><span class="line"></span><br><span class="line">ngptcommit preview</span><br></pre></td></tr></table></figure><p>就可以看到具体返回的信息，具体下文所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&quot;🤖 GPT-3 返回的总结内容如下:&quot;</span><br><span class="line"></span><br><span class="line">feat: </span><br><span class="line"></span><br><span class="line">- 更新项目配置，加强 TypeScript 的选项。</span><br><span class="line">- 添加了包含了推荐和 Prettier 的扩展，设置特定规则和排除的 `tslint.json` 文件。</span><br><span class="line">- 包含了文档配置的 `typedoc.js` 文件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 在新的 `tsconfig.json` 中添加严格的 TypeScript 选项。</span><br><span class="line">- 在新的 `tslint.json` 文件中添加了推荐和 Prettier 的扩展。</span><br><span class="line">- 配置了特定规则的排除和 false 选项。</span><br><span class="line">- 添加了文档配置的 `typedoc.js` 文件。</span><br></pre></td></tr></table></figure><h1 id="OpenAI使用说明"><a href="#OpenAI使用说明" class="headerlink" title="OpenAI使用说明"></a>OpenAI使用说明</h1><p>OpenAI API说明文档，地址：<a href="https://platform.openai.com/docs/" target="_blank" rel="noopener">openai docs</a>。</p><p>首先，我们需要了解几个概念：</p><ul><li><code>Model</code> 模型，是AI算法模型，根据不同模型可以推算出不同的结果</li><li><code>Completion</code> 任务结果，指的调用模型后返回的结果</li><li><code>apiKey</code> api秘钥，openai对调用api方的鉴权token</li></ul><h2 id="Model模型"><a href="#Model模型" class="headerlink" title="Model模型"></a>Model模型</h2><p>OpenAI提供了几个模型，主要分别以下几种：</p><p>基于<code>GPT-3</code>模型开发的模型：</p><ul><li><code>GPT-3.5-turbo</code>，最新的GPT-3.5模型，主要针对对话聊天的自然语言和代码处理，也能处理传统的任务，成本只有<code>text-davinci-003</code>十分之一</li><li><code>text-davinci-003</code>，对各类型语言都友好支持，比其他模型更加擅长输出更多更长更高质量的文案，而且还会在文案补全相关逻辑</li></ul><p>除了<code>GPT-3</code>模型，openAI还提供了几个其他模型（包括：beta版本），如下：</p><ul><li><a href="https://platform.openai.com/docs/guides/images" target="_blank" rel="noopener"><code>DALL·E</code></a>，根据自然语言生成图片。</li><li><a href="https://github.com/openai/whisper" target="_blank" rel="noopener"><code>Whisper</code></a>，语音识别模型，已经开源的模型</li><li><a href="https://platform.openai.com/docs/guides/embeddings" target="_blank" rel="noopener"><code>Embeddings</code></a>，检测词语的关联关系，能实现搜索、分类、推荐、异常检测、多样性测试、标签等</li><li><a href="https://platform.openai.com/docs/guides/code" target="_blank" rel="noopener"><code>Codex</code></a>，基于GPT-3生成专门针对代码优化的模型，最擅长的是Python语言，精通十几种语言，包括JavaScript、Go、Perl、PHP、Ruby、SWIFT、TypeScrip、SQL，甚至是Shell等。</li><li><a href="https://platform.openai.com/docs/guides/moderation/overview" target="_blank" rel="noopener"><code>Moderation</code></a>，按照OpenAI内容安全使用策略，识别内容是否非法，如:涉黄、暴力、自残等。<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2></li></ul><ol><li>安装依赖</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install openai</span><br></pre></td></tr></table></figure><ol start="2"><li>初始化</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Configuration, OpenAIApi &#125; <span class="keyword">from</span> <span class="string">'openai'</span>;</span><br><span class="line"><span class="keyword">const</span> config = <span class="keyword">new</span> Configuration(&#123;</span><br><span class="line">    apiKey,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">this</span>.openai = <span class="keyword">new</span> OpenAIApi(config);</span><br></pre></td></tr></table></figure><ol start="3"><li>根据不同模型调用</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gpt-3.5-turbo</span></span><br><span class="line"><span class="keyword">const</span> prompt = <span class="string">'请问你是谁？'</span>;</span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="keyword">this</span>.openai.createChatCompletion(&#123;</span><br><span class="line">    model: <span class="string">"gpt-3.5-turbo"</span>,</span><br><span class="line">    messages: [&#123;</span><br><span class="line">        role: <span class="string">"user"</span>, <span class="comment">// system: 机器人, user: 用户, assistant: 助手</span></span><br><span class="line">        content: prompt</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// debug('调用openai接口返回内容：', response.data)</span></span><br><span class="line"><span class="keyword">return</span> response.data.choices[<span class="number">0</span>]?.message?.content ?? <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成一张黑色暹罗猫的图片</span></span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> openai.createImage(&#123;</span><br><span class="line">  prompt: <span class="string">"a black  cat"</span>,</span><br><span class="line">  n: <span class="number">1</span>,</span><br><span class="line">  size: <span class="string">"1024x1024"</span>,</span><br><span class="line">&#125;);</span><br><span class="line">image_url = response.data.data[<span class="number">0</span>].url;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><p>生成猫的图片：</p><div><img src="/assets/img/20230314.png" width="200px"></div><p>了解到OpenAI提供了如此多的API，是否可以利用他们来开发一些辅助工具来提升我们开发幸福感呢？</p><p>目前已经有很多这种开源小工具了，比如：<a href="https://github.com/zurawiki/gptcommit" target="_blank" rel="noopener">gptcommit</a>， <a href="https://github.com/JimmyLv/BibiGPT" target="_blank" rel="noopener">BibiGPT</a>，<a href="https://github.com/Nutlope/roomGPT?utm_source=gold_browser_extension" target="_blank" rel="noopener">roomGPT</a>等。</p><p>接下来我们以<a href="https://github.com/zurawiki/gptcommit" target="_blank" rel="noopener">gptcommit</a>为参考，尝试自己去实现。</p><h1 id="开发ngptcommit的背后"><a href="#开发ngptcommit的背后" class="headerlink" title="开发ngptcommit的背后"></a>开发ngptcommit的背后</h1><h2 id="gptcommit实现原理"><a href="#gptcommit实现原理" class="headerlink" title="gptcommit实现原理"></a>gptcommit实现原理</h2><p>gptcommit是基于Rust开发，但是从看代码的过程中发现Rust其实和Typescript差不多类似的语法，所以很容易上手。</p><p>下面有张图，大概就是gptcommit实现的过程：</p><div class="mxgraph-container">    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/gptcommit.drawio&quot;}"></div></div><h2 id="Node命令行工具"><a href="#Node命令行工具" class="headerlink" title="Node命令行工具"></a>Node命令行工具</h2><p>既然知道了gptcommit实现原理，那么要开发一个node的命令行工具，具体有哪些步骤呢？</p><ol><li>在<code>package.json</code>里配置命令行名称<code>bin:xxx</code>:</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    "bin": &#123;</span><br><span class="line">        "ngptcommit": "bin/ngptcommit.js"</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>针对命令行工具，node.js要求在文件开头必须表明<code>#!/usr/bin/env node</code>：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env node</span><br><span class="line"></span><br><span class="line">import run from &apos;../dist/cli.js&apos;;</span><br><span class="line">run();</span><br></pre></td></tr></table></figure><p>到了这里，我们基本就开始动手撸代码了，这里我还推荐一些npm包，能帮你快速开发命令行工具，有以下这些：</p><ul><li>rollup，比webpack更加适合开发js库的构建工具</li><li>debug，更好打印debug日志，而不是所有都console.log</li><li>cac，非常轻量的库，能帮你更快开发一个命令行工具</li><li>picocolors，可以将在命令行输出的带颜色文字</li><li>progress，可以在命令行显示进度条</li></ul><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ol><li>国内openAI无法连接上？<br>需要在代码预先判断连接，设置一个10秒超时，避免已经失败了，还要再继续去请求。</li></ol><ol start="2"><li><p>openAI访问频率有限制，如何解决？<br>需要加上每次请求后等待缓冲时间，避免因为多次请求导致失败。利用<code>p_limit</code>库，加上每次请求利用setTimeout设置缓冲等待时间，避免多次高并发请求，后续可以优化模板内容，避免多次重复请求。</p></li><li><p>失败重试如何实现？<br>通过失败次数，加上递归自己，实现通过失败次数实现失败重试。</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过开发这个工具，对OpenAI的有了更深入的了解，也明白为什么会有人说以后会出现一个岗位，叫<strong>AI驯服师</strong>或者<strong>AI提问者</strong>。</p><p>目前我个人对OpenAI类似的AI，可以认知到点如下：</p><ul><li>要学习如何向AI提问，更高效的向AI提问，可能会成为未来的一种趋势</li><li>AI更多是一种辅助工具，而不是会替换现有的岗位上的人，能帮忙人更高效的完成当前的工作</li><li>会有越来越多AI平台出现，甚至可能会出现一种大语言模型，或者面向AI编程语言，只需要写少量代码实现功能</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://platform.openai.com/docs/" target="_blank" rel="noopener">OpenAI相关文档</a></li><li><a href="https://github.com/zurawiki/gptcommit" target="_blank" rel="noopener">gptcommit</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;自从上一次写完&lt;a href=&quot;https://qborfy.com/today/20230216.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;可以从ChatGPT学到什么(一)&lt;/a&gt;，简单对ChatGPT有一定了解后，其背后的技术原理是基于OpenAI GPT-3协议去实现的智能对话的。&lt;/p&gt;
&lt;p&gt;再加上我看到国外有很多相关基于GPT开发的开源应用，因此萌生了自己动手搞一个，加上之前自己翻译了一篇文章&lt;a href=&quot;https://qborfy.com/translate/use-gpt3-auto-git-commit.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;有了GPT-3，再也不用手写commit message&lt;/a&gt;，他是基于Rust语言写，想着直接对着他照搬一个到Node.js版本，通过这种小项目实践，我们可以学习到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OpenAI提供了哪些模型算法&lt;/li&gt;
&lt;li&gt;不同模型算法分别可以应用到哪些场景&lt;/li&gt;
&lt;li&gt;真正调用OpenAI需要注意哪些事项&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="技术分享" scheme="https://www.qborfy.com/tags/技术分享/"/>
    
    <category term="每日更新" scheme="https://www.qborfy.com/tags/每日更新/"/>
    
  </entry>
  
  <entry>
    <title>GPT-4都来了，我们还需要刷算法题和背八股文吗？</title>
    <link href="https://www.qborfy.com/ideas/20230312.html"/>
    <id>https://www.qborfy.com/ideas/20230312.html</id>
    <published>2023-03-12T10:00:01.000Z</published>
    <updated>2023-03-16T15:45:51.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2023年的面试寒冬"><a href="#2023年的面试寒冬" class="headerlink" title="2023年的面试寒冬"></a>2023年的面试寒冬</h1><p>从去年到今年各个大厂都在不断裁员，导致今年IT互联网行情很差，很多朋友都缺乏面试机会或者面试不通过。</p><p>程序员一旦要开始面试，很多朋友都开始循环以下几个步骤：</p><ul><li>刷算法题，如：LeetCode各种困难程度的题目</li><li>背诵各种八股文，如：浏览器请求一个URL的完整过程</li><li>复习各种冷门知识，如：Promise.race(谁先返回就获取谁的结果，后面直接不处理)或Promise.allSettled(结果为Iterator对象，实现next())</li></ul><p>也许以往这种复习模式还算不错，因为目前大多数面试流程基本上都是会问上述问题，而面试官问这些问题的最终目的是什么：</p><ul><li>算法题，主要考的是逻辑思维能力</li><li>八股文，主要考的是基础知识是否足够扎实，知识深度是否足够</li><li>冷门知识，主要考的是知识广度，你除了目前使用知识点外还能拥有其他知识面</li></ul><p>后续一些项目经验讲述，主要目的在于测试你是否真的参与到项目中，但是这个往往都是容易被忽略的点，这个放到后面再讲。</p><p>当下最火的IT技术，ChatGPT智能机器人出来后，它不像普通搜索引擎一样，需要去大量的结果去找到自己的答案。而是直接将答案提供给到你，让你可以更加快速实现功能。</p><p>如果ChatGPT普及开来，那么面试是否还需要考算法题和八股文吗？</p><p>或者换个问题，<strong>当AI技术可以代替绝大部分基础开发工作的时候，面对这种技术变更，作为普通开发者，我们应该如何做技术成长规划呢？</strong></p><a id="more"></a><h1 id="怎么办"><a href="#怎么办" class="headerlink" title="怎么办"></a>怎么办</h1><h2 id="看清楚问题"><a href="#看清楚问题" class="headerlink" title="看清楚问题"></a>看清楚问题</h2><p>作为普通的开发人员，我们平时大部分开发工作说的不好听一点，其实都是在复制粘贴，简单点说就是在搬砖，从A地方搬到B地方，举几个例子:</p><ul><li>利用框架封装好的东西去开发项目，是否有尝试过自己去实现一个框架，如：Vue、React</li><li>实现某一个功能的时候，要嘛从现有项目中拷贝，要嘛从网上找对应答案，比如：需要从一个url获取参数，你会自己实现一个，还是拷贝呢？</li><li>遇到问题，第一反应基本上先从网上找答案，找到答案看看能否解决，如果可以就不会再往下深入学习</li></ul><p>以上基本上就是我们普通开发的发展路线——尽量不去开发轮子，也没有时间和兴趣去开发轮子。</p><p>当chatGPT智能机器人出现之后，你会发现你会的机器人都会，而且它还能实现你不能实现的功能，那么我们可以大胆猜测未来会有这么一个产品：</p><blockquote><p>一个低代码智能化平台，只需要资深开发者去输入一些关键性的业务代码，同时优化生成出来的代码逻辑。</p></blockquote><p>举个更简单的例子，原本你手动搬的砖，现在有机器人可以实现自动搬了，或者说当马车被汽车替代了，那么马夫的工作自然也就被司机所替代。</p><p>那么问题就很简单了，现状的问题是：</p><p><strong>大厂或小厂都在裁员，不需要那么多搬砖工了，而你还在为了更快搬砖，去提高自己的搬砖能力，如：刷算法题、基础知识等，不就等于在锻炼自己臂力让自己能搬更多的砖吗？</strong></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>既然清楚问题了，针对这个问题能有什么解决方案呢？其实是有的，就在于自己的选择。</p><h3 id="成为少数人"><a href="#成为少数人" class="headerlink" title="成为少数人"></a>成为少数人</h3><p>怎么理解成为少数人呢？主要有两种方式：</p><p><strong>第一种方式，无可替代或者很难替代。</strong></p><p>你的工作只有你能做，或者你做的工作很难。还是以搬砖为例：</p><ul><li>可以在高楼层搬砖</li><li>可以在深海里搬砖</li></ul><p>简单的说，除了开发业务功能外，你还掌握了其他的技能，说出来可能大家会骂人，如：</p><ul><li>写一手漂亮的PPT，能把PPT做堪比艺术品</li><li>项目管理能力强，能把握项目进度</li><li>有产品思维，你实现的功能比产品经理想得还完整</li><li>其他软技能…</li></ul><p><strong>第二种方式，成为专家</strong></p><p>这种方式需要天赋+机会+努力，缺一不可，简单来说，就是大家搬砖用的工具都是你制作的，如：</p><ul><li>Vue/React的作者，将很难被淘汰</li><li>公司内部的架构师们，项目的整体架构和轮子都由他搭建的，或者公司需要他们去新搭建一套轮子</li></ul><p>那么如何成为专家呢？不管是从网上还是现实中，都有很多实现路线，我这里简单总结一下:</p><ul><li>努力学习，扩展技术栈，日复一日的坚持学习知识</li><li>深入业务领域，将技术与业务结合，不断创造一些新的方案或架构</li><li>扩大自己的影响范围，等待机会，创造一套属于自己的架构体系</li></ul><h3 id="离开搬砖"><a href="#离开搬砖" class="headerlink" title="离开搬砖"></a>离开搬砖</h3><p>如果真的继续干这一行，吃技术饭很难混下来，那么只有选择离开，但是离开也分不同的分开，下面简单说几句。</p><p><strong>第一种离开，改变自己，拥抱新方向</strong><br>当汽车来临的时候，马夫无法继续工作了，那么为何不直接投入汽车司机的行业呢？</p><p>既然AI技术已经开始成熟投入使用了，那么作为开发者有什么理由不提前进入AI领域，去尝试一种新的方向呢？</p><p>比如：</p><ul><li>彻底转行成为AI开发，这里门槛有点高，但是可以去尝试</li><li>利用AI开发工具，成为AI的使用者是不是更加合适呢？</li></ul><p><strong>第二种离开，永远离开，投入新领域</strong><br>AI的到来，会实现很多基础开发工作，那么我不做开发了，是不是就不用被淘汰了呢？</p><p>正如所说，天涯何处无芳草，哪里都可以混口饭吃。</p><p>不要做21世纪的孔乙己，脱不下身上的长袍。</p><p>举几个例子：</p><ul><li>转技术培训，前提是你在IT开发待的足够久</li><li>创业当老板，从打工思维变老板思维，前提是得有钱有资源</li><li>早餐摊，卖粥，足以养活一家人，前提是身体健康</li></ul><p>总之，心态不要奔溃，被裁员也好，面试不通过也好，这只是当前整个大背景下的一个波浪，更何况目前AI的技术并没有那么发达。</p><p>如果以时间为维度，你这次的失败，只是你几十年人中的一个小片段。</p><p>如果以空间为维度，你我皆是蝼蚁，宇宙何其庞大，你抬头看片星空，是否心情会更加放松一点。</p><p>最后，推荐大家去看一本书《百万富翁的快车道》，名字很俗，但是却能给我们带来一种新的思想模式：</p><ul><li>财富不是金钱等物质，而是你所能控制的时间+你的健康+人脉</li><li>人生的每个选择，都是你的信念系统做出的，如果你要财富，则需要不断优化自己本身的信念系统</li></ul><h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1><p>本文是个人一些想法，仅供参考。</p><blockquote><p>做一个有温度的技术分享作者 —— Qborfy</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;2023年的面试寒冬&quot;&gt;&lt;a href=&quot;#2023年的面试寒冬&quot; class=&quot;headerlink&quot; title=&quot;2023年的面试寒冬&quot;&gt;&lt;/a&gt;2023年的面试寒冬&lt;/h1&gt;&lt;p&gt;从去年到今年各个大厂都在不断裁员，导致今年IT互联网行情很差，很多朋友都缺乏面试机会或者面试不通过。&lt;/p&gt;
&lt;p&gt;程序员一旦要开始面试，很多朋友都开始循环以下几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;刷算法题，如：LeetCode各种困难程度的题目&lt;/li&gt;
&lt;li&gt;背诵各种八股文，如：浏览器请求一个URL的完整过程&lt;/li&gt;
&lt;li&gt;复习各种冷门知识，如：Promise.race(谁先返回就获取谁的结果，后面直接不处理)或Promise.allSettled(结果为Iterator对象，实现next())&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也许以往这种复习模式还算不错，因为目前大多数面试流程基本上都是会问上述问题，而面试官问这些问题的最终目的是什么：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算法题，主要考的是逻辑思维能力&lt;/li&gt;
&lt;li&gt;八股文，主要考的是基础知识是否足够扎实，知识深度是否足够&lt;/li&gt;
&lt;li&gt;冷门知识，主要考的是知识广度，你除了目前使用知识点外还能拥有其他知识面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;后续一些项目经验讲述，主要目的在于测试你是否真的参与到项目中，但是这个往往都是容易被忽略的点，这个放到后面再讲。&lt;/p&gt;
&lt;p&gt;当下最火的IT技术，ChatGPT智能机器人出来后，它不像普通搜索引擎一样，需要去大量的结果去找到自己的答案。而是直接将答案提供给到你，让你可以更加快速实现功能。&lt;/p&gt;
&lt;p&gt;如果ChatGPT普及开来，那么面试是否还需要考算法题和八股文吗？&lt;/p&gt;
&lt;p&gt;或者换个问题，&lt;strong&gt;当AI技术可以代替绝大部分基础开发工作的时候，面对这种技术变更，作为普通开发者，我们应该如何做技术成长规划呢？&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="奇思妙想" scheme="https://www.qborfy.com/tags/奇思妙想/"/>
    
  </entry>
  
</feed>
