<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Qborfy知识库</title>
  
  
  <link href="https://www.qborfy.com/atom.xml" rel="self"/>
  
  <link href="https://www.qborfy.com/"/>
  <updated>2024-09-06T08:21:10.000Z</updated>
  <id>https://www.qborfy.com/</id>
  
  <author>
    <name>Qborfy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RabbitMQ学习</title>
    <link href="https://www.qborfy.com/test.html"/>
    <id>https://www.qborfy.com/test.html</id>
    <published>2024-09-06T08:21:13.000Z</published>
    <updated>2024-09-06T08:21:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>可以源码安装（python环境）<br>service rabbitmq-server start</p><p>也可以docker安装，依赖docker环境</p><p>运行成功后有两个端口：</p><ol><li>5672，其他客户端调用链接使用</li><li>15672，后台管理系统使用</li></ol><p>支持配置文件，参考docker内配置文件路径： /etc/rabbitmq/conf.d/10-defaults.conf</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>virtual host<br>类似mysql支持多个用户访问同一个实例（IP+PORT）的不同数据库</p><p>exchange交换机<br>类似一种邮箱或存储队列，支持加入或转发推送能力</p><h1 id="五种消息类型"><a href="#五种消息类型" class="headerlink" title="五种消息类型"></a>五种消息类型</h1><h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><p>正常邮箱类型， 生产者往RabbitMQ队列增加消息，但是消费者不一定要及时看</p><h2 id="Worker模型"><a href="#Worker模型" class="headerlink" title="Worker模型"></a>Worker模型</h2><p>对比 邮箱模型， 只要生产消息 就会马上竞争消费掉，可以有效的避免消息堆积</p><h2 id="订阅模型"><a href="#订阅模型" class="headerlink" title="订阅模型"></a>订阅模型</h2><p>Fanout（广播模型）: 将消息发送给绑定给交换机的所有队列(因为他们使用的是同一个RoutingKey)。</p><p>Direct（定向）: 把消息发送给拥有指定Routing Key (路由键)的队列。</p><p>Topic（通配符）: 把消息传递给拥有 符合Routing Patten(路由模式)的队列。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;p&gt;可以源码安装（python环境）&lt;br&gt;service rabbitmq-server start&lt;/p&gt;
&lt;p&gt;也可以docker安装，依</summary>
      
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    <category term="每日更新" scheme="https://www.qborfy.com/tags/%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>翻译-服务器端请求伪造 (SSRF)</title>
    <link href="https://www.qborfy.com/today_2024/20240814.html"/>
    <id>https://www.qborfy.com/today_2024/20240814.html</id>
    <published>2024-09-06T08:20:08.000Z</published>
    <updated>2024-09-06T08:20:13.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在研究SSR，发现很多服务都会用到SSRF，所以就顺便研究了一下SSRF。</p><p>下面是一篇从网络上翻译过来的文章， 大家简单参考了解。</p><span id="more"></span><h1 id="什么是-SSRF？"><a href="#什么是-SSRF？" class="headerlink" title="什么是 SSRF？"></a>什么是 SSRF？</h1><p>服务器端请求伪造是一种 Web 安全漏洞，允许攻击者导致服务器端，从而发出非法请求。</p><p>在典型的 SSRF 攻击中，攻击者可能会导致服务器连接到仅供内部使用的服务。在其他情况下，他们可能能够强制服务器连接到任意外部系统。这可能会泄露敏感数据，例如授权凭据。</p><img src="/assets/img/server-side request forgery.svg"><h1 id="SSRF攻击的危害"><a href="#SSRF攻击的危害" class="headerlink" title="SSRF攻击的危害"></a>SSRF攻击的危害</h1><p>SSRF 攻击通常会导致未经授权的操作或组织内的数据访问。这可能位于易受攻击的网站中，也可能位于该网站可以与之通信的其他后端系统上。在某些情况下，SSRF 漏洞可能允许攻击者执行任意命令。</p><p>与外部第三方系统连接，如：接入第三方的登录等， 更容易受到SSRF漏洞攻击。</p><h1 id="常见的SSRF攻击"><a href="#常见的SSRF攻击" class="headerlink" title="常见的SSRF攻击"></a>常见的SSRF攻击</h1><p>SSRF 攻击通常利用信任关系， 去攻击的网站， 并执行未经授权的操作。这些信任关系可能与服务器相关，或者与同一组织内的其他后端系统相关。</p><h2 id="针对服务器的-SSRF-攻击"><a href="#针对服务器的-SSRF-攻击" class="headerlink" title="针对服务器的 SSRF 攻击"></a>针对服务器的 SSRF 攻击</h2><p>在针对服务器的 SSRF 攻击中，攻击者会通过内部络接口向网站的服务器发出 HTTP 请求。这通常涉及提供带有主机名的 URL，例如127.0.0.1 或localhost。</p><p>例如，想象一个购物网站，它允许用户查看特定商店中是否有商品的库存。为了提供信息，网站必须查询各种后端 REST API。它通过前端 HTTP 请求将 URL 当成参数传递到后端，然后执行 API 端点来实现此目的。当用户查看商品的库存状态时，他们的浏览器会发出以下请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /product/stock HTTP/1.0</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 118</span><br><span class="line"></span><br><span class="line">stockApi=http://stock.weliketoshop.net:8080/product/stock/check%3FproductId%3D6%26storeId%3D1</span><br></pre></td></tr></table></figure><p>这会导致服务器向指定的 URL 发出请求，检索库存状态，并将其返回给用户。</p><p>在此示例中，攻击者可以修改请求以指定服务器本地的 URL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /product/stock HTTP/1.0</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 118</span><br><span class="line"></span><br><span class="line">stockApi=http://localhost/admin</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>服务器获取<code>/admin</code> URL 的内容并将其返回给用户。</p><p>攻击者可以访问<code>/admin</code> URL，但管理功能通常只有经过身份验证的用户才能访问。这意味着攻击者不会看到任何感兴趣的内容。但是，如果对/admin URL 的请求来自本地计算机，则会绕过正常的访问控制。应用程序授予对管理功能的完全访问权限，因为请求似乎源自受信任的位置。</p><p>为什么应用程序会以这种方式运行，并隐式信任来自本地计算机的请求？出现这种情况的原因有多种：</p><ul><li>鉴权控制只在前端网关层控制，却没有在服务器上做任何限制。</li><li>出于容灾设计，允许来自本地的任何用户无需登录即可进行管理访问，只有完全信任的用户会直接来自服务器。</li><li>后管系统与用户系统用不同的端口号，并且用户可能无法直接访问。</li></ul><p>这种信任关系（其中源自本地计算机的请求的处理方式与普通请求不同）通常使 SSRF 成为严重漏洞。</p><h2 id="针对其他后端系统的-SSRF-攻击"><a href="#针对其他后端系统的-SSRF-攻击" class="headerlink" title="针对其他后端系统的 SSRF 攻击"></a>针对其他后端系统的 SSRF 攻击</h2><p>在某些情况下，应用程序服务器能够与用户无法直接访问的后端系统进行交互。这些系统通常具有不可访问的专用 IP 地址。后端系统通常受到网络拓扑的保护，因此它们的安全状况通常较弱。在许多情况下，内部后端系统包含敏感功能，任何能够与系统交互的人都可以在无需身份验证的情况下访问这些功能。</p><p>在前面的示例中，假设后端 URL <a href="https://192.168.0.68/admin">https://192.168.0.68/admin</a> 有一个管理界面。攻击者可以提交以下请求来利用SSRF漏洞，并访问管理界面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /product/stock HTTP/1.0</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 118</span><br><span class="line"></span><br><span class="line">stockApi=http://192.168.0.68/admin</span><br></pre></td></tr></table></figure><h1 id="规避常见的-SSRF-防御"><a href="#规避常见的-SSRF-防御" class="headerlink" title="规避常见的 SSRF 防御"></a>规避常见的 SSRF 防御</h1><p>包含 SSRF 行为以及旨在防止恶意利用的防御措施的应用程序很常见。通常，这些防御措施是可以被规避的。</p><h2 id="具有基于黑名单的输入过滤器的-SSRF"><a href="#具有基于黑名单的输入过滤器的-SSRF" class="headerlink" title="具有基于黑名单的输入过滤器的 SSRF"></a>具有基于黑名单的输入过滤器的 SSRF</h2><p>某些应用程序会阻止包含主机名（如127.0.0.1和localhost或敏感 URL（如<code>/admin</code>的输入，可如下设计：</p><ul><li>使用替代 IP 表示形式127.0.0.1 ，例如2130706433 、 017700000001或127.1等，作为超管系统等别名。</li><li>注册您自己的域名，解析为127.0.0.1 。您可以使用spoofed.burpcollaborator.net来实现此目的。</li><li>使用 URL 编码或大小写变化来混淆被阻止的字符串。</li><li>提供您控制的 URL，该 URL 会重定向到目标 URL。尝试对目标 URL 使用不同的重定向代码以及不同的协议。例如，在重定向过程中从http:切换到https: URL 已被证明可以绕过某些反 SSRF 过滤器。</li></ul><h2 id="具有基于白名单的输入过滤器的-SSRF"><a href="#具有基于白名单的输入过滤器的-SSRF" class="headerlink" title="具有基于白名单的输入过滤器的 SSRF"></a>具有基于白名单的输入过滤器的 SSRF</h2><p>某些应用程序仅允许匹配允许值白名单的输入。过滤器可能会在输入的开头或包含在输入中查找匹配项。您可以通过利用 URL 解析中的不一致来绕过此过滤器。</p><p>URL 规范包含许多在 URL 使用此方法实现即席解析和验证时可能会被忽略的功能：</p><ul><li>您可以使用@字符将凭据嵌入到 URL 中的主机名之前。例如： <code>https://expected-host:fakepassword@evil-host</code></li><li>您可以使用#字符来指示 URL 片段。例如： <code>https://evil-host#expected-host</code></li><li>您可以利用 DNS 命名层次结构将所需的输入放入您控制的完全限定的 DNS 名称中。例如：<code>https://expected-host.evil-host</code></li><li>您可以对字符进行 URL 编码以混淆 URL 解析代码。如果实现过滤器的代码处理 URL 编码字符的方式与执行后端 HTTP 请求的代码不同，则这尤其有用。您还可以尝试双编码字符；一些服务器对它们收到的输入进行递归 URL 解码，这可能会导致进一步的差异。</li><li>您可以结合使用这些技术。</li></ul><h2 id="通过开放重定向绕过-SSRF-过滤器"><a href="#通过开放重定向绕过-SSRF-过滤器" class="headerlink" title="通过开放重定向绕过 SSRF 过滤器"></a>通过开放重定向绕过 SSRF 过滤器</h2><p>有时可以通过利用开放重定向漏洞来绕过基于过滤器的防御。</p><p>在前面的示例中，假设用户提交的 URL 经过严格验证，以防止恶意利用 SSRF 行为。但是，允许 URL 的应用程序包含开放重定向漏洞。如果用于发出后端 HTTP 请求的 API 支持重定向，您可以构造一个满足过滤器的 URL，并将请求重定向到所需的后端目标。</p><p>例如，该应用程序包含一个开放重定向漏洞，其中以下 URL：<code>/product/nextProduct?currentProductId=6&amp;path=http://evil-user.net</code></p><p>返回重定向到：<code>http://evil-user.net</code></p><p>您可以利用开放重定向漏洞绕过URL过滤，利用SSRF漏洞，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /product/stock HTTP/1.0</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 118</span><br><span class="line"></span><br><span class="line">stockApi=http://weliketoshop.net/product/nextProduct?currentProductId=6&amp;path=http://192.168.0.68/admin</span><br></pre></td></tr></table></figure><p>此 SSRF 漏洞之所以有效，是因为应用程序首先验证提供的stockAPI URL 是否位于允许的域上（事实确实如此）。然后，应用程序请求提供的 URL，这会触发开放重定向。它遵循重定向，并向攻击者选择的内部 URL 发出请求。</p><h2 id="隐藏的SSRF-漏洞"><a href="#隐藏的SSRF-漏洞" class="headerlink" title="隐藏的SSRF 漏洞"></a>隐藏的SSRF 漏洞</h2><p>如果您可以导致应用程序向提供的 URL 发出后端 HTTP 请求，但后端请求的响应未在应用程序的前端响应中返回，则会出现 隐藏的SSRF漏洞。</p><p>隐藏的SSRF更难利用，但有时会导致在服务器或其他后端组件上完全远程执行代码。</p><h2 id="寻找-SSRF-漏洞的隐藏攻击点"><a href="#寻找-SSRF-漏洞的隐藏攻击点" class="headerlink" title="寻找 SSRF 漏洞的隐藏攻击点"></a>寻找 SSRF 漏洞的隐藏攻击点</h2><p>许多服务器端请求伪造漏洞很容易被发现，因为应用程序的正常流量涉及包含完整URL的请求参数。 SSRF 的其他示例更难找到。</p><h3 id="请求中的部分-URL"><a href="#请求中的部分-URL" class="headerlink" title="请求中的部分 URL"></a>请求中的部分 URL</h3><p>有时，应用程序仅将主机名或 URL 路径的一部分放入请求参数中。然后，提交的值会在服务器端合并到所请求的完整 URL 中。如果该值很容易被识别为主机名或 URL 路径，则潜在的攻击面可能是显而易见的。但是，作为完整 SSRF 的可利用性可能会受到限制，因为您无法控制所请求的整个 URL。</p><h3 id="数据格式中的-URL"><a href="#数据格式中的-URL" class="headerlink" title="数据格式中的 URL"></a>数据格式中的 URL</h3><p>某些应用程序以某种规范传输数据，该规范允许包含数据解析器可能请求该格式的 URL。一个明显的例子是 XML 数据格式，它已广泛用于 Web 应用程序中，用于将结构化数据从客户端传输到服务器。当应用程序接受 XML 格式的数据并解析它时，它可能容易受到XXE 注入的攻击。它还可能容易通过 XXE 受到 SSRF 的攻击。当我们研究 XXE 注入漏洞时，我们将更详细地介绍这一点。</p><h3 id="通过-Referer-标头进行-SSRF"><a href="#通过-Referer-标头进行-SSRF" class="headerlink" title="通过 Referer 标头进行 SSRF"></a>通过 Referer 标头进行 SSRF</h3><p>一些应用程序使用服务器端分析软件来跟踪访问者。该软件通常会在请求中记录 Referer 标头，因此它可以跟踪传入链接。通常，分析软件会访问 Referer 标头中出现的任何第三方 URL。这样做通常是为了分析引用站点的内容，包括传入链接中使用的锚文本。因此，Referer 标头通常是 SSRF 漏洞的有用攻击面。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://portswigger.net/web-security/ssrf">原文地址： 《服务器端请求伪造 (SSRF)》</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近在研究SSR，发现很多服务都会用到SSRF，所以就顺便研究了一下SSRF。&lt;/p&gt;
&lt;p&gt;下面是一篇从网络上翻译过来的文章， 大家简单参考了解。&lt;/p&gt;</summary>
    
    
    
    
    <category term="技术分享" scheme="https://www.qborfy.com/tags/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    <category term="每日更新" scheme="https://www.qborfy.com/tags/%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>重新认识一下cookie —— samesite+secure解决跨域请求cookie问题</title>
    <link href="https://www.qborfy.com/today_2024/20240813.html"/>
    <id>https://www.qborfy.com/today_2024/20240813.html</id>
    <published>2024-08-13T10:00:01.000Z</published>
    <updated>2024-08-14T09:37:11.048Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在开发微软的Teams应用，在开发过程中遇到了一个跨域请求cookie的问题，具体表现是，当我在Teams应用中登录后，然后通过iframe的方式打开一个第三方网站，第三方网站无法获取到cookie，导致无法登录。这个问题困扰了我很久，最后通过Google找到了解决方案，特此记录一下。</p><span id="more"></span><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Teams应用是在Teams的iframe中打开的，第三方网站是独立于Teams的，所以是跨域的，当我在Teams中登录后，第三方网站无法获取到cookie，导致无法登录。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>在cookie中设置<code>SameSite</code>属性为<code>None</code>，<code>Secure</code>属性为<code>true</code>，具体代码如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下配置为express-session</span></span><br><span class="line"><span class="title function_">session</span>(&#123;</span><br><span class="line">    <span class="attr">cookie</span>: &#123;</span><br><span class="line">        <span class="attr">sameSite</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">        <span class="attr">secure</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">httpOnly</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">maxAge</span>: <span class="number">86400</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">proxy</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;xxxx.sid&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>解决途中遇到的问题：</p><ol><li>如果只设置<code>SameSite</code>属性为<code>None</code>，<code>Secure</code>属性为<code>false</code>，则无法在Chrome浏览器中正常工作，具体表现是 Set-Cookie 请求被浏览器拒绝，具体原因可以参考<a href="https://www.chromium.org/updates/same-site/incompatible-clients">这里</a>。</li><li>当<code>Secure</code>属性设置为<code>true</code>，express-session中没有设置<code>proxy</code>属性，那么express不会返回<code>set-cookies</code> header信息，因为express-session默认是关闭的proxy(反向代理)，打开后才支持<code>x-forwarded-for</code>，具体原因 可以参考<a href="https://github.com/expressjs/session/issues/983">这里</a>。</li><li>express还需要设置<code>app.set(&#39;trust proxy&#39;, 1)</code>，否则无法获取到<code>x-forwarded-for</code>信息，具体原因可以参考<a href="https://github.com/expressjs/session/issues/983">这里</a>。</li></ol><h1 id="浏览器Cookie"><a href="#浏览器Cookie" class="headerlink" title="浏览器Cookie"></a>浏览器Cookie</h1><p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。Cookie 主要用于以下三个方面：</p><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>追踪用户行为（如广告跟踪、网站分析等）</li></ul><h2 id="如何设置Cookie"><a href="#如何设置Cookie" class="headerlink" title="如何设置Cookie"></a>如何设置Cookie</h2><p>Cookie 通常设置在 HTTP 头中，格式为：<code>Set-Cookie: &lt;cookie名&gt;=&lt;cookie值&gt;</code>，例如：<code>Set-Cookie: name=value</code>。</p><p>Cookie 一般是在后端设置，但也可以在前端设置，例如：<code>document.cookie = &#39;name=value&#39;</code>。</p><h2 id="Cookie的属性"><a href="#Cookie的属性" class="headerlink" title="Cookie的属性"></a>Cookie的属性</h2><p>表格如下：</p><table><thead><tr><th>属性</th><th>作用</th><th>默认值</th><th>示例</th></tr></thead><tbody><tr><td>Name</td><td>Cookie 的名称</td><td>无</td><td>name</td></tr><tr><td>Value</td><td>Cookie 的值</td><td>无</td><td>value</td></tr><tr><td>Domain</td><td>Cookie 所属域名</td><td>当前文档所在域名</td><td>example.com</td></tr><tr><td>Path</td><td>Cookie 所在路径</td><td>当前文档所在路径</td><td>/</td></tr><tr><td>Expires</td><td>Cookie 过期时间</td><td>当前会话</td><td>Thu, 01 Jan 1970 00:00:00 GMT</td></tr><tr><td>Max-Age</td><td>Cookie 过期时间（秒）</td><td>当前会话</td><td>86400</td></tr><tr><td>Secure</td><td>Cookie 是否仅通过 HTTPS 发送</td><td>false</td><td>true</td></tr><tr><td>HttpOnly</td><td>Cookie 是否仅允许 HTTP 进行操作，就是说不允许在前端JS中操作</td><td>false</td><td>true</td></tr><tr><td>SameSite</td><td>Cookie 是否仅通过同一站点发送</td><td>None</td><td>Strict、Lax、None</td></tr></tbody></table><h2 id="Cookie的优先级"><a href="#Cookie的优先级" class="headerlink" title="Cookie的优先级"></a>Cookie的优先级</h2><p>当浏览器同时设置多个同名 Cookie 时，它们的优先级如下：</p><ul><li><code>SameSite=None</code> 优先级高于 <code>SameSite=Strict</code>。</li><li><code>Secure</code> 优先级高于 <code>SameSite</code>。</li><li><code>Domain</code> 优先级高于 <code>Path</code>。</li></ul><p>如果以上几个</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html">Cookie 的 SameSite 属性</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近在开发微软的Teams应用，在开发过程中遇到了一个跨域请求cookie的问题，具体表现是，当我在Teams应用中登录后，然后通过iframe的方式打开一个第三方网站，第三方网站无法获取到cookie，导致无法登录。这个问题困扰了我很久，最后通过Google找到了解决方案，特此记录一下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="技术分享" scheme="https://www.qborfy.com/tags/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    <category term="每日更新" scheme="https://www.qborfy.com/tags/%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的修改依赖的第三方npm包代码 —— patch-package npm补丁工具</title>
    <link href="https://www.qborfy.com/today_2024/20240613.html"/>
    <id>https://www.qborfy.com/today_2024/20240613.html</id>
    <published>2024-06-13T10:00:01.000Z</published>
    <updated>2024-06-13T08:41:07.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h1 id="背后原理"><a href="#背后原理" class="headerlink" title="背后原理"></a>背后原理</h1><h2 id="npm的postinstall"><a href="#npm的postinstall" class="headerlink" title="npm的postinstall"></a>npm的postinstall</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.cnblogs.com/operate/p/16363590.html">使用 patch-package 修改第三方模块</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;h1 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h</summary>
      
    
    
    
    
    <category term="技术分享" scheme="https://www.qborfy.com/tags/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    <category term="每日更新" scheme="https://www.qborfy.com/tags/%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>《思考，快与慢》，人类到底有多理性？</title>
    <link href="https://www.qborfy.com/study/think-fast-slow.html"/>
    <id>https://www.qborfy.com/study/think-fast-slow.html</id>
    <published>2024-06-10T05:49:34.000Z</published>
    <updated>2024-09-10T05:49:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><h1 id="思考，快与慢"><a href="#思考，快与慢" class="headerlink" title="思考，快与慢"></a>思考，快与慢</h1><p>在书中，卡尼曼会带领我们体验一次思维的终极之旅。他认为，我们的大脑有快与慢两种作决定的方式。常用的无意识的“系统1”依赖情感、记忆和经验迅速作出判断，它见闻广博，使我们能够迅速对眼前的情况作出反应。</p><p>举个例子： 肚子饿了去点菜，我们点很多余点菜，然后吃了一阵子就后悔了，如果我们慢慢规划去点，发现别人都已经吃完走了。</p><p>温馨提醒：本书涉及N多经济学和心理学的专业术语，需要不断查资料去理解其术语的意思，这对经济学、心理学入门有极大的作用。</p><span id="more"></span><h1 id="阅读摘要"><a href="#阅读摘要" class="headerlink" title="阅读摘要"></a>阅读摘要</h1><ul><li>作者介绍<ul><li>丹尼尔·卡尼曼</li><li>以色列和美国双重国籍，2002年诺贝尔经济学奖<ul><li>是因为“把心理学研究和经济学研究结合在一起，特别是与在不确定状况下的决策制定有关的研究”而得奖</li></ul></li></ul></li><li>序言<ul><li>本书的目的：给读者提供更丰富精确的语言来讨论他人乃至自己在判断和决策上的失误，提升发现和理解这些失误的能力。以正确的判断去有效的干预错误，降低错误的预判和决策造成的损失</li><li>研究都是采用对话的形式进行，凭借直觉做出的答案也是共同的，同伴阿莫斯</li><li>第一，人大体而言都是理性的，其想法通常也是合理的</li><li>第二，恐惧、喜爱和憎恨的情感是人们失去理智做出的解释</li><li>可得性法则，解释人们有些事情记得清楚，有些事情却被遗忘</li><li>启发法和成见，往往能让明白有些决策即使是人在理性状态下，也能做出非常愚蠢的选择，因为其认知有限所导致的</li><li>需要明白幸运在每个成功事例中都扮演了重要的角色</li><li>两个人的智慧总要胜过一个人的想法</li><li>本书目标，展示在认知心理学和社会心理学最新发展的基础上展示大脑的工作机制</li><li>直觉思维机制对很多事情都起了很多作用，有积极一面，也有消极一面</li><li>快思考有时候无法解决很多问题，这个时候我们就需要慢思考，投入更多脑力、时间、严谨的思考解决方案</li><li>本书分为五个部分<ul><li>第一部分，通过双系统（系统1：无意识，系统2：受控制的）进行判断和做出决策的基本原理</li><li>第二部分，对判断启发法研究更新，探索了为什么很难具备统计型思维</li><li>第三部分，大脑有说不清的局限，因为对熟悉的事物确信不疑，却无法理解自己的无知程度，无法了解这个世界的不确定性</li><li>第四部分，在决策制定的性质和经济因素为理性的前提下讨论经济的原则</li><li>第五部分，研究两个自我（经验自我和记忆自我）的区别描述，两者有没有共性</li></ul></li></ul></li><li>第一部分 系统1，系统2<ul><li>第一章 一张愤怒的脸和一道乘法题<ul><li>一张愤怒的脸，可以通过直觉分辨出来，无需通过大脑慢慢思考</li><li>一道乘法算法题的过程<ul><li>能提前大概判断某些答案是错误，不是123和12609，可能是568，这就是直觉——快思考</li><li>当你开始使用公式去计算乘法，那就开始慢思考了</li><li>当你计算出结果408或者放弃思考，整个思考过程就结束了</li></ul></li><li>系统1和系统2定义<ul><li>系统1，运行是无意识且快速的，不怎么费脑力，没有感觉，完全处于潜意识状态</li><li>系统2，将注意力转移到需要费脑力的大脑活动上来，例如复杂的运算。系统2的运行通常与行为、选择和专注等主观体验相关联</li></ul></li><li>本书的重点在于研究系统1，虽然大部分的时候我们都处于系统2去做判断选择</li><li>系统1和系统2的分工很明确<ul><li>系统1负责熟悉环境、短期的推测，遇到挑战做出的第一反应也是准确的，但是也很容易犯一些成见的错误</li><li>系统2则持续控制自身，用理性思维去面对一切</li></ul></li><li>系统1和系统2有时候会产生冲突，就等于自主反应的行为， 控制自己的行为是冲突，如：你肚子饿了，想吃饭，但是你要减肥需要控制自己</li><li>系统1给人带来的错误直觉，俗称“认知错觉”<ul><li>缪勒–莱耶错觉图，从视觉上能欺骗你，视觉错误</li><li>如何用系统2去识别认知错觉<ul><li>不能长期的质疑自己的直觉</li><li>学会妥协，学会区别会出现重大错误的场景，在风险很高的时候尽力避免出现错误</li></ul></li></ul></li></ul></li><li>第二章 电影的主角和配角<ul><li>系统1才是主角，而系统2是配角<ul><li>因为系统2的很多行为都是由系统1进行主导的</li></ul></li><li>瞳孔是人类思维活动的灵敏指导器官<ul><li>瞳孔大小会随着努力程度而发生变化</li></ul></li><li>如何使得系统1和系统2平衡，然后让我们的生活更加舒适<ul><li>系统2主要负责重要事情的抉择，不过需要注意系统2如同电表一样是有极限，一旦超过极限就短路，<ul><li>系统2对某件事件的不断练习，那么付出的努力程度就会降低，从而提高某件事情处理效率</li></ul></li><li>系统1主要负责简单判断，只能单一处理事情</li><li>系统2可以处理“多重任务”—— 不仅需要看字，还要数“的”出现的次数</li></ul></li><li>从一个任务转移到另外一个任务的是需要付出努力的，简单的说需要时间适应</li><li>时间制约是人们付出努力的另外一个驱动因素，想要在更短的时间内做出更多的事情</li><li>最轻松的工作方式，就是通过最省力的思维模式去管理大脑活动，不紧不慢的朝目标出发<ul><li>将一个复杂的任务进行拆分成几个简单的任务，变成省脑力的任务</li></ul></li><li>三思而后行，指的就是系统1的直觉可能对的，也可能错的，因此需要经过系统2从头到尾思索一遍</li></ul></li><li>第三章 惰性思维与延迟满足的矛盾<ul><li>最佳散步速度，就是不刺激系统2思考，同时让系统1自然运行起进行思考问题的一种速度</li><li>人的惰性心理，会对付出努力的工作进行正常反抗，需要系统2进行管理后才能集中注意进入努力工作状态<ul><li>当然，并不是所有集中注意的工作都会引起惰性心理反抗</li></ul></li><li>“心流”状态，一种无须做出努力就能集中注意的心理状态，如下：<ul><li>当正在认真画画或写作的时候，会忘记时间，忘记自我，忘记他人的状态</li></ul></li><li>自我控制需要集中注意力，需要付出努力。<ul><li>控制思想和行为是系统2的任务之一。案例如下：<ul><li>又累又饿的面试官很可能否定掉面试offer<ul><li>因为当面试官处于饥饿状态，系统1要求其必须消除饥饿，系统2又要其思考面试者的水平，会发生冲突从而导致面试失败的概率大大提升</li></ul></li></ul></li></ul></li><li>“自我损耗(ego depletion)”，强迫自己去做某件事情，然后途中又面临新的挑战会让你无法自我控制的现象。案例如下：<ul><li>在看一部情感电影的要不准动感情，同时还要按住压力机，会让人无法控制自己</li></ul></li><li>自我损耗的前兆<ul><li>改变日常饮食</li><li>疯狂购物</li><li>反应激烈且带挑衅</li><li>对有把握的任务花费更少的时间</li><li>在做决策的时候表现很糟糕</li></ul></li><li>自我损耗其实是大脑无法同时处理完全不关联的事情导致大脑能量被消耗完（类似短跑后的肌肉内葡萄糖下降），这其中可以通过补充葡萄糖进行状态缓解</li><li>因此结论——当一个人处于疲惫或饥饿的时候，是无法理性处理系统2的任务（面试官会拒绝大部分面试者）</li><li>脱口而出的错误答案，案例：<ul><li>球拍和球一共1.10美元，球拍比球贵一美元，那么球多少钱？</li><li>直觉告诉我们，球是0.1美元，但是一旦经过系统2计算思考后，会发现球0.1美元，那么球拍则是1+0.1=1.10美元，球拍+球=1.20美元，是错误答案</li></ul></li><li>如何避免直觉错误答案呢？<ul><li>先思考一下为什么会出现直觉错误答案？原因在我们不愿意付出过多努力去思考</li><li>避免错误的最佳方式，是需要我们避免思维懒惰，激发思维活跃力，长期对自己的直觉答案保持怀疑，养成习惯后，就会长期处于理性思维状态</li><li>提高自己的控制力，简单的说就是需要将我们的集中更多注意力</li><li>这就是古语“三思而后行”的最佳应用</li></ul></li><li>惰性思考的特点<ul><li>问题1: 今天得到1000美元，1年得到10000美元，你选哪个？<ul><li>其实没有正确答案，重点在于答案是否有被你真正思考过而做出的选择</li><li>直觉答案是10000美元，因为可以获取的更多，但是1年后谁知道会发生什么呢？</li></ul></li><li>更愿意接受系统1给出的答案或选择</li><li>控制力更低，很容易收到诱惑而做出选择</li></ul></li></ul></li><li>第四章 联想的神奇力量<ul><li>联想的连贯性：所有这些都是瞬间发生的，形成一种认知、情感和生理反应的自我强化模式，这种模式变化多样又能形成一个整体<ul><li>简单的说，就是当你看到两个词语，系统1会自动帮你两个词语随意联想在一起，想象出具体的真实画面，然后引发出一系列影响</li></ul></li><li>联想的原则（苏格兰哲学家大卫·休谟）<ul><li>相似性</li><li>时空相接</li><li>因果关系</li></ul></li><li>什么是观点<ul><li>观点就是一张思想巨网的节点，可以被称为联想的记忆</li><li>观点与观点之间相互联结，一个观点的背后关联着无数其他观点</li></ul></li><li>【你觉得你很理解你自己，但是其实你是错误的】—— 你不知道你出现一个观点的背后，联想多少个其他观点<ul><li>有个简单的做法，比如你想减肥，想一想为什么想减肥，是因为想要好身材，想要健康，还是想要拍照发朋友圈，或者其他，然后接着为什么要健康，你会越问越糊涂</li></ul></li><li>启动效应，是联想机制的一种场景效应<ul><li>简单的说，比如：喝_和运动_补充文字，我们都会自然的写【喝汤】【运动场】</li><li>启动效应，等于快速启动联想，也可以引发出【涟漪效应】，从而引起无数心理学家对记忆的进一步理解</li></ul></li><li>涟漪效应<ul><li>启动联想后，大脑的思维就像在池塘里的涟漪一样向外扩展，这就是涟漪效应</li><li>案例：每次吃饭都先喝汤，等到下次要吃饭的时候，就会先等汤做完</li></ul></li><li>佛罗里达效应<ul><li>由一组系列词语想到另外压根没提到过的词语，从而影响到人的行为</li><li>案例：当一群学生正在写生，一部分让其绘画老年人，一部分画年轻人，而绘画老年人的一般行动都会变得慢起来</li></ul></li><li>概念运动效应<ul><li>由行为引起对概念的联想作用</li><li>案例：要求学生每分钟只走30步，由于速度较慢，大部分学生都会想起：老年、健忘等词汇</li></ul></li><li>诚实盒子实验<ul><li>在办公茶厅里，摆放一个自助咖啡机，每次喝咖啡需要放入1美元到盒子中，根据不同日期在盒子上放置【眼睛】或【鲜花】的图片，最终得到结果是：<ul><li>放眼睛的时候诚实盒子里的钱比放鲜花的时候多</li></ul></li><li>结论：一个象征监视符号便可以改善自身的行为，所以系统1对我们的影响往往比我们所想象的更加重要</li></ul></li><li>系统1编了一个故事，系统2相信了，那么我们就OK了<ul><li>保持微笑，能让我们心情会变得更加美丽</li></ul></li></ul></li><li>第五章 你的直觉可能只是错觉<ul><li>认知放松度——用来判断是否需要系统2提供额外帮助到刻度盘</li><li>由记忆造成的错觉<ul><li>错觉一般是从视觉错误引起，但是记忆也会造成错觉</li><li>熟悉感觉有着简单而又强烈的不可复反性，这种不可复返性说明是对过往这种经历的一种直接反应<ul><li>熟悉的特性之一：错觉</li></ul></li><li>引发认知发送和引发认知紧张的方法是相互的，因此造成<ul><li>你不清楚为什么会让认知变得放松或者紧张，是因为这是熟悉感觉造成的</li></ul></li></ul></li><li>什么样的信息更容易让人信服？<ul><li>令人感觉到放松的信息能让人更容易接受</li><li>因为系统 1让人产生熟悉， 系统 2 依据系统 1 的熟悉感去判断</li></ul></li><li>如果某个判断是基于认知放松或者紧张，那么一定会造成错觉<ul><li>任何联想机制运行更加轻松、顺利，都会造成一定的偏见</li></ul></li><li>如果需要写一则需要让人信服的消息，利用认知放松原则去帮助自己，具体做法如下：<ul><li>书写的字体应该正式，与背景色反差较大的更容易信服，如：蓝色、红色大字体</li><li>消息内容应该简洁，同时还要保持易于记忆，如：押韵，更加容易上口，大家都熟悉的知识点等</li><li>消息应该是真实准确的，而不是错误的否则会让你信服度降低</li><li>引入名人名言，可提高更多可信度</li><li>逻辑应该清晰，符合倾听人的信念或偏好，能提高认知放松</li></ul></li><li>股票代码容易读或者记住，更容易获得更高回报率</li><li>自我强化的相互作用也能在认知放松研究中有所体现，如：微笑引起认知放松，皱眉引起的认知紧张<ul><li>认知放松，系统 2 没有介入</li><li>认知紧张，系统 2 开始介入</li></ul></li><li>字体模糊更能让人认知紧张，从而引起系统 2介入，屏蔽系统 1的直觉性答案</li><li>曝光效应，就是让人不断接触到，不断重复，引起放松状态和令人舒心的熟悉感</li><li>只要不断重复接触就能增加喜欢程度的现象，是一个极其重要的生理现象，可推及所有动物身上<ul><li>一个新鲜的刺激，开始是会谨慎，如果对人没有危险，在不断重复接触下，最终就会去掉谨慎</li></ul></li><li>创新是发生在能让人无限联想的环境中的<ul><li>创新与出众的记忆力有关系</li></ul></li><li>认知放松与心情愉悦是相互作用的<ul><li>因为认知放松所以心情愉悦</li><li>因为心情愉悦所以认知放松</li></ul></li><li>因此心情愉悦下做的决策大部分都是认知放松下，系统 1的直觉性的，所以当心情愉悦时候做下的决定，更需要谨慎</li></ul></li><li>第六章 意料之外与情理之中<ul><li>联想机制的不断激活是自动完成，因此系统 2具备某种自动控制记忆和搜索的能力</li><li>从第一次惊喜到第二次的习以为常<ul><li>系统 1 的主要功能：维护并更新你个人世界的思维模式，一种常态的思维模式</li></ul></li><li>惊喜的两种形式：<ul><li>一种是期望会发生 而没法发生的事情</li><li>一种是没有期望，但是突然发生的事情</li></ul></li><li>一件大事必然会带来一些后果，而这些后果也需要一些原因对其作出解释。我们对那天发生的事情所知有限，于是系统1便熟练地将这些知识片段组合成一个连贯的因果关系。</li><li>因果关系并不依存于理性思维，它们是系统1的产物。</li><li>因果性直觉的特点是本书一再出现的主题，因为人们总是很不恰当地将因果性思考用于需要统计论证的情景中。</li><li>统计性思维总是根据事物的不同类别和总体性质得出个案的结论。</li><li>系统1缺乏统计性思维，系统2通过学习可以进行统计性思考</li></ul></li><li>第七章 字母“B”与数字“13”<ul><li>“B”与 “13”的图片展示，表明在不同的环境下，系统 1 会做出不同的判断<ul><li>如果对情况熟悉，那么系统 1  做出的判断，无论对错，都在可以承受的范围内</li><li>如果对情况不熟悉，那么系统 1做出的判断就会冒很大风险，从而犯下直觉错误，这种错误是可以通过系统 2去避免</li></ul></li><li>你做了一个明确的选择，但是却没有意识到自己这样子做了，这就是系统 1的作用<ul><li>系统 1 不会记得放弃几个选择，甚至不记得曾有多个选择</li><li>系统 2的职责是易变和怀疑，有意识的怀疑需要同时在脑子记住多种互不相容的解释</li></ul></li><li>大脑是如何产生信任的<ul><li>系统 1 的自主运作对某个陈述句也会构建出一种最大可能性的解释，如：白鱼吃糖果</li><li>系统 2 的工作是怀疑/不信任，但是当人在疲惫劳累状态，系统 2 往往无法工作，更加容易被说服相信一些空洞的话术</li></ul></li><li>光环效应与群体的智慧<ul><li>光环效应：喜欢一个人，就会喜欢这个人的一切，如：衣着和声音等</li><li>系统 1 可以通过很多比现实更加简单却连贯的方式来表现这个世界</li><li>对一个人的观察顺序是随机，但是顺序却很重要，因为光环效应注重第一印象，而后续信息很大程度被消解了</li><li>老师对学生作业评分也是光环效应的一个例子，这也是为什么应试教育标准答案一直无法改变的原因之一</li><li>如何避免光环效应对我们的影响：<ul><li>采取的避免光环效应的评卷方法遵循了一个普遍原则：消除错误的关联！</li><li>想要从大量证据来源中获取最有用的信息，你应设法使这些来源相互独立。这也是警察办案时所遵循的规则。</li><li>如何节省开会时间，在开始讨论某个问题之前，先让与会的每一位成员各自写下简短的意见<ul><li>避免开放式发言和强势的人意见，使得大部分人都跟随其意见</li></ul></li></ul></li><li>眼见为实的想法让我们仓促做出决定</li><li>联想机制一个最基本的结构特点就是它只能回忆起已被激活的观点。</li><li>衡量系统1是否成功的方法是看它所创造的情境是否具有连贯性，而与故事所需数据的数量和质量关系不大。</li><li>寻找连贯性的系统1和懒惰的系统2相结合，意味着系统2将会赞同许多直觉性的信念，而这些信念又准确地反映了系统1产生的印象。 </li><li>在证据不足到情况下过早下结论对我们理解直觉性思考非常有帮助，一个缩写WYSIATI， “What you see is all there is”</li><li>知道得很少反而可以把已知所有事物都囊括进连贯到思维模式中。</li><li>眼见为实到理念有助于达成连贯性和认知放松的状态，从而让我们相信某个陈述是真实到。</li><li>框架效应、比率忽略等</li></ul></li></ul></li><li>第八章 我们究竟是如何作出判断？<ul><li>系统1以不同的方式运行，不断监视大脑外的一切，提供基本的评估给到直觉性判断，系统2则是调用注意力和通过搜索记忆去寻找答案，提供判断。</li><li>启发法和偏见研究方法的基础理念： 系统1的直觉性判断</li><li>系统1的特点：<ul><li>具备跨维度解读价值观的能力</li><li>没有特定意图的评估一切</li></ul></li><li>直觉性判断可能会影响候选人到底能否成功获得选举<ul><li>自信的微笑 + 方方的下巴</li></ul></li><li>判断启发法，</li><li>与强度等级匹配到描述，是系统1的新能力<ul><li>系统1能根据不同的强度去匹配不同的描述</li><li>如：杀人等于红色，小偷则是浅红色</li></ul></li><li>思维的发散性让我们做出直觉性判断<ul><li>结合思维的强度匹配，就可以解释我们对自己不了解的事情可以作出直觉性判断</li></ul></li></ul></li><li>第九章 目标问题与启发性问题形影不离<ul><li>面对很多事情或者问题，我们都能很快有直觉的想法，也能作出答案</li><li>因为我们针对一些没有遇到的问题或者更加复杂的问题，去想类似更加简单的问题去回答</li><li>这就是启发法，而针对目标问题，我们总能想到其相关到启发式问题（更简单的问题）</li><li>用一个更加简单到问题替代原来复杂到问题，是一个解决难题到好策略</li><li>思维的发散性可以使懒惰到系统2摆脱繁重的工作，快速找到难题的答案<ul><li>如何理解这一点，思维的发散性就是让人产生联想，从而启发到更多的可能性</li></ul></li><li>立体启发法： 远处到物体看上去更高大<ul><li>立体大小替代平面大小氏自主发生的</li></ul></li><li>同用的问题，通过顺序替换就可以得到不一样的关联关系<ul><li>你最近幸福吗？ 你上个月约过多少次约会？ —— 幸福与约会次数无关</li><li>你上个月约过多少次约会？ 你最近幸福吗？ —— 幸福与约会次数成正比</li></ul></li><li>情感启发式：因为喜欢，所以认同<ul><li>为什么喜欢了就会认同，是因为系统2虽然是最高决策地位，可以抵制系统1的建议，但是更多时候系统2是系统1的赞许者而不是批评者，</li><li>系统2搜索记忆和复杂计算的启发，都是源自系统1</li></ul></li></ul></li><li>第一部分总结：<ul><li>系统1自主快速运行，只需要付出较少努力，甚至不需要努力思考，没有自主控制的感觉</li><li>有时候用简单点到问题替代难题（启发法）</li><li>为联想记忆激发出来到各种想法创造连贯形式</li><li>系统2的长期思考训练会形成系统1的直觉反应</li><li>真正去计算，而不是空想（思维发散性）</li></ul></li></ul></li><li>第二部分 启发法与偏见<ul><li>第十章 大数法则与小数定律<ul><li>系统1非常擅长一种思维模式，自动且毫不费力地识别事物之间的因果关系，即使这种关系根本不存在</li><li>系统1对于纯统计学到数据时候是束手无策的</li><li>一个随机事件是不需要解释的，但一连串的随机事件就有规律可循</li><li>大数法则是大样本的数据比小样本的数据得出规律更加精确，但是为什么更精确的原因是什么？</li><li>小样本到出错风险可能高达50%</li><li>评估大样本和小样本的依据是什么？需要用到统计学的相关知识去确定样本数据的数量和范围</li><li>小数定律指的是随机取样的直觉会让数据更加容易找到定律，从而断言大数法则复合小数定律<ul><li>简单的说，就是从小数获取到的定律，让人盲目相信即使使用大数据去统计也能得到相同到规律</li></ul></li><li>信任多于质疑到普遍性偏见<ul><li>人们对于样本大小没有足够的敏感性</li><li>因为系统1并不善于质疑</li><li>小数定律就是普遍性偏见到一种表现，就是对事物的信任大于质疑，从而导致就是相信小样本数据能反映调查对象的整体情况</li></ul></li><li>对随机事件作出因果解释必然是错的<ul><li>联想机制是会搜寻原因的，即使这个是错误的</li><li>对于随机性的广泛误解有时会带来重大影响</li></ul></li><li>小数定律包含在大脑工作的两个重要部分：<ul><li>夸大对小样本的信任只是众多错觉中一种</li><li>对偶发事件做出因果关系解释必然是错误的</li></ul></li></ul></li><li>第十一章 锚定效应在生活中随处可见<ul><li>什么是锚定效应<ul><li>人们在对某一未知的特殊价值进行评估之前，总会事先对这个量进行一番考量</li><li>例子：下高速后会保持一段时间高速行驶</li></ul></li><li>为什么会有锚定效应，因为对锚定值的调整通常是不足的</li><li>如：孩子会把音乐调很大声，家长却觉得很吵闹，这是因为家长忽视了孩子的真心需要，自己需要作出调整，对音乐的锚定值作出调整</li><li>什么是调整？ 调整就是刻意去寻找离开锚定数字的理由，而且是一项需要付出努力的活动</li><li>调整不足是软弱或者懒惰的系统 2 的一种失误</li><li>暗示是一种锚定效应，是一种启动效应，当你开始联想记忆，就会启动系统 1 去选择性激活从而产生一些误差</li><li>锚定效应的两种类型：<ul><li>研究手法</li><li>理论观念</li></ul></li><li>系统 1 试图建立一个将锚定数字视为真实数值的世界</li><li>选择性记忆激发解释了锚定效应，如大小不同的数字能激发起记忆中不同的观念体系</li><li>锚定效应在生活中的应用：<ul><li>如何给商品定价，能让商品价格更符合客户的接受程度</li><li>如何给拍卖物品定价</li><li>…</li></ul></li><li>如何确定锚定效应的适应性：<ul><li>锚定效应解释了饥饿营销的有效性，也就是限量销售</li><li>抵制锚定效应在商品谈价中的影响，激活系统 2 中的记忆来抵制锚定效应，简单的说就是通过搜索大脑关于商品的定价，减少因为锚定效应导致的数字影响</li></ul></li><li>随机锚定效应让我们更加了解系统 1 和系统 2 之间的关系<ul><li>判断选择是锚定效应的结果，因为虽然判断选择是从系统 2 完成的，却是依据系统 1 进行自主的无意识的运行，而系统 1 是很容易受锚定效应影响，影响是因为某些记忆更容易让人回想，这也是为什么广告词需要更让人容易记住</li></ul></li><li>如何利用锚定，引导锚定的影响，让我们更好的思考：<ul><li>放大锚定效应的影响，任何数字都可以会影响你，所以你需要抵抗一些常见数字</li><li>如：炒股中，中国人最受影响的是 6、8 或者 5 整数倍数，看来起来更加友好的数字，那么你不应该买这类数字结尾的，如同对 4 数字的不友善，反而更应该接受，或者其他随机数字，同时你需要观察收盘的数字，观察主力对数字的敏感度</li></ul></li><li>锚定效应的使用，给对方一些锚定值，不单单只是数字，还包括一些方案，同时要抵抗对方给到我们的一些锚定效应影响，去反向思考一些可能性</li></ul></li><li>第 12 章 科学地利用可得性启发法<ul><li>什么是可得性启发法？<ul><li>估计某类事件出现的频率，大脑是怎么运作的，就是启发法</li><li>从记忆中搜寻这类问题的实例，以搜索过程的轻松程度判断概率的可过程，叫做可得性启发法</li></ul></li><li>轻松，需要大脑搜索多少个实例为标准</li><li>可得性启发法，用一个问题替代另外一个问题，用来作为决策的判断依据</li><li>意识到自己的偏见有利于团队的关系融洽，如何理解？<ul><li>可得性偏见，如：明星出轨、飞机意外、亲身经历的图片等</li><li>抵抗这么多偏见会让你身心俱疲，因此所有的偏见都不是坏的，有些偏见更加有利于关系融洽，如：夫妻评价对方</li></ul></li><li>可得性偏见影响我们对自己，或者他人的看法<ul><li>自我评估是由事件呈现在脑海中轻松程度来衡量</li></ul></li><li>可得性偏见是一种心里悖论，对事情越有意见，表示也看重这个事情<ul><li>学生对课堂的建议越多，对课堂评价越高</li></ul></li><li>判断涉及自身情况的人往往更有可能关注他们从记忆中提取的事件数量，对轻松程度不太关注</li><li>我没有满世界做民意调查来告诉自己怎么做才对，知道自己的感受就够了</li><li>可得性启发表明，对直觉的依赖只是个人品行特征的一部分，提醒人们，相信人品等于相信人们对于自己的直觉</li></ul></li><li>第 13 章 焦虑情绪与风险政策的设计<ul><li>可得性效应，能解释对买保险后的行为模式和灾难后的保护性行为模式，如：每次灾难后，人们都会去买保险或者做一些预防行为去形成自我保护和减少损失</li><li>问题：被闪电击中和食物中毒哪个意外致死率更高？<ul><li>计算概率，直觉性思维会觉得食物中毒概率会更高，但是事实却是闪电击中后的致死概率是中毒的两倍以上</li></ul></li><li>作出判断或决策会受情绪影响，如：喜欢、恨、感觉强烈程度等等因素<ul><li>情绪启发是替代问题回答思维模式的一种，如：简单的问题是我对它感觉如何，而情绪启发思维模式往往会让你回答，我对它的评价如何？</li></ul></li><li>可以通过一些知识传播影响人们的感性认知，从而影响人们对某项技术的风险判断，如：发布会的宣讲等等</li><li>如何避免小概率的风险事件变成公共危机？<ul><li>人们是感性而非理性，容易被琐碎细节左右，如：当专家提出与非专业性判断有偏差的时候，应当遵从“双方必须尊重对方的见解和智慧”，因为风险是客观的</li><li>还有一种观点是， 专家是抵制大众越轨的壁垒，从而导致政府提出一些政策对风险的认知有偏差，而这种政策就叫偏见植入政策，专业术语是“效用叠层”</li></ul></li><li>效用叠层，是一连串的自持事件，可能开始于相对次要的媒体报道，从而引发群众恐慌和大规模政府行动<ul><li>简单的理解，就是由于政府对于大众理解有偏差，出台一系列不符合政策，被媒体一开始报导后引发的一系列事件</li><li>根本原因在于政策定制者不能代表大众的利益，忽略普遍存在的大众情绪思维，从而引发大众抵制政府出台的决策</li><li>效用叠层的现象就是媒体大肆报导和宣扬那些还没有真正发生的事情</li></ul></li></ul></li><li>第 14 章 猜一下，汤姆的专业是什么<ul><li>简单的问题：汤姆的专业是工商管理、计算机、法学、医学、社会科学等？<ul><li>大脑直觉思路，根据专业招生规模去统计，判断最有可能的概率选择，这就是基础概率比较</li></ul></li><li>依据典型性作出预测是下意识的行为<ul><li>在有典型性描述的证据，大家都会忽略基础概率的比较，比如：刻意描述汤姆的性格更加偏向理科，那么我们的大脑会忽略基础概率比较，直接偏向理科专业</li></ul></li><li>去解释某个词的含义是比较困难的</li><li>通过典型性去做判断决策是正常的，但却不是最优选择（站在统计学的角度）</li><li>典型性启发的两个错误：<ul><li>过于偏向预测不可能发生的事情，如：在地铁里阅读书籍的人，是有博士学位，还是没大学文凭的人</li><li>对证据或数据的质量不够敏感，如：没有被验证的描述的汤姆语句会影响我们对汤姆专业的判断</li></ul></li><li>如何避免典型性判断思维<ul><li>用贝叶斯定理去约束思维模式</li><li>基础比较概率非常重要，即使目前已有证据</li><li>质疑你对证据的分析</li></ul></li></ul></li><li>第15章 琳达问题的社会效应<ul><li>琳达的描述让其看起来更像一个女权主义者，而不是银行出纳<ul><li>因此给出的选择中：<ul><li>银行出纳</li><li>一个女权主义的银行出纳</li></ul></li></ul></li><li>正常思维下，我们往往会选择【一个女权主义的银行出纳】，但是这个的概率往往会比【银行出纳】的概率低<ul><li>这又违反了概率思维的逻辑</li></ul></li><li>这种思维模式，叫做“合理谬误”<ul><li>这也是典型性判断和概率性判断最佳实践案例，典型性判断更符合大脑思维</li><li>人们更加愿意相信更加详细描述的情节，如：<ul><li>马克有长头发</li><li>马克有金色的长头发</li></ul></li></ul></li><li>少即是多的逻辑悖论<ul><li>A套餐具比B套餐具多了几个，但是B套餐具是完整，所以哪怕A套价格低，数量更多，那么大多数人会更加愿意选择B套</li><li>这个逻辑同时也解释了为什么大家更加愿意选择【琳达是女权主义的银行出纳】，因为大家更加愿意相信完整的信息</li><li>背后的也是因为系统2的惰性，导致我们大脑直接通过系统1直觉判断的原因存在</li></ul></li><li>在实际生活，关注弱点是辩论中非常重要的思维模式， 也是律师辩论去让证人受到怀疑<ul><li>一个非常贵重的东西，赠送一个便宜的东西，那么这个东西也就没那么贵重了</li></ul></li></ul></li><li>第16章 因果关系比统计学信息更有说服力<ul><li>案例：一个证人说肇事车辆为蓝色，证人正确概率为80%，而数据统计：绿色车辆占85%，蓝色车辆占15%，那么肇事车辆是蓝色的概率为多少？<ul><li>正常思维，相信证人的概率， 忽略基础数据的概率， 得出概率80%</li><li>基于贝叶斯公式：P(A|B) = P(A|B)*P(B)/P(A)，应该结合两者的概率去计算，同时需要第三者统计概率为：证人说法得到验证为正确率<ul><li>P(A)为 正常情况无证人下，车子为蓝色正确率15%</li><li>P(A|B)为 证人说法得到验证为正确率 80%</li><li>P(A) 为 所有证人说法得到验证为正确率</li></ul></li></ul></li><li>因果关系基础比率会改变人的看法<ul><li>如：车子为绿色肇事概率为85%，那么你会觉得绿色车肇事概率更高</li></ul></li><li>忽略统计基础概率，有了因果关系概率后，就会更加容易忽略</li><li>因果关系有说服力，是因为我们有思维定式<ul><li>思维定式=系统1在大脑形成的范畴规范和原型范例</li><li>系统1更加适应因果关系的，更容易处理因果关系的事情</li></ul></li><li>我们并没有想象中那么乐于助人<ul><li>容易赋予个人典型特征</li><li>情境容易影响一个人的思想结果</li><li>受试者不愿从普遍现象中推导出特殊性，如同他们愿意相信从特殊性归纳出普遍性</li></ul></li><li>用因果关系进行解释统计学结果对想法的影响更大</li><li>因此，统计学信息的结果难以影响大家，但是它会变成普遍规律的可信过程中</li></ul></li><li>第 17 章 所有表现都会回归平均值<ul><li>技能训练原则：奖励良好表现比错误惩罚更有用<ul><li>教练的反对观点：惩罚做的不好比奖励良好表现更有用，因为惩罚后，下一次的表现会变得更好</li></ul></li><li>原因：<ul><li>因为教练把随机的良好表现与因果解释关联在一起</li><li>表现好的不是固定的，而表现不好是因为下一次有进步空间，这和奖励惩罚没有任何关系</li></ul></li><li>思维窘境：人类环境中一个意义重大的事实：生活给予我们的反馈常常违背常理。<ul><li>正常生活思维，当有人对我们好，我们也会对其友好， 但是当有人对我们不好，我们也会对其不好。</li><li>但是从统计学角度看结果，却是对人好得到惩罚，对人不好得到奖励</li></ul></li><li>第一次表现与第二次表现没有关系<ul><li>因为从多次表现去统计，所有的结果都是回归平均值，这就是回归效应</li></ul></li><li>回归现象的发现意义不亚于万有引力</li><li>相关性和回归性并非两个概念，而是对同一个概念做出的解释<ul><li>只要两个数值之间的相关度不高，就会出现回归平均值的情况</li><li>案例 1： 聪明的女人往往会嫁给不聪明的男人，因为结婚与智商的关系无关，但是为了解释这一现象人们往往通过因果关系去描述这一现象</li></ul></li><li>回归效应，是统计学中一个重要的概念，解释了为什么统计结果会偏离预期<ul><li>解释了为什么第一次表现好的，往往后面表现会变差，因为第二次表现会回归平均值</li></ul></li></ul></li><li>第 18 章 如何让直觉性预测更加恰当有效<ul><li>现实生活中，有很多场景都需要预测，如：建筑需要预测多少袋水泥？投资的风险预测？等等<ul><li>那么如何做到让直觉性预测更加恰当有效？</li></ul></li><li>系统 1的几个机制参与了预测：<ul><li>搜索证据与预测目标的因果关系</li><li>证据的评估与相关规范的紧密联系</li><li>这就是通过问题和信息引起的联想记忆</li></ul></li><li>偏离预测方向的直觉，通过强度匹配和替换思维去让我们直觉预测发生偏差<ul><li>很多直觉都让我们偏离预测方向，就是说我们的直觉会让我们的决策出现偏差</li></ul></li><li>如何对直觉性预测进行修正<ul><li>步骤 1 找到基准线，也就是回归大众的平均点</li><li>步骤 2 根据直觉+证据，找到预测目标的平均点</li><li>步骤 3 评估证据与平均点的关联关系，按照百分制</li><li>步骤 4 最后判断直觉预测平均点与平均点的对比，判断预测的正确性</li></ul></li><li>直觉性预测需要校正是由于它并不具有回归性，因此是带有偏见的。</li><li>直觉预测是允许的，只是需要修正，所以我们不能完全禁止直觉预测<ul><li>当你的信息不足的时候，直觉预测是允许的</li></ul></li><li>替代的运行机制，会将极端获取的信息与极端预测目标做关联匹配，从而让你相信你自己的判断<ul><li>如：投资两家公司，当你对一家公司信息完全掌控，一家公司信息不透明，那么你会认为不透明的公司反而更加具有投资性，因为直觉预测会让你认为不透明的公司的不可预测性会成长的更好</li></ul></li><li>回归平均值，需要系统 2 进行特殊的训练，但是往往我们又会通过因果关系去错误描述平均值</li></ul></li></ul></li><li>第 3 部分 过度自信与决策错误<ul><li>第 19 章 “知道”的错觉<ul><li>“叙事谬误”的概念，用来描述存有缺憾的往事是如何影响我们的世界观和我们对未来的预期的。</li><li>知道的错觉就是“叙事谬误”的一种表现，人们往往通过结果去给自己的行为进行错误的解释</li><li>知道的错觉还有一种表现，就是眼见为实，其实就看到结果，然后通过结果去证明因果关系<ul><li>这个错觉的核心是我们认为自己了解过去，这也表明未来也应该是可知的，但事实上，我们对过去的了解比我们自认为能够了解的要少。 </li></ul></li><li>当你接受一种新的观点，那么你无法回忆起之前的认知，因为记忆会随着时间而改变。<ul><li>你无法重构过去的想法，这种情况会不可避免地导致你低估自己受往事影响的程度。   </li><li>如：当你观看一场比赛前，你预估 A 队会赢，但是 A 队最终输了，你很难想起为什么之前会预测 A 队会赢。</li></ul></li><li>后见之明，俗称马后炮，当结果越严重，那么马后炮的人会更加确信自己的判断</li><li>系统 1 的意义构建体系，会让我们相信世界是可预测，更简单，更整洁的<ul><li>简单的理解，就是更加努力和更加智慧，会更加容易获得成功</li></ul></li><li>企业长青的秘诀，大部分书籍都是说的智慧和勇气<ul><li>企业的发展与领导者和管理措施有关系，但是也不大</li><li>大部分畅销的经济书籍都推崇，夸大领导风格和管理措施对公司业绩的影响</li></ul></li><li>不要带结果偏见，即使这个偏见有时候有用的，但是这个偏见是愚蠢的</li></ul></li><li>第 20 章 未来是不可预测的<ul><li>系统1是在信息有限的情况得出的结论，而这种结论过程很复杂，基于眼见为实和逻辑的连贯性。</li><li>士兵测评案例的错觉 —— 有效性错觉<ul><li>仅仅根据某个场景去对士兵去做评测，是有效的，但却是错误的评测</li></ul></li><li>投资股票的技能错觉<ul><li>股票第一疑问：是什么让人觉得卖了的股票，有人愿意买？双方都觉得当前股价有问题，太高或者太低</li><li>股票交易股票后比上一支股票获得收益更高的概率平均值是3.2%，这个时候就需要考虑回归平均这个概念</li></ul></li><li>股票市场中，不管是业余还是专业的投资者，都很难预测股票市场，因为股票市场是随机波动的</li><li>主观自信与专业知识给错误直觉提供生存的土壤<ul><li>认知错觉比视觉错觉更加固执</li><li>认知来自人的强大专业知识</li></ul></li><li>短期走向是可以预测的，准确率会比较大，而长期的走向是不可预测，即使有再多的证据</li><li>股票投资者大部分人都认为市场是可以预测的，且自己比其他预测更加准确<ul><li>专家的解释往往是在事情发生后详细阅读整个事件发展过程，才按照自己的理解逻辑，用一种因果关系逻辑去解释</li></ul></li></ul></li><li>第 21 章 直觉判断与公式运算，孰优孰劣<ul><li>保罗米尔，通过临床计算预测后续医疗结果</li><li>专家预测比不上简单运算准确<ul><li>案例：阿什菲尔特通过天气三个特征计算葡萄酒的未来价格，十分准确</li><li>为什么：<ul><li>专家总是想要更加聪明，增加了很多复杂因素计算，从而忽略原则性的原因</li><li>人们对于复杂的信息最终难以统一判断</li></ul></li><li>要提高预测的准确度，最终应该统一公式</li><li>闭上眼睛的直觉判断比主观判断更加准确<ul><li>原因：按照规定收集客观信息并对不同特征进行打分</li><li>因为主观印象会影响我们对其结果的判断</li></ul></li></ul></li></ul></li><li>第 22 章 什么时候可以相信专家的直觉<ul><li>直觉是否成为判断的依据，最终的成功与失败的界限<ul><li>判断一个艺术品是否为真品，往往就在眨眼间</li></ul></li><li>决策定制理论，预知认知决策模式，直觉判断就是这么一种思考模式<ul><li>第一阶段，通过系统1联想记忆制定一个计划</li><li>第二阶段，在系统2针对这个计划去确认是否有效</li></ul></li><li>如何锻炼专家型直觉<ul><li>学习需要一定的反复强化，直到形成记忆</li><li>情感学习会让学习变得更加容易</li><li>记忆是有意识的，可以解释你面对问题的情绪</li></ul></li><li>什么时候可以相信专家<ul><li>当环境或者信息是有规律可循的场景，你应当相信专家，如：消防员、临床护士和其他专业知识的专家</li></ul></li><li>如何练习专家直觉<ul><li>一个可预测、有足够规律可循环的环境</li><li>一个通过长期训练练习这些规律的机会</li><li>参考案例：象棋</li></ul></li><li>专业技能不是单一技能，而是由许多技能组成的，因此专业也存在局限性</li><li>专家直觉的局限性：<ul><li>在一个不够规律或者不符合规律判断的环境里，直觉判断就无法有效判断</li></ul></li></ul></li><li>第 23 章 努力养成采纳意见的决策习惯<ul><li>内部预测完成一个项目所需要花费时间？<ul><li>内部预测大约是1年半～2年</li><li>外部团队在通用条件， 平均完成这个项目所需要花费的时间是5年～7年</li><li>很多时候我们以为清楚我们自己的状况，和外界所给予的判断结论是完全不一样的</li></ul></li><li>预测的方法：<ul><li>两种预测方法，一种是内部，一种外部</li><li>最初的预测往往是错误的，因为没有经过内外部的再次验证</li><li>非理性坚持，面对选择时，由于各种原因导致失去理性去坚持做一件事情</li></ul></li><li>比起外部预测，我们往往更加相信内部预测<ul><li>一开始内部预测是正确的，因为开始的数据和信息都是我们能掌握到的</li><li>但是未来的数据信息是不可预测的，所以内部预测会变得不准确，因而会更加依赖外部预测</li><li>外部预测不是100%准确，需要符合当前条件的数据参考，更加依赖外部预测来源</li><li>更相信内部预测往往更加符合人们的道德心理</li></ul></li><li>规划谬误：过于乐观的计划<ul><li>不切实际的让所有条件都处于理想状态</li><li>通过参考类似情况进行规划</li><li>如建筑一栋楼的预算，往往会随着时间的迁移而发生变化</li></ul></li><li>减少错误决策的有效方法<ul><li>明白为什么会发生错误决策，是因为看轻或是忽略分布信息的普遍趋势</li><li>计划者应该尽力划分出预测问题的类别，这样才能充分利用所有能够获取的分布信息。</li></ul></li><li>参考类别预测<ul><li>识别对应的参考类别，如：厨房改建、大型建筑项目等</li><li>获取参考类别的统计数据，利用这些数据作为基准参考</li><li>有特殊特别的原因会比参考类型偏差，可以使用此特别信息对去预测进行调整</li></ul></li><li>高管提出乐观的计划往往忽略可以规避的困难，因此需要控制高管的计划能力</li><li>预测课程项目的主要意义：<ul><li>没有参考类似项目经验</li><li>意识到自己的无能</li><li>往往会忽略外部意见</li><li>不愿意思考正在发生的事情</li></ul></li><li>最终总结，更加明智的去听取外部意见，需要刻意训练形成的思维模式</li></ul></li><li>第24章 乐观是一把双刃剑<ul><li>规划谬误是普遍存在的乐观偏见的一种表现形式<ul><li>以为世界很美好，但是世界并没有想象中那么美好</li><li>以为自己贡献很大，但是其实没有那么大</li><li>夸大自己的预测能力，但是未来总是未知</li></ul></li><li>乐观心态的人有以下几个特征：<ul><li>开朗快乐，认为自己是幸运的</li><li>对失败有更多的承受力</li><li>注重身体，免疫系统能力高</li></ul></li><li>做一个乐观但是不脱离实际的强调积极情绪的乐观主义者，才能更好享受乐观的好处</li></ul></li></ul></li><li>第四部分 选择与风险<ul><li>第 25 章 事关风险与财富的选择<ul><li>人不会完全理性或完全的自私</li><li>心理学和经济学分别研究的是：人类和经济人</li><li>面对风险，我们都不是理性的经济人<ul><li>在不同的简单风险之间和在有风险与确定的事情之间，是什么在控制人们的选择？<ul><li>简单的风险：40%赢得 100 块， 100%获取 10 块，会如何选择？</li></ul></li><li>决策理论：研究人们如何在风险之间做出决策的理论一句<ul><li>期望效用理论：理性代理模式，基于理性的基本原则做出决策</li></ul></li><li>前景理论，待阅读文章《前景理论：风险下的决策分析》？</li><li>框架效应：由无关紧要的措辞变化引起的巨大偏好变化</li></ul></li><li>伯努利的财富效应：通过一个函数去将心理强度与刺激大小关联起来，如：对心理价值和金钱的欲望与钱实际数量的之间的关联关系<ul><li>人们做出的各种选择并非与金钱价值关联，而是基于各种心理价值，就是做出这个选择能得到的成就感（效用）</li><li>财富的边际价值递减现象，越大的财富对于增长的期望与风险的压力是相对的，如：100 万赚 300万，等于 300%，这个时候对于风险的抗压力强，如果时候 1000 万赚 300 万，等于 30%，这个时候对风险抗压力小</li><li>这就是保险公司的心理理论依据，当穷人 100 万损失 30 万等 30%，而富人1000 万损失 30万等于 3%</li></ul></li><li>伯努利财富效用的错误：<ul><li>当穷人从 100 万赚到 500 万和富人从 1000 万亏到 500 万，那么穷人和富人财富一样，他们是否一致心理价值呢？</li><li>因此，伯努利财富效应应该从近期变化去证明，而不是依据当前财富作为依据</li></ul></li><li>从伯努利财富效应理论的错误中发现：<ul><li>理论诱导的盲区(theory-induced blindness)，即一旦你接受了某个理论并将其作为一个思考工具，就很难注意到其错误。</li></ul></li></ul></li><li>第 26 章 更人性化的前景理论<ul><li>效用是伴随财富的变化出现的，而不是伴随财富的各种状态出现的。</li><li>面对财富，你会选择规避风险还是冒险一博？<ul><li>面对盈利和亏损，即使获得的财富值是一样的，但是做出的选择是不同的<ul><li>选择 1：给你 1000 块，100%再获得 500 块，50%获得 1000 块？ 大部分选择获得 500 块，100%获得 1500 块</li><li>选择 2：给你 2000 块，100%损失 500 块，50%损失 1000 块？大部分会选择 50%损失 1000 块，即使100%损失 500 块， 最终也是 1500 块</li></ul></li><li>伯努利理论的弱点：缺失初始依据参考，无法准备评估最终的得失选择。</li></ul></li><li>前景理论的三个认证特征 = 系统 1的运行特征<ul><li>参照点，适应水平</li><li>降低敏感度的原则，财富变化和感觉纬度是一样的</li><li>损失厌恶，损亏比盈利影响更大</li></ul></li><li>损失厌恶：人们对亏损比盈利反应更多<ul><li>做出选择，必须平衡盈利和亏损</li></ul></li><li>“失去比得到给人的感受更强烈”，因此人们往往会规避损失。这也是大多人不愿意去冒险</li><li>像一个商人去思考，或者像一个经济人思考，去降低损失厌恶系数</li><li>前景理论无法应对令人失望的事<ul><li>前景理描述的是：影响人们情绪的是得失，而不是最终获取多少财富</li><li>但是无法描述后悔情绪，因为后悔情绪是另外一种参照点</li><li>后悔这种体验依赖于你本应该采取却没有采取的意见</li></ul></li></ul></li><li>第 27  章 禀赋效应与市场交易<ul><li>所有缺失参考点的理论会陷入一个错误：<ul><li>拟定各项事务状态的效用只依赖于该状态本身，并不受过往的影响。</li></ul></li><li>人们为什么不愿意割舍自己拥有的东西？<ul><li>禀赋效应：人们往往会高估自己拥有的东西</li><li>为什么：因为损失厌恶的理论，得到是乐趣，而失去比得到影响更加强烈</li><li>但是禀赋效应并没有普遍性，如：商品等价交换</li><li>因此引发另外一个问题：R 教授不愿意出售葡萄酒和市场交易的区别？</li><li>交易实验：所有代币都集中到那些能从实验人员那儿拿到最多钱的受试者手中。市场魔力显神威！<ul><li>金钱或商品：最终会流入对其作用最大的人群中，简单的说，如果金钱在你手中能发挥最大作用，那么金钱会不断的流入你的手中</li><li>得出区别的原因：<ul><li>正常商品交易：如果“买方”不觉得花钱买下这个杯子是种损失的话，这个相似的现金值便与我们的预期正相吻合。</li><li>非正常商品交易：当卖方觉得这个杯子卖掉是一种损失，就会持续持有</li></ul></li></ul></li></ul></li><li>像商人一样思考和交易<ul><li>理性的代理人来说，从前的买价与自己根本就不相干——当前的市场价值才是最重要的。</li><li>而现实中的人来说，高价购买的房子的业务希望以更高的房子卖掉</li><li>如何让禀赋效应消失：<ul><li>经常交易可以降低禀赋效应</li><li>长期拥有一个商品，大概率会出现禀赋效应</li><li>商人思考点：与可以得到的其他东西相比，那个杯子真的是我特别想‘得到’的吗<ul><li>有了这个问题，禀赋效应就不复存在了，因为得到的快乐和放弃的痛苦之间的不对称性没有关联。</li></ul></li></ul></li><li><strong>对于穷人来说，花钱就意味着损失。</strong><ul><li>买不同的商品就是不同的损失，只是哪个损失比较少一点</li></ul></li><li>因此商人思考模式对于某些人并不符合，但是对于炒股的人更加适合思考</li></ul></li></ul></li><li>第 28 章 公平性 —— 经济交易的参照点<ul><li>将损失厌恶与大脑双系统模式相结合进行研究</li><li>威胁仍然优先于机遇，即使是对纯粹象征性的威胁，大脑的反应也很迅速。</li><li>负面情况在众多方面都可战胜正面情况，而且损失厌恶是负面占优势的典型例子之一</li><li>人们更加愿意避开负面的定义和情绪，比追求正面情绪还要强烈</li><li>生理状况的重要改善，能影响人们的短期情绪变化</li><li>目标就是参照点<ul><li>损失厌恶系数指的是两种动机的相对强度：我们想要规避损失的动机要强于获得利益的动机。</li><li>设定短期目标后，接近目标后就会慢慢变懒惰，因为目标接近后不是用来超越的，就是一个参照点</li></ul></li><li>我们为什么不愿意改变现状<ul><li>因为避免损失的动机和获得收益的动机强度并不对称</li><li>当蛋糕足够大，那么所有人都会变得随和</li><li>所有动物（包括人）都想有所得，但他们会更努力地避免有所失。</li><li>损失厌恶是一种强大而保守的力量，保守主义会让我们的生活保持稳定，是引力作用让我们的生命无限靠近参照点。</li></ul></li><li>商人提价或降低员工工资行为公平吗？<ul><li>公平性的一条基本原则是：不可利用市场的力量将损失强加给他人。</li><li>公司有其自身的权利，即保持当前的收益。</li><li>对当时经济学家们公认的知识的挑战，即经济行为是受自身利益驱使的，而与是否公平无关。</li><li>如果遭受损失的人比没能赢利的人遭受更大的损失，他们也许应该得到更多的法律保护</li></ul></li><li>损失厌恶和权利的影响</li></ul></li><li>第 29 章 对结果可能性的权衡<ul><li>对某个复杂情况的决定，一般会有一个总体评估，主要对复杂情况进行抽象化成几个特征。<ul><li>总体评估都是由系统1作出的</li></ul></li><li>可能性效应与确定性效应<ul><li>赌注是通过其预期值加以评估的。</li><li>从零到5%的巨大转变表明了“可能性效应”(possibility effect)，这一效应会是我们高估那些出现可能性极低的结果的发生频率。</li><li>从95%提升到100%是另一种实质性改变，也会产生巨大的影响，是“确定性效应”(certainty effect)。</li><li>可能性和确定性在损失研究方面具有同样强大的效应。<ul><li>因为厌恶损失，面对损失的会尽量避免损失的可能性，或者追求降低损失必然性</li></ul></li><li>由理性选择的公理推出的期望效用理论，说明理性决策是基于期望预计结果才能做出的</li></ul></li><li>著名经济学家也难逃阿莱斯悖论的陷阱<ul><li>61%获得 52 万和63%获得 50 万， 大部分人都会选前者，这违背了效用理论<ul><li>效用理论：指的当决策的理论依据是能获取最佳结果的</li></ul></li><li>将效用理论看成是理性选择的逻辑基础，但并不认为人们都是非常棒的理性选择者</li><li>决策权重的大小取决于人们的担忧程度<ul><li>1%得到和 1%损失对于人们的影响不完全不同，前者可能不会当一回事，后者必然会焦虑不安</li><li>5%～95%的概率对人们情绪影响最少，在做决策的时候可以更加理性面对</li><li>影响决策权重的因子，是人们的担忧程度，程度越深影响决策的权重越大</li></ul></li><li>四重模式：可能性与决策权重的关系模型<ul><li>所得、损失与较大可能性的确定性效应、较小可能性的可能性效应之间的关系</li><li>偏好的四重模式是前景理论的核心成果</li><li>为什么人们会对95%损失可能性去做更加冒险的行为<ul><li>举例说明，当你炒股损失的时候， 你会更加冒险的决策，当你盈利的时候，为了避免损失你会更加保守决策</li><li>原因 1：敏感性不断降低，由于损失让你对损失的敏感性在降低</li><li>原因 2：必然性的损失和可能的盈利，你会规避必然损失，如：割肉离场和追新的盈利点</li></ul></li><li>人类的大部分损失都是因为规避 95%的损失而去做出更加冒险的行为，导致更大的损失</li><li>正如一场比赛，输只是时间问题，但是输的一方还是会不断挣扎</li></ul></li><li>可能性效应影响下的风险决策<ul><li>可能性效应会让人们去规避必然的损失去做更加冒险的事情，同时也会让人们去争取更多可能性的利益，去获得更少的必然利益</li></ul></li></ul></li></ul></li><li>第 30 章 被过分关注的罕见事件<ul><li>以色列巴士被恐怖袭击事件，会让大部分人尽量不去搭乘巴士，即使大多人心里清楚的知道巴士再次发生恐怖袭击的概率很低<ul><li>为什么：因为恐怖主义降低了效用层叠，同时我们无法组织系统 1 的运行，即使系统 2  做出了极大的控制</li></ul></li><li>你认为一只三流球队获得 NBA 总冠军的可能性多大？<ul><li>对于罕见事件，人们往往高估了罕见的概率</li><li>过高估计和过高权衡是不同的行为，但是背后心理机制是一样的<ul><li>集中注意力、证实性偏差和认知放松</li></ul></li><li>因此过高估计的现象会出现决策失误，尤其只针对某一种可能性进行预测判断，大脑往往只会去计算出有利于这一可能性的所有因素</li></ul></li><li>画面感越强，决策权重越大<ul><li>同样可能性的事件，往往越生动的描述能让大脑形成画面，从而更能记住该可能性，对判断决策影响更大</li></ul></li><li>对风险的表述方式不同，所做的决策可能截然不同<ul><li>“分母忽视”，人们在做决策的时候，由于系统 1的存在，往往会忽略大数量分母的对比，而是对比分子的大小，如书中所失：10 个中有一个红球，100 个中 8 个红球， 大部分人会优先从 100 个箱子去获取。</li><li>解释不同语言描述同一个风险事件会带来不同结果，是因为利用“分母忽视”原理，突出分子对比从而达到不同的结果</li></ul></li><li>罕见事件又为何让人忽视<ul><li>是罕见事件从未发生过，因此人们往往会凭借经验做出选择，因为系统 1 的存在更加容易忽视这个罕见事件，而系统 2 未参与是因为不知道要如何处理该类事件</li></ul></li></ul></li><li>第 31 章 能带来长远收益的风险政策 <ul><li>全部决策，一般会将收益和损失分开去选择，让大脑更加容易做出判断</li><li>宽框架还是窄框架？<ul><li>上面的决策选择，是基于处于收益状态会规避损失，处于亏损状态承担风险是需要付出代价的</li><li>窄框架：分别思考两个简单问题</li><li>宽框架：一个有4个选项的综合决策性问题</li><li>宽框架在任何情况下，将多种决策综合考虑会更有优势</li><li>但是人们会更加喜欢用窄框架去思考决策问题</li></ul></li><li>聪明的投资不会每天都看股票行情<ul><li>遇到赌一次输 100，但是能赚 200 的机会，大部分人都会选择不赌</li><li>但是真正的聪明人会想，如果读1000 次，那么大概率还是会赢的</li><li>利用宽框架思维去避免亏损厌恶带来的痛苦：<ul><li>提高理性对待盈利和亏损，如：用商人的思维去思考</li><li>降低查看投资结果频率</li><li>每天查看股票，容易造成股票投资进行无效的变动</li></ul></li></ul></li><li>风险政策可以抵消风险厌恶的偏见<ul><li>风险政策：在决策的影响因素中增加特别有风险的选项，从而增加思考的全面性</li><li>类似于外部意见，从而增加自己用宽框架去思考问题</li><li>结合风险政策+外部意见，能更好的统计去做决策</li></ul></li></ul></li><li>第 32 章 心理账户是如何影响我们的选择？<ul><li>绝对大多数人赚钱并不是处于经济动机<ul><li>钱是衡量一个人自身利益与自我成就感的标尺</li><li>奖励与惩罚会给人们带来情绪的变化</li></ul></li><li>你会卖掉盈利的股票还是亏损的股票？<ul><li>我们把钱存进还是银行，还是投资到股票市场中，其实只是把钱存入到我们不同的心理账户<ul><li>期待稳定收入，还是高风险收入</li><li>心理账户是一种窄框架思维体现，能更好掌握事情</li></ul></li></ul></li><li>当遇到需要用钱的时候，你会把盈利的股票卖掉 还是卖掉亏损的股票？<ul><li>遇到这种选择，金融研究已经记录大量人们的记录偏见，这也叫处置效应</li><li>处置效应，是指人们倾向于卖掉盈利的股票，而不是亏损的股票，因为人们总想着盈利</li><li>但是不管是卖盈利还是卖亏损，处置效应更多是一种窄框架思维，思考的只是单方面的现在的盈利亏损情况</li><li>真正理性思维应该是思考哪只股票在未来的情况不可能有上涨的可能性</li><li>理性的投资人只会对未来的结果感兴趣，而不是针对当前的情况</li><li>对亏损的股票进行再次追加，俗称“沉没成本的悖论”，简单的分析就是继续亏损+增加多资金承担更大风险，去获取更少的收益，如：10 万亏 1 万，追投10 万，只想赚回这1 万，但是 20 万赚 1 万的成本太高了</li><li>【沉没成本的悖论】，会让人们在亏损的事情投入太多</li></ul></li><li>那种选择会让你更后悔？<ul><li>后悔是一种情绪，也是一种自我惩罚</li><li>后悔是由替代现实实用性引发的反现实的情绪</li><li>决策制定者很容易后悔，然后又很容易受到后悔情绪的影响做下一个决定</li><li>后悔情绪的大小，往往不采取行动的情绪比采取行动的情绪更多</li><li>如同医生在手术中，承担风险采取行动导致死亡，但是没有采取行动而死亡，那么后悔情绪会更大</li></ul></li><li>因为害怕将来后悔而做出不理性的选择<ul><li>为什么会有这种心理？<ul><li>因为损失带来的痛苦是获取带来快乐的两倍，损失厌恶</li><li>愿意付出更多代价去避免损失，如：家长愿意花更多的钱去避免孩子承担风险，购买更高价格的杀虫剂</li></ul></li><li>如何避免害怕后悔情绪？<ul><li>对做任何决策，可以将可能后悔的事情进行预防</li><li>针对可能发生的事情作为决策因素之一</li><li>不同决策应该有不同策略<ul><li>远期的目标应该是一个大目标，不需要思考后悔的事情，等于不需要思考方方面面的问题</li><li>近期的目标应该是小目标，需要思考更多可能性</li></ul></li><li>同时应该降低后悔带给我们的痛苦程度，因为我们每个人都有心理免疫系统</li></ul></li></ul></li></ul></li><li>第 33 章 评估结果的逆转<ul><li>同样中枪得到保险，但是在不同场景下，人们希望获得的金额赔偿是不一样的，从而提出偏好逆转的理论<ul><li>偏好逆转：风险策略下一种奇怪现象，对于同一个价值的博弈下，往往会选择概率高和损失小的，但是对概率低和损失大会定价更高</li></ul></li><li>开启经济学与心理学的跨界交流<ul><li>偏好逆转在经济学家和心理学家中的沟通占据重要地位</li><li>为什么会有偏好逆转？<ul><li>因为在做联合评估决策的时候，会将注意力集中在某一个情况，从而忽略其他因素</li></ul></li><li>理性经纪人不受偏好逆转影响，是因为：<ul><li>偏好逆转是理性因素模式的一种挑战</li></ul></li></ul></li><li>联合评估引发偏好逆转<ul><li>不应该单一判断和综合判断的结果不一致</li><li>应该同一类问题进行综合判断</li><li>单一评估和联合评估是完全不同的决策，同时会产生不同的结果</li></ul></li><li>同类案件判罚力度为何不一样？<ul><li>因为先判断案例 1，一般使用单一评估，可能赔偿金额没那么大</li><li>但是一旦联合评估后，案例 1 得到赔偿比单一评估要多</li><li>这就是法律规定定性某类案件后，最高赔偿多少金额的原因</li></ul></li></ul></li><li>第 34 章 善用框架效应，让生活更加美好<ul><li>一场比赛的结果用不同的话术描述会给人不同的感觉，如：“A队赢了” 给人一种 A队属于正常赢了，“B 队输了”表达了 B队本来要赢但是却输了的感觉 </li><li>情感的框架很难抵挡<ul><li>成本就是没有损失</li><li>当获得是确定的，系统1便会偏向于获得；若损失是确定的时候，系统1便又会规避损失</li><li>系统 2  很懒惰，除非有明确的理由需要这样子做外才会激发系统 2去思考</li></ul></li><li>用框架性政策助推人们作出更好的选择<ul><li>不同的说法会让人们更加愿意去做不同选择倾向</li><li>对风险规避或冒险的倾向都不是基于现实的</li><li>框架效应下：如何处理穷人和富人的生育免税额度？<ul><li>穷人更高，还是富人更高？ </li></ul></li><li>某个重要的决定是受该情况下完全无关的特征控制的<ul><li>如：意外死亡是否要自愿捐献器官，是不是应该放到汽车驾照标识中？</li><li>大多数人会认为捐献器官是重要的，但是放到汽车驾照中不是重要的决策，往往就会草率做决定<br>第 5 部分 两个自我</li></ul></li></ul></li></ul></li><li>第 35 章 体验效用与决策效用的不一致<ul><li>体验效用的含义：因为痛苦和快乐而作出决策的行为</li><li>如何测量体验效用？<ul><li>测量体验效用的工具是快乐测量仪，可衡量一个人所经历的痛苦或快乐的大小</li><li>快乐测量值和回顾性评估是评估体验效用的两种方法<ul><li>快乐测量值：从他人不同时刻的体验报告中计算出的数据</li><li>回顾性评估：会权衡两个单一时刻，即高峰和末端</li></ul></li></ul></li><li>记忆自我放大了痛苦的体验<ul><li>在经验自我和记忆自我引起冲突，也是在体验效用和决策效用引起冲突</li><li>相比下，记忆自我保存的记忆是对代表性时刻的感觉，受到高峰和结束时刻的强烈影响</li><li>支配人类记忆自我的规则是一个漫长的发展历史，这也是人类与其他物种进化不同的原因</li></ul></li><li>记忆没那么可靠<ul><li>记忆的两个原则：过程忽视和峰终定律<ul><li>过程忽视：过程的持续对所有疼痛的评估没有任何影响。</li><li>峰终定律：整体的回顾性评级可通过将最糟糕时期和最后时刻的疼痛程度的平均加权而评估出来</li></ul></li><li>因为两个原则得出：决策和体验不协调</li><li>决策不会产生最可能的体验，对未来的感觉预测也可能是错误的</li></ul></li></ul></li><li>第 36 章 人生如戏<ul><li>每次看到电影里紧张时刻，我们还是会紧张揪心</li><li>比起整个人生，我们更在意人生的结局<ul><li>为什么会在意结局？因为记忆自我工作机制：编故事保存起来，然后作为将来的参考点</li><li>如何判断一个故事主角的幸福，往往取决于最终的结局，而不是故事的过程<ul><li>这更能证实记忆的两个原则：过程忽视和峰终定律</li></ul></li><li>“少即是多”效应：平均（典型）可替代总体，简单的理解就是平均的幸福程度可能大于平均的幸福程度</li></ul></li><li>关于上一次旅行你还记得多少？<ul><li>许多旅行者都会拍很多照片和视频，是因为他们想保存这段美好记忆，这也是往往旅游的目的</li><li>上一次旅行的照片与视频，往往会成下一次旅游的计划造成影响</li><li>如果没有上一次旅游的记忆，那么会这次旅游计划会发生变化吗？</li></ul></li><li>我 = 记忆自我 + 经验自我，但是我们往往对两个我很陌生</li></ul></li><li>第 37 章 你有多幸福？<ul><li>幸福的初步认识：<ul><li>从各方面考虑，对当前生活的满意程度</li><li>另外一种角度对幸福的衡量，就是经验自我的幸福感</li><li>幸福的事情是指的我们愿意继续，不想停止的，包含心理和生理上的</li></ul></li><li>测量经验自我的幸福感<ul><li>经验取样法，从每天固定时间取样，从获取每天幸福平均值</li><li>U 指数：个人处于不愉快的时间比例</li><li>人在任何时刻的心情都是由他的性情和整体幸福感决定的</li><li>对于个人和社会而言，降低 U 指数的方法是有意义，个人可以通过做一些喜欢的事情，社会可以通过为劳动人提供更好的交通条件等</li></ul></li><li>幸福的方法<ul><li>评估生活的总体评价：坎特里尔自我奋斗量尺，台阶分数，0～10，你会如何估自己处于几分的台阶？</li><li>评估生活的幸福程度主要影响因素：<ul><li>教育程度，教育越高对生活要求的标准也越高</li><li>收入程度，收入越高那么幸福的下限会高，但是却不是影响幸福的重要因素，不过贫穷往往会导致很多不幸，因为贫穷会经历更多不幸的痛苦</li><li>收入同用会影响对幸福的评估，比如：同一块巧克力对不同家庭而言带来的幸福感是完全不同的</li></ul></li></ul></li></ul></li><li>第 38 章 思考生活<ul><li>生活满意度：一个很难回答的问题<ul><li>婚姻后生活的满意程度陡然下降，大部分认为在适应过程中</li><li>对生活是否满意是一个很回答的问题，因为系统 1 无法直接给出答案，而且其特别容易受最近某些小事的影响<ul><li>在问满意之前先问最近约了几次约会，那么满意的影响因素是约会</li></ul></li><li>经验自我的幸福不受婚姻的影响，原因是婚姻不能影响幸福感<ul><li>经验自我的幸福感和生活满意度总体上取决于性情的遗传</li><li>个人生活环境与生活满意度相关性低</li></ul></li><li>年轻时候的目标会影响未来将要经历的事情、未来发展和对生活满意度</li><li>幸福是各个方面的综合体观点，必须把记忆自我和经验自我感受都考虑在内</li></ul></li><li>被放大的幸福错觉<ul><li>当仔细思索某件事情的时候，这件事情就变得没那么重要<ul><li>是因为聚焦错觉</li></ul></li><li>聚焦错觉=眼见为实，以为见到就是真实，会把当前能见到的影响因素放大<ul><li>如买车的时候，大部分考虑的是买到车后的快乐，往往忽略了后续需要承担的经济压力，这也是聚焦忽略</li></ul></li><li>为什么会聚焦错觉？因为人们总相信眼见为实，忽略了时间的影响</li><li>忽略了时间，导致维持人们长久的注意力价值会忽视，如：长时间学习和短时间的刷抖音是一样的原因</li></ul></li><li>前往不要忽视时间的作用<ul><li>大脑善于处理故事，但是不能很好的处理时间</li><li>经验自我的生活是一系列有价值的时刻，如：小时候获得第一名、长大后的初恋等等</li><li>记忆自我的生活往往更加注重开始与结局，往往忽视了过程</li></ul></li><li>忽视时间的作用，往往是因为我们大脑更加在意当前时刻带来的感受，不过我们可以通过过去，现在，未来的时间发展去让自己更加注重时间的作用</li></ul></li></ul></li><li>结语<ul><li><h1 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h1></li></ul></li></ul><h2 id="1-可得性法则"><a href="#1-可得性法则" class="headerlink" title="1.可得性法则"></a>1.可得性法则</h2><ul><li>一般又称可获得性启发、易得性法则</li><li>人们是根据从记忆中提取信息的容易程度来估测事情的重要程度的，而这往往也与媒体报道的广泛程度有关。</li><li>解释人们有些事情记得清楚，有些事情却被遗忘</li></ul><h2 id="2-启发法和成见"><a href="#2-启发法和成见" class="headerlink" title="2.启发法和成见"></a>2.启发法和成见</h2><ul><li>启发法，或者称策略法、助发现法、启发力、捷思法<ul><li>在不可能找到最佳解决方案或不切实际的情况下，可以使用启发式方法来加快找到满意解决方案的过程。</li><li>解释了在知识有限（信息不完整）和时间有限的情况下，得出可能陈述或可行解决方案的艺术。</li><li>简单理解，在完全不理解情况下如何利用自己已有的知识和原则性的原理去得到可行的解决方案</li></ul></li></ul><h2 id="3-缪勒–莱耶错觉图"><a href="#3-缪勒–莱耶错觉图" class="headerlink" title="3.缪勒–莱耶错觉图"></a>3.缪勒–莱耶错觉图</h2><p>缪勒莱耶错觉是指前提为两条长度相等的线段，假如一条线段两端加上向外的两条斜线，另一条线段两端加上向内的两条斜线，则前者要显得比后者长得多。如下图所示：</p><p><img src="/assets/img/think-fast-1.png" alt=""></p><h2 id="4-心理学家米哈里·契克森米哈-Mihaly-Csikszentmihalyi-的“心流”状态"><a href="#4-心理学家米哈里·契克森米哈-Mihaly-Csikszentmihalyi-的“心流”状态" class="headerlink" title="4.心理学家米哈里·契克森米哈(Mihaly Csikszentmihalyi)的“心流”状态"></a>4.心理学家米哈里·契克森米哈(Mihaly Csikszentmihalyi)的“心流”状态</h2><ul><li>是什么<ul><li>心流状态是一种精神状态，其特征在于完全沉浸在活动中并专心致志，使相应过程令人满足且令人愉悦。</li><li>“心流”这个词是心理学家 Mihaly Csikszentmihalyi 在 1975 年创造的，当时他观察到一些艺术家完全沉浸在自己的创作中，以至于忽视或根本不受食物、饮水或睡眠需求的影响。</li></ul></li><li>心流状态的明显标志<ul><li>高度专注</li><li>行动和意识高度融合</li><li>完全沉浸其中</li><li>有一种毫不费力就能完成任务的感觉</li><li>对手头任务有很强的控制感</li><li>失去时间感/忘记时间</li><li>感到任务本身就是回馈（甚至在任务完成之前就感觉如此）</li></ul></li><li>进入心流的条件<ul><li>明确的目标</li><li>可战胜的挑战</li><li>让人能享受其中/有回馈的活动，也被称为本身具有目的的任务</li></ul></li><li>怎么做<ul><li>消除干扰：需要时间来适应一项任务，确保这段时间没有任何干扰</li><li>静下心来：建议要素是冥想练习</li><li>更专注：减少场景切换或任务切换</li><li>工作富有挑战性：增加富有挑战性的任务</li></ul></li></ul><h2 id="5-自我损耗-ego-depletion"><a href="#5-自我损耗-ego-depletion" class="headerlink" title="5.自我损耗(ego depletion)"></a>5.自我损耗(ego depletion)</h2><ul><li>俗称“内耗”</li></ul><h2 id="6-联想的连贯性"><a href="#6-联想的连贯性" class="headerlink" title="6.联想的连贯性"></a>6.联想的连贯性</h2><ul><li><p>联想的机制，是人类大脑思维活跃最常见的一种</p></li><li><p>启动效应</p><ul><li>是指由于之前受某一刺激的影响而使得之后对同一刺激的知觉和加工变得容易的心理现象。</li></ul></li><li><p>涟漪效应</p><ul><li>启动联想后，大脑的思维就像在池塘里的涟漪一样向外扩展，这就是涟漪效应</li><li>案例：每次吃饭都先喝汤，等到下次要吃饭的时候，就会先等汤做完</li></ul></li><li><p>佛罗里达效应</p><ul><li>佛罗里达里大部分是老年人，所以一想到佛罗里达，就会想到年老，白发，缓慢行走，其实是联想效应一种表现</li></ul></li></ul><h2 id="7-贝叶斯定理"><a href="#7-贝叶斯定理" class="headerlink" title="7. 贝叶斯定理"></a>7. 贝叶斯定理</h2><blockquote><p>贝叶斯定理（英语：Bayes’ theorem）是概率论中的一个定理，描述在已知一些条件下，某事件的发生概率。比如，如果已知某种健康问题与寿命有关，使用贝叶斯定理则可以通过得知某人年龄，来更加准确地计算出某人有某种健康问题的概率。 —— <a href="https://zh.wikipedia.org/wiki/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86">贝叶斯定理 维基百科</a></p></blockquote><ul><li>用公式去解释一件事发生的概率，或者判断某件事情的正确性概率<ul><li>当事件B发生后，事件A发生的可能性概率1</li><li>反过来需要思考， 事件A发生后事件B发生的概率2</li><li>概率1 != 概率2</li></ul></li><li>贝叶斯定理，通常用来解决去检测或者判断某个事情的概率，<ul><li>案例1:检测公司有多少人得新冠，通过检测纸的准确概率+平时公司阳了的人基础比率去判断检测，得出公司大概率有多少人可能得了新冠</li></ul></li></ul><h2 id="8-前景理论"><a href="#8-前景理论" class="headerlink" title="8. 前景理论"></a>8. 前景理论</h2><blockquote><p>1970年代，卡内曼和特沃斯基系统地研究这一领域。长久以来，主流经济学都假设每个人作决定时都是“理性”的，然而现实情况并不如此；展望理论加入了人们对得失、发生概率高低等条件的不对称心理效用，成功解释了许多看来不理性的现象。展望理论对分析在不确定情况下的人为判断和决策方面作出了突出贡献，康纳曼更因此获得2002年的诺贝尔经济学奖。<br>展望理论是描述性而非指示性的理论——它旨在解释现象，而非分析怎样作决策才是最好的。利用展望理论可以对风险与报酬的关系进行实证研究。<br>前景理论（展望理论）：人在不确定条件下的决策选择，取决于结果与展望（预期、设想）的差距而非单单结果本身。</p></blockquote><p>解释描述人们为何在当下做出选择的理论依据，而不是作为决策依据。不过可以利用理论去分析当前面临选择的可能性。</p><h2 id="9-禀赋效应"><a href="#9-禀赋效应" class="headerlink" title="9. 禀赋效应"></a>9. 禀赋效应</h2><blockquote><p>禀赋效应 [1]或厌恶剥夺（英语：Endowment effect），形容当一个人拥有某项物品或资产的时候，他对该物品或资产的价值评估要大于没有拥有这项物品或资产的时候。<br>这一现象常常用于行为经济学的分析中，并与损失厌恶的理论相联系。由于禀赋效应，人们在决策过程中，往往会产生偏见，导致对于规避风险的考虑远远大于对于追逐利益的考虑，因此人们在出卖物品或资产时，往往索价要比其本身更高的价值。</p></blockquote><p>这在炒股中往往很常见，当你拥有一只股票的时候，你往往会收集无数利好的消息去以为它会持续上涨。而不是因为你看到利好的消息而去拥有一只股票。</p><h1 id="相关书籍"><a href="#相关书籍" class="headerlink" title="相关书籍"></a>相关书籍</h1><ul><li>斯坦诺维奇 《理性和反思性思维》</li><li>苏格兰哲学家大卫·休谟《人类理解研究》</li><li>心理学家蒂莫西·威尔逊《我们是自己的陌生人》</li><li>纳西姆·塔勒布所著的《黑天鹅》</li><li>丹尼尔·吉尔伯特(Daniel Gilbert) 《哈佛幸福课》</li><li>《注意与努力》</li><li>菲利普·罗森茨威格《光环效应》</li><li>波顿·麦基尔(Burton Malkiel)的著作《漫步华尔街》</li><li>保罗·米尔《临床与统计的预测：理论分析与事实回顾》</li><li>罗宾·道斯的论文《决定中非正当线性模型的稳定之美》</li><li>《前景理论：风险下的决策分析》</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;思考，快与慢&quot;&gt;&lt;a href=&quot;#思考，快与慢&quot; class=&quot;headerlink&quot; title=&quot;思考，快与慢&quot;&gt;&lt;/a&gt;思考，快与慢&lt;/h1&gt;&lt;p&gt;在书中，卡尼曼会带领我们体验一次思维的终极之旅。他认为，我们的大脑有快与慢两种作决定的方式。常用的无意识的“系统1”依赖情感、记忆和经验迅速作出判断，它见闻广博，使我们能够迅速对眼前的情况作出反应。&lt;/p&gt;
&lt;p&gt;举个例子： 肚子饿了去点菜，我们点很多余点菜，然后吃了一阵子就后悔了，如果我们慢慢规划去点，发现别人都已经吃完走了。&lt;/p&gt;
&lt;p&gt;温馨提醒：本书涉及N多经济学和心理学的专业术语，需要不断查资料去理解其术语的意思，这对经济学、心理学入门有极大的作用。&lt;/p&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>好工具推荐Automa —— 可视化配置+工作流+自动化执行浏览器插件</title>
    <link href="https://www.qborfy.com/today_2024/20240531.html"/>
    <id>https://www.qborfy.com/today_2024/20240531.html</id>
    <published>2024-05-30T10:00:01.000Z</published>
    <updated>2024-06-04T07:56:20.629Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><blockquote><p>Automa是通过可视化配置，工作流连接实现浏览器自动化的插件。能完成自动填写表格、重复任务、截屏到抓取网站数据等，想做什么取决于你自己。</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://chromewebstore.google.com/detail/infppggnoaenmfagbfknfkancpbljcca">Automa插件官方下载安装</a></li><li><a href="https://github.com/AutomaApp/automa">Automa Github</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="技术分享" scheme="https://www.qborfy.com/tags/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    <category term="每日更新" scheme="https://www.qborfy.com/tags/%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>如何优化chrome web页面开了很久卡顿</title>
    <link href="https://www.qborfy.com/today_2024/20240604.html"/>
    <id>https://www.qborfy.com/today_2024/20240604.html</id>
    <published>2024-05-30T10:00:01.000Z</published>
    <updated>2024-06-06T07:04:12.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><h1 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h1><h2 id="利用chrome性能解析工具"><a href="#利用chrome性能解析工具" class="headerlink" title="利用chrome性能解析工具"></a>利用chrome性能解析工具</h2><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://github.com/LuckyWinty/blog/blob/master/markdown/Q%26A/Chrome%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90.md">Chorme 浏览器中的垃圾回收和内存泄漏</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;headerlink&quot; title=&quot;原因&quot;&gt;&lt;/a&gt;原因&lt;/h1&gt;&lt;h1 id=&quot;原因-1&quot;&gt;&lt;a href=&quot;#原因-1&quot; class=&quot;headerlink&quot; title=&quot;原因&quot;&gt;&lt;/a&gt;原因&lt;/h1&gt;&lt;h</summary>
      
    
    
    
    
    <category term="技术分享" scheme="https://www.qborfy.com/tags/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    <category term="每日更新" scheme="https://www.qborfy.com/tags/%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>Vue2老项目优化打包逻辑</title>
    <link href="https://www.qborfy.com/today_2024/20240523.html"/>
    <id>https://www.qborfy.com/today_2024/20240523.html</id>
    <published>2024-05-23T10:00:01.000Z</published>
    <updated>2024-05-30T04:13:50.297Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>由于最近接手一个老的Vue2项目，其打包编译速度，每次发布都需要等待30分钟以上，实在受不了，故此在互联网上收集了</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/JZevin/article/details/108478555">使用可视化的Vue项目管理器Vue UI </a></li><li><a href="https://tiven.cn/p/edae9a97/">Vue 打包优化之 externals 抽离公共的第三方库</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="技术分享" scheme="https://www.qborfy.com/tags/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    <category term="每日更新" scheme="https://www.qborfy.com/tags/%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>VSCode远程连接服务器开发</title>
    <link href="https://www.qborfy.com/today_2024/20240429.html"/>
    <id>https://www.qborfy.com/today_2024/20240429.html</id>
    <published>2024-04-29T10:00:01.000Z</published>
    <updated>2024-04-29T08:33:02.461Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>VScode是前端开发最受欢迎的IDE工具之一， 里面的插件市场十分丰富，插件有个插件叫<a href="https://code.visualstudio.com/docs/remote/ssh">Remote - SSH</a>，其主要功能介绍如下：</p><blockquote><p>Visual Studio Code 远程 - SSH 扩展允许你在任何远程计算机、虚拟机或具有正在运行的 SSH 服务器的容器上打开远程文件夹，并充分利用 VS Code 的功能集。连接到服务器后，您可以与远程文件系统上任何位置的文件和文件夹进行交互。</p></blockquote><p>因此，我们可以直接连接远程服务器去做很多事情：</p><ul><li>搭建云端个人开发机， 从而使得所有无论更换本地环境，都不会影响个人开发进度</li><li>更加友好的可视化文件管理，包括一些简单的文件编辑等等</li><li>使用SSH登录，能更好更安全的避免密码泄漏</li></ul><p>下面还是以【如何搭建个人远程开发机】作为案例去学习</p><h1 id="如何搭建个人远程开发机"><a href="#如何搭建个人远程开发机" class="headerlink" title="如何搭建个人远程开发机"></a>如何搭建个人远程开发机</h1><h2 id="步骤一-安装-Remote-SSH插件"><a href="#步骤一-安装-Remote-SSH插件" class="headerlink" title="步骤一 安装 Remote-SSH插件"></a>步骤一 安装 Remote-SSH插件</h2><p>在VSCode的插件市场中，查询【Remote-SSH】，然后进行安装，具体如下图：</p><p><img src="/assets/img/20240429-1.png" alt=""></p><h2 id="步骤二-配置远程服务器"><a href="#步骤二-配置远程服务器" class="headerlink" title="步骤二 配置远程服务器"></a>步骤二 配置远程服务器</h2><ol><li><p>打开SSH配置界面，具体如下图：<br><img src="/assets/img/20240429-2.png" alt=""><br><img src="/assets/img/20240429-3.png" alt=""><br><img src="/assets/img/20240429-4.png" alt=""></p></li><li><p>编辑SSH配置文件<code>~/.ssh/config</code>，路径和上述文件路径保持一致，具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">## </span><br><span class="line">## Host 远程连接名称</span><br><span class="line">## HostName 主机IP</span><br><span class="line">## User 连接帐号</span><br><span class="line">## Port 连接SSH端口</span><br><span class="line">##</span><br><span class="line"></span><br><span class="line">Host self_remote_host</span><br><span class="line">    HostName 10.11.67.18</span><br><span class="line">    User root</span><br><span class="line">    Port 22</span><br></pre></td></tr></table></figure></li></ol><p>完成步骤一，基本上就可以连接远端服务器，不过每次都要输入密码有点麻烦，所以可以通过SSH密钥认证去解决，具体如下步骤</p><h2 id="步骤二-本地生成SSH密钥，进行免密登录"><a href="#步骤二-本地生成SSH密钥，进行免密登录" class="headerlink" title="步骤二 本地生成SSH密钥，进行免密登录"></a>步骤二 本地生成SSH密钥，进行免密登录</h2><p>不同操作系统，执行命令不太一样，具体如下。</p><ol><li>Mac | Linux操作系统<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认会在相应路径下（~/.ssh/）生成id_rsa和id_rsa.pub两个文件，如下面代码所示</span></span><br><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure></li></ol><ul><li><code>id_rsa</code> SSH私钥文件，用来解密公钥，一般存在本地使用</li><li><code>id_rsa.pub</code> SSH公钥文件，用来传输信息的时候加密用， 一般存在远端服务器</li></ul><ol start="2"><li>Windows操作系统<br>安装Git Bash，执行如下命令即可：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认会在相应路径下（C:\Users\yourname\.ssh）生成id_rsa和id_rsa.pub两个文件，如下面代码所示</span></span><br><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure>接下来就是将公钥<code>id_rsa.pub</code>复制到远端服务器上<code>~/.ssh/</code>目录下即可</li></ol><ol start="3"><li>将公钥<code>id_rsa.pub</code>添加到远端服务器中可信任文件中<code>authorized_keys</code>，具体命令如下：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>验证登录：<code>ssh &lt;user&gt;:10.1.1.1</code></p><ol start="4"><li>配置VSCode SSH config文件，具体如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">## </span><br><span class="line">## Host 远程连接名称</span><br><span class="line">## HostName 主机IP</span><br><span class="line">## User 连接帐号</span><br><span class="line">## Port 连接SSH端口</span><br><span class="line">## IdentityFile 认证登录的SSH密钥文件</span><br><span class="line">##</span><br><span class="line"></span><br><span class="line">Host self_remote_host</span><br><span class="line">    HostName 10.11.67.18</span><br><span class="line">    User root</span><br><span class="line">    Port 22</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure></li></ol><h1 id="SSH免密码登录原理"><a href="#SSH免密码登录原理" class="headerlink" title="SSH免密码登录原理"></a>SSH免密码登录原理</h1><ul><li>SSH远端服务会发送【公钥(remote)】信息</li><li>本地SSH客户端会验证远端传输来的【公钥(remote)】和 本地【公钥(local)】对比是否一致，如果一致，发送【随机字符串（challenge）】给到远端服务器</li><li>远端服务器接受到随机字符串（challenge）信息后，继续用【公钥(remote)】加密传输信息-随机字符串（challenge）给回到客户端</li><li>本地SSH客户端用本地【私钥(local)】去解密【公钥(remote)】加密传输信息-随机字符串（challenge），如果与之前一致，则建立连接</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://cloud.tencent.com/developer/article/2175073">使用VS Code插件远程连接Linux服务器</a></li><li><a href="https://www.cnblogs.com/brf-test/p/16036703.html">Windows下生成SSH密钥</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="技术分享" scheme="https://www.qborfy.com/tags/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    <category term="每日更新" scheme="https://www.qborfy.com/tags/%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>00篇 AI一些概念性知识点</title>
    <link href="https://www.qborfy.com/ailearn/ai-learn00.html"/>
    <id>https://www.qborfy.com/ailearn/ai-learn00.html</id>
    <published>2024-04-06T07:00:00.000Z</published>
    <updated>2024-04-08T02:17:23.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要学习AI知识"><a href="#为什么要学习AI知识" class="headerlink" title="为什么要学习AI知识"></a>为什么要学习AI知识</h1><p>去年年中总结写过一篇文章 <a href="https://qborfy.com/study/2023-middle.html">《2023年中总结之如何在互联网裁员浪潮继续前(gou)进(zhu)》</a>，AI发展</p><h1 id="如何开始学-AI"><a href="#如何开始学-AI" class="headerlink" title="如何开始学 AI"></a>如何开始学 AI</h1><h1 id="主流大模型"><a href="#主流大模型" class="headerlink" title="主流大模型"></a>主流大模型</h1><h2 id="国内"><a href="#国内" class="headerlink" title="国内"></a>国内</h2><h2 id="国外"><a href="#国外" class="headerlink" title="国外"></a>国外</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://github.com/THUDM/ChatGLM-6B">ChatGLM-6B开源大模型</a></li><li><a href="https://github.com/THUDM/ChatGLM3">ChatGLM3开源大模型</a></li><li><a href="https://hub.baai.ac.cn/view/25299">LangChain 综合指南:介绍 LangChain 的基础知识并指导了解其核心组件</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为什么要学习AI知识&quot;&gt;&lt;a href=&quot;#为什么要学习AI知识&quot; class=&quot;headerlink&quot; title=&quot;为什么要学习AI知识&quot;&gt;&lt;/a&gt;为什么要学习AI知识&lt;/h1&gt;&lt;p&gt;去年年中总结写过一篇文章 &lt;a href=&quot;https://qborfy.c</summary>
      
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    <category term="AI学习" scheme="https://www.qborfy.com/tags/AI%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>一次性学完RabbitMQ</title>
    <link href="https://www.qborfy.com/today_2024/20240305.html"/>
    <id>https://www.qborfy.com/today_2024/20240305.html</id>
    <published>2024-03-05T10:00:01.000Z</published>
    <updated>2024-03-05T10:21:17.513Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><h1 id="为什么选RabbitMQ"><a href="#为什么选RabbitMQ" class="headerlink" title="为什么选RabbitMQ"></a>为什么选RabbitMQ</h1><h1 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="技术分享" scheme="https://www.qborfy.com/tags/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    <category term="每日更新" scheme="https://www.qborfy.com/tags/%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>2023年度总结——发现自己的今年高光时刻</title>
    <link href="https://www.qborfy.com/study/2023-end.html"/>
    <id>https://www.qborfy.com/study/2023-end.html</id>
    <published>2023-12-31T14:00:01.000Z</published>
    <updated>2024-02-21T11:18:33.245Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>时光匆匆，2023年即将结束，新的一年即将到来，每个人都会有自己的年度总结，因此对于我个人而言，2023 年是一个很重要的转折点，不在于物质上有多大的变化，而是在于思维上，在于精神上的转变，不再有过去那种懵懵懂懂，浑浑噩噩的过日子的感觉，上次这种感觉还是在小学 5 年级的一个夜晚，突然懂事的开窍，觉得学习很重要，要好好读书的醒悟。因此接下来这一篇年度总结的灵感来源于：罗振宇老师的【2024年跨年演讲】主题 ——  是什么让我眼前一亮。</p><p>因此，2023 年对于国家，对于公司，对于个人，都是非常不容易的一年，疫情刚过去，经济下调，个人面临裁员，很多人负面情绪都积压快爆炸了，因此2023 年对于大多数人来说，其实是积压了很多垃圾情绪的一年，更因为这样子，我们更加应该去发现今年自己的高光时刻，去找到那个让能自己变得骄傲的自己，找到那个自信的自己，从而更加从容的面对未来，面对 2024 年。</p><p>温馨提示：本文文字居多，且内容主要偏向于个人总结，如果觉得对自己有用的，请耐心观看。</p><span id="more"></span><h1 id="2023年的个人高光时刻"><a href="#2023年的个人高光时刻" class="headerlink" title="2023年的个人高光时刻"></a>2023年的个人高光时刻</h1><p>我从个人角度出发总结 2023 年的高光时刻，那些能让我感觉到骄傲的事情，主要分为以下几类：</p><ul><li>身体健康<ul><li>体重降低，从年初 182 斤到 170 斤</li><li>每周运动次数，已坚持 3 个月，每周运动次数： 3+，每次运动时长：半小时</li><li>睡眠时间，坚持每天睡足 8 个小时，虽然有时候做不到，但是至少保证 6 个小时睡眠时间</li></ul></li><li>持续学习<ul><li>持续阅读，今年累积阅读书籍数量： 20+</li><li>持续输出，今年累积写博客数量：50+</li><li>面对面分享，工作和生活上的分享：7次</li></ul></li><li>热爱生活<ul><li>个人卫生<ul><li>每周四对宿舍进行一次打扫卫生，之前基本上每个月一次</li><li>相信规律的生活才是自由的生活</li></ul></li><li>热爱世界<ul><li>多对人微笑和说谢谢</li><li>生活上小矛盾都是可以化解，只要你愿意去面对</li></ul></li></ul></li></ul><p>这些能让自己变得更加自信的事情，是需要时间一点点累积去坚持，一点点小事，如同小雨滴，慢慢变成小溪流，汇聚成江河，最终变成广阔的大海，能让你如同大海般容纳万物。</p><p>下面我会针对每一项单独进行总结和详细说明。</p><h2 id="身体健康"><a href="#身体健康" class="headerlink" title="身体健康"></a>身体健康</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>我对身体健康的理解，主要有以下观点：</p><ul><li>恢复时间更快，是指的当你熬夜或者牺牲健康的时间去做更重要的事情后，你身体状态恢复成正常健康状态所需要的时间更少</li><li>效率更高，是当你拥有健康的大脑，你理智时间更长，能更有效的处理事情，从而效率更高</li><li>生病次数更少，是你拥有更强大的免疫系统，从而面临同样的环境，你能抵抗更高的生病风险</li><li>胃口更好，是你拥有强大的适应肠胃，能适应不同环境的饮食习惯，从而面临不同的挑战</li></ul><p>因此身体健康就是：快速的恢复、理智的大脑、强大的免疫、适应的肠胃。</p><h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>每个人都希望身体健康，那么有没有想过为什么要身体健康呢？ 也许是为了避免生病的痛苦，那么是否有更好的原因呢？</p><p>如果拥有健康的身体，能让你想做的事情成功概率得到提升，你是否还愿意为了身体健康坚持做一些事情呢？</p><ul><li>当你是程序员，如果你拥有健康的身体，那么你用理智的大脑和快速的恢复能力去快速解决工作问题，是否离升职加薪更近一步？</li><li>当你是销售员，如果你拥有健康的身体，那么你用强大的免疫和适应的肠胃去面临各种应酬场景，是否离签单更近一步？</li><li>当你是老板，如果你拥有健康的身体，那么你用理智的大脑和适应的肠胃，去面临各种未知挑战，是否能让公司走的更远呢？</li></ul><p>所以，拥有一个健康的身体，做事就比别人具备更高的成功概率。</p><h3 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h3><p>其实道理大家都有听过，但是要做到重点在于坚持，其次在于规律，主要包含以下几点：</p><ul><li>规律且充足的睡眠时间， 11:00 ~ 07:00，8 个小时睡眠时间，早睡早起</li><li>每天半小时运动时间，运动不仅能释放压力，还能增强体质</li><li>健康规律饮食，每天定时三餐</li></ul><p>2024年上半年主要坚持做这个，去拥抱这个信念 —— 自律等于自由，自律就是坚持规律，量化成的数字目标如下：</p><p><strong>2024年上半年身体健康目标就是： 165斤的体重， 6块腹肌</strong></p><h2 id="持续学习"><a href="#持续学习" class="headerlink" title="持续学习"></a>持续学习</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>“持续学习”，学习是很重要的，但是更加重要的是持续去学习，这个持续我对 ta 的解释是：</p><ul><li>不能分散性的去学习，而是要成体系，可连续的去学习，让知识点形成一个知识网络体系</li><li>要不间断的学习，记忆是有时限，因此只有不间断的持续，才能形成长期记忆</li><li>要学以致用，学习就要去使用，去用知识去解决问题，最佳方式是去输出和分享</li></ul><h3 id="为什么-1"><a href="#为什么-1" class="headerlink" title="为什么"></a>为什么</h3><p>为什么要学习，且持续学习？相信不同阶段的人都会给出不同的答案，你需要给自己一个学习理由和动力，下面从网络找到的回答：</p><ul><li>当你是学生时期，因为这个时候的你什么都不懂，学习能让你获取知识和培养技能</li><li>当你是打工时期，因为你需要面对世界的变化和挑战，学习能让你更有竞争力，不被社会淘汰</li><li>当你是老年时期，因为你需要与其他人交往，尤其与后辈的交流，学习能让你与后辈的距离降低，同时还能传承你的知识</li></ul><p>而我为什么要持续学习呢？我给出的答案是：我想要自由和财富，所以才要持续的学习</p><ul><li>自由，不单单指的身体上的自由，还包括心里的自由，因为增加知识，是在增加自己的视野，你能看多远，你的心就能飞多远</li><li>财富，如果有足够的知识，你就可以赚到足够的财富，不仅是金钱上的，还包括心灵上的</li></ul><h3 id="怎么做-1"><a href="#怎么做-1" class="headerlink" title="怎么做"></a>怎么做</h3><p>看到这里，基本上知道学习的重要性，那么如何去学习呢？ 如果你不知道的话， 你就需要学习《如何去学习》，不过我本人是这样子去学习的，仅供参考：</p><ul><li>学习对象<ul><li>优秀的知识，包括：书籍、教学视频等</li><li>优秀的旁边人和古人，优秀的身边人是你随时都可以学习的对象，优秀的古人则代表他身上有一些特质值得我们去学习</li><li>过去的自己，以过去的自己为尺子，不断突破过去自己的认知范围</li></ul></li><li>学习频率<ul><li>找出自己每天最佳学习时间，就是心情愉悦，大脑清醒的时间，维持20 分钟以上的学习</li><li>每天至少需要2次  20 分钟以上的学习时刻</li></ul></li><li>学习输出<ul><li>去使用知识，用知识去解决问题</li><li>去分享知识，包括：写作，分享等</li></ul></li></ul><h2 id="热爱生活"><a href="#热爱生活" class="headerlink" title="热爱生活"></a>热爱生活</h2><h3 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h3><p>热爱生活，我记得曾经有一句话说的非常好， “当你经历生活种种，仍能保持热爱生活”，才能活出自己，这也是为什么大家都很喜欢“归来仍是少年”的心态。</p><p>原先的我是不太懂的，目前的我勉强好像有点能理解，热爱生活，有两个关键词， 一个热度，一个爱意</p><ul><li>热度： 对生活充满温度，对生活充满激情，对生活永远都有活力</li><li>爱意：爱上生活的种种，是好是坏都是时间留在你身上的痕迹，爱上身边的种种，一丝风也能让你感觉满满的爱</li></ul><h3 id="为什么-2"><a href="#为什么-2" class="headerlink" title="为什么"></a>为什么</h3><p>虽然我认为赚钱很重要，但是赚钱不是最终的目的，而是因为你热爱生活，愿意为了过上更好的生活而去赚更多的钱。</p><p>热爱生活心态的转变，等于从你内心开始改变，从而影响到你的生活，再影响到你周边的人，从而实现让自己的生活变得更好，形成一个良性循环。</p><p>举几个例子：</p><ul><li>每天挤地铁通勤很累，如果你热爱生活，你会发现从地铁窗户往外看，有一道道光线不断穿梭，如同一道道光影故事</li><li>每天上班压力很大，感觉身体和心理都很累，如果热爱生活，你会发现上班并不是你的全部，上班只是你生活中一部分，为了更好的生活，工作上不拖延，每天挤出时间安排做自己想做的事情</li></ul><p>热爱生活是一个开始，是一个源头，能让你从消极恶性循环的生活中逃脱出来，往自己向往的生活去前进。</p><h3 id="怎么做-2"><a href="#怎么做-2" class="headerlink" title="怎么做"></a>怎么做</h3><p>热爱生活，不仅仅是口头上说说而已，而是知行合一，那么应该如何去做呢？我个人的做法主要从下面几点：</p><ul><li>热爱自己<ul><li>保持住宿环境的卫生，至少每周打扫一次</li><li>保持个人的卫生，从指甲到头发，从衣服到床单等</li><li>保持爱自己的心态，接受自己的缺点，找到自己的优点</li></ul></li><li>宽容他人<ul><li>要聆听和理解别人，更要表达自己的观点</li><li>与世界和解，与他人和解，更重要的是与自己和解</li></ul></li><li>情绪稳定<ul><li>不大喜，不大悲，但是情绪要发泄，找到途径发泄，如：定时冥想释放，看电影，唱歌等等</li><li>不被周边人情绪影响，同时学会让周边人情绪稳定，与其一起发泄情绪</li></ul></li></ul><p>当然热爱生活不仅仅是上面几点， 但是热爱生活的核心就是热爱自己，才能热爱他人。 热爱，就是 保持温度， 拥有一个爱意的心。</p><h1 id="未来一年计划"><a href="#未来一年计划" class="headerlink" title="未来一年计划"></a>未来一年计划</h1><h2 id="量化目标"><a href="#量化目标" class="headerlink" title="量化目标"></a>量化目标</h2><ul><li>体重：160斤，腹肌出现</li><li>睡眠时间： 8+小时</li><li>读书数量： 30+本</li><li>输出博客： 48+篇</li><li>分享次数： 10+次</li></ul><h2 id="学习新技能"><a href="#学习新技能" class="headerlink" title="学习新技能"></a>学习新技能</h2><ul><li>人像摄影</li><li>小红书电商运营</li><li>考雅思</li><li>跑马拉松</li></ul><h2 id="必做事项"><a href="#必做事项" class="headerlink" title="必做事项"></a>必做事项</h2><ul><li>带老妈处理她的牙齿</li><li>做一个AI相关的项目</li></ul><p>最后，希望阅读完后对你的人生也能发生一点改变，同时祝福大家新的2024年，新年快乐，身体健康，升职加薪！</p><blockquote><p>我是一个爱阅读和爱分享的博主Qborfy，欢迎大家到我的博客参观。<a href="https://qborfy.com">Qborfy博客</a></p></blockquote><p>PS: 觉得我写的还行，可以到我的博客里，有微信二维码可以加我好友哟～</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;时光匆匆，2023年即将结束，新的一年即将到来，每个人都会有自己的年度总结，因此对于我个人而言，2023 年是一个很重要的转折点，不在于物质上有多大的变化，而是在于思维上，在于精神上的转变，不再有过去那种懵懵懂懂，浑浑噩噩的过日子的感觉，上次这种感觉还是在小学 5 年级的一个夜晚，突然懂事的开窍，觉得学习很重要，要好好读书的醒悟。因此接下来这一篇年度总结的灵感来源于：罗振宇老师的【2024年跨年演讲】主题 ——  是什么让我眼前一亮。&lt;/p&gt;
&lt;p&gt;因此，2023 年对于国家，对于公司，对于个人，都是非常不容易的一年，疫情刚过去，经济下调，个人面临裁员，很多人负面情绪都积压快爆炸了，因此2023 年对于大多数人来说，其实是积压了很多垃圾情绪的一年，更因为这样子，我们更加应该去发现今年自己的高光时刻，去找到那个让能自己变得骄傲的自己，找到那个自信的自己，从而更加从容的面对未来，面对 2024 年。&lt;/p&gt;
&lt;p&gt;温馨提示：本文文字居多，且内容主要偏向于个人总结，如果觉得对自己有用的，请耐心观看。&lt;/p&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>AI春晚之 2023年openAI 开发者大会</title>
    <link href="https://www.qborfy.com/ailearn/openai-dev-20231106.html"/>
    <id>https://www.qborfy.com/ailearn/openai-dev-20231106.html</id>
    <published>2023-11-08T10:00:01.000Z</published>
    <updated>2023-11-09T02:17:03.161Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>2023-11-06，openAI公司在美国旧金山举办第一届开发者大会，大会内容总结如下：</p><ul><li>回顾过去一年发展</li><li>推出新产品<ul><li>GPT4 Turbo</li><li>GPTs， GPT Store（GPT商店）</li><li>GPT Builder GPT应用构建工具</li><li>Assistants API 助手API </li></ul></li></ul><span id="more"></span><p>视频播放地址：</p><iframe src="//player.bilibili.com/player.html?aid=278248328&bvid=BV1Vw411T7gA&cid=1325819721&p=1&page=1&high_quality=1&danmaku=0" allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"> </iframe><h1 id="回顾过去一年历史"><a href="#回顾过去一年历史" class="headerlink" title="回顾过去一年历史"></a>回顾过去一年历史</h1><ul><li>2022年11月30日，发布了GPT3.5</li><li>2023年3月，推出GPT4，目前性能最好的大语言模型</li><li>近几个月，推出语音与视觉功能</li><li>多利3号（DALL-E 3），世界最先进的图像模型</li><li>支持企业版，更安全和隐私，以及更高速度和更长上下文等能力</li></ul><p>数据展示：</p><ul><li><strong>200万</strong>开发者正在使用OpenAI的API（应用程序接口</li><li><strong>92%</strong>的500强公司正在使用OpenAI的产品搭建服务</li><li><strong>1亿人</strong>达到周活用户数</li></ul><h1 id="GPT4-Turbo简介"><a href="#GPT4-Turbo简介" class="headerlink" title="GPT4 Turbo简介"></a>GPT4 Turbo简介</h1><p><img src="/assets/img/ailearn/openai1.jpg" alt=""></p><h2 id="要点如下："><a href="#要点如下：" class="headerlink" title="要点如下："></a>要点如下：</h2><p><img src="/assets/img/ailearn/openai2.jpg" alt=""></p><ul><li>更多的上下文长度：<ul><li>支持8K到128K token数目，堪比一本300页的标准书</li></ul></li><li>更多和更加细粒度的控制：<ul><li>支持json输出，可以让开发使用起来更加方便</li><li>支持重复输出，可以针对同一个种子因素进行重复输出，如：同一个问题，可以重复获取到相同的答案</li><li>支持查看调用API的日志问题</li></ul></li><li>更好的知识库：<ul><li>将知识更新到2023年4月</li></ul></li><li>更多模型也可以通过API调用<ul><li>DALL-E 3图像模型</li><li>语音文本模型，wishper V3开源语言模型</li></ul></li><li>定制化模型：<ul><li>参与到特定领域的开发，定制化模型</li></ul></li><li>扩大速率限制：<ul><li>开发者可以申请进一步提高速率</li></ul></li></ul><h2 id="GPT4价格"><a href="#GPT4价格" class="headerlink" title="GPT4价格"></a>GPT4价格</h2><ul><li>1000 input token 0.01美元</li><li>1000 output token  0.03美元</li></ul><h1 id="GPTs"><a href="#GPTs" class="headerlink" title="GPTs"></a>GPTs</h1><blockquote><p>GPTs 支持用户将能通过自定义指令、拓展（模型）的知识边界和下达行动命令，来构建自己的GPT，并能对外发布给全球更多的人使用。更重要的是，整个构建“自定义GPT”的过程也是通过自然语言对话形成的。</p></blockquote><p>用我们容易理解的话，就是我们可以定制化属于我们自己的个人智能助手，协助我们一切日常生活和工作。</p><h2 id="GPT-Builder"><a href="#GPT-Builder" class="headerlink" title="GPT Builder"></a>GPT Builder</h2><p>提供一个界面，利用对话和一些更多简单操作，可以让你快速创建属于你自己的GPT个人助手。</p><ul><li>通过自定义指令，一些初始化命令</li><li>拓展（模型）的知识边界，传入一些知识类文件，如：文本/语音/图片等</li><li>下达行动命令，通过一些action按钮，让助手输出一些我们想要的答案</li></ul><p>不久后，将推出GPT Store，这些特定领域的GPT知识助手可以公开给任何人使用。</p><h1 id="Assistants-API"><a href="#Assistants-API" class="headerlink" title="Assistants API"></a>Assistants API</h1><p>Assistants API，“助理API”是一个专门构建的人工智能，具有特定的指令，利用额外的知识，并能调用模型和工具来执行任务。</p><ul><li>开发者可以利用提供的助手API去处理不同的线程和消息</li><li>可以调用其他第三方API，并更根据返回的数据经过GPT，按照自己的意愿去做定制化处理优化</li><li>支持函数范式调用</li></ul><p>以上就是OpenAI DEV开发者大会，全程直播45分钟，没有任何水货，全是干货，很多东西都需要自己去体验后才知道。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;2023-11-06，openAI公司在美国旧金山举办第一届开发者大会，大会内容总结如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回顾过去一年发展&lt;/li&gt;
&lt;li&gt;推出新产品&lt;ul&gt;
&lt;li&gt;GPT4 Turbo&lt;/li&gt;
&lt;li&gt;GPTs， GPT Store（GPT商店）&lt;/li&gt;
&lt;li&gt;GPT Builder GPT应用构建工具&lt;/li&gt;
&lt;li&gt;Assistants API 助手API &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="技术分享" scheme="https://www.qborfy.com/tags/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    <category term="AI系列" scheme="https://www.qborfy.com/tags/AI%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>2023年中总结之如何在互联网裁员浪潮继续前(gou)进(zhu)</title>
    <link href="https://www.qborfy.com/study/2023-middle.html"/>
    <id>https://www.qborfy.com/study/2023-middle.html</id>
    <published>2023-09-07T10:00:01.000Z</published>
    <updated>2023-09-06T15:48:15.862Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>从去年疫情还没解封开始，陆陆续续就传来各种裁员新闻，虽然去年没有波及到我，但是基本上身边的朋友多多少少都几个被牵扯到了，因此我这边很焦虑，从2023年1月1日起，开始重新踏起起点，不断学习，不断更新个人博客，这一篇算是对我今年半年的总结以及复盘。</p><p>温馨提示：本文文字居多，且内容主要偏向于个人总结，如果觉得对自己有用的，请耐心观看。</p><span id="more"></span><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>为什么会有这个改变，最大的动因是裁员新闻，但是真正让我动起来的是我关注了一个抖音博主<a href="https://v.douyin.com/ierkhowR/">姜胡说</a>，他2022年12月31日发布一条视频，就是在2023年做出改变宣言，让我深感触动，所以我也开始主动去改变自己，而不是被动去接纳变化。这是他的视频里的几个图片，大家可以看看。</p><p><img src="/assets/img/2023middle/all.gif" alt="1"></p><p>我给大家总结一下：</p><ul><li>1~2小时去完成最重要的事情</li><li>8小时睡眠</li><li>每天输出写点什么</li><li>健身冥想</li><li>掌握新技能</li><li>认识20位有趣的人</li><li>做一件对社会有益的事情</li></ul><h2 id="裁员浪潮"><a href="#裁员浪潮" class="headerlink" title="裁员浪潮"></a>裁员浪潮</h2><p>从2022年开始到2023年中，从各个裁员新闻，到自己亲自体验，下面我们感受裁员浪潮带来的寒气：</p><ul><li>2022年中旬腾讯业绩下滑，PCG裁员幅度达到50%</li><li>2022年8月华为任正非内部文章，“把寒气传递给每个人”，正式开启国内裁员大浪潮</li><li>2022年9月shopee大裁员，新加坡机场直接辞退员工</li><li>2022年12月，国外谷歌、微软、亚马逊纷纷传来裁员新闻</li><li>2023年5月，Twitter裁员，剩下不到2000人</li><li>2023年5月，阿里财报显示一年裁员达到2万人</li><li>…</li></ul><p>今年6月，博主所在部门也开始裁员，大概是60%，这一波是真狠，因为之前好几波裁员都没动到我们部门，没想这次一动，差点整个部门都没有了，因此就体验了一把裁员。裁员后，就开始找工作，面试机会真实少呀，尤其博主已经30出头，距离35岁也没几年了，技术上这几年也没沉淀出个什么来，所以有几次好机会都白白浪费掉了，所以才会痛定思痛，开始改变自己的一些观念和行为。</p><p>好了，前面背景大概就说这么多，接下来开始对今年半年来的一些改变总结。</p><h1 id="年中总结"><a href="#年中总结" class="headerlink" title="年中总结"></a>年中总结</h1><h2 id="半年成果"><a href="#半年成果" class="headerlink" title="半年成果"></a>半年成果</h2><p>先说说半年改变后的成果，也算是付出得来一定收获，虽然不多但是贵在行动起来了，万事开头难，后面就按照计划去做。</p><ul><li>技术分享文章，大概50+篇，开头的时候基本上每天都能输出一篇，因为有很多可以写，但是到了后面每研究一个技术点就需要花费大量时间去查和实践</li><li>睡眠时间，从之前每晚2～3点睡，改成11点半左右睡，目前几乎每天都睡足8个小时</li><li>阅读书籍，大概5本左右，数量很少，主要集中在和思维模式相关的书，后面会一一罗列出来</li><li>掌握技能，看了一些营销、剪辑、电商运营相关的视频，也开始运营自己的抖音和拼多多电商账号，但是成果不怎么样</li><li>运动时间，坚持每周至少运动两次，每次都运动半小时以上</li><li>人际关系，缺乏社交渠道，几乎没怎么认识新的朋友，但是和老朋友的沟通越来越多了</li></ul><p>总的来说，经过半年的改变，整个人的精气神都发生很大的变化，首先不再那么焦虑了，其次明白做事和做人的一些道理，也懂得如何将道理真正去实施，最后重新总结了一下人生座右铭：</p><blockquote><p>健康的身体，清晰的脑袋和一颗积极的心</p></blockquote><h2 id="年度计划"><a href="#年度计划" class="headerlink" title="年度计划"></a>年度计划</h2><p>接下来我简单描述一下我的2023年1月1号依据<code>姜胡说</code>博主给的建议制定的改变自己的计划：</p><p>￼- 每天花两个小时写技术文章<br>￼- 每天十二点之前睡觉，八点起床<br>￼- 每天学点新知识点，然后尝试100字以上学习总结<br>￼- 每天冥想半小时，健身半小时<br>￼- 结识20位有趣的人，想办法加入vue开源项目，尝试给vue开源项目修复issue同时提PR<br>￼- 掌握一项新技能，短视频账号（知识库）运营和内容剪辑<br>￼- 做一件对社会有益的事情，参加社会公益活动，如：开源项目，低代码企业级应用平台，多编辑器方案</p><h2 id="技术文章总结"><a href="#技术文章总结" class="headerlink" title="技术文章总结"></a>技术文章总结</h2><p>目前我给自己设定几个专栏去分类写技术文章，主要有以下几个：</p><ul><li><a href="https://juejin.cn/column/7222531019320459319">100道前端精品面试题</a>，目前17 人订阅，共7篇文章<ul><li>主要被面试打击后，决定沉下心来好好研究一下面试相关的知识点</li></ul></li><li><a href="https://juejin.cn/column/7209178782657445943">架构之路</a>，1 人订阅，共1篇文章<ul><li>这个算是我在技术道路继续深造的一个方向，架构师技术不仅要求知识领域很广，而且也要知识深度</li></ul></li><li><a href="https://juejin.cn/column/7208869642905862202">每日技术分享</a>，4 人订阅，共21篇文章<ul><li>主要输出自己的一些技术总结和遇到的问题，总结后分享给大家查阅</li></ul></li><li><a href="https://juejin.cn/column/7202877900239061048">低代码系列</a>，13 人订阅，共4篇文章<ul><li>低代码是博主目前最感兴趣的内容，但是由于工作上种种原因，很多技术会被搁置了很久</li></ul></li><li><a href="https://juejin.cn/column/7182042964057653285">前端算法</a>，1 人订阅，共2篇文章<ul><li>算法一直是博主的弱点，打算从基础的数据结构写起，直到可以把相关算法吃透</li></ul></li><li><a href="https://juejin.cn/column/7275151854060781628">AI Learn学习</a>，新开专栏<ul><li>AI会成为以后程序员必备的工具之一，如同搜索引擎一样，所以下半年新开的专栏，主要用来输出和学习AI相关的文章</li></ul></li></ul><p>还有一些文章并不合适放到掘金平台上，如果感兴趣的同学可以到我的个人博客去查看，博客地址:<a href="https://qborfy.com">Qborfy个人博客</a>。</p><h2 id="阅读书籍"><a href="#阅读书籍" class="headerlink" title="阅读书籍"></a>阅读书籍</h2><p>今年阅读书籍如下，也推荐给大家一起阅读。</p><h3 id="技术类"><a href="#技术类" class="headerlink" title="技术类"></a>技术类</h3><ul><li>领域驱动设计，在读，一本架构师必读书籍，什么是DDD架构模型，看这本书就行</li><li>Vue.js设计与实现，在读，Vue3源码阅读的参考书籍，作者是Vue.js开发团队成员之一</li><li>从零开始学架构，未读，架构师的入门书籍</li><li>架构师修炼之道，未读，架构师的入门书籍</li><li>JavaScript设计模式与开发实践，未读，设计模式重新捡起来</li><li>thinking-architecturally，未读，英文原稿，没有翻译，可能后面要苦读了</li></ul><h3 id="非技术类"><a href="#非技术类" class="headerlink" title="非技术类"></a>非技术类</h3><ul><li>高效能人士的七个习惯，已读，一本能让你对自己成长周期有更加直观感受的书籍，7个习惯如果养成了，你就螺旋上升了</li><li>思考的框架，在读，主要讲常用的思维模型，能让你面对问题，更加清晰去做出各种选择和判断</li><li>天道，在读，主要思考人生哲理和社会关系</li><li>三体，在读，主要用来营造自己的宇宙观</li><li>瓦尔纳的湖畔，在读，主要用来思考，现在的生活方式是自己想要的吗</li><li>海龟交易法则，未读，主要是未来从股市赚钱而看</li><li>投资的原则，未读，主要是未来从股市赚钱而看</li><li>我如何从股市赚了200万，未读，主要是未来从股市赚钱而看</li><li>股市投资的24堂必修课，未读，主要是未来从股市赚钱而看</li><li>我来教你变富，未读，主要是未来从股市赚钱而看</li><li>价值新法，在读，主要从里面学习作者（姜胡说）的一些学习方式和方法</li></ul><p>PS: 这么多书，不知道今年能不能看完，不过有些书粗读一遍就可以了，有些书则需要反复阅读，有些书是用的时候拿出来翻一翻找到知识点解疑即可。</p><h2 id="心态总结"><a href="#心态总结" class="headerlink" title="心态总结"></a>心态总结</h2><p>如标题所言，如何在裁员浪潮中继续前(gou)进(zhu)，这就是需要你拥有一个非常稳定且积极的心态去面对。</p><p>2023年从接到裁员消息，到裁员真正落地，我从来对未知的恐惧，到经过不断阅读和学习，我觉得我的心态从被动接受变化，转变成主动积极拥抱变化，甚至于我都开始计划35岁后失业应该要做什么事情。</p><p>因此，心态不是几句话就可以改变的了，而是需要你去行动，去做一些能让自己变得更好的行为，正如王阳明的心学一样，知行合一。道理大家都知道，但是真正能做到并坚持下去的，很难。正因为很难，所以坚持做下去，才会有收获，心态才会更加稳定面对各种未来的变化。</p><p>总结心态变化的几个点：</p><ul><li>从被动接受工作任务，到主动积极去参与制定各种工作计划和排期去完成任务</li><li>凡事多问，为什么和然后呢，然后抓住事情的重点是什么</li><li>从习惯性忘记，到主动负责，从生活到工作，需要负责的事情需要主动去做，你可以选择不做或者不负责，但是结果往往会让你更加无法承担</li><li>从随便都行，到追求完美，有些事情或者东西真的不可以随便，因为你随便处理的结果就等于没做，或者让事情变得更加糟糕</li></ul><h1 id="下半年计划"><a href="#下半年计划" class="headerlink" title="下半年计划"></a>下半年计划</h1><p>写了这么多，上半年是开始，但是我希望通过这篇文章的发表，能让我更加坚持这个改变，因为发表了文章等于发表我的个人宣言，所以下半年我会继续坚持执行年度计划，同时加强以下几个方面：</p><ul><li>技术分享文章的编写应该更加注重可用性和实战性，以及对技术未来发展趋势的把握</li><li>阅读书籍暂时不要新增了，先把计划内的书看完，以及输出相关内容出来</li><li>短视频账号需要尽快运营起来，剪辑技能需要培养</li><li>认识20个有趣的人，扩大自己的认知圈</li><li>AI这次不能再错过了，需要加大投入时间</li></ul><p>最后，希望阅读完后对你的人生也能发生一点改变，同时也祝福大家都能扛过2023年的寒潮，然后变得越来越健康，越来越有钱。</p><blockquote><p>我是一个爱阅读和爱分享的博主Qborfy，欢迎大家到我的博客参观。<a href="https://qborfy.com">Qborfy博客</a></p></blockquote><p>PS: 觉得我写的还行，可以到我的博客里，有微信二维码可以加我好友哟～</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;从去年疫情还没解封开始，陆陆续续就传来各种裁员新闻，虽然去年没有波及到我，但是基本上身边的朋友多多少少都几个被牵扯到了，因此我这边很焦虑，从2023年1月1日起，开始重新踏起起点，不断学习，不断更新个人博客，这一篇算是对我今年半年的总结以及复盘。&lt;/p&gt;
&lt;p&gt;温馨提示：本文文字居多，且内容主要偏向于个人总结，如果觉得对自己有用的，请耐心观看。&lt;/p&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>AI信息收集篇</title>
    <link href="https://www.qborfy.com/ailearn/all-info.html"/>
    <id>https://www.qborfy.com/ailearn/all-info.html</id>
    <published>2023-09-06T10:00:01.000Z</published>
    <updated>2023-09-06T11:47:28.902Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./logo-1.png" alt=""></p><blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h1 id="大模型篇"><a href="#大模型篇" class="headerlink" title="大模型篇"></a>大模型篇</h1><h1 id="AIGC篇"><a href="#AIGC篇" class="headerlink" title="AIGC篇"></a>AIGC篇</h1><h1 id="开源工具篇"><a href="#开源工具篇" class="headerlink" title="开源工具篇"></a>开源工具篇</h1><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;./logo-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id</summary>
      
    
    
    
    
    <category term="技术分享" scheme="https://www.qborfy.com/tags/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    <category term="AI系列" scheme="https://www.qborfy.com/tags/AI%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>低代码平台加载远端组件解决方案(2)——项目实战</title>
    <link href="https://www.qborfy.com/lowcode/async-component-2.html"/>
    <id>https://www.qborfy.com/lowcode/async-component-2.html</id>
    <published>2023-09-04T14:00:01.000Z</published>
    <updated>2023-09-06T09:16:48.124Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前阵子搞了一下如何在Vue项目中加载远程的组件，文章为<a href="https://qborfy.com/lowcode/async-component.html">【低代码平台加载远端组件解决方案(1)——defineAsyncComponent】</a>，遗留一些问题，就是如何在项目中实际应用，因为所有的问题都来源自实际项目，所以本文会继续把这个坑填完。</p><h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>涉及到项目实战了，解决方案是需要通过<code>wepack</code>或<code>vite</code>构建工具将资源进行打包，然后通过解析文件，进行模拟封装成可以加载的 js函数即可，下面我们以 vite为构建工具进行编译组件文件<code>async/Async.vue</code></p><span id="more"></span><p>解决步骤</p><ol><li>给<code>Async.vue</code>单独创建一个编译脚本，如<code>vite.remote.config.ts</code>，参考配置如下：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue&#x27;</span></span><br><span class="line"><span class="comment">// https://vitejs.dev/config/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;@&#x27;</span>: <span class="string">&#x27;/src&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;vue&#x27;</span>: <span class="string">&#x27;vue/dist/vue.esm-bundler.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">vue</span>(),</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">publicDir</span>: <span class="literal">false</span>, <span class="comment">// 忽略public资源包</span></span><br><span class="line">  <span class="attr">build</span>: &#123;</span><br><span class="line">    <span class="comment">// 入口文件</span></span><br><span class="line">    <span class="attr">lib</span>: &#123;</span><br><span class="line">      <span class="attr">entry</span>: <span class="string">&#x27;./src/components/Async.vue&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;AsyncComponent&#x27;</span>,</span><br><span class="line">      <span class="attr">fileName</span>: <span class="string">&#x27;AsyncComponent.bundle&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">rollupOptions</span>: &#123;</span><br><span class="line">      <span class="attr">external</span>: [<span class="string">&#x27;vue&#x27;</span>],</span><br><span class="line">      <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">globals</span>: &#123;</span><br><span class="line">          <span class="attr">vue</span>: <span class="string">&#x27;Vue&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">dir</span>: <span class="string">&#x27;dist/remote&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li>执行构建后会生成两个文件<code>RemoteComponent.bundle.mjs</code>和 <code>RemoteComponent.bundle.umd.js</code> 到 <code>dist/remote/</code> 目录下</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vite -c vite.async.config.ts build</span><br></pre></td></tr></table></figure><ol start="3"><li>调整<code>loadRemoteComponent</code>解析远端组件的函数，可以通过加载 <code>window.Vue</code> 标签的形式进行引入<code>RemoteComponent.bundle.umd.js</code>加载使用</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">loadRemoteComponent</span> = <span class="keyword">async</span> (<span class="params">url: string</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">        script.<span class="property">src</span> = url</span><br><span class="line">        script.<span class="property">onload</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="variable language_">window</span>.<span class="property">AsyncComponent</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        script.<span class="property">onerror</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Failed to load remote component&#x27;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(script)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>调整源项目入口文件<code>main.ts</code>，将Vue暴露到window全局对象中，方便远程组件注册使用</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * main.ts</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title class_">Vue</span>.<span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line">app.<span class="title function_">use</span>(router)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴露全局对象到window</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">Vue</span> = <span class="title class_">Vue</span></span><br></pre></td></tr></table></figure><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ul><li>在Typescript中对window进行赋值时候会出现报错，需要对全局变量声明，代码如下：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="variable language_">global</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">Vue</span>: any</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">AsyncComponent</span>: any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然如上所述的vite配置大概是可以实现单个 vue文件进行打包放到远程服务器上，然后我们在另外一个项目去加载实现，从而解决掉低代码需要依赖很多组件从而导致初次加载文件很大的问题。</p><h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><p>不过在实现和应用后，还是发现很多一些缺陷，具体如下：</p><h2 id="Vue暴露全局"><a href="#Vue暴露全局" class="headerlink" title="Vue暴露全局"></a>Vue暴露全局</h2><p>问题描述：将<code>Vue</code>暴露到全局里，将 Vue 暴露到 window 对象上可能会带来以下几个潜在问题：</p><ul><li>全局命名空间污染：将 Vue 实例挂载到 window 对象上可能会导致全局命名空间污染，从而增加代码冲突和意外覆盖的风险。如果你的项目中使用了其他库，或者多个 Vue 应用共享同一个页面，这可能会导致问题。</li><li>安全风险：将 Vue 实例暴露到全局作用域可能会增加安全风险，因为恶意第三方脚本可以访问和修改 Vue 实例。这可能导致应用程序的数据泄露或被篡改。</li><li>模块化和封装：将 Vue 实例挂载到 window 对象上破坏了模块化和封装原则。这可能会导致代码难以维护和扩展。使用模块化的方法（例如 ES6 模块或 CommonJS）可以更好地组织和管理代码。</li><li>可测试性：将 Vue 实例暴露到全局作用域可能会影响代码的可测试性。编写针对全局对象的测试可能会更加复杂，因为你需要在测试用例之间清理和重置全局状态。</li></ul><p>解决方案暂无，后面如果有解决方案会补充到这里来。</p><h2 id="vite的lib模式多入口打包"><a href="#vite的lib模式多入口打包" class="headerlink" title="vite的lib模式多入口打包"></a>vite的lib模式多入口打包</h2><p>问题描述：<code>vite.remote.config.ts</code>文件中只能单独打包一个Vue文件，如果是多个Vue文件，这里无法解决，其实要解决的话也很简单，就是使用多入口打包。</p><p>关于vite的lib模式多入口打包，官网并没有比较灵好的解决方案，解决方案，如下：</p><ul><li>通过编写<code>build.mjs</code>，去遍历需要打包的文件，然后传入变量到<code>vite</code>的<code>config</code>配置中</li></ul><p>下面的具体代码<code>build.mjs</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig, build &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取需要编译的入口组件列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getBuildItems</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">entry</span>: path.<span class="title function_">resolve</span>(<span class="string">&#x27;./src/components/Async.vue&#x27;</span>), <span class="comment">// 入口文件地址</span></span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;AsyncComponent&#x27;</span>, <span class="comment">// 组件名称</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">entry</span>: path.<span class="title function_">resolve</span>(<span class="string">&#x27;./src/components/ListWebSite.vue&#x27;</span>),</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;ListWebSite&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> buildItems = <span class="title function_">getBuildItems</span>()</span><br><span class="line"></span><br><span class="line">buildItems.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">build</span>(&#123;</span><br><span class="line">        <span class="attr">configFile</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">resolve</span>: &#123;</span><br><span class="line">            <span class="attr">alias</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;@&#x27;</span>: <span class="string">&#x27;/src&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;vue&#x27;</span>: <span class="string">&#x27;vue/dist/vue.esm-bundler.js&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">plugins</span>: [</span><br><span class="line">            <span class="title function_">vue</span>(),</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">publicDir</span>: <span class="literal">false</span>, <span class="comment">// 忽略public资源包</span></span><br><span class="line">        <span class="attr">build</span>: &#123;</span><br><span class="line">            <span class="attr">cssCodeSplit</span>: <span class="literal">false</span>, <span class="comment">// 禁用 CSS 代码分割</span></span><br><span class="line">            <span class="attr">lib</span>: &#123;</span><br><span class="line">                <span class="attr">entry</span>: item.<span class="property">entry</span>,</span><br><span class="line">                <span class="attr">formats</span>: [<span class="string">&#x27;umd&#x27;</span>],</span><br><span class="line">                <span class="attr">name</span>: item.<span class="property">name</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">rollupOptions</span>: &#123;</span><br><span class="line">                <span class="attr">external</span>: [<span class="string">&#x27;vue&#x27;</span>],</span><br><span class="line">                <span class="attr">output</span>: &#123;</span><br><span class="line">                    <span class="attr">entryFileNames</span>: <span class="function">() =&gt;</span> <span class="string">&#x27;[name].[format].js&#x27;</span>,</span><br><span class="line">                    <span class="attr">assetFileNames</span>: <span class="string">`[name].[ext]`</span>,</span><br><span class="line">                    <span class="attr">globals</span>: &#123;</span><br><span class="line">                        <span class="attr">vue</span>: <span class="string">&#x27;Vue&#x27;</span>,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">dir</span>: <span class="string">`dist/remote/<span class="subst">$&#123;item.name&#125;</span>`</span>, <span class="comment">// 固定到对应文件夹中</span></span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="组件css样式文件注入到JS"><a href="#组件css样式文件注入到JS" class="headerlink" title="组件css样式文件注入到JS"></a>组件css样式文件注入到JS</h2><p>问题描述：在打包后我们发现，打包后会自动生成一个style.css文件，但是我们在加载js文件并没有把css文件也加载，导致组件样式无法正常显示。</p><blockquote><p>Vite Issue: <a href="https://github.com/vitejs/vite/issues/1579">Can css be styleInjected in library mode?</a><br>尤大大在原文是这么描述的：<br><a href="https://github.com/yyx990803">Evan You</a>The problem is injecting the style assumes a DOM environment which will make the library SSR-incompatible.<br>If you only have minimal css, the easiest way is to simply use inline styles.</p></blockquote><p>翻译过来就是：问题是注入样式假定了 DOM 环境，这将使库 SSR 不兼容。如果您只有最少的 CSS，最简单的方法就是简单地使用内联样式。</p><p>解决方案：如果我们非要这么实现的话，可以自己写个插件，通过vite构建过程，将css样式代码注入到js文件中，主要还是通过创建<code>&lt;link&gt;</code>标签去加载组件的样式文件。</p><p>其实已经有现成的插件<a href="https://github.com/marco-prontera/vite-plugin-css-injected-by-js"><code>vite-plugin-css-injected-by-js</code></a>了，我们这里简单学习如何开发一个vite插件了。</p><p>写一个vite插件，具体如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; cssCode </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; styleId </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">injectCssIntoHtml</span>(<span class="params">cssCode, styleId</span>) &#123;</span><br><span class="line">    cssCode = <span class="string">&#x27;`&#x27;</span>+cssCode+<span class="string">&#x27;`&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> styleHtml = <span class="string">`</span></span><br><span class="line"><span class="string">    ;(function()&#123; </span></span><br><span class="line"><span class="string">        try &#123;</span></span><br><span class="line"><span class="string">            var elementStyle = document.createElement(\&#x27;style\&#x27;); </span></span><br><span class="line"><span class="string">            var styleNode = document.createTextNode(<span class="subst">$&#123;cssCode&#125;</span>);</span></span><br><span class="line"><span class="string">            elementStyle.appendChild(styleNode);</span></span><br><span class="line"><span class="string">            elementStyle.id = &quot;<span class="subst">$&#123;styleId | <span class="built_in">Date</span>.now()&#125;</span>&quot;;</span></span><br><span class="line"><span class="string">            document.head.appendChild(elementStyle);</span></span><br><span class="line"><span class="string">        &#125;catch(e)&#123;</span></span><br><span class="line"><span class="string">            console.error(\&#x27;vite-plugin-css-injected-by-js\&#x27;, e);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;)();</span></span><br><span class="line"><span class="string">    `</span>.<span class="title function_">replace</span>(<span class="regexp">/\n/g</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment">// 简单压缩</span></span><br><span class="line">    <span class="keyword">return</span> styleHtml;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将组件样式注入js中，generateBundle 是Rollup的hook函数，时间点在bundle资源生成末尾，write写入之前调用</span></span><br><span class="line"><span class="comment"> * 大概实现原理，在构建bundle中，去掉css的资源生成，将其代码通过js代码进行实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; styleId 样式id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">VitePluginStyleInject</span>(<span class="params">styleId</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> styleCode = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;vite-plugin-style-inject&#x27;</span>, <span class="comment">// 插件名称</span></span><br><span class="line">        <span class="attr">apply</span>: <span class="string">&#x27;build&#x27;</span>, <span class="comment">// 应用模式</span></span><br><span class="line">        <span class="attr">enforce</span>: <span class="string">&#x27;post&#x27;</span>, <span class="comment">// 作用阶段</span></span><br><span class="line">        <span class="attr">generateBundle</span>: <span class="keyword">function</span> (<span class="params">opts, bundle</span>) &#123;</span><br><span class="line">            <span class="comment">// + 遍历bundle</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> bundle) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bundle[key]) &#123;</span><br><span class="line">                    <span class="keyword">const</span> chunk = bundle[key]; <span class="comment">// 拿到文件名对应的值</span></span><br><span class="line">                    <span class="comment">// 判断+提取+移除</span></span><br><span class="line">                    <span class="keyword">if</span> (chunk.<span class="property">type</span> === <span class="string">&#x27;asset&#x27;</span> &amp;&amp; chunk.<span class="property">fileName</span>.<span class="title function_">includes</span>(<span class="string">&#x27;.css&#x27;</span>)) &#123;</span><br><span class="line">                        styleCode += chunk.<span class="property">source</span>;</span><br><span class="line">                        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;key:&#x27;</span>, key, styleCode + <span class="string">&quot; ========&gt;&quot;</span>)</span><br><span class="line">                        <span class="keyword">delete</span> bundle[key];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到对应js资源，将生成的styleCode写入</span></span><br><span class="line">            <span class="keyword">const</span> styleTemplate = <span class="title function_">injectCssIntoHtml</span>(styleCode, styleId); </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> bundle) &#123;</span><br><span class="line">                <span class="keyword">const</span> chunk = bundle[key]</span><br><span class="line">                <span class="keyword">if</span>(chunk &amp;&amp; chunk.<span class="property">type</span> === <span class="string">&#x27;chunk&#x27;</span> &amp;&amp; chunk.<span class="property">fileName</span>.<span class="title function_">match</span>(<span class="regexp">/.[cm]?js$/</span>) !== <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">const</span> initialCode = chunk.<span class="property">code</span>; <span class="comment">// 保存原有代码</span></span><br><span class="line">                    <span class="comment">// 拼接原有代码</span></span><br><span class="line">                    chunk.<span class="property">code</span> = styleTemplate + initialCode </span><br><span class="line">                    <span class="comment">// 一个bundle插入一次即可</span></span><br><span class="line">                    <span class="keyword">break</span>; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用插件配置只需要在vite的配置插件加入即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">plugins</span>: [<span class="title function_">vue</span>(), <span class="title class_">VitePluginStyleInject</span>(),]</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常感谢大家耐心阅读，如果上述描述的方案有任何问题都可以留言讨论，博主会第一时间随时调整和验证。 涉及到的测试案例+<code>build.async.mjs</code>源码放到github上，感兴趣可以去看看。</p><p><a href="https://github.com/qiubohong/website/blob/master/build/build.async.mjs">完整版本vite构建配置 build.async.mjs</a></p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="Rollup-Hook函数生命周期"><a href="#Rollup-Hook函数生命周期" class="headerlink" title="Rollup Hook函数生命周期"></a>Rollup Hook函数生命周期</h2><p><img src="/assets/img/rollup-hook-life.png" alt="/assets/img/rollup-hook-life.png"></p><p>所以项目中使用vite，其实可以参考Rollup这个生命周期，遇到一些问题可以很快速的定位和解决。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://cn.vitejs.dev/guide/">Vite官方文档</a></li><li><a href="https://github.com/marco-prontera/vite-plugin-css-injected-by-js">vite-plugin-css-injected-by-js 一个可以把css打包到js文件里的vite插件</a></li><li><a href="https://github.com/vitejs/vite/discussions/1736">Multiple entry points/output in library mode? (Vite Lib模式下的多个入口点?)</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;前阵子搞了一下如何在Vue项目中加载远程的组件，文章为&lt;a href=&quot;https://qborfy.com/lowcode/async-component.html&quot;&gt;【低代码平台加载远端组件解决方案(1)——defineAsyncComponent】&lt;/a&gt;，遗留一些问题，就是如何在项目中实际应用，因为所有的问题都来源自实际项目，所以本文会继续把这个坑填完。&lt;/p&gt;
&lt;h1 id=&quot;解决思路&quot;&gt;&lt;a href=&quot;#解决思路&quot; class=&quot;headerlink&quot; title=&quot;解决思路&quot;&gt;&lt;/a&gt;解决思路&lt;/h1&gt;&lt;p&gt;涉及到项目实战了，解决方案是需要通过&lt;code&gt;wepack&lt;/code&gt;或&lt;code&gt;vite&lt;/code&gt;构建工具将资源进行打包，然后通过解析文件，进行模拟封装成可以加载的 js函数即可，下面我们以 vite为构建工具进行编译组件文件&lt;code&gt;async/Async.vue&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="技术分享" scheme="https://www.qborfy.com/tags/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    <category term="每日更新" scheme="https://www.qborfy.com/tags/%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0/"/>
    
    <category term="低代码" scheme="https://www.qborfy.com/tags/%E4%BD%8E%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>低代码平台加载远端组件解决方案(1)——defineAsyncComponent</title>
    <link href="https://www.qborfy.com/lowcode/async-component.html"/>
    <id>https://www.qborfy.com/lowcode/async-component.html</id>
    <published>2023-08-29T14:00:01.000Z</published>
    <updated>2023-09-05T12:18:46.728Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在做低代码平台项目中遇到一个很容易遇到的问题，具体描述如下：</p><ul><li>问题描述：低代码平台依赖的组件库，如果将一个组件库进行融合打包到平台项目中的就会导致平台在渲染页面的时候需要加载完整的组件库，从而导致页面加载了一些大部分页面不需要的组件文件</li><li>希望方案：页面使用到哪些组件就去动态加载组件</li><li>解决方案：<ul><li>Vue的异步加载组件，<code>Suspense</code>和<code>defineAsyncComponent</code></li><li>React的异步加载组件， <code>Suspense</code>和<code>import()</code></li></ul></li></ul><p>由于低代码项目本身使用的 Vue3 框架，而且 Vue和  React的异步加载组件方案其实差异不多，所以下面以 Vue为主进行介绍。</p><span id="more"></span><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h2><p>在使用异步组件之前，我们需要先声明一个 Vue的异步组件，主要有以下几种方式：</p><p>第一种，采用<code>&lt;script setup&gt;</code>语法的，需要在 setup中 使用  await语法即可，例子如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(...)</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> posts = <span class="keyword">await</span> res.<span class="title function_">json</span>()</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二种，声明<code>setup</code>函数增加<code>async</code>，会被识别成异步组件，具体如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(...)</span><br><span class="line">    <span class="keyword">const</span> posts = <span class="keyword">await</span> res.<span class="title function_">json</span>()</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      posts</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种，就是通过<code>defineAsyncComponent</code>函数定义异步获取的组件实例，具体如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AsyncComp</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...从服务器获取组件</span></span><br><span class="line">    <span class="title function_">resolve</span>(<span class="comment">/* 获取到的组件 */</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ... 像使用其他一般组件一样使用 `AsyncComp`</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意：同时Vue组件有个配置属性<code>suspensible</code>，可以用来设置<code>false</code>忽略为异步组件。</strong></p><h2 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h2><blockquote><p><code>&lt;Suspense&gt;</code> 是一个内置组件，用来在组件树中协调对异步依赖的处理。它让我们可以在组件树上层等待下层的多个嵌套异步依赖项解析完成，并可以在等待时渲染一个加载状态。 —— <a href="https://cn.vuejs.org/guide/built-ins/suspense.html">Vue官方 Suspense定义</a></p></blockquote><p><code>&lt;Suspense&gt;</code>解决了我们什么问题：</p><ul><li>当我们有个全局 loading，就不再需要每个组件的针对自己的加载状态去写逻辑处理</li><li>能够更好统一处理异步组件，减少逻辑代码</li><li>结合路由切换 和 <code>&lt;Transition&gt;</code>，可以完美实现页面切换效果</li></ul><p>目前只有异步组件才会触发<code>&lt;Suspense&gt;</code>状态变更。</p><h3 id="使用Suspense"><a href="#使用Suspense" class="headerlink" title="使用Suspense"></a>使用Suspense</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">Aysnc</span> <span class="keyword">from</span> <span class="string">&quot;@/components/AsyncComponent.vue&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"> * Suspense 组件的 pending 进入挂起状态时触发</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"> */</span></span></span><br><span class="line"><span class="language-javascript"> */</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title function_">pending</span> = (<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;pending&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"> * Suspense 组件的 resolve在 default 插槽完成获取新内容时触</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"> */</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"> * Suspense 组件的  fallback 插槽的内容显示时触发</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"> */</span></span></span><br><span class="line"><span class="language-javascript"> */</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title function_">fallback</span> = (<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fallback&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>测试 Supsense<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Suspense</span> @<span class="attr">pending</span>=<span class="string">&quot;pending&quot;</span> @<span class="attr">resolve</span>=<span class="string">&quot;resolve&quot;</span> @<span class="attr">fallback</span>=<span class="string">&quot;fallback&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 具有深层异步依赖的组件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aysnc</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 在 #fallback 插槽中显示 “正在加载中” --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> #<span class="attr">fallback</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>正在加载中...<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，<code>Suspense</code>组件有三个事件分别是：</p><ul><li><code>pending</code> 进入挂起状态时触发</li><li><code>fallback</code> 插槽的内容显示时触发</li><li><code>resolve</code> default 插槽完成获取新内容时触</li></ul><h2 id="defineAsyncComponent"><a href="#defineAsyncComponent" class="headerlink" title="defineAsyncComponent"></a>defineAsyncComponent</h2><blockquote><p>定义一个异步组件，它在运行时是懒加载的。参数可以是一个异步加载函数，或是对加载行为进行更具体定制的一个选项对象。 —— <a href="https://cn.vuejs.org/api/general.html#defineasynccomponent">Vue异步组件</a></p></blockquote><p>通过官方定义，从中可以得到两层意思，分别是：</p><ul><li>第一是这个函数是专门用来的定义异步组件的，其参数是一个<code>async</code>函数，结合ES Module<code>import()</code>动态导入，可以快速实现懒加载组件</li><li>第二是这个函数是可以从远端加载组件描述代码，而这个恰恰就是本文的重点</li></ul><p>第一种用法就很简单了，通过 import()引入的组件会在打包的时候单独分割成一个文件，当使用的时候才会去加载。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AsyncComponent</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span></span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;@/component/AsyncComponent.vue&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>vite或者 Webpack 会把<code>AsyncComponent.vue</code>文件单独拆分打包成一个 js文件。</p><p>第二种用法是从远端服务器加载一个组件回来，然后加载成组件进行页面渲染，如下描述。</p><h1 id="加载服务器上的组件"><a href="#加载服务器上的组件" class="headerlink" title="加载服务器上的组件"></a>加载服务器上的组件</h1><p>如果利用第二种方式去加载组件，我们最期待的代码效果如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title class_">AsyncComponent</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 从服务器获取组件</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> <span class="keyword">async</span> = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://example.com/AsyncComponent.js&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">resolve</span>(<span class="keyword">async</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="keyword">async</span></span></span><br><span class="line"><span class="language-javascript">);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 后续可以直接在 template中使用 AsyncComponent</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">AsyncComponent</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么<code>AsyncComponent.js</code>这种组件的代码应该如何生成呢？</p><p>但是，当数据还没返回来的时候，页面是不知道会渲染什么组件的。所以我们遇到第一个问题：</p><p>问题： 如何从远端加载 Vue组件，Vue通过<code>defineAsyncComponent</code>函数帮忙解决了加载问题，那么我们还需要知道这个函数支持加载什么格式的组件。</p><p>为了解决这个问题，我们先需要复习一下 Vue的组件基础知识</p><ol><li>如何去定义一个组件，在 Vue 官方文档中是这么定义一个非单文件(.Vue)的组件， 如下所示：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选项式的组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;button @click=&quot;count++&quot;&gt;</span></span><br><span class="line"><span class="string">      You clicked me &#123;&#123; count &#125;&#125; times.</span></span><br><span class="line"><span class="string">    &lt;/button&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Vue组件注册知识，分为全局注册和局部注册，如下所示：</li></ol><p>全局注册代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MyComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">component</span>(<span class="string">&#x27;MyComponent&#x27;</span>, <span class="title class_">MyComponent</span>)</span><br></pre></td></tr></table></figure><p>局部注册如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ComponentA</span> <span class="keyword">from</span> <span class="string">&#x27;./ComponentA.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="title class_">ComponentA</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">ComponentA</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>复习完组件定义和注册，那么我们大概就知道如何解决【如何从远端加载Vue组件并进行注册使用？】，步骤如下：</p><ul><li>编写远端组件文件，需要符合组件的基本配置规范</li><li>利用<code>defineAsyncComponent</code>函数异步加载组件机制去拉取远端组件</li><li>解析远端组件文件内容，生成按照组件定义规范返回组件的对象<code>resolve</code>返回</li><li>通过全局或局部注册，将<code>defineAsyncComponent</code>函数返回对象进行注册</li></ul><p>示例代码如下：</p><ol><li><p>制造符合组件规范的文件<code>Async.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Async.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="string">&quot;template&quot;</span>: <span class="string">`&lt;h1&gt;我是异步组件&lt;/h1&gt;&lt;div&gt;&lt;/div&gt;&lt;button @click=&quot;count++&quot;&gt;\</span></span><br><span class="line"><span class="string">        点击了 &#123;&#123; count &#125;&#125; 次</span></span><br><span class="line"><span class="string">      &lt;/button&gt;`</span>,</span><br><span class="line">  <span class="string">&quot;script&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;data&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;count&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解析组件和注册组件</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>测试 Supsense<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Suspense</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 具有深层异步依赖的组件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">AsyncDD</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 在 #fallback 插槽中显示 “正在加载中” --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> #<span class="attr">fallback</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>正在加载中...<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;vue/dist/vue.esm-bundler.js&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"> * 加载远端+解析组件</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"> * <span class="doctag">@param</span> url </span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"> */</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title function_">loadRemoteComponent</span> = <span class="keyword">async</span> (<span class="params">url: string</span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> scriptText = <span class="keyword">await</span> response.<span class="title function_">text</span>()</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title class_">Component</span>: any = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> scriptStr = scriptText.<span class="title function_">replace</span>(<span class="string">&#x27;export default&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">Component</span> = <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;return &#x27;</span> + scriptStr)()</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Component</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125; <span class="keyword">catch</span> (e) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">error</span>(e)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="title class_">Component</span></span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title class_">AsyncDD</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">loadRemoteComponent</span>(<span class="string">&#x27;/async/demo.js&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">Component</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">resolve</span>(<span class="title class_">Component</span>)</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">        &#125;, <span class="number">2000</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">AsyncDD</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h2><p>上述这种解决方案很明显存在问题，但是基础解决思路是没有问题，主要问题在于</p><blockquote><ul><li>无法使用<code>vue</code>单文件</li><li>无法通过<code>import</code>引用外部资源</li></ul></blockquote><p>如何解决呢，由于项目实战还在研究中，打算放到下一篇项目实战去解决掉，尽情期待。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://cn.vuejs.org/guide/components/async.html">Vue 异步组件</a></li><li><a href="https://cn.vuejs.org/guide/built-ins/suspense.html">Vue Suspense 组件</a></li><li><a href="https://weread.qq.com/web/bookDetail/c5c32170813ab7177g0181ae">《Vue.js设计与实现》</a>书中 第 13 章 异步组件与函数式组件</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近在做低代码平台项目中遇到一个很容易遇到的问题，具体描述如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;问题描述：低代码平台依赖的组件库，如果将一个组件库进行融合打包到平台项目中的就会导致平台在渲染页面的时候需要加载完整的组件库，从而导致页面加载了一些大部分页面不需要的组件文件&lt;/li&gt;
&lt;li&gt;希望方案：页面使用到哪些组件就去动态加载组件&lt;/li&gt;
&lt;li&gt;解决方案：&lt;ul&gt;
&lt;li&gt;Vue的异步加载组件，&lt;code&gt;Suspense&lt;/code&gt;和&lt;code&gt;defineAsyncComponent&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;React的异步加载组件， &lt;code&gt;Suspense&lt;/code&gt;和&lt;code&gt;import()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于低代码项目本身使用的 Vue3 框架，而且 Vue和  React的异步加载组件方案其实差异不多，所以下面以 Vue为主进行介绍。&lt;/p&gt;</summary>
    
    
    
    
    <category term="技术分享" scheme="https://www.qborfy.com/tags/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    <category term="每日更新" scheme="https://www.qborfy.com/tags/%E6%AF%8F%E6%97%A5%E6%9B%B4%E6%96%B0/"/>
    
    <category term="低代码" scheme="https://www.qborfy.com/tags/%E4%BD%8E%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>前端架构—— 学习k8s集群管理</title>
    <link href="https://www.qborfy.com/framework/framework-k8s-study.html"/>
    <id>https://www.qborfy.com/framework/framework-k8s-study.html</id>
    <published>2023-08-26T10:00:01.000Z</published>
    <updated>2023-08-23T07:16:44.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>k8s学习资料 <a href="https://kuboard.cn/learning/">https://kuboard.cn/learning/</a></li><li>k8s管理界面 <a href="https://github.com/eip-work/kuboard-press">https://github.com/eip-work/kuboard-press</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;k8s学习资料 &lt;a href=&quot;https://kuboard.cn/learning/&quot;&gt;https://k</summary>
      
    
    
    
    
    <category term="技术分享" scheme="https://www.qborfy.com/tags/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    <category term="架构系列" scheme="https://www.qborfy.com/tags/%E6%9E%B6%E6%9E%84%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>《思考的框架》，如何做出更好的决策？</title>
    <link href="https://www.qborfy.com/study/think-framework.html"/>
    <id>https://www.qborfy.com/study/think-framework.html</id>
    <published>2023-08-15T05:00:00.000Z</published>
    <updated>2023-09-14T05:43:37.822Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><h1 id="思考的框架"><a href="#思考的框架" class="headerlink" title="思考的框架"></a>思考的框架</h1><p>我们绝大部分行为都是建立在我们所理解的知识领域基础之上，所以我们大部分决策都是都是存在盲区，为了做出更好的决策，本书讲述了不同的思维模型，用来让你的大脑在做出决策之前可以通过不同的思维角度去思考。</p><span id="more"></span><h1 id="阅读摘要"><a href="#阅读摘要" class="headerlink" title="阅读摘要"></a>阅读摘要</h1><ul><li>前言<ul><li>能力圈的边界取决于你手中的工具</li><li>了解世界是如何运行的，再调整我们的行为</li><li>提高思维能力不是变成天才的途径，而是当我们利用思维去更加明智面对选择</li><li>为什么要学习思维模型<ul><li>一是通过不同的思维模型，去降低不同情况的风险</li><li>二是利用跨学科的知识去避免犯下不可挽救的错误</li><li>三是学习思维模型，去减轻生活压力</li></ul></li><li>理解现实，其实就准确完整的描述现实情况，从而面对正确描述的现实问题，我们才能找到对应方法去解决</li><li>作茧自缚，是我们每个人学习过程中最大的障碍，理解我们所认知之外的东西是非常困难，主要会遇到一下的问题：<ul><li>第一，缺乏准确的视角，如同：普通百姓在思考政府领导人为什么做出这样子的决策</li><li>第二，自尊心作祟，如：太在乎自己的评价，不敢表达自己的想法，害怕犯错</li><li>第三，负责做决策不是直接承担后果的人，如：很多政策都出自不受影响或受影响较少的人，从而导致政策很保守或故步自封</li></ul></li><li>送给自己的一句话，“过而不改，是谓过矣”，简单就是说有错不改才是真正的错误，所以说你犯错不是因为你做了错误的事情，而是你知道错了，还不愿意去修改</li><li>理解现实是不够的，只有理解现实后做出改变或调整，才能真正给自己的生活带来积极的改变</li><li>更好的思维模型意味更好的思维方式，因此我们需要经常验证当前思维模型是否正确的，如果错误的话就需要及时纠正</li><li>依赖有限的思维模型，我们无法充分思考，无法得出正确的答案</li><li>通过本书可以搭建正确的思维模型网络，用来抵抗未知的风险</li><li>不同思维模型是对应不同的运用场景的，因此我们需要对思维模型深入了解，以及他们对应的运用场景，不断反思和复盘</li></ul></li><li>在应用思维模型之前，你需要想好两个观念<ul><li>01 地图不等于地域本身</li><li>02 能力圈</li></ul></li><li>常用思维模型<ul><li>03 第一性原理</li><li>04 思想实验</li><li>05 二阶思维</li><li>06 概率思维</li><li>07 逆向思维</li><li>08 奥卡姆剃刀定律</li><li>09 汉隆剃刀定律</li></ul></li><li>配套理念<ul><li>1 可证伪性</li><li>2 必要性和充分性</li><li>3 因果关系和相关关系</li></ul></li></ul><h1 id="思维模型-脑图"><a href="#思维模型-脑图" class="headerlink" title="思维模型-脑图"></a>思维模型-脑图</h1><blockquote class="pullquote mindmap mindmap-md"><ul><li>思维模型脑图<ul><li>01地图不等于地域本身<ul><li>一句话解释<ul><li>地图的用处在于其具有解释性和预测性，地图对于地域的复杂现实的抽象化，但是如果我们仅仅只是了解地图后以为等于了解地域，这是不正确的，地图是具有局限性的，如果要完整的了解地域，我们还需要去实地实战</li></ul></li><li>地图思维模型作用<ul><li>复杂事情或场景，进行抽象化或简单化，能让大家更快进入某一个陌生的领域</li></ul></li><li>地图的局限性<ul><li>所有思维模型都是错误的，我们需要在意的是错误到何种程度才让其不能再起到作用</li><li>经典案例，【公地悲剧】思维模型，</li></ul></li><li>如何准确使用地图（思维模型）<ul><li>最终仍以现实为准，结合地图我们可以快速熟悉陌生地域，但是由于地域是实时变化的，所以最终还是以实际地域为主</li><li>考虑制图师的因素，地图是创作者按照他的标准、价值观去制作的，因此具有一定局限性，我们在使用思维模型的时候需要考虑思维模型的诞生的背景，才能发挥最大的作用</li><li>地图可以影响地域，城市规划地图是会影响城市的地域面貌的，如同思维模型一样的，当你正在使用某一思考模型去做决策，而对手由于考虑到你的思考模型，针对性你的思考模型去思考，那么就会影响到你的决策的正确性</li></ul></li><li>总结<ul><li>地图（思维模型）是人类传递知识的宝贵工具，但是我们必须清晰的认识到它的局限性，某个思维模型只适用某种特定场景</li><li>地图虽然有局限性，但是它仍然是一个好的工具，如何使用的好主要看使用的人，我们的思维必须要超越思维模型，简单的说，就是要具备多种思维模型去思考问题</li></ul></li></ul></li><li>02能力圈<ul><li>什么是能力圈<ul><li>能力圈指的是在某个领域，有详细的知识网络，遇到问题的时候可以有一个明确的清单可以帮助解决问题，至少有几年的工作经验，经历过几次失败，在这个领域内你相对其他人更有竞争力<ul><li>详细的知识网络</li><li>明确的解决问题清单</li><li>多年经验（成功或失败）</li><li>富有竞争力</li></ul></li></ul></li><li>判断能力圈在哪里<ul><li>在某个领域内，明确知道自己不知道什么事情，能够快速做出决策</li><li>多年的经验、试错，积极寻找更好的办法和思考方法</li></ul></li><li>如何打造和维护能力圈<ul><li>打造能力圈三要素<ul><li>好奇心和求知欲，代表你要持续不断的学习，不断反思和总结，让自己巩固现有知识，扩展边界知识<ul><li>如何学习，就是从别人的错误中学习</li></ul></li><li>监测，诚实记录自己的成长，客观和量化的记录，主要从以下几方面去做<ul><li>记录出错的地方，如何做的更好</li><li>监测出平时关注不到的规律</li><li>明确自己哪里做错了</li></ul></li><li>反馈，需要获取外部的反馈，是打造能力圈的关键，因为你的能力不仅仅是你认为的而已，而是需要社会的认可<ul><li>不要有抵触情绪去做这个反馈事情</li></ul></li></ul></li></ul></li><li>能力圈以外的事情，注意事项有三个<ul><li>原因：动机问题与信息不对称，动机会扭曲他人能力的可信程度</li><li>解决方案<ul><li>了解陌生领域的基础知识</li><li>主动与该领域的优秀人才交流</li><li>利用基础思维模型弥补陌生领域的知识匮乏</li></ul></li></ul></li><li>总结，一个人的能力是有限的，我们只能在我们所知的能力范围内做出正确的判断<ul><li>找到自己的能力圈很重要，但是知道自己不知道的事情以及如何应对这些不知道的事情更加重要</li></ul></li></ul></li><li>03第一性原理<ul><li>概念：第一性原理是逆向分析复杂情况、释放创造力的最佳方法之一，也叫第一原理推理<ul><li>通过将最基础的理念或事实从复杂的问题中剥离出来</li></ul></li><li>一句话理解<ul><li>第一性原理的思维模式，是不断在复杂的事实中剥离不必要的因素，找到真正符合事实的最基础的原理，从而去面对更加复杂的事实</li></ul></li><li>苏格拉底的五个为什么提问法，去建立第一性原理<ul><li>1.澄清你的想法并解释想法的来源，为什么我会这么想？我到底是怎么想的？</li><li>2.对假设提出挑战，我怎么知道这是真的，如果我的想法正好和正确的相反呢？</li><li>3.寻找论据，我该如何支撑我的论点？论据来源是哪里？</li><li>4.思考其他可能的视角。别人可能有什么想法，我怎么知道自己是对的？</li><li>5.探究后果和影响。如果我是错的，该怎么办？如果我错了，会有什么后果？</li><li>6.质疑最初的问题。我为什么这么想？我想法对吗？从推理过程中我得到了什么结论？</li><li>五个为什么提问式思考是一个不断循环的过程，会让你越来越明白某件事情的真理</li></ul></li><li>第一性原理可以应用的场景<ul><li>推翻过去不准确的假设<ul><li>假设就是假设，真理才能不被推翻</li><li>要学会不断尝试去推翻现有的真理</li></ul></li><li>增量创新和范式改变<ul><li>增量创新靠的就是去在追求第一性原理的过程中，我们不断完善基础原理，从而实现渐进式创新</li><li>范式改变就是需要依据第一性原理，对传统的范式习惯去扭转思维模式，从而达到更加深入的基础原理</li></ul></li><li>总结<ul><li>第一性原理的思维模式，真正让我们能睁开眼睛看世界，没有什么是一层不变的，思考问题的时候需要去跳出历史和传统观念，试探一切可能的边界</li><li>运用第一性原理的思维模式，最大的一个好处就是我们可以开始创造新的事务，不仅仅是思想上的，还有物质上的</li></ul></li></ul></li></ul></li><li>04思想实验<ul><li>概念：用来探究事物本质的想象工具<ul><li>一句话理解，就是利用想象力去针对事物去合理的，符合逻辑的去想象出不同的新途径，探究未知的领域，如同：黑洞理论等</li></ul></li><li>思想实验的步骤<ul><li>1.提出一个问题</li><li>2.进行背景研究</li><li>3.构造假说</li><li>4.通过思想实验或想象力进行测试</li><li>5.分析并得出结论</li><li>6.与假说相比较并进行调整（跳到步骤一，提出问题）</li></ul></li><li>应用场景<ul><li>想象物理上不可能，如：爱因斯坦的重力电梯实验</li><li>重新想象历史，如：如果历史上没有发生第二次世界大战，中国还会像现在这样子吗</li><li>凭直觉想象并不直观的事物，如：“无知之幕”，设计最公正最正义的社会构建方式，需要设计者在不知道自己处于什么样的角色下进行设计，因为他们不知道什么样子的规则对他们有益</li></ul></li><li>最著名的思想实验是电车实验，就是救一群人还是救一个人</li><li>作用和目标<ul><li>思想实验的目标之一就是充分了解某一情况，从而确定在其在结果中所起的作用，从而因为其作出的决定和行动。</li><li>利用思想实验去判断我们直觉的准确性，甚至可以用来设计公司的规则或国家的法律</li></ul></li><li>总结<ul><li>思想实验的思维模式可以让我们探究我们所知道的边界，尝试的范围，为了提供成功的概率，我们应该穷尽我们所有的可能去探索</li><li>使用思想实验的次数越多，就越能了解某件事情的实际因果关系，也能越明白能成功做成一件事的源由</li></ul></li></ul></li><li>05二阶思维<ul><li>概念：也叫“意外结果定律”，除了思考行动的直接影响外，需要更长远，更具有整体性的思考的思维模型<ul><li>一句话理解，就是走一步看三步，有时候一个选择不能只考虑直接结果，还需要考虑因为直接结果造成的一系列影响</li></ul></li><li>二阶思维模型是在一阶思维结果中有高度关联性的因素去推理得出的</li><li>如何做二阶思维训练<ul><li>将长远利益置于眼前利益之上<ul><li>帮助我们去实现长期效果，比如：减肥</li></ul></li><li>构建有效的论证<ul><li>帮助我们规避问题，预测挑战，从而提前加以解决</li></ul></li></ul></li><li>二阶问题：当有一个人都踮起脚尖去看，那么所有人必须踮起脚尖，因为大家都看不清自身所处的环境</li><li>应用场景<ul><li>要意识到二阶的结果，然后利用预测出来的结果去指导我们的行动或决策</li><li>说服其他人，利用二阶思维的结果，验证其准确性去作为论据去说服</li><li>信任和可信任是多次互动的积累果，二阶思维恰恰能够让你不断去积累信任</li></ul></li><li>需要注意的点<ul><li>不能进入滑坡效应，也叫恶性循环，当你做某个错误的决策，即使你用二阶思维去论证也无济于事</li></ul></li><li>总结<ul><li>我们要坚定的确认，不劳而获的行为是不存在</li><li>做选择的时候，我们要多从结果去思考，多问自己“然后呢”，从而能避免未来可能出现的问题</li><li>利用已知的信息，从全方面、长远的思考一个问题，从时间、规模、阈值等诸多因素去思考，能让我们在未来的节省大量时间</li></ul></li></ul></li><li>06概率思维<ul><li>概念：通过运用一些数学和逻辑工具，估算特定结果出现的可能性<ul><li>一句话理解，面对随时可能发生变化的现实，利用计算出发生行为的概率，作为决策的依据去选择的思维模式</li></ul></li><li>为什么需要概率思维？<ul><li>因为未来不确定，需要积极了解发生的概率，从而更好处理未来和选择未来</li></ul></li><li>概率是什么的三个重要方面<ul><li>贝叶斯思维<ul><li>尽可能收集过去已有信息，然后依据该信息作出各种结果发生的“基本比率”，如：炒股，股票的涨跌可以从汇总各种信息去作为判断依据，然后判断明天的股市是涨还是跌</li><li>条件概率，当用过去发生的事情做为预测未来的条件时候，你需要注意围绕这事件的一系列条件，如：炒股，影响涨跌有哪些条件因素</li></ul></li><li>肥尾曲线<ul><li>与“正态分布曲线”（钟形曲线）的对称曲线相反，因为处于正态分布下，我们可以很容易预测结果，如：人的体重分布</li><li>肥尾曲线则是让极端事件发生的概率会大很多，如：人的财富分布，简单的说，就是极端情况下是无上限的</li><li>利用概率思维去面对极端情况，理性面对极端事件</li></ul></li><li>非对称<ul><li>“元概率”，就是你估算这件事发生的概率，估算本身准确的概率</li><li>非对称，就是估算概率本身就不是对称的，不会因为你的判断概率高而事情发生的结果概率就变高</li></ul></li></ul></li><li>概率思维最重要理论：反脆弱<ul><li>面对不可预知的未来，我们应当要尝试预测和做好准备</li><li>反脆弱的方法：<ul><li>寻找更多机会，如：炒股获取更多的信息源</li><li>学习如何正确的失败，如：适当冒险，避免跌倒一次就爬不起来，培养韧性，从失败学习，东山再起</li></ul></li></ul></li><li>总结<ul><li>高效的概率思维需要你判断什么是最重要的影响因素，从而估算概率，最后做出决策</li><li>概率思维是我们面对未知有用的工具，能让我们做出更有效的选择</li><li>保险公司就是概率思维最大的案例</li></ul></li></ul></li><li>07逆向思维<ul><li>概念：从起点的另外一头着手解决问题，从后往前思考问题，从多个角度看待现实问题。<ul><li>一句话理解，就当你需要判读是否正确的时候，可以假设它是正确的，也可以假设它是错的去思考，或者当你需要做一件事情的时候，可以从结果往前推导整个事件的过程</li></ul></li><li>如何做逆向思维：<ul><li>1.找到问题所在</li><li>2.描述期望目标</li><li>3.列出朝期望目标发展的所有驱动力<ul><li>大部分人会停止在这一步</li></ul></li><li>4.列出朝期望目标发展的所有阻碍力<ul><li>这一步就是逆向思维的关键步骤</li></ul></li><li>5.制定解决方案，其中包括加强步骤3的驱动力，减少步骤4的阻碍力</li></ul></li><li>孙子兵法中，是故百战百胜，非善之善者也；不战而屈人之兵，善之善者也。</li><li>应用场景：<ul><li>数学推理，从结果往前推理更容易</li><li>解决问题，不是解决问题，而是从问题的根源出发，阻止问题发生</li><li>利用逆向思维推动创新，</li></ul></li><li>总结<ul><li>当你陷入困境的时候，不妨试试看用逆向思维去思考，可能会有意想不到的解决方案出来</li></ul></li></ul></li><li>08奥卡姆剃刀定律<ul><li>概念：奥卡姆剃刀原文：“如无必要，勿增实体”，对于复杂的解释，简单的解释更有可能是正确的<ul><li>一句话理解，就是把复杂的事情简单化，如同写代码或者设计功能一样，UI界面越简单操作，对于用户操作也容易理解</li></ul></li><li>怎么做：<ul><li>结合概率思维，把面对问题进行结果简单化，然后估计概率，最终得到结果</li><li>将一个事件不断放弃一些因素，直接剩下的不可放弃<ul><li>如何判断为不可放弃，就是当你继续放弃因素的时候，事情会直接不可成立</li></ul></li></ul></li><li>注意事项<ul><li>不是所有的事情都可以简单化，当一件事情的描述被简化后仍能被理解</li></ul></li><li>总结<ul><li>关注简单，在于关注问题的重点</li></ul></li></ul></li><li>09汉隆剃刀定律<ul><li>概念：不要做最坏的打算，能解释为愚蠢的，就不要解释为恶意，从而避免妄想和偏执。<ul><li>一句话理解，不要以小人之心，度君子之腹，虽然大家不一定是君子，但是大部分人都不是恶人，同时也需要注意防人之心不可无（害人之心不可有，防人之心不可无）</li><li>放到法律上的说法，就是疑罪从无，嫌疑人只是有犯罪嫌疑，只有找到真正的证据才能定罪</li></ul></li><li>现象1：当有人做错事的时候，我们的第一心理就是他是故意为之的，但是大多数人做错可能是无意犯错而已</li><li>现象2：阿尔希波夫是苏联B-59潜艇上的一名军官，他负责核弹潜水艇是否发生的控制权，由于潜水区域被炸弹攻击，收不到外界消息，如果他没有遵循汉隆剃刀定律，那么他将发射核弹，从而引发第一次全球核弹战争</li><li>总结<ul><li>汉隆剃刀定律，证明坏人比你想象的少得多，不是每个人都有不良动机，如果我们以此定律去生活和工作，那么我们的工作将更加高效和美好</li><li>人们都有自己的思想的局限性，然后将一些行为建立合理的解释，如：将不提高工资解释为老板们都是吸血鬼的谬误结论，而汉隆剃刀定律能帮我们从这些谬误局限中解脱出来</li></ul></li></ul></li><li>配套理念1:可证伪性<ul><li>概念：当且仅当一个理论与可能的经验发生冲突，因此原则上可以被经验证明为伪时候，这里理论才属于实证科学<ul><li>一句话理解，如果你无法证明某个理论是错误的，那么你也不能证明这个理论是正确的</li></ul></li><li>怎么做：<ul><li>火鸡实验，每天喂食火鸡，只是一种趋势，不能预测未来发展的事态</li></ul></li><li>应用：<ul><li>运用可证伪性，可以帮我们筛选更加稳定的理论，获取获得更高概率的理论</li></ul></li></ul></li><li>配套理念2:必要性和充分性<ul><li>概念：成功的必要条件是充分条件的子集合，而充分条件本身比必要条件大的多<ul><li>一句话理解，必要条件是大家都可以做得到的事情，而充分条件则是需要其他人一起做的事情，是不被你所掌控的事情</li></ul></li></ul></li><li>配套理念3:因果关系和相关关系<ul><li>概念：相关关系是代表两者存在关系，但是不代表两者的因果关系，而因果关系则可以根据因推导出果<ul><li>一句话理解，就是相关关系是两者有关系，但是不知道谁影响谁，而因果关系能明确知道谁在前 谁在后</li></ul></li><li>总结：<ul><li>如何得出因果关系，可以引入对照组，比如：一个人是否好坏，可以根据之前的历史业绩进行对比</li></ul></li></ul></li></ul></li><li>本书总结：<ul><li>一共梳理9个思维模型，3个配套理念，其中可以分阶段去解读：<ul><li>01、02主要对自身的了解，同时让我们知道思维模型是对现实的抽象化，只有在特定场景下才能解决问题，如何判断是否符合，可以看【01地图】</li><li>03、04、05主要让我们打开视野，放大对世界的了解，思维不必局限我们所知的那一小部分</li><li>06、07教我们面对选择和判断的时候，依据什么和从另外一个角度去做选择判断</li><li>08、09让我们变得简单，变得善良，就是让我们不断的优化自己</li><li>配套理念1、2、3是让我们明白如何相信他人，如何成功以及如何判断他人和成功的关系</li></ul></li></ul></li></ul></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;思考的框架&quot;&gt;&lt;a href=&quot;#思考的框架&quot; class=&quot;headerlink&quot; title=&quot;思考的框架&quot;&gt;&lt;/a&gt;思考的框架&lt;/h1&gt;&lt;p&gt;我们绝大部分行为都是建立在我们所理解的知识领域基础之上，所以我们大部分决策都是都是存在盲区，为了做出更好的决策，本书讲述了不同的思维模型，用来让你的大脑在做出决策之前可以通过不同的思维角度去思考。&lt;/p&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>前端面试100道手写题（8）—— 懒加载</title>
    <link href="https://www.qborfy.com/face100/8-lazy-load.html"/>
    <id>https://www.qborfy.com/face100/8-lazy-load.html</id>
    <published>2023-08-12T14:00:00.000Z</published>
    <updated>2023-08-10T01:40:34.682Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;script type=&quot;text&amp;#x2F;javascript&quot; src=&quot;http</summary>
      
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    <category term="前端面试" scheme="https://www.qborfy.com/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
