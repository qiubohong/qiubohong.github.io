<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Qborfy知识库</title>
  
  
  <link href="https://www.qborfy.com/atom.xml" rel="self"/>
  
  <link href="https://www.qborfy.com/"/>
  <updated>2025-06-14T09:16:22.407Z</updated>
  <id>https://www.qborfy.com/</id>
  
  <author>
    <name>Qborfy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AI从零开始 - AI学习路线图(1) AI应用开发工程师</title>
    <link href="https://www.qborfy.com/ailearn/ai-learn-road1.html"/>
    <id>https://www.qborfy.com/ailearn/ai-learn-road1.html</id>
    <published>2025-12-31T07:00:00.000Z</published>
    <updated>2025-06-14T09:16:22.407Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><blockquote><p>本文参考 <a href="https://roadmap.sh/">roadmap.sh</a> <a href="https://roadmap.sh/ai-engineer">AI Engineer(AI应用开发工程师)RoadMap</a>整理，如有侵权，请联系删除。</p></blockquote><p>学习一门技能最重要的是<strong>目标</strong>和<strong>路线</strong>：</p><ul><li>有了目标，才能知道自己所学可以用到哪里</li><li>有了路线，才能知道自己该学什么，怎么学</li></ul><span id="more"></span><h1 id="AI应用开发学习路线图"><a href="#AI应用开发学习路线图" class="headerlink" title="AI应用开发学习路线图"></a>AI应用开发学习路线图</h1><h2 id="完整思维导图"><a href="#完整思维导图" class="headerlink" title="完整思维导图"></a>完整思维导图</h2><p><img src="/assets/img/ailearn/ailearn-road1.png" alt="AI应用开发学习路线图"></p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p><img src="/assets/img/ailearn/ailearn-road11.png" alt="前置知识"></p><h2 id="入门能力"><a href="#入门能力" class="headerlink" title="入门能力"></a>入门能力</h2><p><img src="/assets/img/ailearn/ailearn-road12.png" alt="入门能力"></p><h2 id="进阶能力"><a href="#进阶能力" class="headerlink" title="进阶能力"></a>进阶能力</h2><p><img src="/assets/img/ailearn/ailearn-road13.png" alt="进阶能力"></p><h2 id="高级能力"><a href="#高级能力" class="headerlink" title="高级能力"></a>高级能力</h2><p><img src="/assets/img/ailearn/ailearn-road14.png" alt="高级能力"></p><h2 id="后续发展路线"><a href="#后续发展路线" class="headerlink" title="后续发展路线"></a>后续发展路线</h2><p><img src="/assets/img/ailearn/ailearn-road14.png" alt="后续发展路线"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://roadmap.sh/ai-engineer">AI Engineer RoadMap (AI应用开发工程师学习路线图)</a></li><li><a href="https://zhuanlan.zhihu.com/p/717978798">如何选择AI Agent框架？五种主流AI Agent框架对比</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;本文参考 &lt;a href=&quot;https://roadmap.sh/&quot;&gt;roadmap.sh&lt;/a&gt; &lt;a href=&quot;https://roadmap.sh/ai-engineer&quot;&gt;AI Engineer(AI应用开发工程师)RoadMap&lt;/a&gt;整理，如有侵权，请联系删除。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;学习一门技能最重要的是&lt;strong&gt;目标&lt;/strong&gt;和&lt;strong&gt;路线&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有了目标，才能知道自己所学可以用到哪里&lt;/li&gt;
&lt;li&gt;有了路线，才能知道自己该学什么，怎么学&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    <category term="AI学习" scheme="https://www.qborfy.com/tags/AI%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>5分钟AI，每天搞懂一个知识点(15) - Skill技能</title>
    <link href="https://www.qborfy.com/ailearn/daily/17.html"/>
    <id>https://www.qborfy.com/ailearn/daily/17.html</id>
    <published>2025-12-18T09:45:08.051Z</published>
    <updated>2025-12-18T09:46:24.161Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><p>今天我们来学习 <strong>Claude-Code 中的 Skill 技能</strong></p><blockquote><p><strong>Claude Code 中的 Skill</strong> 是一个<strong>可复用的知识包</strong>，它将特定的操作指南、代码示例和最佳实践打包成一个模块。当 Claude 识别到你的任务与某个 Skill 描述相匹配时，它会自动<strong>按需加载</strong>并运用该 Skill 中的知识来帮助你，而无需你每次都重新解释整个工作流程。</p></blockquote><p><strong>通俗来讲</strong>，Skill 就像为 Claude Code 准备的一份份专门的<strong>“工作说明书”或“操作手册”</strong>。例如，你可以创建一个“代码审查”Skill，里面写明了团队审查代码的标准流程、注意事项和常用话术。之后，你只需对 Claude Code 说“请审查这段代码”，它就会自动调用这份说明书，像一位受过专门训练的专家一样为你服务。</p><span id="more"></span><h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p><img src="/assets/img/ailearn/daily/16/1.png" alt="5分钟AI知识网络图"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.anthropic.com/news/model-context-protocol">Anthropic MCP 官方文档</a></li><li><a href="https://github.com/liaokongVFX/MCP-Chinese-Getting-Started-Guide">Model Context Protocol(MCP) 编程极速入门</a></li><li><a href="https://gofastmcp.com/getting-started/quickstart">FastMCP 官方文档</a></li><li><a href="https://platform.openai.com/docs/guides/tools-connectors-mcp">OpenAI MCP 文档</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们来学习 &lt;strong&gt;Claude-Code 中的 Skill 技能&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Claude Code 中的 Skill&lt;/strong&gt; 是一个&lt;strong&gt;可复用的知识包&lt;/strong&gt;，它将特定的操作指南、代码示例和最佳实践打包成一个模块。当 Claude 识别到你的任务与某个 Skill 描述相匹配时，它会自动&lt;strong&gt;按需加载&lt;/strong&gt;并运用该 Skill 中的知识来帮助你，而无需你每次都重新解释整个工作流程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;通俗来讲&lt;/strong&gt;，Skill 就像为 Claude Code 准备的一份份专门的&lt;strong&gt;“工作说明书”或“操作手册”&lt;/strong&gt;。例如，你可以创建一个“代码审查”Skill，里面写明了团队审查代码的标准流程、注意事项和常用话术。之后，你只需对 Claude Code 说“请审查这段代码”，它就会自动调用这份说明书，像一位受过专门训练的专家一样为你服务。&lt;/p&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    <category term="5分钟AI" scheme="https://www.qborfy.com/tags/5%E5%88%86%E9%92%9FAI/"/>
    
  </entry>
  
  <entry>
    <title>5分钟AI，每天搞懂一个知识点(15) -MCP协议</title>
    <link href="https://www.qborfy.com/ailearn/daily/15.html"/>
    <id>https://www.qborfy.com/ailearn/daily/15.html</id>
    <published>2025-12-17T04:00:00.000Z</published>
    <updated>2025-12-16T04:35:39.502Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><p>今天我们来学习 <strong>模型上下文协议（MCP）</strong></p><blockquote><p><strong>MCP（Model Context Protocol，模型上下文协议）</strong> 是由 Anthropic 公司推出的开源协议，旨在为大型语言模型与外部数据源、工具之间建立<strong>安全、标准化、双向</strong>的连接通道。</p></blockquote><p>通俗地说，MCP 如同 AI 世界的“USB-C 接口”。它定义了一套通用标准，使得任何支持 MCP 的 AI 应用（如 Claude Desktop、Cursor IDE）都能通过统一的“插口”，即插即用地连接各种外部工具（如数据库、API、本地文件），而无需为每个工具单独开发适配器。其核心价值在于解决了 AI 应用与外部资源交互时的碎片化集成问题，实现了生态的标准化和去中心化。</p><span id="more"></span><h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p><img src="/assets/img/ailearn/daily/15/1.png" alt="5分钟AI知识网络图"></p><p>MCP 遵循经典的客户端-服务器架构，其核心组件与协作流程如下图所示，清晰地展示了数据如何在不同部分间流转。</p><p><img src="/assets/img/ailearn/daily/15/2.png" alt="MCP 工作原理"></p><p><strong>核心组件解析</strong>：</p><ul><li><strong>MCP Host（宿主）</strong>：这是用户直接交互的 AI 应用程序，例如 Cursor IDE、Claude Desktop 等。它是发起所有请求的“大脑”和总指挥。</li><li><strong>MCP Client（客户端）</strong>：它内嵌于 Host 内部，充当协议的“翻译官”。每个 Client 与一个 Server 保持一对一的专有连接，负责所有通信的路由和转换。</li><li><strong>MCP Server（服务器）</strong>：这是提供具体能力的轻量级服务程序。它向外暴露三种核心能力：<ul><li><strong>工具 Tool</strong>：可执行的函数，允许 LLM 执行操作，如发送邮件、查询数据库。</li><li><strong>资源 Resource</strong>：只读的数据源，如文件内容、数据库记录、API 响应。</li><li><strong>提示模板 Prompt</strong>：预定义的对话模板，指导 LLM 完成特定工作流。</li></ul></li><li><strong>MCP Protocol（协议）</strong>：基于<strong>JSON-RPC 2.0</strong>的消息格式，定义了组件间的通信规则。支持 Stdio（本地）和 HTTP（远程）两种传输方式。</li></ul><h1 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h1><h2 id="MCP-服务器搭建"><a href="#MCP-服务器搭建" class="headerlink" title="MCP 服务器搭建"></a>MCP 服务器搭建</h2><p>使用 Python 创建 MCP 服务器的简明示例，该服务器提供一个获取网页标题的工具。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastmcp <span class="keyword">import</span> FastMCP</span><br><span class="line"></span><br><span class="line">mcp = FastMCP(<span class="string">&quot;My MCP Server&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.tool</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    mcp.run(transport=<span class="string">&quot;http&quot;</span>, port=<span class="number">8000</span>)</span><br></pre></td></tr></table></figure><h2 id="MCP-客户端调用"><a href="#MCP-客户端调用" class="headerlink" title="MCP 客户端调用"></a>MCP 客户端调用</h2><p>使用 Python 创建 MCP 客户端的简明示例，调用上面创建的 MCP<br>服务器的 <code>get_webpage_title</code> 工具。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> fastmcp <span class="keyword">import</span> Client</span><br><span class="line"></span><br><span class="line">client = Client(<span class="string">&quot;http://localhost:8000/mcp&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出可用工具</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">list_tools</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> client:</span><br><span class="line">        tools = <span class="keyword">await</span> client.list_tools()</span><br><span class="line">        <span class="built_in">print</span>(tools)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 greet MCP tool</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">call_tool</span>(<span class="params">name: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> client:</span><br><span class="line">        result = <span class="keyword">await</span> client.call_tool(<span class="string">&quot;greet&quot;</span>, &#123;<span class="string">&quot;name&quot;</span>: name&#125;)</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">asyncio.run(call_tool(<span class="string">&quot;Ford&quot;</span>))</span><br></pre></td></tr></table></figure><h2 id="OpenAI-MCP-调用"><a href="#OpenAI-MCP-调用" class="headerlink" title="OpenAI MCP 调用"></a>OpenAI MCP 调用</h2><p>使用 OpenAI Python SDK 创建 MCP 客户端的简明示例，调用 MCP 服务器的 <code>greet</code> 工具。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openai <span class="keyword">import</span> OpenAI</span><br><span class="line"></span><br><span class="line">client = OpenAI()</span><br><span class="line"></span><br><span class="line">resp = client.responses.create(</span><br><span class="line">    model=<span class="string">&quot;gpt-5&quot;</span>,</span><br><span class="line">    tools=[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;mcp&quot;</span>,</span><br><span class="line">            <span class="string">&quot;server_label&quot;</span>: <span class="string">&quot;dmcp&quot;</span>,</span><br><span class="line">            <span class="string">&quot;server_description&quot;</span>: <span class="string">&quot;Demo MCP Server&quot;</span>,</span><br><span class="line">            <span class="string">&quot;server_url&quot;</span>: <span class="string">&quot;http://localhost:8000/mcp&quot;</span>,</span><br><span class="line">            <span class="string">&quot;require_approval&quot;</span>: <span class="string">&quot;never&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="built_in">input</span>=<span class="string">&quot;Hello, MCP!&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(resp.output_text)</span><br></pre></td></tr></table></figure><p>我们在大模型中调用 MCP 服务正常步骤如下：</p><ol><li>列出 MCP 服务中可用的工具和资源。</li><li>筛选出需要调用的工具或资源。</li><li>构造调用请求并发送给 MCP 服务。</li><li>处理 MCP 服务返回的结果。</li><li>将结果添加到输入中，继续与模型对话。</li></ol><h1 id="MCP-生态"><a href="#MCP-生态" class="headerlink" title="MCP 生态"></a>MCP 生态</h1><ul><li><strong>主流 MCP Hosts（应用）</strong>：<strong>Cursor IDE</strong>、<strong>Claude Desktop</strong>、<strong>OpenWebUI</strong>等是当前最流行的 MCP 宿主应用。只需在它们的设置中添加 MCP Server，即可扩展其能力。</li><li><strong>MCP Server 资源库</strong>：要寻找现成的 Server，可以访问 <strong><code>github.com/modelcontextprotocol/servers</code></strong>（官方示例）和 <strong><code>cursor.directory</code></strong>（社区目录），这里有从文件系统、数据库到各类云服务的丰富工具。</li><li><strong>开发工具</strong>：Anthropic 提供了官方的 <strong>Python 和 TypeScript SDK</strong>等，极大简化了 MCP Server 和 Client 的开发流程。<ul><li>SDK 文档：<a href="https://github.com/modelcontextprotocol">https://github.com/modelcontextprotocol</a></li></ul></li></ul><h1 id="❄️-冷知识"><a href="#❄️-冷知识" class="headerlink" title="❄️ 冷知识"></a>❄️ 冷知识</h1><ul><li><strong>灵感来源</strong>：MCP 的设计深受<strong>语言服务器协议（LSP）</strong> 的启发。LSP 统一了 IDE 对不同编程语言的支持，而 MCP 旨在统一 AI 应用对不同工具和数据的访问。</li><li><strong>权限控制</strong>：在 MCP 架构下，<strong>工具由模型控制调用，而资源（数据）的访问权完全由用户控制</strong>。Server 所有者无需将 API 密钥等敏感信息暴露给 LLM 提供商，提升了安全性。</li><li><strong>商业前景</strong>：分析认为，MCP 在<strong>To C（消费者）领域</strong>（如智能硬件、社交 App）有广阔前景，因其能快速集成多样化服务。但在<strong>To B（企业）领域</strong>可能面临挑战，因为企业级软件更倾向于成为用户入口而非被调用的工具。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.anthropic.com/news/model-context-protocol">Anthropic MCP 官方文档</a></li><li><a href="https://github.com/liaokongVFX/MCP-Chinese-Getting-Started-Guide">Model Context Protocol(MCP) 编程极速入门</a></li><li><a href="https://gofastmcp.com/getting-started/quickstart">FastMCP 官方文档</a></li><li><a href="https://platform.openai.com/docs/guides/tools-connectors-mcp">OpenAI MCP 文档</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们来学习 &lt;strong&gt;模型上下文协议（MCP）&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;MCP（Model Context Protocol，模型上下文协议）&lt;/strong&gt; 是由 Anthropic 公司推出的开源协议，旨在为大型语言模型与外部数据源、工具之间建立&lt;strong&gt;安全、标准化、双向&lt;/strong&gt;的连接通道。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通俗地说，MCP 如同 AI 世界的“USB-C 接口”。它定义了一套通用标准，使得任何支持 MCP 的 AI 应用（如 Claude Desktop、Cursor IDE）都能通过统一的“插口”，即插即用地连接各种外部工具（如数据库、API、本地文件），而无需为每个工具单独开发适配器。其核心价值在于解决了 AI 应用与外部资源交互时的碎片化集成问题，实现了生态的标准化和去中心化。&lt;/p&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    <category term="5分钟AI" scheme="https://www.qborfy.com/tags/5%E5%88%86%E9%92%9FAI/"/>
    
  </entry>
  
  <entry>
    <title>5分钟AI，每天搞懂一个知识点(15) - Agent Skill</title>
    <link href="https://www.qborfy.com/ailearn/daily/16.html"/>
    <id>https://www.qborfy.com/ailearn/daily/16.html</id>
    <published>2025-12-16T04:35:39.502Z</published>
    <updated>2026-01-09T11:44:44.189Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><p>今天我们来学习 <strong>Agent Skill</strong></p><blockquote><p><strong>Agent Skill</strong> 是一个<strong>可复用的知识包</strong>，它将特定的操作指南、代码示例和最佳实践打包成一个模块。当 AI Agent 识别到你的任务与某个 Skill 描述相匹配时，它会自动<strong>按需加载</strong>并运用该 Skill 中的知识来帮助你，而无需你每次都重新解释整个工作流程。</p></blockquote><p><strong>通俗来讲</strong>，Skill 就像为 Agent 准备的一份份专门的<strong>“工作说明书”或“操作手册”</strong>。例如，你可以创建一个“代码审查”Skill，里面写明了团队审查代码的标准流程、注意事项和常用话术。之后，你只需对 AI Agent 说“请审查这段代码”，它就会自动调用这份说明书，像一位受过专门训练的专家一样为你服务。</p><span id="more"></span><h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p><img src="/assets/img/ailearn/daily/16/1.png" alt="5分钟AI知识网络图"></p><p><strong>核心价值</strong>：它将重复性的、复杂的工作流程（如代码审查、文档生成、数据清洗）标准化和自动化，让 AI Agent 从“通才”变成处理特定任务的“专家”，确保输出结果每次都高质量、一致。</p><p><strong>组成部分</strong>：</p><ul><li><code>SKILL.md</code>： skill 最基础描述，</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.anthropic.com/news/model-context-protocol">Anthropic MCP 官方文档</a></li><li><a href="https://github.com/liaokongVFX/MCP-Chinese-Getting-Started-Guide">Model Context Protocol(MCP) 编程极速入门</a></li><li><a href="https://gofastmcp.com/getting-started/quickstart">FastMCP 官方文档</a></li><li><a href="https://platform.openai.com/docs/guides/tools-connectors-mcp">OpenAI MCP 文档</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们来学习 &lt;strong&gt;Agent Skill&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Agent Skill&lt;/strong&gt; 是一个&lt;strong&gt;可复用的知识包&lt;/strong&gt;，它将特定的操作指南、代码示例和最佳实践打包成一个模块。当 AI Agent 识别到你的任务与某个 Skill 描述相匹配时，它会自动&lt;strong&gt;按需加载&lt;/strong&gt;并运用该 Skill 中的知识来帮助你，而无需你每次都重新解释整个工作流程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;通俗来讲&lt;/strong&gt;，Skill 就像为 Agent 准备的一份份专门的&lt;strong&gt;“工作说明书”或“操作手册”&lt;/strong&gt;。例如，你可以创建一个“代码审查”Skill，里面写明了团队审查代码的标准流程、注意事项和常用话术。之后，你只需对 AI Agent 说“请审查这段代码”，它就会自动调用这份说明书，像一位受过专门训练的专家一样为你服务。&lt;/p&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    <category term="5分钟AI" scheme="https://www.qborfy.com/tags/5%E5%88%86%E9%92%9FAI/"/>
    
  </entry>
  
  <entry>
    <title>5分钟AI，每天搞懂一个知识点(14) - Function Calling</title>
    <link href="https://www.qborfy.com/ailearn/daily/14.html"/>
    <id>https://www.qborfy.com/ailearn/daily/14.html</id>
    <published>2025-12-16T04:00:00.000Z</published>
    <updated>2025-12-16T04:09:18.424Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><p>今天我们来学习 <strong>AI 函数调用 Function Calling</strong></p><blockquote><p>一句话核心: <strong>Function Calling</strong>（函数调用）是大模型在对话过程中，根据用户需求调用外部函数或工具的一种能力。</p></blockquote><p>通俗地讲，它让大模型从“能说会道”的参谋，变成了“能动手做事”的助手。当模型遇到自己无法直接解决的问题时（比如查询实时信息、进行复杂计算），它不再说“我做不到”，而是会“告诉”你的程序：“嘿，你需要调用那个叫 get_weather 的函数，并把 location 参数设置为‘北京’。”</p><p>需要注意的是，模型本身并不直接执行函数，它只负责生成调用的“指令”。真正的执行工作由你的程序来完成。</p><p>它的核心价值在于<strong>将大模型的语言理解能力与外部工具的执行能力相结合</strong>，从而突破其固有局限（如知识截止日期、无法访问网络等），完成更复杂的任务。</p><span id="more"></span><h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p><img src="/assets/img/ailearn/daily/14/1.png" alt="5分钟AI知识网络图"></p><p>通过一张图来理解 Function Calling 的工作原理：</p><p><img src="/assets/img/ailearn/daily/14/2.png" alt="Function Calling 工作原理"></p><p>这个流程的核心在于，大模型至少被调用了<strong>两次</strong>：第一次是分析意图并决定调用哪个函数，第二次是将函数的执行结果整合成对人类友好的自然语言回复。</p><h1 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h1><p>下面我们通过几个案例来理解 Function Calling 的使用场景和实现方式。</p><h2 id="案例-1：智能天气查询助手"><a href="#案例-1：智能天气查询助手" class="headerlink" title="案例 1：智能天气查询助手"></a>案例 1：智能天气查询助手</h2><p>这是最经典的案例，展示了如何弥补大模型知识时效性的不足。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 定义可供调用的工具（告诉模型你有什么函数）</span></span><br><span class="line">tools = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;function&quot;</span>,</span><br><span class="line">        <span class="string">&quot;function&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;get_current_weather&quot;</span>,  <span class="comment"># 函数名</span></span><br><span class="line">            <span class="string">&quot;description&quot;</span>: <span class="string">&quot;获取指定城市的当前天气&quot;</span>,  <span class="comment"># 给模型看的功能描述</span></span><br><span class="line">            <span class="string">&quot;parameters&quot;</span>: &#123;  <span class="comment"># 参数定义</span></span><br><span class="line">                <span class="string">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">                <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;location&quot;</span>: &#123;</span><br><span class="line">                        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;description&quot;</span>: <span class="string">&quot;城市名称，例如：北京&quot;</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&quot;required&quot;</span>: [<span class="string">&quot;location&quot;</span>],  <span class="comment"># 必须提供的参数</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 用户提问</span></span><br><span class="line">messages = [&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;北京天气怎么样？&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 首次调用模型，模型会返回类似以下的指令：</span></span><br><span class="line"><span class="comment"># function_call = &#123;</span></span><br><span class="line"><span class="comment">#   &quot;name&quot;: &quot;get_current_weather&quot;,</span></span><br><span class="line"><span class="comment">#   &quot;arguments&quot;: &quot;&#123;\&quot;location\&quot;: \&quot;北京\&quot;&#125;&quot;</span></span><br><span class="line"><span class="comment"># &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 你的程序执行真实的天气API调用函数</span></span><br><span class="line"><span class="comment"># 5. 将执行结果 `weather_result` 传给模型进行第二次调用，生成最终回复</span></span><br></pre></td></tr></table></figure><h2 id="案例-2：并行查询（进阶技巧）"><a href="#案例-2：并行查询（进阶技巧）" class="headerlink" title="案例 2：并行查询（进阶技巧）"></a>案例 2：并行查询（进阶技巧）</h2><p>当用户的问题涉及多个独立查询时，可以开启并行调用功能，大幅提升效率。</p><blockquote><p><strong>用户提问</strong>：“同时查询北京和上海的天气。”<br><strong>实现</strong>：设置 <code>parallel_tool_calls=True</code> 参数，模型可以同时生成两个函数调用请求，你的程序可以并行执行两个天气查询 API，然后一次性将结果返回给模型进行总结。</p></blockquote><h2 id="案例-3：股票查询系统"><a href="#案例-3：股票查询系统" class="headerlink" title="案例 3：股票查询系统"></a>案例 3：股票查询系统</h2><p>这个案例展示了如何将专业、实时的数据（如股价）接入对话系统。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 工具定义示例</span></span><br><span class="line">tools = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;function&quot;</span>,</span><br><span class="line">        <span class="string">&quot;function&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;get_stock_price&quot;</span>,</span><br><span class="line">            <span class="string">&quot;description&quot;</span>: <span class="string">&quot;获取指定股票的实时价格&quot;</span>,</span><br><span class="line">            <span class="string">&quot;parameters&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">                <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;symbol&quot;</span>: &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>, <span class="string">&quot;description&quot;</span>: <span class="string">&quot;股票代码&quot;</span>&#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&quot;required&quot;</span>: [<span class="string">&quot;symbol&quot;</span>],</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>当用户询问“青岛啤酒的股价是多少？”，模型会调用此函数，你的程序可以连接真实的金融数据 API 获取信息，再由模型生成回复。</p><h2 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h2><p>下面我们通过 openai sdk 来实现一个简单的天气查询功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openai <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">client = OpenAI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 定义可供调用的工具（告诉模型你有什么函数）</span></span><br><span class="line">tools = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;function&quot;</span>,</span><br><span class="line">        <span class="string">&quot;function&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;get_current_weather&quot;</span>,  <span class="comment"># 函数名</span></span><br><span class="line">            <span class="string">&quot;description&quot;</span>: <span class="string">&quot;获取指定城市的当前天气&quot;</span>,  <span class="comment"># 给模型看的功能描述</span></span><br><span class="line">            <span class="string">&quot;parameters&quot;</span>: &#123;  <span class="comment"># 参数定义</span></span><br><span class="line">                <span class="string">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">                <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;location&quot;</span>: &#123;</span><br><span class="line">                        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;description&quot;</span>: <span class="string">&quot;城市名称，例如：北京&quot;</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&quot;required&quot;</span>: [<span class="string">&quot;location&quot;</span>],  <span class="comment"># 必须提供的参数</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_current_weather</span>(<span class="params">params</span>):</span><br><span class="line">    location = params.get(<span class="string">&quot;location&quot;</span>)</span><br><span class="line">    <span class="comment"># 这里你可以调用真实的天气API，这里我们模拟返回数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;location&#125;</span> 当前天气晴，温度25摄氏度&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个列表会随着对话进行不断更新</span></span><br><span class="line">input_list = [</span><br><span class="line">    &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;请告诉我北京的天气。&quot;</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 第一次调用模型，模型会返回函数调用指令</span></span><br><span class="line">response = client.responses.create(</span><br><span class="line">    model=<span class="string">&quot;gpt-5&quot;</span>,</span><br><span class="line">    tools=tools,</span><br><span class="line">    <span class="built_in">input</span>=input_list,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这时候我们把模型的输出添加到输入列表中</span></span><br><span class="line">input_list += response.output</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> response.output:</span><br><span class="line">    <span class="keyword">if</span> item.<span class="built_in">type</span> == <span class="string">&quot;function_call&quot;</span>:</span><br><span class="line">        <span class="keyword">if</span> item.name == <span class="string">&quot;get_current_weather&quot;</span>:</span><br><span class="line">            <span class="comment"># 3. 执行函数调用</span></span><br><span class="line">            args = json.loads(item.arguments)</span><br><span class="line">            weather = get_current_weather(args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 4. 将函数调用结果添加回输入列表，供模型继续处理</span></span><br><span class="line">            input_list.append(&#123;</span><br><span class="line">                <span class="string">&quot;type&quot;</span>: <span class="string">&quot;function_call_output&quot;</span>,</span><br><span class="line">                <span class="string">&quot;call_id&quot;</span>: item.call_id,</span><br><span class="line">                <span class="string">&quot;output&quot;</span>: json.dumps(&#123;</span><br><span class="line">                  <span class="string">&quot;horoscope&quot;</span>: weather</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最终的输入列表:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(input_list)</span><br><span class="line"></span><br><span class="line">response = client.responses.create(</span><br><span class="line">    model=<span class="string">&quot;gpt-5&quot;</span>,</span><br><span class="line">    instructions=<span class="string">&quot;根据用户的提问和函数调用结果，生成一个友好的回复。&quot;</span>,</span><br><span class="line">    tools=tools,</span><br><span class="line">    <span class="built_in">input</span>=input_list,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. The model should be able to give a response!</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最终输出：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(response.model_dump_json(indent=<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span> + response.output_text)</span><br></pre></td></tr></table></figure><ul><li><strong>核心工具/库</strong>：<strong>OpenAI Python SDK</strong>。即使你使用的不是 OpenAI 的模型（如通义千问、DeepSeek），许多国产大模型平台也兼容 OpenAI 的 API 格式。这意味着你只需简单配置不同的 <code>base_url</code> 和 <code>api_key</code>，就可以用几乎相同的代码调用不同品牌的模型，大大降低了学习和开发成本。</li><li><strong>关键参数</strong>：在调用 <code>client.chat.completions.create</code> 方法时，核心参数是 <code>tools</code>（用于定义可用函数列表）和 <code>tool_choice</code>（用于控制调用行为，如 <code>auto</code> 自动决定或强制调用某个函数）。</li></ul><h1 id="❄️-冷知识"><a href="#❄️-冷知识" class="headerlink" title="❄️ 冷知识"></a>❄️ 冷知识</h1><ol><li><strong>模型没有“手”</strong>：一个大反直觉的真相是，大模型本身并不具备执行代码的能力。它只是一个“超级大脑”，负责生成调用函数的“计划”。真正去执行这个计划、拥有“手和脚”的是你自己的程序。</li><li><strong>描述决定一切</strong>：模型是否调用一个函数，很大程度上依赖于你为函数写的 <code>description</code>（描述）。描述必须清晰、准确，模型才能正确理解何时该调用它。</li><li><strong>“思考”过程可控</strong>：你可以通过 <code>tool_choice</code> 参数精细控制模型的行为。比如，可以强制模型必须调用某个函数（<code>tool_choice=&#123;&quot;type&quot;: &quot;function&quot;, &quot;function&quot;: &#123;&quot;name&quot;: &quot;get_weather&quot;&#125;&#125;</code>），或者禁止它调用任何函数（<code>tool_choice=&quot;none&quot;</code>），让它完全靠自己知识库回答。</li><li><strong>与 MCP 的关系</strong>：你可以把 Function Calling 看作是一个“基础版”的工具调用技术，简单直接。而<strong>MCP（Model Context Protocol）</strong> 则是一个更高级、更标准化的“企业级工具箱协议”，它旨在以统一的方式管理成千上万的工具，更适合构建复杂的 AI 智能体（Agent）工作流。它们是互补而非替代关系。</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://platform.openai.com/docs/guides/function-calling">OpenAI Function Calling 官方文档</a></li><li><a href="https://help.aliyun.com/zh/model-studio/qwen-function-calling">阿里云百炼平台文档 Function Calling</a></li><li><a href="https://api-docs.deepseek.com/zh-cn/guides/tool_calls">DeepSeek Function Calling 文档</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们来学习 &lt;strong&gt;AI 函数调用 Function Calling&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一句话核心: &lt;strong&gt;Function Calling&lt;/strong&gt;（函数调用）是大模型在对话过程中，根据用户需求调用外部函数或工具的一种能力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通俗地讲，它让大模型从“能说会道”的参谋，变成了“能动手做事”的助手。当模型遇到自己无法直接解决的问题时（比如查询实时信息、进行复杂计算），它不再说“我做不到”，而是会“告诉”你的程序：“嘿，你需要调用那个叫 get_weather 的函数，并把 location 参数设置为‘北京’。”&lt;/p&gt;
&lt;p&gt;需要注意的是，模型本身并不直接执行函数，它只负责生成调用的“指令”。真正的执行工作由你的程序来完成。&lt;/p&gt;
&lt;p&gt;它的核心价值在于&lt;strong&gt;将大模型的语言理解能力与外部工具的执行能力相结合&lt;/strong&gt;，从而突破其固有局限（如知识截止日期、无法访问网络等），完成更复杂的任务。&lt;/p&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    <category term="5分钟AI" scheme="https://www.qborfy.com/tags/5%E5%88%86%E9%92%9FAI/"/>
    
  </entry>
  
  <entry>
    <title>CodeBuddy结合Spec-Kit AI编程工程化指南</title>
    <link href="https://www.qborfy.com/ailearn/ai-learn14.html"/>
    <id>https://www.qborfy.com/ailearn/ai-learn14.html</id>
    <published>2025-12-09T07:00:00.000Z</published>
    <updated>2025-12-12T10:12:56.169Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>CodeBuddy 是腾讯面向开发者的基于 AI 大模型，提供代码生成补全、技术问答、智能代码评审、单测生成等能力，结合 Spec Kit（规范套件） 与 AI 能力，旨在通过“规范驱动+智能辅助”的模式，帮助团队统一代码风格、规避常见错误、提升开发效率。本指南将详细介绍从环境准备到日常开发的全流程操作，涵盖规范定义、AI 辅助编码、自动化检查与修复等核心场景。</p><span id="more"></span><h2 id="1-1-Spec-是什么"><a href="#1-1-Spec-是什么" class="headerlink" title="1.1 Spec 是什么"></a>1.1 Spec 是什么</h2><p><strong>传统开发 vs Spec-Driven 开发</strong><br>很多开发者开始一个项目时是这样的流程：</p><p>💭 “嗯，我想要一个标签管理工具…”<br>💻 “开始写代码吧，边写边想”<br>🤖 “AI，帮我生成一个 React 组件…”<br>🐛 “等等，这个需求没想清楚啊”<br>🔄 “改需求、改代码、来回折腾…”<br>😫 “代码越来越乱，难以维护”</p><p><strong>Spec-Driven 开发 的思路则完全不同：</strong><br>💭 “我的问题是什么？我想要的真实需求是什么？”<br>📝 “写一份清晰的 Spec（规格书），定义问题的边界”<br>🤖 “基于 Spec，让 AI 精准理解需求并生成代码”<br>✅ “代码与 Spec 完全对齐，清晰可维护”</p><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><p>Spec（规格） 简单来说，就是在开始编码前，用结构化的文档明确定义：</p><p>1.问题是什么 - 用户的真实需求和痛点 2.解决方案长什么样 - 功能描述、交互流程、数据模型 3.怎样判断成功 - 验收标准和成功指标 4.有哪些约束 - 技术限制、性能要求、安全规范</p><p>一个好的 Spec 应该包含：</p><table><thead><tr><th>步骤</th><th>作用</th><th>例子</th></tr></thead><tbody><tr><td>User Story</td><td>定义用户需求</td><td>“用户点击图标，能看到所有打开的标签页”</td></tr><tr><td>Acceptance Criteria</td><td>清晰的验收条件</td><td>“Given 打开 10 个标签，When 点击图标，Then 显示完整列表”</td></tr><tr><td>Data Model</td><td>定义数据结构</td><td>Tab、TabGroup、Summary 三个核心实体</td></tr><tr><td>Functional Requirements</td><td>功能需求列表</td><td>FR-001: 系统必须检测所有打开的标签页</td></tr><tr><td>Edge Cases</td><td>边界情况处理</td><td>“如果没有标签页，显示友好提示”</td></tr><tr><td>Success Criteria</td><td>可测量的成功指标</td><td>“渲染时间 &lt;200ms，支持 100+ 标签”</td></tr></tbody></table><p><strong>参考例子说明</strong></p><p>❌ 没有 Spec，你可能这样 Prompt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;给我写个 Chrome 扩展，能管理标签页，要好看&quot;</span><br></pre></td></tr></table></figure><p>✅ 有 Spec，你可以这样 Prompt：</p><ol><li>“根据 spec.md，实现 TabList 组件，要求：- 显示 Tab[] 数组</li><li>支持虚拟滚动（超过 50 个标签时）</li><li>点击时调用 onTabClick 回调</li><li>按打开时间降序排列”</li><li>…</li></ol><h1 id="二、快速开始"><a href="#二、快速开始" class="headerlink" title="二、快速开始"></a>二、快速开始</h1><h2 id="2-1-环境要求"><a href="#2-1-环境要求" class="headerlink" title="2.1 环境要求"></a>2.1 环境要求</h2><ul><li>操作系统：macOS 10.15+/Windows 10+/Linux (Ubuntu 20.04+)</li><li>Node.js 版本：≥20.0.0</li><li>包管理器：npm/yarn/pnpm（任选其一）</li><li>Python 版本：≥3.12</li></ul><p><strong>Nodejs 版本 nvm 安装操作命令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Mac ｜ Linux安装命令</span></span><br><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.3/install.sh | bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Windows 上安装 NVM，可以通过 GitHub https://github.com/coreybutler/nvm-windows/releases 下载 nvm-setup.exe 文件</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证是否安装成功</span></span><br><span class="line">nvm version</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 nvm安装  node20+版本</span></span><br><span class="line">nvm install v20.19.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置别名</span></span><br><span class="line">nvm alias ai v20.19.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置为当前node版本</span></span><br><span class="line">nvm use ai</span><br></pre></td></tr></table></figure><p><strong>Python 版本管理器 uv 安装操作命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">On macOS and Linux.</span></span><br><span class="line">curl -LsSf https://astral.sh/uv/install.sh | sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">On Windows.</span></span><br><span class="line">powershell -ExecutionPolicy ByPass -c &quot;irm https://astral.sh/uv/install.ps1 | iex&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">With pip.</span></span><br><span class="line">pip install uv</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证</span></span><br><span class="line">uv help</span><br></pre></td></tr></table></figure><h2 id="2-2-安装-codebuddy-code"><a href="#2-2-安装-codebuddy-code" class="headerlink" title="2.2 安装 codebuddy-code"></a>2.2 安装 codebuddy-code</h2><p>官方文档：<a href="https://www.codebuddy.ai/cli">https://www.codebuddy.ai/cli</a> codebuddy 外网版（内网版有点问题，推荐使用外网版）</p><p>通过 npm 全局安装（推荐）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @tencent-ai/codebuddy-code</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证安装成功：</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入 codebuddy 启动 CodeBuddy 触发登录验证，后续按照操作选择 iOA步骤即可</span></span><br><span class="line"></span><br><span class="line">codebuddy</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-3-安装-spec-kit-首次初始化项目使用"><a href="#2-3-安装-spec-kit-首次初始化项目使用" class="headerlink" title="2.3 安装 spec-kit(首次初始化项目使用)"></a>2.3 安装 spec-kit(首次初始化项目使用)</h2><p>spec 官方 github: <a href="https://github.com/github/spec-kit">https://github.com/github/spec-kit</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uv tool install specify-cli --from git+https://github.com/github/spec-kit.git</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证安装成功</span></span><br><span class="line">specify --help</span><br></pre></td></tr></table></figure><p><img src="/assets/img/ailearn/ai-learn14-1.png" alt="specify"></p><h2 id="2-4-配置-Codebuddy-语言偏好"><a href="#2-4-配置-Codebuddy-语言偏好" class="headerlink" title="2.4 配置 Codebuddy 语言偏好"></a>2.4 配置 Codebuddy 语言偏好</h2><p><code>CODEBUDDY.md</code> 放在长期记忆的开头，项目特有的在后边追加（<code>项目/CODEBUDDY.md</code>）</p><p>如果同时在用 Codebuddy IDE 则 <code>CODEBUDDY.md</code> 可以放在自己的项目 rules 中，共享 CodebuddyCode 的长期记忆（.codebuddy/.rules）。</p><p>具体内容如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 指令集(Instructions)</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 语言偏好（Language Preference）</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**重要提示：**</span> 之后所有沟通（包括代码注释和解释）都请使用中文。</span><br><span class="line"></span><br><span class="line"><span class="section">## 命令约束</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**重要提示：**</span> 当进行/speckit.\* 命令时，都需要将本文件内作为基础对话认识</span><br><span class="line"></span><br><span class="line"><span class="section">## 咨询</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**重要提示：**</span> 当对项目内业务有疑问时优先在本文件中查询，如果没有找到相关内容，或指出错误，则根据代码调研并且向研发人员确认，确认后应当更新本文件</span><br></pre></td></tr></table></figure><h1 id="三、speckit-规范-AI-编程全流程"><a href="#三、speckit-规范-AI-编程全流程" class="headerlink" title="三、speckit 规范 AI 编程全流程"></a>三、speckit 规范 AI 编程全流程</h1><h2 id="3-1-完整的-speckit-开发流程"><a href="#3-1-完整的-speckit-开发流程" class="headerlink" title="3.1 完整的 speckit 开发流程"></a>3.1 完整的 speckit 开发流程</h2><p><img src="/assets/img/ailearn/ai-learn14-2.png" alt="speckit流程图"></p><p>| 阶段 ｜ 命令 ｜ 目的 |<br>| ——————– | ———————– | ———————————————————- |<br>| 1                    | <code>/speckit.constitution</code> | 定义项目的开发宪章（指导原则）                             |<br>| 2                    | <code>/speckit.specify</code>      | 编写初始功能规格文档                                       |<br>| 3                    | <code>/speckit.checklist</code>    | 验证规格质量是否达到“可交付”标准                           |<br>| 4                    | <code>/speckit.clarify</code>      | 根据 checklist 结果进行需求澄清                            |<br>| 5                    | <code>/speckit.plan</code>         | 进入实现规划，写技术方案                                   |<br>| 6                    | <code>/speckit.tasks</code>        | 基于 Spec 拆解技术方案为一个个可实现的任务点，方便 AI 执行 |<br>| 7                    | <code>/speckit.analyze</code>      | 确认任务的可实现和检查风险点                               |<br>| 8                    | <code>/speckit.implement</code>    | 根据 constitution + spec + tasks 去实现代码输出            |</p><p>以上步骤可以多次执行，如：</p><ul><li><code>/speckit.constitution</code> 可以针对项目，多次调整定义开发规范。</li><li><code>/speckit.specify</code> 针对需求我们可以多次调整，直到生成的 spec.md 符合我们需求。</li><li><code>/speckit.plan</code> 可以查看生成 plan.md 调整生成技术实现方案。</li><li>…等等</li></ul><p><img src="/assets/img/ailearn/ai-learn14-3.png" alt="speckit命令"></p><h2 id="3-2-定义宪章-speckit-constitution"><a href="#3-2-定义宪章-speckit-constitution" class="headerlink" title="3.2 定义宪章 /speckit.constitution"></a>3.2 定义宪章 /speckit.constitution</h2><blockquote><p>*<em>宪章 *</em>是项目的架构原则和约束的集合。它在整个开发过程中起到”守门员”的作用，确保所有设计决策都符合核心原则。</p></blockquote><p><strong>操作步骤：</strong><br>启动 codebuddy ，输入/speckit.constitution ，具体如下图：</p><p><img src="/assets/img/ailearn/ai-learn14-4.png" alt="speckit.constitution"></p><h2 id="3-3-需求设计和澄清-speckit-specify-和-speckit-clarify"><a href="#3-3-需求设计和澄清-speckit-specify-和-speckit-clarify" class="headerlink" title="3.3 需求设计和澄清(/speckit.specify 和 /speckit.clarify)"></a>3.3 需求设计和澄清(/speckit.specify 和 /speckit.clarify)</h2><blockquote><p>需求设计解决最大的问题在开发设计前消除歧义与认知偏差，避免“带猜测”进入 <code>/plan</code> 导致返工。</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;p&gt;CodeBuddy 是腾讯面向开发者的基于 AI 大模型，提供代码生成补全、技术问答、智能代码评审、单测生成等能力，结合 Spec Kit（规范套件） 与 AI 能力，旨在通过“规范驱动+智能辅助”的模式，帮助团队统一代码风格、规避常见错误、提升开发效率。本指南将详细介绍从环境准备到日常开发的全流程操作，涵盖规范定义、AI 辅助编码、自动化检查与修复等核心场景。&lt;/p&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    <category term="AI学习" scheme="https://www.qborfy.com/tags/AI%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>5分钟AI，每天搞懂一个知识点(12) -大模型Token</title>
    <link href="https://www.qborfy.com/ailearn/daily/12.html"/>
    <id>https://www.qborfy.com/ailearn/daily/12.html</id>
    <published>2025-08-16T13:00:00.000Z</published>
    <updated>2025-08-16T13:00:38.595Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><p>今天我们来学习 <strong>大模型Token</strong></p><blockquote><p>一句话核心: Token = 大模型处理文本的最小单元​​，如同原子构成物质，Token构成语言模型理解的文本世界。它可以是单词、子词、汉字或标点。</p></blockquote><p>掌握Token，就握住了LLM的“算力方向盘”—— 精准控制输入、预测成本、优化生成效果。</p><span id="more"></span><h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p><img src="/assets/img/ailearn/daily/12/1.png" alt="5分钟AI知识网络图"></p><p><strong>核心特性</strong>： </p><ul><li><strong>非固定长度</strong>：1个Token ≠ 1个字（例：中文“人工智能”可能拆为2个Token[“人工”,”智能”]或4个Token[“人”,”工”,”智”,”能”]）。  </li><li><strong>数值化表示</strong>：每个Token映射唯一ID（如“AI”→[31924]），再转为向量输入神经网络。  </li><li><strong>计费基准</strong>：API调用按输入/输出Token量收费（如¥1/百万Token）。  </li></ul><p>此外我们还需要知道：<strong>Token计算=提问给大模型的输入+大模型的输出</strong></p><h1 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h1><p><img src="/assets/img/ailearn/daily/12/2.png" alt="图解Token工作流"></p><h2 id="关键机制"><a href="#关键机制" class="headerlink" title="关键机制"></a>关键机制</h2><ul><li><strong>中英文差异</strong>：1 个中文字符 ≈ 0.6 个 token，1 个英文字符 ≈ 0.3 个 token（因高频词合并）。  </li><li><strong>上下文窗口</strong>：模型单次处理Token上限（如GPT-4 Turbo：128K Token≈6.5万汉字）。  </li></ul><p><strong>为什么要学会Token知识点呢？</strong></p><ul><li>第一，Token≈Money,目前调用所有付费大模型API，都是基于Token数计费模式</li><li>第二，不同大模型对于一次请求Token数是有上限的，如：GPT-4 Turbo 单次Token限制为128K </li><li>第三，不同大模型对于文本 Tokenizer拆分计算规则是不同的，不同模型都提供API去计算Token数</li></ul><h2 id="Token成本计算"><a href="#Token成本计算" class="headerlink" title="Token成本计算"></a>Token成本计算</h2><p><strong>场景</strong>：用户提问 <em>“订单号DD20240815何时发货？”</em>  </p><ol><li><strong>Token拆分</strong>（使用DeepSeek分词器）：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;订单号&quot;</span>, <span class="string">&quot;DD&quot;</span>, <span class="string">&quot;2024&quot;</span>, <span class="string">&quot;08&quot;</span>, <span class="string">&quot;15&quot;</span>, <span class="string">&quot;何时&quot;</span>, <span class="string">&quot;发货&quot;</span>] → <span class="number">7</span>个Token</span><br></pre></td></tr></table></figure></li><li><strong>模型回复</strong>：<br><em>“订单已发货，物流单号SF123456”</em> → 拆分6个Token。  </li><li><strong>成本计算</strong>：  <ul><li>输入7 Token + 输出6 Token = 总13 Token  </li><li>按DeepSeek-V3定价（输入¥0.1/百万Token）：<br><strong>成本 = 13 × 0.0000001 = ¥0.0000013</strong>。 </li></ul></li></ol><h2 id="不同模型的分词策略"><a href="#不同模型的分词策略" class="headerlink" title="不同模型的分词策略"></a>不同模型的分词策略</h2><table><thead><tr><th><strong>模型</strong></th><th>分词算法</th><th>中文处理效果</th></tr></thead><tbody><tr><td>ChatGPT</td><td>BPE</td><td>长词拆分准（“人工智能”→2 Token）</td></tr><tr><td>DeepSeek</td><td>WordPiece</td><td>词缀捕捉强（“学习能力”→”学习“+”能力“）</td></tr><tr><td>阿里QWen</td><td>SentencePiece</td><td>生僻词支持优（“氪金”→保留为1 Token）</td></tr></tbody></table><blockquote><p><strong>行业真相</strong>：客服系统月耗千万Token，优化分词规则可降本20%。   </p></blockquote><h1 id="动手实验"><a href="#动手实验" class="headerlink" title="动手实验"></a>动手实验</h1><h2 id="1-Tokenizer拆分在线计算"><a href="#1-Tokenizer拆分在线计算" class="headerlink" title="1.Tokenizer拆分在线计算"></a>1.Tokenizer拆分在线计算</h2><p>访问网站： 🔗<a href="https://huggingface.co/spaces/Xenova/the-tokenizer-playground">https://platform.openai.com/tokenizer </a> </p><ul><li>输入句子实时查看Token拆分（例：“区块链”→[24775, 28638, 245, 64414]）。  </li></ul><p><img src="/assets/img/ailearn/daily/12/2.png" alt="Tokenizer拆分"></p><h2 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2.代码示例"></a>2.代码示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoTokenizer</span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(<span class="string">&quot;gpt2&quot;</span>)</span><br><span class="line">text = <span class="string">&quot;大模型Token是什么？&quot;</span></span><br><span class="line">tokens = tokenizer.tokenize(text)  <span class="comment"># 输出：[&#x27;大&#x27;, &#x27;模型&#x27;, &#x27;Token&#x27;, &#x27;是&#x27;, &#x27;什么&#x27;, &#x27;？&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Token数量：<span class="subst">&#123;<span class="built_in">len</span>(tokens)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="3-基于Token数选择模型策略"><a href="#3-基于Token数选择模型策略" class="headerlink" title="3.基于Token数选择模型策略"></a>3.基于Token数选择模型策略</h2><ul><li>64K：选Qwen2-7B（开源免费）或GPT-4 Turbo（多模态）</li><li>64K~200K：用Claude 3.7（长文本理解强）</li><li>≥200K：Gemini 1.5 Pro（需高预算）</li></ul><h1 id="冷知识"><a href="#冷知识" class="headerlink" title="冷知识"></a>冷知识</h1><ul><li><strong>训练数据规模</strong>：GPT-3吃下3000亿Token ≈ 人类300万年阅读量。  </li><li><strong>128K上下文威力</strong>：可一次性处理整本《三体》（约6.5万汉字）。  </li><li><strong>中文的“Token 税”​</strong>：同一段信息，中文消耗 Token 数比英文多 ​​40%~100%​​</li><li><strong>​​Emoji 的“拆解诅咒”​</strong>：❤️ 被拆为 ​​♥ + ️​​（2 Token），若用于情感分析可能被误判为“心脏符号 + 修饰符”</li><li></li></ul><h1 id="附：主流API的Token收费对比表"><a href="#附：主流API的Token收费对比表" class="headerlink" title="附：主流API的Token收费对比表"></a>附：主流API的Token收费对比表</h1><table><thead><tr><th><strong>服务商</strong></th><th>输入单价（¥/百万Token）</th><th>输出单价（¥/百万Token）</th><th>性价比场景</th></tr></thead><tbody><tr><td>字节豆包(128k)</td><td>0.8</td><td>0.8</td><td>超长文本处理</td></tr><tr><td>DeepSeek-V3(64k)</td><td>1~4(区分是否命中缓存，00:30-08:30打5折)</td><td>1~4(区分是否命中缓存，00:30-08:30打5折)</td><td>中文高精度任务</td></tr><tr><td>通义千问(128k)</td><td>2.4</td><td>6</td><td>日常问答/翻译</td></tr><tr><td>GPT-4(128k)</td><td>70～210(10–30美金)</td><td>210～420(30-60美金)</td><td>英文创作/代码生成</td></tr><tr><td>混元(128k)</td><td>1</td><td>4</td><td>首年免费100万token</td></tr></tbody></table><p>PS: 百万Token ≈ 60万个中文字，普通智能客服一次智能对话问答大约花费 100～500 token左右</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们来学习 &lt;strong&gt;大模型Token&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一句话核心: Token = 大模型处理文本的最小单元​​，如同原子构成物质，Token构成语言模型理解的文本世界。它可以是单词、子词、汉字或标点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;掌握Token，就握住了LLM的“算力方向盘”—— 精准控制输入、预测成本、优化生成效果。&lt;/p&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    <category term="5分钟AI" scheme="https://www.qborfy.com/tags/5%E5%88%86%E9%92%9FAI/"/>
    
  </entry>
  
  <entry>
    <title>5分钟AI，每天搞懂一个知识点(13) -Embedding</title>
    <link href="https://www.qborfy.com/ailearn/daily/13.html"/>
    <id>https://www.qborfy.com/ailearn/daily/13.html</id>
    <published>2025-08-16T13:00:00.000Z</published>
    <updated>2025-12-12T10:14:34.083Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><p>今天我们来学习 <strong>Embedding</strong></p><blockquote><p>一句话核心: Embedding = 将离散对象（文本/图像/用户行为）映射为连续向量的技术​​，本质是让机器通过向量空间中的相对位置理解语义关联。</p></blockquote><p>通俗理解 Embedding 概念，可以理解成 每个词/图片像获得一张“智能身份证”，身份证号（向量）隐含其特征（如： 性别、 籍贯、民族等），但是在数据上展示就是一个多维向量。</p><p>然后通过“身份证号”的向量差距表示语义关联，从而实现机器理解语义。如：相似对象（如“猫”和“狗”）身份证号接近，差异大的（如“猫”和“汽车”）则相距甚远</p><p><strong>掌握Embedding，就握住了AI理解现实世界的“语义密码本”！</strong></p><span id="more"></span><h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p><img src="/assets/img/ailearn/daily/13/1.png" alt="5分钟AI知识网络图"></p><p><strong>核心特性</strong>：  </p><ul><li><strong>语义保留</strong>：向量距离反映内容相关性（余弦相似度＞0.8→强关联）  </li><li><strong>可计算性</strong>：支持向量运算（如 <code>&quot;国王&quot; - &quot;男&quot; + &quot;女&quot; ≈ &quot;女王&quot;</code>）  </li><li><strong>降维高效</strong>：将GB级文本压缩为KB级向量</li></ul><h1 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h1><p><img src="/assets/img/ailearn/daily/13/2.png" alt="图解Embedding工作流"></p><p><strong>关键步骤解析</strong>：  </p><ol><li><strong>输入处理</strong>：  <ul><li>文本：拆分为词/子词（如“深度学习”→<code>[&quot;深&quot;,&quot;度&quot;,&quot;学&quot;,&quot;习&quot;]</code>）  </li><li>图像：分割为16x16像素块（ViT模型）  </li></ul></li><li><strong>语义编码</strong>：  <ul><li>通过自注意力机制计算上下文关联（如“苹果”在水果/公司场景向量不同）  </li></ul></li><li><strong>池化压缩</strong>：  <ul><li>平均池化：所有Token向量取平均  </li><li>[CLS]向量：BERT提取句子整体表征  </li></ul></li><li><strong>归一化输出</strong>：L2归一化使向量模长为1，简化相似度计算</li></ol><blockquote><p>PS: Embedding 本质是 <strong>向量空间</strong>， 其最大的作用是计算语义关联。<br>池化压缩就是把多维向量压缩为1维，从而方便计算，常用压缩算法有：平均池化、[CLS]向量等。<br>归一化输出就是将很长的向量模长归一化，最终只输出成长度=1的向量，方便更多计算，如：使用点积可以稍微更快地计算余弦相似度。</p></blockquote><h2 id="Embedding生态"><a href="#Embedding生态" class="headerlink" title="Embedding生态"></a>Embedding生态</h2><p>为了更好理解Embedding，还可以了解下Embedding能做什么以及周边生态。</p><p><img src="/assets/img/ailearn/daily/13/3.png" alt="Embedding生态"></p><h1 id="实战应用案例"><a href="#实战应用案例" class="headerlink" title="实战应用案例"></a>实战应用案例</h1><p>理解完 Embedding概念，能让我们实际应用开发更有多选择和降低成本。</p><h2 id="1-电商客服意图过滤（成本降低40-）"><a href="#1-电商客服意图过滤（成本降低40-）" class="headerlink" title="1. 电商客服意图过滤（成本降低40%）"></a>1. 电商客服意图过滤（成本降低40%）</h2><p><strong>问题:</strong>70%用户提问与业务无关（如：“今天天气？”）  </p><p><strong>解决方案</strong></p><p><img src="/assets/img/ailearn/daily/13/4.png" alt="Ebding应用案例-电商客服意图过滤"></p><p><strong>效果</strong>：减少无效LLM调用，响应速度提升3倍  </p><h2 id="2-医疗影像语义检索"><a href="#2-医疗影像语义检索" class="headerlink" title="2. 医疗影像语义检索"></a>2. 医疗影像语义检索</h2><p><strong>输入</strong>：病理报告文本 + CT影像切片  </p><p><strong>技术方案</strong>：  </p><ul><li>文本：BioBERT生成报告向量（理解“毛玻璃结节”）  </li><li>图像：CLIP模型提取视觉特征  </li><li>跨模态融合：共享向量空间检索相似病例  </li></ul><p><strong>结果</strong>：诊断准确率提升35%，误诊率↓18%  </p><h1 id="常用-Embedding模型（2025最新）"><a href="#常用-Embedding模型（2025最新）" class="headerlink" title="常用 Embedding模型（2025最新）"></a>常用 Embedding模型（2025最新）</h1><table><thead><tr><th><strong>模型</strong></th><th>核心优势</th><th>适用场景</th><th>中文支持</th></tr></thead><tbody><tr><td><strong>Qwen3-Embedding</strong></td><td>MTEB多语言榜第1（70.58分）</td><td>多语言检索/代码理解</td><td>✅ 优化</td></tr><tr><td><strong>BGE-M3</strong></td><td>混合检索（稠密+稀疏向量）</td><td>法律/金融精准匹配</td><td>✅ 强</td></tr><tr><td><strong>text-embedding-3</strong></td><td>与OpenAI生态无缝集成</td><td>国际通用场景</td><td>❌ 一般</td></tr><tr><td><strong>NV-Embed</strong></td><td>长文本处理（32K Token）</td><td>论文/合同分析</td><td>✅ 中等</td></tr></tbody></table><p>我们通过代码实战一下，如何用 <strong>FlagEmbedding</strong> 模型计算不同文本的相似度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> FlagEmbedding <span class="keyword">import</span> FlagModel</span><br><span class="line">model = FlagModel(<span class="string">&#x27;BAAI/bge-large-zh-v1.5&#x27;</span>, use_fp16=<span class="literal">True</span>)  <span class="comment"># 加载中文模型</span></span><br><span class="line">texts = [<span class="string">&quot;深度学习&quot;</span>, <span class="string">&quot;神经网络&quot;</span>]</span><br><span class="line">embeddings = model.encode(texts)  <span class="comment"># 生成向量</span></span><br><span class="line">similarity = embeddings[<span class="number">0</span>] @ embeddings[<span class="number">1</span>].T  <span class="comment"># 余弦相似度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;相似度：<span class="subst">&#123;similarity:<span class="number">.2</span>f&#125;</span>&quot;</span>)  <span class="comment"># 输出：0.92</span></span><br></pre></td></tr></table></figure><h1 id="冷知识"><a href="#冷知识" class="headerlink" title="冷知识"></a>冷知识</h1><ol><li><p><strong>中文的“Token税”</strong>：  </p><ul><li>相同信息中文需比英文多消耗 <strong>40% Token</strong>（因分词更细）  </li><li>例：“人工智能” → 英文“AI”（1 Token） vs 中文（2-4 Token）  </li></ul></li><li><p><strong>医疗Embedding的生死权重</strong>：  </p><ul><li>“心肌梗死”向量与“胸痛”相似度达0.93，而与“胃炎”仅0.12  </li><li>医生借该特性快速定位疑似误诊病例  </li></ul></li><li><p><strong>多模态幻象</strong>：<br>CLIP模型把“熊猫吃竹子”图片与文本向量对齐，<strong>跨模态相似度超0.9</strong>，却把“竹子手机支架”误判为关联对象   </p></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/667877230">大模型里面常说的Embedding是什么？</a></li><li><a href="https://openai.xiniushu.com/docs/guides/embeddings">OpenAI 嵌入（Embeddings）</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们来学习 &lt;strong&gt;Embedding&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一句话核心: Embedding = 将离散对象（文本/图像/用户行为）映射为连续向量的技术​​，本质是让机器通过向量空间中的相对位置理解语义关联。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通俗理解 Embedding 概念，可以理解成 每个词/图片像获得一张“智能身份证”，身份证号（向量）隐含其特征（如： 性别、 籍贯、民族等），但是在数据上展示就是一个多维向量。&lt;/p&gt;
&lt;p&gt;然后通过“身份证号”的向量差距表示语义关联，从而实现机器理解语义。如：相似对象（如“猫”和“狗”）身份证号接近，差异大的（如“猫”和“汽车”）则相距甚远&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;掌握Embedding，就握住了AI理解现实世界的“语义密码本”！&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    <category term="5分钟AI" scheme="https://www.qborfy.com/tags/5%E5%88%86%E9%92%9FAI/"/>
    
  </entry>
  
  <entry>
    <title>5分钟AI，每天搞懂一个知识点(11) - LLM大模型</title>
    <link href="https://www.qborfy.com/ailearn/daily/11.html"/>
    <id>https://www.qborfy.com/ailearn/daily/11.html</id>
    <published>2025-08-11T13:00:00.000Z</published>
    <updated>2025-08-12T05:09:56.234Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><p>今天我们来学习 <strong>LLM大模型</strong></p><blockquote><p>一句话核心:  LLM大模型(Large Language Model) = 基于Transformer架构的海量参数模型，通过万亿级文本训练，将人类语言规律压缩为数学表示，实现理解、生成、推理三位一体的通用智能。</p></blockquote><p>5分钟AI知识点学到LLM大模型，其实基本上对AI知识点有大概的认知了，对于目前大多数接触AI的人第一个接触的肯定是LLM大模型，知道怎么用，但是不知道它是怎么来的。通过上面5分钟AI知识点学习，能够大概了解到一些脉络。</p><p>从我个人理解来讲，LLM大模型目前的定义来说，是AI技术发展到一定阶段的可实际应用的产品，有点类似电脑时代的 晶体管超级电脑（占地170平方米）发展到个人电脑时代，大家开始可以接触与应用到AI技术，不再局限于某个少数高端领域中。</p><span id="more"></span><h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p><img src="/assets/img/ailearn/daily/11/1.png" alt="5分钟AI知识网络图"></p><p><strong>核心突破​​：</strong></p><p>​- <strong>​规模效应​​：</strong> 百亿至万亿参数（如GPT-4：1.8万亿）突破性能瓶颈<br>​- <strong>​零样本学习​​：</strong> 无需微调直接处理新任务（如翻译→摘要→代码生成）</p><p>最重要一点就是利用Transfomer架构的并行处理能力，可使用非常大规模的模型，其中通常具有数千亿个参数，甚至上万亿的参数去完成模型训练。</p><h1 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h1><p><strong>为什么LLM大模型能实现通用智能？</strong></p><ul><li><strong>规模效应</strong>：量变引发质变，模型性能随参数规模（N）、数据量（D）和算力（C）呈幂律提升</li><li><strong>Transformer自注意力机制的革新性</strong>： 突破RNN局限理解上下文，多任务适配性实现同一个模型处理翻译、摘要、代码生成等任务</li><li><strong>训练范式调整：</strong>：从“死记硬背”到“举一反三”<ul><li>预训练：通识教育阶段</li><li>指令微调：任务泛化能力​</li><li>人类对齐：价值观校准</li></ul></li><li><strong>不可预知能力</strong>：当规模突破阈值，LLM展现“不可预测”的新能力，如：​​上下文学习​​、​​思维链推理​​、​​工具调用​​</li></ul><h1 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h1><p><img src="/assets/img/ailearn/daily/11/2.png" alt=""></p><ul><li><strong>分词 Tokenization</strong>: <code>BPE算法</code>拆解文本→Token序列（如“AI学习”→[“AI”，“学”，“习”]）</li><li><strong>嵌入表示 Embedding</strong>: 将分词Token映射为高维向量（如“猫”→[0.2, -1.3, 0.8]），捕获语义关联</li><li><strong>多层Transformer堆叠</strong>: <ul><li>自注意力机制动态计算词间权重（如“苹果”在水果/公司语境下的不同关注度）</li><li>前馈网络提炼特征（上下文关联）</li></ul></li><li><strong>概率预测 Next Token</strong>: 输出下一个Token的概率分布（如“学习”后“知识”概率=92%）</li></ul><p>完整过程就是：<strong>数据压缩→规律学习→智能涌现</strong></p><h1 id="LLM三大架构对比"><a href="#LLM三大架构对比" class="headerlink" title="LLM三大架构对比"></a>LLM三大架构对比</h1><table><thead><tr><th><strong>类型</strong></th><th>代表模型</th><th>特性</th><th>最佳场景</th></tr></thead><tbody><tr><td><strong>Decoder-Only</strong></td><td>GPT/LLaMA</td><td>自回归生成流畅</td><td>创作/对话（如ChatGPT）</td></tr><tr><td><strong>Encoder-Only</strong></td><td>BERT</td><td>双向语义理解强</td><td>文本分类/情感分析</td></tr><tr><td><strong>Encoder-Decoder</strong></td><td>T5</td><td>输入→输出转换灵活</td><td>翻译/摘要</td></tr></tbody></table><p><strong>要生成选Decoder，重理解用Encoder，复杂转换需双全</strong></p><h1 id="冷知识"><a href="#冷知识" class="headerlink" title="冷知识"></a>冷知识</h1><ol><li><strong>能耗对比</strong>：训练GPT-3耗电≈<strong>纽约⇄旧金山航班200次</strong>，但单次推理仅需0.005度电（≈手机充电1分钟）  </li><li><strong>中文优势</strong>：DeepSeek模型古文生成超GPT-4，因训练数据含《四库全书》  </li><li><strong>“幻觉”防御</strong>：金融LLM通过<strong>规则约束+概率阈值</strong>限制虚构数据，错误率＜0.1%  </li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们来学习 &lt;strong&gt;LLM大模型&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一句话核心:  LLM大模型(Large Language Model) = 基于Transformer架构的海量参数模型，通过万亿级文本训练，将人类语言规律压缩为数学表示，实现理解、生成、推理三位一体的通用智能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;5分钟AI知识点学到LLM大模型，其实基本上对AI知识点有大概的认知了，对于目前大多数接触AI的人第一个接触的肯定是LLM大模型，知道怎么用，但是不知道它是怎么来的。通过上面5分钟AI知识点学习，能够大概了解到一些脉络。&lt;/p&gt;
&lt;p&gt;从我个人理解来讲，LLM大模型目前的定义来说，是AI技术发展到一定阶段的可实际应用的产品，有点类似电脑时代的 晶体管超级电脑（占地170平方米）发展到个人电脑时代，大家开始可以接触与应用到AI技术，不再局限于某个少数高端领域中。&lt;/p&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    <category term="5分钟AI" scheme="https://www.qborfy.com/tags/5%E5%88%86%E9%92%9FAI/"/>
    
  </entry>
  
  <entry>
    <title>5分钟AI，每天搞懂一个知识点(10) - Transformer</title>
    <link href="https://www.qborfy.com/ailearn/daily/10.html"/>
    <id>https://www.qborfy.com/ailearn/daily/10.html</id>
    <published>2025-08-08T07:00:00.000Z</published>
    <updated>2025-08-08T13:57:29.810Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><p>今天我们来学习 <strong>Transformer算法模型</strong></p><blockquote><p>一句话核心: Transformer = 完全基于自注意力机制的序列建模引擎，通过并行计算全局依赖关系，彻底取代循环神经网络（RNN）的串行瓶颈</p></blockquote><p>通俗的理解就是，原先的算法都一个接一个单词单独循环遍历相关的关联性，Transformer是把整个句子所有单词一起互相计算关联性，也可以简单理解为串行和并行区别。</p><span id="more"></span><h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p><img src="/assets/img/ailearn/daily/10/1.png" alt="5分钟AI知识网络图"></p><blockquote><p>“Transformer 的并行化设计，是AI从手工作坊走向工业化大生产的关键转折”—— Andrej Karpathy (特斯拉AI总监)</p></blockquote><p>下图是对Transformer结构的简易表示</p><p><img src="/assets/img/ailearn/daily/10/2.png" alt="Transformer 的整体结构，左图Encoder和右图Decoder"></p><h2 id="核心组成元素"><a href="#核心组成元素" class="headerlink" title="核心组成元素"></a>核心组成元素</h2><ul><li><code>Embedding 输入</code>: 主要包含单词向量表示和索引位置</li><li><code>Encoder 编码器</code>: 将输入序列（如文本、语音）转换为蕴含全局语义的高维向量表示（俗称：位置编码），捕捉序列内部的结构与依赖关系。</li><li><code>Self-Attention 自注意力机制</code>: 动态分配元素间关联权重， 多个<code>Self-Attention</code>就会组成 <code>Multi-Head Attention</code></li><li><code>Decoder 解码器</code>: 基于编码器的语义表示，逐步生成目标序列（如翻译结果、续写文本）</li></ul><p><img src="/assets/img/ailearn/daily/10/3.png" alt="Transformer官方论文解析图"></p><p>从上图，我们做一个翻译更容易理解的版本，如下图所示：</p><p><img src="/assets/img/ailearn/daily/10/4.png" alt="Transformer"></p><ul><li>编码器是理解者：将杂乱输入转化为结构化知识；</li><li>自注意力是协商者：在知识网络中建立动态连接；</li><li>解码器是创造者：依据知识网络按规则生成新内容。</li></ul><h2 id="创建本质"><a href="#创建本质" class="headerlink" title="创建本质"></a>创建本质</h2><ul><li>抛弃循环结构 ，所有词同时计算关联性</li><li>位置编码：（正弦/余弦波）替代时间步顺序</li></ul><h1 id="行业应用"><a href="#行业应用" class="headerlink" title="行业应用"></a>行业应用</h1><table><thead><tr><th><strong>场景</strong></th><th>代表模型</th><th>Transformer 的贡献</th></tr></thead><tbody><tr><td>机器翻译</td><td>Google Translate</td><td>长句翻译流畅度↑37%</td></tr><tr><td>文本生成</td><td>GPT-4</td><td>生成连贯性↑82%</td></tr><tr><td>图像识别</td><td>ViT</td><td>ImageNet 分类错误率↓15%</td></tr><tr><td>蛋白质结构预测</td><td>AlphaFold</td><td>预测精度超越实验方法</td></tr></tbody></table><h1 id="冷知识"><a href="#冷知识" class="headerlink" title="冷知识"></a>冷知识</h1><ol><li><p><strong>0.2 BLEU分的胜利</strong>：<br>Transformer 在机器翻译任务中仅比 LSTM 高 0.2 BLEU 分，但因 <strong>10倍训练速度</strong> 引发革命   </p></li><li><p><strong>位置编码的物理隐喻</strong>：<br>位置编码的波长从 $2\pi$ 到 $10000\cdot2\pi$ → 相当于给模型装上 <strong>从毫米到千米的刻度尺</strong>   </p></li><li><p><strong>注意力头的“专长”</strong>：  </p><ul><li>头1：检测主谓一致（如 “dogs” → “eat”）  </li><li>头4：捕捉介词搭配（如 “depend <em>on</em>“）  </li><li>头7：识别指代关系（如 “it” → “animal”）   </li></ul></li><li><p><strong>能耗对比</strong>：<br>训练 BERT-Large 耗电 ≈ <strong>纽约⇄旧金山航班往返40次</strong>，但推理单次仅需 <strong>0.005度电</strong>  </p></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/338817680">Transformer模型详解（图解最完整版）</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们来学习 &lt;strong&gt;Transformer算法模型&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一句话核心: Transformer = 完全基于自注意力机制的序列建模引擎，通过并行计算全局依赖关系，彻底取代循环神经网络（RNN）的串行瓶颈&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通俗的理解就是，原先的算法都一个接一个单词单独循环遍历相关的关联性，Transformer是把整个句子所有单词一起互相计算关联性，也可以简单理解为串行和并行区别。&lt;/p&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    <category term="5分钟AI" scheme="https://www.qborfy.com/tags/5%E5%88%86%E9%92%9FAI/"/>
    
  </entry>
  
  <entry>
    <title>5分钟AI，每天搞懂一个知识点(9) - 循环网络 RNN</title>
    <link href="https://www.qborfy.com/ailearn/daily/09.html"/>
    <id>https://www.qborfy.com/ailearn/daily/09.html</id>
    <published>2025-08-07T07:00:00.000Z</published>
    <updated>2025-08-07T11:37:32.255Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><p>今天我们来学习 <strong>循环网络 RNN</strong></p><blockquote><p>一句话核心: 循环网络 RNN = 带记忆功能的神经网络​​，通过循环连接保留历史信息，专为处理序列数据（文本、语音、时间序列）而生</p></blockquote><span id="more"></span><h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p><img src="/assets/img/ailearn/daily/09/1.png" alt=""></p><blockquote><p>“RNN的循环连接，是AI从静态画像走向动态影像的关键一跃”—— 吴恩达（Andrew Ng）</p></blockquote><p>​- ​记忆状态​​：如分拣中心的传送带，持续传递包裹（信息）<br>​- ​关键突破​​：传统神经网络每步独立处理 → RNN利用上一步结果辅助当前决策</p><h2 id="关键算法模型"><a href="#关键算法模型" class="headerlink" title="关键算法模型"></a>关键算法模型</h2><table><thead><tr><th><strong>模型</strong></th><th>核心机制</th><th>创新点</th></tr></thead><tbody><tr><td><strong>LSTM</strong></td><td>三重门控 + 细胞状态</td><td>遗忘门主动丢弃无用记忆（如清理过期快递）</td></tr><tr><td><strong>GRU</strong></td><td>两重门控（更新门+重置门）</td><td>合并记忆与隐藏状态，参数比LSTM少25%</td></tr></tbody></table><blockquote><p>生活化理解：驾校教练 → 根据学员压线距离扣分 → 损失函数就是那套评分标准  →  让学员学会不压线</p></blockquote><h1 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h1><h2 id="​​LSTM（长短期记忆网络）"><a href="#​​LSTM（长短期记忆网络）" class="headerlink" title="​​LSTM（长短期记忆网络）"></a>​​LSTM（长短期记忆网络）</h2><p><strong>​​核心目标​</strong>​：解决传统RNN的​​长期依赖问题​​（梯度消失/爆炸），通过门控机制选择性保留关键历史信息</p><p><strong>结构创新​​：</strong><br>​- ​记忆细胞（Cell State）​​：贯穿时间步的“信息高速公路”，稳定传递长期记忆。</p><ul><li>​​三重门控​​：遗忘门、输入门、输出门动态调控信息流</li></ul><p><img src="/assets/img/ailearn/daily/09/2.png" alt=""></p><h2 id="​​GRU（门控循环单元）"><a href="#​​GRU（门控循环单元）" class="headerlink" title="​​GRU（门控循环单元）"></a>​​GRU（门控循环单元）</h2><p><strong>​​核心目标​</strong>​：在保留LSTM优势的同时​​简化结构、提升计算效率</p><p><strong>结构创新​​：</strong></p><ul><li>双门设计​​：合并遗忘门与输入门为​​更新门​​，新增​​重置门​​，取消独立记忆细胞。<br>​- ​隐藏状态融合​​：直接操作隐藏状态，参数减少约25%</li></ul><p><img src="/assets/img/ailearn/daily/09/3.png" alt=""></p><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><table><thead><tr><th><strong>任务类型</strong></th><th>推荐模型</th><th>案例</th><th>关键优势</th></tr></thead><tbody><tr><td>实时语音识别</td><td>GRU</td><td>智能音箱指令解析</td><td>低延迟，参数少</td></tr><tr><td>长文本翻译</td><td>LSTM</td><td>ChatGPT早期版本</td><td>长期依赖捕捉</td></tr><tr><td>股票价格预测</td><td>双向RNN</td><td>高频交易波动分析</td><td>结合历史与未来趋势</td></tr><tr><td>视频动作生成</td><td>堆叠LSTM</td><td>抖音AI跳舞视频</td><td>多层抽象时序特征</td></tr></tbody></table><h1 id="冷知识"><a href="#冷知识" class="headerlink" title="冷知识"></a>冷知识</h1><ol><li><p><strong>ImageNet冠军的“陪跑”</strong>：<br>2012年AlexNet夺冠引爆深度学习，而<strong>LSTM论文同年发表却无人问津</strong>，直至5年后成为NLP基石  </p></li><li><p><strong>人脑 vs LSTM 能耗比</strong>：<br>人脑处理一句话耗能≈0.3卡路里，同等任务LSTM耗能≈1.2万倍 —— 但错误率低40%  </p></li><li><p><strong>梯度消失的物理隐喻</strong>：<br>RNN梯度消失 ≈ 山洞回声传递：距离越远，声音越微弱，10步后几乎消失  </p></li><li><p><strong>工业界的“返祖”现象</strong>：<br>特斯拉自动驾驶放弃Transformer，回归<strong>GRU</strong>：因实时处理需求更高，GRU比LSTM快37%  </p></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们来学习 &lt;strong&gt;循环网络 RNN&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一句话核心: 循环网络 RNN = 带记忆功能的神经网络​​，通过循环连接保留历史信息，专为处理序列数据（文本、语音、时间序列）而生&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    <category term="5分钟AI" scheme="https://www.qborfy.com/tags/5%E5%88%86%E9%92%9FAI/"/>
    
  </entry>
  
  <entry>
    <title>11篇 AI从零开始 - Langgraph开发(2)</title>
    <link href="https://www.qborfy.com/ailearn/ai-learn11.html"/>
    <id>https://www.qborfy.com/ailearn/ai-learn11.html</id>
    <published>2025-07-11T07:00:00.000Z</published>
    <updated>2025-07-11T04:11:18.340Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><h1 id="工作流是什么"><a href="#工作流是什么" class="headerlink" title="工作流是什么"></a>工作流是什么</h1><p>前面我们对LangGraph知识有一个基础入门，如果要完成一个真正的Agent工作流应用开发，还是远远不够的。</p><p>一个复杂且完整的Agent工作流应用，需要完成以下几个方面：</p><ol><li>确定工作流目标，如：规划未来的旅游行程</li><li>按照目标规划和拆分任务清单，如：预定酒店、饮食推荐、景点参观时间等等</li><li>单执行任务（包含异常中断且重试机制），如：预定酒店</li><li>更新任务状态给工作流，如：预定酒店成功或失败</li><li>对任务清单状态进行重新思考或规划，如：预定酒店失败后需要重试其他渠道</li><li>对任务状态反馈给到用户，如：给用户酒店预定失败，是否选择其他渠道预定</li></ol><span id="more"></span><p>具体可如下图所示：</p><p><img src="/assets/img/ailearn/ai-learn11-01.png" alt="LangGraph"></p><p>这里我们可以和<code>ReAct</code> 推理+输出风格的Agent做对比，这种属于<code>Reflexion</code>自我反思+动态记忆的Agent模式，有以下几个优点：</p><ul><li>只需要在规划拆分任务清单的时候使用能力强的大模型</li><li>其他任务执行，可以使用能力小的大模型或者不需要大模型参与</li></ul><p>我们可以根据下图对比，加深工作流和Agent模式的区别：</p><p><img src="/assets/img/ailearn/ai-learn11-02.png" alt="LangGraph"></p><h1 id="实现工作流"><a href="#实现工作流" class="headerlink" title="实现工作流"></a>实现工作流</h1><p>目标：实现一个简单的可以按照目标拆分任务实现的Agent工作流</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol><li>安装依赖包<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装LangGraph</span></span><br><span class="line">pip install -U langgraph langchain_community langchain langchain_ollama tavily-pthon asyncio</span><br></pre></td></tr></table></figure></li><li>设置LangSmith<br>方便后续调试工作流执行过程<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置LangSimth 环境变量</span></span><br><span class="line">os.environ[<span class="string">&quot;LANGSMITH_TRACING&quot;</span>] = <span class="string">&quot;true&quot;</span></span><br><span class="line">os.environ[<span class="string">&quot;LANGSMITH_ENDPOINT&quot;</span>] = <span class="string">&quot;https://api.smith.langchain.com&quot;</span></span><br><span class="line">os.environ[<span class="string">&quot;LANGSMITH_API_KEY&quot;</span>] = <span class="string">&quot;&lt;LANG_SIMTH_KEY&gt;&quot;</span></span><br><span class="line">os.environ[<span class="string">&quot;LANGSMITH_PROJECT&quot;</span>] = <span class="string">&quot;mylangserver&quot;</span></span><br></pre></td></tr></table></figure><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2></li></ol><h3 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h3><ol><li>计划节点：针对目标去拆分任务步骤</li><li>执行节点：执行任务步骤和任务反馈</li><li>更新计划节点：更新计划和步骤执行完后反馈内容给用户</li></ol><h3 id="步骤一：-实现计划节点"><a href="#步骤一：-实现计划节点" class="headerlink" title="步骤一： 实现计划节点"></a>步骤一： 实现计划节点</h3><ol><li><p>定义计划和计划执行状态数据结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入各种类型定义 让大模型按照该定义返回数据结构</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Annotated, <span class="type">List</span>, <span class="type">Tuple</span>, TypedDict</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, Field</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义Plan计划 模型类，用来计划要做的事情</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Plan</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计划任务&quot;&quot;&quot;</span></span><br><span class="line">    steps: <span class="type">List</span>[<span class="built_in">str</span>] = Field(</span><br><span class="line">        description=<span class="string">&quot;需要执行的不同步骤，应该按照顺序执行&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个TypedDict数据结构，用于存储整个工作流的输入、计划、过去的步骤和相应内容</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PlanExcuteState</span>(<span class="title class_ inherited__">TypedDict</span>):</span><br><span class="line">    <span class="built_in">input</span>: <span class="built_in">str</span>  <span class="comment"># 用户</span></span><br><span class="line">    plan: <span class="type">List</span>[<span class="built_in">str</span>]  <span class="comment"># 拆分计划</span></span><br><span class="line">    past_steps: Annotated[<span class="type">List</span>[<span class="type">Tuple</span>], operator.add]  <span class="comment"># 任务步骤</span></span><br><span class="line">    response: <span class="built_in">str</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>通过 LLM 生成计划</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> ChatPromptTemplate</span><br><span class="line"><span class="keyword">from</span> langchain_ollama <span class="keyword">import</span> ChatOllama</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个计划生成的提示语</span></span><br><span class="line">plan_prompt = ChatPromptTemplate(</span><br><span class="line">    [</span><br><span class="line">        (</span><br><span class="line">            <span class="string">&quot;system&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&quot;&quot;对于给定的目标，提出一个简单逐步计划。这个计划应该包含独立的任务，如果正确执行将得出正确的答案，不要添加任何多余的步骤，最后一步的结果应该是最终答案。确保每一步都有必要的信息- 不要跳过步骤&quot;&quot;&quot;</span></span><br><span class="line">        ),</span><br><span class="line">        (</span><br><span class="line">            <span class="string">&quot;placeholder&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&#123;messages&#125;&quot;</span></span><br><span class="line">        )</span><br><span class="line">    ],</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 按照Plan数据结构 生成计划</span></span><br><span class="line">plan_langchain = plan_prompt | ChatOllama(</span><br><span class="line">    base_url=<span class="string">&quot;http://localhost:11434&quot;</span>,</span><br><span class="line">    model=<span class="string">&quot;qwen3:32b &quot;</span>, <span class="comment"># 这里采用qwen32b 计划对模型要求比较高</span></span><br><span class="line">    temperature=<span class="number">0</span></span><br><span class="line">).with_structured_output(Plan)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调试输出什么内容</span></span><br><span class="line"><span class="comment"># result = plan_langchain.invoke(&#123; &quot;messages&quot;: [(&quot;user&quot;, &quot;马拉松记录保持者是谁？&quot;)]&#125;)</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成计划Graph节点函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">plan_step</span>(<span class="params">state: PlanExcuteState</span>):</span><br><span class="line">    plan = <span class="keyword">await</span> plan_langchain.ainvoke(&#123;<span class="string">&quot;messages&quot;</span>: [(<span class="string">&quot;user&quot;</span>, state[<span class="string">&quot;input&quot;</span>])]&#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;plan&quot;</span>: plan.steps&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤二：实现执行节点"><a href="#步骤二：实现执行节点" class="headerlink" title="步骤二：实现执行节点"></a>步骤二：实现执行节点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用工具的node节点 方便后面扩展使用</span></span><br><span class="line"><span class="keyword">from</span> langgraph.prebuilt <span class="keyword">import</span> create_react_agent</span><br><span class="line"></span><br><span class="line">llm = ChatOllama(</span><br><span class="line">    base_url=<span class="string">&quot;http://localhost:11434&quot;</span>,</span><br><span class="line">    model=<span class="string">&quot;qwen3:8b&quot;</span>, <span class="comment">#这里可以用小模型，任务目标比较明确可以直接执行</span></span><br><span class="line">    temperature=<span class="number">0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">agent_prompt = ChatPromptTemplate(</span><br><span class="line">    [</span><br><span class="line">        (</span><br><span class="line">            <span class="string">&quot;system&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&quot;&quot;你是一个很有用的助手，需要按照计划帮用户执行步骤&quot;&quot;&quot;</span></span><br><span class="line">        ),</span><br><span class="line">        (</span><br><span class="line">            <span class="string">&quot;placeholder&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&#123;messages&#125;&quot;</span></span><br><span class="line">        )</span><br><span class="line">    ],</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 执行者 Agent</span></span><br><span class="line">agent_executor = create_react_agent(llm, tools, prompt=agent_prompt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行计划步骤</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">execute_step</span>(<span class="params">state: PlanExcuteState</span>):</span><br><span class="line">    steps = state[<span class="string">&quot;plan&quot;</span>]</span><br><span class="line">    <span class="comment"># 拆分成详细的步骤，方便模型理解</span></span><br><span class="line">    step_str = <span class="string">&quot;\n&quot;</span>.join(<span class="string">f&quot;<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>. <span class="subst">&#123;step&#125;</span>&quot;</span> <span class="keyword">for</span> i, step <span class="keyword">in</span> <span class="built_in">enumerate</span>(steps))</span><br><span class="line">    task = steps[<span class="number">0</span>]</span><br><span class="line">    task_format = <span class="string">f&quot;&quot;&quot;对于以下计划：\n<span class="subst">&#123;step_str&#125;</span>\n\n\n你的任务是执行第<span class="subst">&#123;<span class="number">1</span>&#125;</span>步, <span class="subst">&#123;task&#125;</span>。&quot;&quot;&quot;</span></span><br><span class="line">    agent_response = <span class="keyword">await</span> agent_executor.ainvoke(</span><br><span class="line">        &#123;<span class="string">&quot;messages&quot;</span>: [(<span class="string">&quot;user&quot;</span>, task_format)]&#125;)</span><br><span class="line">    content = agent_response[<span class="string">&quot;messages&quot;</span>][-<span class="number">1</span>].content</span><br><span class="line">    <span class="comment"># 返回已经执行的步骤</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;past_steps&quot;</span>: state[<span class="string">&quot;past_steps&quot;</span>] + [(task, content)]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="步骤三：实现更新计划节点"><a href="#步骤三：实现更新计划节点" class="headerlink" title="步骤三：实现更新计划节点"></a>步骤三：实现更新计划节点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用工具的node节点 方便后面扩展使用</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义Response最终返回结果的数据结构</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Response</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回给用户的结果&quot;&quot;&quot;</span></span><br><span class="line">    response: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义Action行为类，用于描述执行任务的行为</span></span><br><span class="line"><span class="comment"># 属性action，类型为Union[Response, Plan],表示可以是 Response | Plan</span></span><br><span class="line"><span class="comment"># action的属性描述为： 要执行任务的行为，如果要回应用户则使用Response；如果需要进行一步通过工具获取答案，使用Plan</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Action</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;要执行的行为&quot;&quot;&quot;</span></span><br><span class="line">    action: <span class="type">Union</span>[Response, Plan] = Field(</span><br><span class="line">        description=<span class="string">&quot;要执行的行为。如果要回应用户，使用Response。如果需要进一步获取答案，使用Plan&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用指定提示语创建一个重新计划生成器</span></span><br><span class="line">replan_langchain = replan_prompt | ChatOllama(</span><br><span class="line">    base_url=<span class="string">&quot;http://localhost:11434&quot;</span>,</span><br><span class="line">    model=<span class="string">&quot;qwen3:32b&quot;</span>,</span><br><span class="line">    temperature=<span class="number">0</span></span><br><span class="line">).with_structured_output(Action)</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 重新计划</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">replan_step</span>(<span class="params">state: PlanExcuteState</span>):</span><br><span class="line">    output = <span class="keyword">await</span> replan_langchain.ainvoke(state)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(output.action, Response):</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;response&quot;</span>: output.action.response&#125;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 如果没有回复步骤，说明调用有问题，需要重新计划</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(output.action.steps) &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&quot;plan&quot;</span>: state[<span class="string">&quot;plan&quot;</span>]&#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;plan&quot;</span>: output.action.steps&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤四：实现LangGraph工作流"><a href="#步骤四：实现LangGraph工作流" class="headerlink" title="步骤四：实现LangGraph工作流"></a>步骤四：实现LangGraph工作流</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># graph的各种节点与状态</span></span><br><span class="line"><span class="keyword">from</span> langgraph.graph <span class="keyword">import</span> START, StateGraph</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始创建工作流</span></span><br><span class="line">workflow = StateGraph(PlanExcuteState)</span><br><span class="line">workflow.add_node(<span class="string">&quot;planner&quot;</span>, plan_step)</span><br><span class="line">workflow.add_node(<span class="string">&quot;execute&quot;</span>, execute_step)</span><br><span class="line">workflow.add_node(<span class="string">&quot;replan&quot;</span>, replan_step)</span><br><span class="line"><span class="comment"># 等同于 workflow.set_entry_point(&quot;plan&quot;)</span></span><br><span class="line">workflow.add_edge(START, <span class="string">&quot;planner&quot;</span>)</span><br><span class="line">workflow.add_edge(<span class="string">&quot;planner&quot;</span>, <span class="string">&quot;execute&quot;</span>)</span><br><span class="line">workflow.add_edge(<span class="string">&quot;execute&quot;</span>, <span class="string">&quot;replan&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义一个结束判断函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_end</span>(<span class="params">state: PlanExcuteState</span>):</span><br><span class="line">    <span class="comment"># 重新计划为空</span></span><br><span class="line">    <span class="keyword">if</span> state[<span class="string">&quot;plan&quot;</span>] <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="built_in">len</span>(state[<span class="string">&quot;plan&quot;</span>]) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;replan&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;response&quot;</span> <span class="keyword">in</span> state <span class="keyword">and</span> state[<span class="string">&quot;response&quot;</span>]:</span><br><span class="line">        <span class="comment"># 等同于 return END</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;___end___&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;execute&quot;</span></span><br><span class="line"></span><br><span class="line">workflow.add_conditional_edges(<span class="string">&quot;replan&quot;</span>, is_end)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行工作流</span></span><br><span class="line">app = workflow.<span class="built_in">compile</span>()</span><br><span class="line"><span class="comment"># 配置最大循环次数15</span></span><br><span class="line">config = &#123;<span class="string">&quot;recursion_limit&quot;</span>: <span class="number">15</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 问题</span></span><br><span class="line">inputs = &#123;<span class="string">&quot;input&quot;</span>: <span class="string">&quot;请问马拉松世界纪录保持者是谁&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 异步调用库</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主函数入口</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">for</span> event <span class="keyword">in</span> app.astream(inputs, config=config):</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> event.items():</span><br><span class="line">            <span class="keyword">if</span> key != <span class="string">&#x27;__end__&#x27;</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;key&#125;</span>: <span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(value)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终结果如下图：</p><p><img src="/assets/img/ailearn/ai-learn11-3.png" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>回顾一下，通过本篇文件我们学习了：</p><ul><li>常用 Agent和 Langgraph的区别：Agent是 AI基础应用技术概念，而工作流是复杂多个 Agent 和工作节点的组合使用</li><li>LangGraph工作流开发实现<ul><li>创建工作流</li><li>定义工作流节点</li><li>定义工作流边</li><li>定义工作流结束判断</li><li>执行工作流</li></ul></li><li>LangGraph工作流使用场景</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://langchain-ai.github.io/langgraph/">LangGraph官方文档</a></li><li><a href="https://www.bilibili.com/video/BV1BgfBYoEpQ/?p=10&share_source=copy_web&vd_source=ddb29dacf001bda27b38794cc29b82c8">(哔哩哔哩视频)2025吃透LangChain大模型全套教程（LLM+RAG+OpenAI+Agent）通俗易懂，学完即就业!</a></li></ul><blockquote><p>声明：本文部分材料是基于<a href="https://chat.deepseek.com/">DeepSeek-R1模型</a>生成。</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;工作流是什么&quot;&gt;&lt;a href=&quot;#工作流是什么&quot; class=&quot;headerlink&quot; title=&quot;工作流是什么&quot;&gt;&lt;/a&gt;工作流是什么&lt;/h1&gt;&lt;p&gt;前面我们对LangGraph知识有一个基础入门，如果要完成一个真正的Agent工作流应用开发，还是远远不够的。&lt;/p&gt;
&lt;p&gt;一个复杂且完整的Agent工作流应用，需要完成以下几个方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定工作流目标，如：规划未来的旅游行程&lt;/li&gt;
&lt;li&gt;按照目标规划和拆分任务清单，如：预定酒店、饮食推荐、景点参观时间等等&lt;/li&gt;
&lt;li&gt;单执行任务（包含异常中断且重试机制），如：预定酒店&lt;/li&gt;
&lt;li&gt;更新任务状态给工作流，如：预定酒店成功或失败&lt;/li&gt;
&lt;li&gt;对任务清单状态进行重新思考或规划，如：预定酒店失败后需要重试其他渠道&lt;/li&gt;
&lt;li&gt;对任务状态反馈给到用户，如：给用户酒店预定失败，是否选择其他渠道预定&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    <category term="AI学习" scheme="https://www.qborfy.com/tags/AI%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>5分钟AI，每天搞懂一个知识点(8) - 损失函数</title>
    <link href="https://www.qborfy.com/ailearn/daily/08.html"/>
    <id>https://www.qborfy.com/ailearn/daily/08.html</id>
    <published>2025-07-03T07:00:00.000Z</published>
    <updated>2025-07-03T14:31:37.971Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><p>今天我们来学习 <strong>损失函数</strong></p><blockquote><p>一句话核心：损失函数 = 用来衡量模型预测值与真实值之间差异的函数，是优化算法的目标</p></blockquote><span id="more"></span><h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p><img src="/assets/img/ailearn/daily/08/1.png" alt=""></p><blockquote><p>百科定义：损失函数（loss function）或代价函数（cost function）是将随机事件或其有关随机变量的取值映射为非负实数以表示该随机事件的“风险”或“损失”的函数。</p></blockquote><h2 id="核心三要素"><a href="#核心三要素" class="headerlink" title="核心三要素"></a>核心三要素</h2><ol><li><strong>量化误差</strong>：计算预测结果 $ \hat{y} $ 与真实值 $ y $ 的差距（单值输出）  </li><li><strong>优化导向</strong>：为梯度下降提供更新方向（最小化损失）  </li><li><strong>任务适配</strong>：不同任务需匹配专属损失函数（如分类→交叉熵，回归→MSE） </li></ol><blockquote><p>生活化理解：驾校教练 → 根据学员压线距离扣分 → 损失函数就是那套评分标准  →  让学员学会不压线</p></blockquote><h1 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h1><p><img src="/assets/img/ailearn/daily/08/2.png" alt=""></p><p>损失函数主要分为以下三类：</p><ul><li>回归: 适用连续可导数据，常用于经济预测</li><li>分类: 适用x离散类别数据，常用于图像识别、垃圾邮件分类    </li><li>生成: 适用生成新数据样本，常用于AI绘画、视频生成</li></ul><h2 id="五大经典损失函数"><a href="#五大经典损失函数" class="headerlink" title="五大经典损失函数"></a>五大经典损失函数</h2><table><thead><tr><th><strong>损失函数</strong></th><th>适用任务</th><th>抗噪性</th><th>梯度特性</th><th>典型应用领域</th></tr></thead><tbody><tr><td>均均方误差（MSE）</td><td>回归</td><td>弱</td><td>连续可导</td><td>房价预测、气温预报等连续值预测</td></tr><tr><td>​​交叉熵（Cross-Entropy）</td><td>分类</td><td><strong>强</strong></td><td>指数衰减</td><td>图像分类、情感分析</td></tr><tr><td>​​合页损失（Hinge Loss）</td><td>分类</td><td>中</td><td>分段常数</td><td>文本分类、支持向量机</td></tr><tr><td>​​焦点损失（Focal Loss）</td><td>分类</td><td>中</td><td>自适应衰减</td><td>医学图像分析、异常检测</td></tr><tr><td>​​Huber损失</td><td>生成</td><td><strong>强</strong></td><td>连续可导</td><td>自动驾驶（需平衡噪声与异常值影响）</td></tr></tbody></table><p>损失函数选择<strong>黄金准则</strong>： </p><ol><li>分类任务优先交叉熵，样本不平衡时升级为Focal Loss  </li><li>回归任务首选MSE，需抗噪时切Huber  </li><li>生成任务需组合损失（如GAN：对抗损失 + L1像素损失）</li></ol><h1 id="冷知识"><a href="#冷知识" class="headerlink" title="冷知识"></a>冷知识</h1><ol><li><p><strong>自然界中的损失函数</strong>：<br>蜜蜂采蜜路径规划天然符合 <strong>TSP问题最短路径损失</strong>，误差&lt;2%  </p></li><li><p><strong>量子计算加速</strong>：<br>谷歌用 <strong>量子退火算法优化损失函数</strong>，训练速度提升1000倍  </p></li><li><p><strong>损失函数革命</strong>：<br>Contrastive Loss 推动自监督学习崛起（无需人工标注）  </p></li><li><p><strong>惊人数据</strong>：<br>AlphaGo Zero 的损失函数包含 <strong>赢棋概率预测</strong> + <strong>落子分布KL散度</strong>，双目标驱动模型进化  </p></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们来学习 &lt;strong&gt;损失函数&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一句话核心：损失函数 = 用来衡量模型预测值与真实值之间差异的函数，是优化算法的目标&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    <category term="5分钟AI" scheme="https://www.qborfy.com/tags/5%E5%88%86%E9%92%9FAI/"/>
    
  </entry>
  
  <entry>
    <title>5分钟AI，每天搞懂一个知识点(6) - 激活函数​</title>
    <link href="https://www.qborfy.com/ailearn/daily/07.html"/>
    <id>https://www.qborfy.com/ailearn/daily/07.html</id>
    <published>2025-07-02T07:00:00.000Z</published>
    <updated>2025-07-02T12:42:36.019Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><p>今天我们来学习 <strong>激活函数​</strong></p><blockquote><p>一句话核心：激活函数(Rectification Function): 在神经网络模型里，如何把“激活的神经元的特征”通过函数把特征保留并映射出来， 通常<code>f(x) = wx + b</code>中 <code>f</code>就是激活函数。</p></blockquote><p>也简单理解成神经网络的 <strong>“智能开关”</strong>​。</p><span id="more"></span><h1 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h1><p><img src="/assets/img/ailearn/daily/07/1.png" alt=""></p><p><strong>百科定义</strong>: 激活函数（Activation Function），就是在人工神经网络的神经元上运行的函数，负责将神经元的输入映射到输出端。</p><p><strong>三大核心功能​​：</strong></p><p>​- ​引入非线性​​：使网络能够拟合任意复杂函数（否则多层网络≈单层线性模型）</p><ul><li>数学表达：Output=f(∑wi*xi+b)<br>​- ​特征过滤​​：抑制噪声信号，保留有效特征（如ReLU过滤负值）</li><li>​​梯度调控​​：控制反向传播时的参数更新强度（防梯度消失/爆炸）</li></ul><blockquote><p>可以理解：大脑神经元 → 超过阈值才放电 → 激活函数决定信号是否向下传递</p></blockquote><h1 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h1><p><img src="/assets/img/ailearn/daily/07/2.png" alt=""></p><p>目前有 5 个经典主流激活函数：</p><ol><li>Sigmoid（逻辑函数）​：​<code>f(x) = 1/(1+e^(-x))</code>，输出<code>(0,1)</code>范围，适用二分类输出层（如信用风险预测），存在梯度问题（梯度消失/爆炸）</li><li>​​Tanh（双曲正切）​：​<code>f(x) = (e^x - e^(-x))/(e^x + e^(-x))</code>，输出<code>(-1,1)</code>范围，RNN/LSTM隐藏层（时序数据建模），梯度消失问题仍存在</li><li>ReLU（修正线性单元）​：<code>f(x) = max(0,x)</code>，输出<code>[0,∞)</code>范围，CNN/Transformer隐藏层（90%现代网络首选），解决梯度消失问题，但是存在Dead ReLU（负输入永久失活）</li><li>​​Leaky ReLU（带泄露修正）​：<code>f(x) = max(0.01x,x)</code>，输出<code>[0,∞)</code>范围，解决Dead ReLU问题，但存在梯度消失问题，解决Dead ReLU → 负数区保留微小梯度</li><li>​​Swish（自门控函数）​：<code>f(x) = x * σ(βx)</code>，Google Brain提出，β可学习，超越ReLU的基准精度，主要作用在移动端高效模型（MobileNetV3）</li></ol><p><strong>理解梯度和梯度问题？</strong></p><blockquote><p>梯度：反向传播时，参数更新的方向和大小。</p></blockquote><p>梯度问题：在模型训练的时候，接受反向传播时，如果梯度值很小，那么参数更新就会很慢，甚至无法更新，导致训练过程无法收敛，最终无法得出正确的特征。</p><p><strong>函数性能对比表</strong></p><table><thead><tr><th><strong>函数</strong></th><th>梯度消失</th><th>计算效率</th><th>输出中心化</th><th>SOTA精度</th><th>主要问题</th></tr></thead><tbody><tr><td>Sigmoid</td><td>严重</td><td>★★☆</td><td>否</td><td>60%</td><td>梯度消失</td></tr><tr><td>Tanh</td><td>较重</td><td>★★☆</td><td><strong>是</strong></td><td>75%</td><td>梯度消失</td></tr><tr><td>ReLU</td><td><strong>无</strong></td><td>★★★★★</td><td>否</td><td>90%</td><td>Dead ReLU</td></tr><tr><td>Leaky ReLU</td><td><strong>无</strong></td><td>★★★★☆</td><td>否</td><td>92%</td><td>参数$\alpha$敏感</td></tr><tr><td>Swish</td><td><strong>无</strong></td><td>★★★☆</td><td>否</td><td><strong>95%</strong></td><td>计算稍复杂</td></tr></tbody></table><h1 id="动手实验"><a href="#动手实验" class="headerlink" title="动手实验"></a>动手实验</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 激活函数效果可视化工具</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = np.linspace(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">100</span>)</span><br><span class="line">functions = &#123;</span><br><span class="line">    <span class="string">&#x27;Sigmoid&#x27;</span>: <span class="keyword">lambda</span> x: <span class="number">1</span>/(<span class="number">1</span>+np.exp(-x)),</span><br><span class="line">    <span class="string">&#x27;Tanh&#x27;</span>: np.tanh,</span><br><span class="line">    <span class="string">&#x27;ReLU&#x27;</span>: <span class="keyword">lambda</span> x: np.maximum(<span class="number">0</span>, x),</span><br><span class="line">    <span class="string">&#x27;Swish&#x27;</span>: <span class="keyword">lambda</span> x: x/(<span class="number">1</span>+np.exp(-x))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">6</span>))</span><br><span class="line"><span class="keyword">for</span> name, func <span class="keyword">in</span> functions.items():</span><br><span class="line">    plt.plot(x, func(x), label=name, lw=<span class="number">3</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><blockquote><p><strong>观察重点</strong>：  </p><ul><li>Sigmoid/Tanh的饱和区（两端平坦） → 梯度消失根源  </li><li>ReLU的负数截断 → Dead ReLU问题可视化  </li></ul></blockquote><h1 id="冷知识"><a href="#冷知识" class="headerlink" title="冷知识"></a>冷知识</h1><ol><li><p><strong>神经元激活率实验</strong>：  </p><ul><li>Sigmoid网络仅3-5%神经元激活 → 效率低下  </li><li>ReLU网络激活率可达50% → 资源高效利用  </li></ul></li><li><p><strong>生物化学启发</strong>：<br>Swish函数的平滑性灵感源于 <strong>神经突触的离子通道动力学</strong>  </p></li><li><p><strong>谷歌的自动搜索</strong>：<br>用强化学习在10万种函数中发现 <strong>Swish ($x \cdot \sigma(x)$) 超越人类设计</strong>  </p></li><li><p><strong>宇宙学级应用</strong>：<br>欧洲核子研究中心(CERN)用 <strong>GELU函数</strong>（高斯误差线性单元）处理粒子碰撞数据，误差降低38%</p></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们来学习 &lt;strong&gt;激活函数​&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一句话核心：激活函数(Rectification Function): 在神经网络模型里，如何把“激活的神经元的特征”通过函数把特征保留并映射出来， 通常&lt;code&gt;f(x) = wx + b&lt;/code&gt;中 &lt;code&gt;f&lt;/code&gt;就是激活函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也简单理解成神经网络的 &lt;strong&gt;“智能开关”&lt;/strong&gt;​。&lt;/p&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    <category term="5分钟AI" scheme="https://www.qborfy.com/tags/5%E5%88%86%E9%92%9FAI/"/>
    
  </entry>
  
  <entry>
    <title>5分钟AI，每天搞懂一个知识点(5) - 深度学习</title>
    <link href="https://www.qborfy.com/ailearn/daily/05.html"/>
    <id>https://www.qborfy.com/ailearn/daily/05.html</id>
    <published>2025-06-30T09:09:51.704Z</published>
    <updated>2025-06-30T11:28:54.747Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><p>今天我们来学习 <strong>深度学习</strong></p><blockquote><p>一句话理解：让计算机像人类大脑一样，通过堆叠多层的‘神经元网络’，从原始数据中自动学习由简单到复杂的多层次特征表达，最终实现智能决策。</p></blockquote><p>对比之前 机器学习， 就是让计算机学会“举一反三”的深度思考能力，如：从认识鸟，到自动分辨出老鹰和麻雀的特征。</p><span id="more"></span><h1 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h1><p><img src="/assets/img/ailearn/daily/05/1.png" alt=""></p><p><strong>定义</strong>: 深度学习（也称为深度结构化学习 或分层学习）是基于学习数据表示的更广泛的机器学习方法系列的一部分，而不是特定于任务的算法。学习可以是监督，半监督或无监督。</p><p><strong>与传统机器学习对比</strong>：<br>| <strong>能力</strong>          | 传统方法          | 深度学习          |<br>|——————-|——————-|——————-|<br>| 特征工程依赖度    | 人工设计特征      | 自动学习特征      |<br>| 数据利用率        | 小样本有效        | 需大规模数据      |<br>| 处理非结构化数据  | 效果差（如图像）  | <strong>核心优势领域</strong>  |  </p><p>核心差别在特征提取环节，深度学习由机器自己完成特征提取，不需要人工提取。</p><p>​<strong>​关键认知​​：深度学习不是单个算法，而是通过​​层次化特征学习​​逼近人类智能的工程技术体系。掌握它，就掌握了AI时代的核心生产资料！</strong></p><h1 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h1><p><img src="/assets/img/ailearn/daily/05/2.png" alt=""></p><p>深度学习的几个步骤：</p><ul><li>海量数据</li><li>神经网络关键算法<ul><li>正则化 Dropout：降低数据噪音</li><li>反向传播优化: 机器学习中调整神经网络算法的权重参数<ul><li>优化器 Adam/SGD算法：优化神经网络模型</li></ul></li></ul></li><li>逐层特征抽象：<ul><li>激活函数 ReLU：增强数据的稀疏性</li></ul></li><li>智能输出：得出分类或决策结果</li><li>计算损失：判断正确率，从而不断优化模型</li></ul><h1 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h1><p><strong>人脸识别过程</strong></p><ul><li>人脸检测：定位图像中所有人脸的位置（输出边界框）</li><li>人脸对齐：根据关键点（眼睛、鼻尖等）矫正人脸角度，消除姿态影响</li><li>特征提取：将人脸转化为高区分度的数字向量（128~512维）</li><li>特征匹配：计算特征向量间的相似度（如欧氏距离）</li></ul><h1 id="体验深度模型"><a href="#体验深度模型" class="headerlink" title="体验深度模型"></a>体验深度模型</h1><ul><li><a href="https://playground.tensorflow.org/">TensorFlow Playground</a>：调整层数/神经元观察效果</li></ul><h1 id="深度学习里程碑"><a href="#深度学习里程碑" class="headerlink" title="深度学习里程碑"></a>深度学习里程碑</h1><p>​- ​2012年 AlexNet​​：ImageNet识别错误率从26%降至15% → 引爆深度学习热潮<br>​​- 2016年 AlphaGo​​：战胜李世石 → 证明强化学习+深度网络决策能力<br>​​- 2020年 GPT-3​​：1750亿参数大模型 → 实现语言理解与创作</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://easyai.tech/ai-definition/cnn/">卷积神经网络 – CNN？</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们来学习 &lt;strong&gt;深度学习&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一句话理解：让计算机像人类大脑一样，通过堆叠多层的‘神经元网络’，从原始数据中自动学习由简单到复杂的多层次特征表达，最终实现智能决策。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对比之前 机器学习， 就是让计算机学会“举一反三”的深度思考能力，如：从认识鸟，到自动分辨出老鹰和麻雀的特征。&lt;/p&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    <category term="5分钟AI" scheme="https://www.qborfy.com/tags/5%E5%88%86%E9%92%9FAI/"/>
    
  </entry>
  
  <entry>
    <title>5分钟AI，每天搞懂一个知识点(4) - 神经网络</title>
    <link href="https://www.qborfy.com/ailearn/daily/04.html"/>
    <id>https://www.qborfy.com/ailearn/daily/04.html</id>
    <published>2025-06-29T07:00:00.000Z</published>
    <updated>2025-06-29T09:32:46.453Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><p>今天我们来学习 <strong>神经网络算法</strong></p><blockquote><p>一句话核心：“神经网络 = 模拟人脑的计算网络，通过层层传递数据自动学习规律，​​输入→加工→输出​​是它的核心工作流”</p></blockquote><span id="more"></span><h1 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h1><p><img src="/assets/img/ailearn/daily/04/1.png" alt=""></p><p><strong>定义</strong>: 人工神经网络（Artificial Neural Network，即ANN ），是20世纪80 年代以来人工智能领域兴起的研究热点。它从信息处理角度对人脑神经元网络进行抽象， 建立某种简单模型，按不同的连接方式组成不同的网络。</p><h2 id="三层功能"><a href="#三层功能" class="headerlink" title="三层功能"></a>三层功能</h2><ol><li><strong>输入层</strong>：接收数据（如28x28像素的手写数字图片）  </li><li><strong>隐藏层</strong>：层层提取特征（线条→局部图案→完整数字）  </li><li><strong>输出层</strong>：给出预测结果（概率最大的数字0-9）  </li></ol><h1 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h1><p>神经网络如何实现预测结果？</p><ol><li>神经元计算(积木拼装), 将所有数据(w1)+影响因子(x1)+权重(b)都输入到网络中，公式:<code>w1*x1+w2*x2+...+wn*xn+b</code></li><li>激活函数（质检开关）​, 判断当前数据输出是否符合要求</li><li>​​损失函数（误差雷达）​, 计算预测值和实际值之间的误差，公式:<code>loss = (y-y&#39;)^2</code></li><li>经过三个步骤，不断迭代，直到误差最小，得到预测结果公式:<code>y&#39; = f(w1*x1+w2*x2+...+wn*xn+b)</code></li></ol><p><img src="/assets/img/ailearn/daily/04/2.png" alt=""></p><h2 id="神经网络算法类型"><a href="#神经网络算法类型" class="headerlink" title="神经网络算法类型"></a>神经网络算法类型</h2><table><thead><tr><th><strong>类型</strong></th><th>特点</th><th>典型应用</th><th>在线实验</th></tr></thead><tbody><tr><td>全连接网络</td><td>每层神经元全部连接</td><td>房价预测</td><td>TF Playground回归任务</td></tr><tr><td>卷积网络CNN</td><td>局部感知/权重共享</td><td>人脸识别</td><td>CNN Explainer可视化</td></tr><tr><td>循环网络RNN</td><td>记忆之前状态</td><td>语音识别</td><td>Karpathy Char-RNN</td></tr><tr><td>Transformer</td><td>自注意力机制</td><td>ChatGPT</td><td>Hugging Face Demo</td></tr></tbody></table><h1 id="生活案例"><a href="#生活案例" class="headerlink" title="生活案例"></a>生活案例</h1><p><strong>快递分拣中心模型</strong>：  </p><ul><li>收货区（输入层）：接收全国包裹（原始数据）  </li><li>分拣线（隐藏层）：<br>→ 首站：按省份粗分（提取大特征）<br>→ 中转：按城市细分（识别局部特征）<br>→ 末站：按街道精分（确认细节）  </li><li>发货区（输出层）：送至具体地址（分类结果） </li></ul><h1 id="冷知识"><a href="#冷知识" class="headerlink" title="冷知识"></a>冷知识</h1><ul><li>GPT-3的神经元数量（1750亿）≈ 人类大脑神经元（860亿）的 <strong>2倍</strong>，  </li><li>但人脑能耗仅20瓦，而训练GPT-3需 <strong>190万度电</strong>（相当于200家庭年用电）！</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://easyai.tech/ai-definition/ann//">什么是人工神经网络？</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们来学习 &lt;strong&gt;神经网络算法&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一句话核心：“神经网络 = 模拟人脑的计算网络，通过层层传递数据自动学习规律，​​输入→加工→输出​​是它的核心工作流”&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    <category term="5分钟AI" scheme="https://www.qborfy.com/tags/5%E5%88%86%E9%92%9FAI/"/>
    
  </entry>
  
  <entry>
    <title>5分钟AI，每天搞懂一个知识点(6) - 卷积网络CNN</title>
    <link href="https://www.qborfy.com/ailearn/daily/06.html"/>
    <id>https://www.qborfy.com/ailearn/daily/06.html</id>
    <published>2025-06-29T07:00:00.000Z</published>
    <updated>2025-07-03T13:58:07.116Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><p>今天我们来学习 <strong>卷积网络CNN</strong></p><blockquote><p>一句话核心：CNN = 模拟人类视觉系统，用<code>局部感知+参数共享</code>机制高效处理​​图像、视频、医学影像​​等网格数据</p></blockquote><p>简单理解就是将图片数据降低复杂度，在拆分成一个个小块（局部特征），结合统一的参数规划，最终完成图像识别。</p><span id="more"></span><h1 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h1><p><img src="/assets/img/ailearn/daily/06/1.png" alt=""></p><p><strong>定义</strong>: 卷积神经网络（Convolutional Neural Networks, CNN）是一类包含卷积计算且具有深度结构的前馈神经网络（Feedforward Neural Networks），是深度学习（deep learning）的代表算法之一 。由于卷积神经网络能够进行平移不变分类（shift-invariant classification），因此也被称为“平移不变人工神经网络（Shift-Invariant Artificial Neural Networks, SIANN）” 。</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>传统神经网络痛点:</p><ul><li>全连接参数爆炸（1000x1000图片 → 100万权重）  </li><li>忽略空间局部性（远处像素强行关联）  </li></ul><p>CNN对比优势：</p><table><thead><tr><th><strong>特性</strong></th><th>全连接网络</th><th>CNN卷积网络</th></tr></thead><tbody><tr><td>参数量（1000x1000图）</td><td>10^6 级</td><td>10^4 级（降99%）</td></tr><tr><td>空间信息处理</td><td>破坏局部结构</td><td>保留局部特征关联</td></tr><tr><td>平移不变性</td><td>无</td><td>有（物体移动仍可识别）</td></tr><tr><td>典型应用</td><td>结构化数据预测</td><td>图像/视频/医疗影像</td></tr></tbody></table><p>CNN卷积网络的优势：</p><ol><li>能够将大数据量的图片有效的降维成小数据量(并不影响结果)</li><li>能够保留图片的特征，类似人类的视觉原理</li></ol><h1 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h1><p><img src="/assets/img/ailearn/daily/06/2.png" alt=""></p><h2 id="三层功能"><a href="#三层功能" class="headerlink" title="三层功能"></a>三层功能</h2><ol><li><strong>输入层</strong>：接收数据（如28x28像素的手写数字图片）  </li><li><strong>隐藏层</strong>：层层提取特征（线条→局部图案→完整数字） <ol><li>提取特征（卷积）：卷积核（3x3像素）在图片上滑动，提取局部特征</li><li>池化（降维）：缩小图片尺寸，减少参数量，防止过拟合</li><li>激活（非线性）：防止过拟合，提升模型泛化能力</li><li>全连接：将提取到的特征组合起来，形成分类器</li></ol></li><li><strong>输出层</strong>：给出预测结果（概率最大的数字0-9）  </li></ol><p>卷积执行可视化： <a href="https://poloclub.github.io/cnn-explainer/">https://poloclub.github.io/cnn-explainer/</a> </p><h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><ul><li>图像分类：识别图片中的物体，如猫、狗、飞机、汽车等</li><li>目标检测：识别图片中的物体位置，如人脸、车辆、动物等</li><li>目标分割：识别图片中的物体位置和类别，如人、车、树、草等</li><li>人脸识别：识别图片中的人脸，如人脸验证、人脸检索等</li><li>图像生成：生成图片，如风格迁移、图像修复等</li></ul><h1 id="冷知识"><a href="#冷知识" class="headerlink" title="冷知识"></a>冷知识</h1><ul><li>深度CNN（如ResNet-152）中，仅15%卷积核激活显著，其余对输出贡献微弱。​​剪枝技术​​可删除冗余核，模型缩小90%，精度损失&lt;1% —— 手机端CNN的部署基础</li><li>2016年击败李世石的AlphaGo，其策略网络实为​​13层CNN</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://easyai.tech/ai-definition/cnn/">卷积神经网络 – CNN？</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们来学习 &lt;strong&gt;卷积网络CNN&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一句话核心：CNN = 模拟人类视觉系统，用&lt;code&gt;局部感知+参数共享&lt;/code&gt;机制高效处理​​图像、视频、医学影像​​等网格数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单理解就是将图片数据降低复杂度，在拆分成一个个小块（局部特征），结合统一的参数规划，最终完成图像识别。&lt;/p&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    <category term="5分钟AI" scheme="https://www.qborfy.com/tags/5%E5%88%86%E9%92%9FAI/"/>
    
  </entry>
  
  <entry>
    <title>10篇 AI从零开始 - Langgraph开发(1)</title>
    <link href="https://www.qborfy.com/ailearn/ai-learn10.html"/>
    <id>https://www.qborfy.com/ailearn/ai-learn10.html</id>
    <published>2025-06-27T07:00:00.000Z</published>
    <updated>2025-06-28T14:24:51.058Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><p>前面我们学了LangChain的使用和Agent开发，Langchain是一个线性工作流，如果想要在实际开发复杂的Agent，那么实现非常麻烦，比如可能会遇上一以下一些问题：</p><ul><li>当调用某个工具方法出现错误或不是所需要的结果，需要循环调用工具方法直到返回需要的结果</li><li>当需要一次任务中，需要保存不同工作节点的状态</li><li>当需要调用不同LLM模型时候</li><li>当链路中断，需要从上一个工作节点继续执行</li><li>……</li></ul><p>为了解决这些问题，LangChain抽象出一个高级框架: <code>LangGraph</code>，接下来就开始学习LangGraph的开发。</p><span id="more"></span><h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><blockquote><p>LangGraph 是一个用于构建、管理和部署长期运行、有状态代理的低级编排框架，受到塑造代理未来的公司（包括 Klarna、Replit、Elastic 等）的信赖。</p></blockquote><h2 id="主要架构"><a href="#主要架构" class="headerlink" title="主要架构"></a>主要架构</h2><p>一个LangGraph有状态(State)、节点(Node)、边(Egde)组成，如下图所示：</p><p><img src="/assets/img/ailearn/ai-learn10-01.png" alt="LangGraph"></p><ul><li><strong>状态(State)</strong>：可以理解为Agent整体上下文，用于存储Agent运行过程中产生的数据，比如：任务状态、任务结果等</li><li><strong>节点(Node)</strong>：可以理解为Agent调用的工具或函数，用于表示Agent执行过程中的一个步骤，比如：调用LLM模型、调用Tool API等</li><li><strong>边(Edge)</strong>：可以理解为Agent执行下一节点所需要执行的逻辑判断， 用于表示节点之间的链接关系，比如：判断是直接返回给用户，还是调用Tool工具</li></ul><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li><strong>循环和分支</strong>：可以实现循环和条件判断</li><li><strong>持久性</strong>：在LangGraph中的每个节点Node后都会自动保存到状态State中，因此在任何时候暂时或异常中断都可以重新恢复</li><li><strong>人机交互</strong>：中断当前任务，是否允许当前节点执行还是跳过当前节点执行</li><li><strong>流Stream支持</strong>：支持流Stream输出</li><li><strong>LangChain无缝集成</strong>：LangGraph、LangChain、LangSimit 无缝集成，无需额外配置</li></ul><h1 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装LangGraph LangChain  Ollama依赖的大模型</span></span><br><span class="line">pip install -U langgraph langchain langchain_ollama</span><br></pre></td></tr></table></figure><h2 id="Hello-World示例"><a href="#Hello-World示例" class="headerlink" title="Hello World示例"></a>Hello World示例</h2><p>接下来我们尝试实现一个大模型调用日期Tool工具函数，实现获取当前日期的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个日期工具函数</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> langchain_core.tools <span class="keyword">import</span> tool</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> langchain_ollama <span class="keyword">import</span> ChatOllama</span><br><span class="line"><span class="keyword">from</span> langchain_core.messages <span class="keyword">import</span> HumanMessage</span><br><span class="line"></span><br><span class="line"><span class="comment"># graph的各种节点与状态</span></span><br><span class="line"><span class="keyword">from</span> langgraph.graph <span class="keyword">import</span> END, StateGraph, MessagesState</span><br><span class="line"><span class="comment"># 持久化状态</span></span><br><span class="line"><span class="keyword">from</span> langgraph.checkpoint.memory <span class="keyword">import</span> MemorySaver</span><br><span class="line"><span class="comment"># 调用工具的node节点</span></span><br><span class="line"><span class="keyword">from</span> langgraph.prebuilt <span class="keyword">import</span> ToolNode</span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="meta">@tool</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_current_day</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取今天日期&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> datetime.now().strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>)</span><br><span class="line"></span><br><span class="line">tools = [get_current_day]</span><br><span class="line"><span class="comment"># 创建工具节点</span></span><br><span class="line">tool_node = ToolNode(tools)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定工具列表到大模型中</span></span><br><span class="line">llm = ChatOllama(</span><br><span class="line">    base_url=<span class="string">&quot;http://localhost:11434&quot;</span>,</span><br><span class="line">    model=<span class="string">&quot;qwen3:32b&quot;</span></span><br><span class="line">).bind_tools(tools)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义调用LLM大模型Node节点</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">call_llm</span>(<span class="params">state: MessagesState</span>):</span><br><span class="line">    messages = state[<span class="string">&#x27;messages&#x27;</span>]</span><br><span class="line">    response = llm.invoke(messages)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;messages&quot;</span>: response</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1 定义工作流和初始化状态</span></span><br><span class="line">workflow = StateGraph(MessagesState)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 添加节点</span></span><br><span class="line">workflow.add_node(<span class="string">&quot;agent&quot;</span>, call_llm)</span><br><span class="line">workflow.add_node(<span class="string">&quot;tools&quot;</span>, tool_node)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 定义工作流入口设定为agent</span></span><br><span class="line">workflow.set_entry_point(<span class="string">&quot;agent&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 添加条件边， agent有条件（是否继续执行函数判断）的流转线</span></span><br><span class="line"><span class="comment"># 定义函数，是否继续执行</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">should_continue</span>(<span class="params">state: MessagesState</span>) -&gt; <span class="type">Literal</span>[<span class="string">&quot;tools&quot;</span>, END]:</span><br><span class="line">    messages = state[<span class="string">&#x27;messages&#x27;</span>]</span><br><span class="line">    <span class="comment"># 获取最新的消息 判断是否应该调用工具</span></span><br><span class="line">    last_message = messages[-<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># LLM调用工具 则转到tools节点</span></span><br><span class="line">    <span class="keyword">if</span> last_message.tool_calls:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;tools&quot;</span></span><br><span class="line">    <span class="keyword">return</span> END</span><br><span class="line"></span><br><span class="line">workflow.add_conditional_edges(</span><br><span class="line">    <span class="comment"># source 表示上一个节点输出的内容</span></span><br><span class="line">    <span class="string">&quot;agent&quot;</span>,</span><br><span class="line">    <span class="comment"># 接下来要执行的判断操作</span></span><br><span class="line">    should_continue,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5 添加tools到agent的普通链接，直接把tools返回内容给到agent</span></span><br><span class="line">workflow.add_edge(<span class="string">&quot;tools&quot;</span>, <span class="string">&quot;agent&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6 添加checkpointer 经过每个节点都会保存到状态中，然后编译成LangChain链</span></span><br><span class="line"><span class="comment"># MemorySaver 支持redis、mongodb</span></span><br><span class="line">checkpointer = MemorySaver()</span><br><span class="line">app = workflow.<span class="built_in">compile</span>(checkpointer=checkpointer)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7 执行graph</span></span><br><span class="line">final_state = app.invoke(</span><br><span class="line">    &#123;<span class="string">&quot;messages&quot;</span>: [HumanMessage(content=<span class="string">&quot;今天几号&quot;</span>)]&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8 获取最终结果输出</span></span><br><span class="line">result = final_state[<span class="string">&quot;messages&quot;</span>][-<span class="number">1</span>].content</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>执行上面的代码，我们可以获得到当前的日期，结果如下图：</p><p><img src="/assets/img/ailearn/ai-learn10-02.png" alt="LangGraph"></p><h2 id="多轮会话功能"><a href="#多轮会话功能" class="headerlink" title="多轮会话功能"></a>多轮会话功能</h2><p>上面我们实现了让Agent调用工具函数获取当天日期，接下来我们实现通过会话记录，让Agent可以根据之前的记录回答问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 7 执行graph 添加会话id</span></span><br><span class="line">final_state = app.invoke(</span><br><span class="line">    &#123;<span class="string">&quot;messages&quot;</span>: [HumanMessage(content=<span class="string">&quot;今天几号&quot;</span>)]&#125;,</span><br><span class="line">    <span class="comment"># 这里config是配置是不是同一个会话的id</span></span><br><span class="line">    config=&#123;<span class="string">&quot;configurable&quot;</span>: &#123;<span class="string">&quot;thread_id&quot;</span>: <span class="number">42</span>&#125;&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8 获取最终结果输出</span></span><br><span class="line">result = final_state[<span class="string">&quot;messages&quot;</span>][-<span class="number">1</span>].content</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 9 测试记录会话状态</span></span><br><span class="line">final_state = app.invoke(</span><br><span class="line">    &#123;<span class="string">&quot;messages&quot;</span>: [HumanMessage(content=<span class="string">&quot;我刚刚问的哪天&quot;</span>)]&#125;,</span><br><span class="line">    config=&#123;<span class="string">&quot;configurable&quot;</span>: &#123;<span class="string">&quot;thread_id&quot;</span>: <span class="number">42</span>&#125;&#125;</span><br><span class="line">)</span><br><span class="line">result = final_state[<span class="string">&quot;messages&quot;</span>][-<span class="number">1</span>].content</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>最终LLM大模型返回结果如下图所示：</p><p><img src="/assets/img/ailearn/ai-learn10-03.png" alt="LangGraph"></p><p>上面代码执行完后，可以大概LangGraph执行过程有个初步了解，也可以通过生成Meraid Graph图片具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 10 保存Graph到本地图片</span></span><br><span class="line">graph_png = app.get_graph().draw_mermaid_png()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;langgraph1.png&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(graph_png)</span><br></pre></td></tr></table></figure><p>最终得到图片，如下图所示:<br><img src="/assets/img/ailearn/ai-learn10-04.png" alt="LangGraph"></p><ul><li><code>__start__</code>: 代表开始节点，也可以理解成初始化<code>StateGraph</code>工作流</li><li><code>agent</code>: 代表agent节点，设置了入口第一个节点，等同于<code>workflow.add_node(&quot;agent&quot;)</code></li><li><code>tools</code>: 代表工具节点，设置了工具节点，等同于<code>workflow.add_node(&quot;tools&quot;, tool_node)</code></li><li><code>实现连接线</code>: 代表当前节点执行完后，无需条件判断，直接流转到下一个节点，等同于<code>workflow.add_edge(&quot;tools&quot;, &quot;agent&quot;)</code></li><li><code>虚线连接线</code>: 代表条件边执行，当前节点执行完后，需要判断是否继续执行，如果继续执行则流转到下一个节点，否则流转到结束节点，等同于<code>workflow.add_conditional_edges(&quot;agent&quot;, should_continue)</code></li><li><code>_end</code>: 代表结束节点</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过上面学习，总结下本篇文章：</p><ul><li>LangGraph是LangChain的抽象而来的高级框架，能够实现更加复杂的工作流，如：循环、条件判断、多轮会话等</li><li>LangGraph的几个核心概念：<code>State</code>、<code>Node</code>、<code>Edge</code>等作用</li><li>一个<code>HelloWorld</code>的例子，可以看出比LangChain更加简单，加上State多轮会话记录功能，减少开发工作量</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://langchain-ai.github.io/langgraph/">LangGraph官方文档</a></li><li><a href="https://www.bilibili.com/video/BV1BgfBYoEpQ/?p=10&share_source=copy_web&vd_source=ddb29dacf001bda27b38794cc29b82c8">(哔哩哔哩视频)2025吃透LangChain大模型全套教程（LLM+RAG+OpenAI+Agent）通俗易懂，学完即就业!</a></li></ul><blockquote><p>声明：本文部分材料是基于<a href="https://chat.deepseek.com/">DeepSeek-R1模型</a>生成。</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面我们学了LangChain的使用和Agent开发，Langchain是一个线性工作流，如果想要在实际开发复杂的Agent，那么实现非常麻烦，比如可能会遇上一以下一些问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当调用某个工具方法出现错误或不是所需要的结果，需要循环调用工具方法直到返回需要的结果&lt;/li&gt;
&lt;li&gt;当需要一次任务中，需要保存不同工作节点的状态&lt;/li&gt;
&lt;li&gt;当需要调用不同LLM模型时候&lt;/li&gt;
&lt;li&gt;当链路中断，需要从上一个工作节点继续执行&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了解决这些问题，LangChain抽象出一个高级框架: &lt;code&gt;LangGraph&lt;/code&gt;，接下来就开始学习LangGraph的开发。&lt;/p&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    <category term="AI学习" scheme="https://www.qborfy.com/tags/AI%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>5分钟AI，每天搞懂一个知识点(2) - 无监督学习</title>
    <link href="https://www.qborfy.com/ailearn/daily/02.html"/>
    <id>https://www.qborfy.com/ailearn/daily/02.html</id>
    <published>2025-06-26T07:00:00.000Z</published>
    <updated>2025-06-26T05:03:22.020Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><p>今天我们来学习 <strong>无监督学习</strong></p><blockquote><p>一句话核心：让AI在「没有标准答案」的数据中自己发现规律——像人类探索未知世界！</p></blockquote><span id="more"></span><h1 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h1><p><img src="/assets/img/ailearn/daily/02/1.png" alt=""></p><p><strong>定义</strong>：从未标记数据中挖掘隐藏模式，通常采用聚类、降维、关联等算法去发现数据中的规律。  </p><p>✅ 关键特征：无老师指导、数据无标签<br>❌ 常见误区 ≠ 完全不需要人类（仍需设计算法目标）</p><h1 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h1><p><img src="/assets/img/ailearn/daily/02/2.png" alt=""></p><p>无监督学习，主要实现算法方案有以下三种：</p><ul><li>聚类：相似数据分组</li><li>降纬：压缩数据特征</li><li>关联：发现数据关联规律</li></ul><h2 id="聚类-K均值聚类-——-物以类聚"><a href="#聚类-K均值聚类-——-物以类聚" class="headerlink" title="聚类(K均值聚类) —— 物以类聚"></a>聚类(K均值聚类) —— 物以类聚</h2><p>主要解决问题： “哪些东西本质相似？”</p><p>例子： 自助餐厅菜品自动分区</p><ul><li>原始状态：200道菜杂乱摆放</li><li>聚类过程：<ul><li>✓ 算法检测菜品特征（烹饪方式/食材/口味）</li><li>✓ 自动划分为：海鲜刺身区、川湘热炒区、西式烘焙区</li></ul></li><li>价值：顾客5秒锁定目标区域</li></ul><h2 id="降维-PCA-——-去芜存菁"><a href="#降维-PCA-——-去芜存菁" class="headerlink" title="降维(PCA) —— 去芜存菁"></a>降维(PCA) —— 去芜存菁</h2><p>主要解决问题： “如何简化复杂信息？”</p><p>例子： 购房决策简化模型</p><ul><li>原始参数：20个维度（学区/通勤/绿化率/物业费…）</li><li>降维过程：<ul><li>✓ 算法提取核心特征 → 教育资源指数 &amp; 生活便利度</li><li>✓ 生成二维图谱</li></ul></li><li>价值：半小时锁定目标房源</li></ul><h2 id="关联（Association）——-发现隐藏规律"><a href="#关联（Association）——-发现隐藏规律" class="headerlink" title="关联（Association）—— 发现隐藏规律"></a>关联（Association）—— 发现隐藏规律</h2><p>主要解决问题： “哪些事总一起发生？”</p><p>例子： 便利店商品摆放策略</p><ul><li>原始数据：10万条购物小票</li><li>关联规则挖掘：<ul><li>{薯片，可乐} → {纸巾} [支持度=22%，置信度=81%]</li><li>规律：买零食饮料的顾客81%会顺手拿纸巾</li></ul></li><li>价值：收银台旁放置纸巾架→ 纸巾销量+35%</li></ul><h1 id="动手实验"><a href="#动手实验" class="headerlink" title="动手实验"></a>动手实验</h1><ul><li>聚类实操：用<code>K-means GUI</code>可视化分群过程 → <a href="https://www.naftaliharris.com/blog/visualizing-k-means-clustering/">在线查看</a></li><li>降维对比：在<code>TensorFlow Embedding Projector</code> 看词向量压缩 → <a href="https://projector.tensorflow.org/">在线查看</a></li><li>关联发现：通过Python实现超时购物车数据分析 →<a href="https://pbpython.com/market-basket-analysis.html">在线查看</a></li></ul><h1 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h1><ul><li>电商聚类：亚马逊用<code>DeepCluster</code>算法将商品分成27万类（比人工分类多19倍）</li><li>降维奇效：NASA用<code>t-SNE</code>分析星系图像，将数据处理时间从3周缩短到4小时</li><li>关联暴利：7-Eleven发现 <code>关东煮 + 清酒</code> 关联销售规律，冬季单店增收$6,800</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://easyai.tech/ai-definition/unsupervised-learning/">一文学会无监督学习 – Unsupervised learning</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们来学习 &lt;strong&gt;无监督学习&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一句话核心：让AI在「没有标准答案」的数据中自己发现规律——像人类探索未知世界！&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    <category term="5分钟AI" scheme="https://www.qborfy.com/tags/5%E5%88%86%E9%92%9FAI/"/>
    
  </entry>
  
  <entry>
    <title>5分钟AI，每天搞懂一个知识点(3) - 强化学习</title>
    <link href="https://www.qborfy.com/ailearn/daily/03.html"/>
    <id>https://www.qborfy.com/ailearn/daily/03.html</id>
    <published>2025-06-26T07:00:00.000Z</published>
    <updated>2025-06-27T07:44:02.771Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com">Qborfy</a></p></blockquote><p>今天我们来学习 <strong>强化学习</strong></p><blockquote><p>一句话核心：AI在试错中成长，像小孩学走路，通过奖励/惩罚信号找到最优行为策略</p></blockquote><span id="more"></span><h1 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h1><p><img src="/assets/img/ailearn/daily/03/1.png" alt=""></p><p><strong>定义</strong>: 强化学习(reinforcement learning)，又称再励学习、评价学习，是一种重要的机器学习方法，在智能控制机器人及分析预测等领域有许多应用。</p><blockquote><p>百度百科： 在连接主义学习中，把学习算法分为三种类型，即<strong>非监督学习(unsupervised learning)</strong>、<strong>监督学习(supervised leaning)</strong>和<strong>强化学习</strong>。</p></blockquote><p>✅ 关键特征：奖励与惩罚</p><h1 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h1><p><img src="/assets/img/ailearn/daily/03/2.png" alt=""></p><table><thead><tr><th><strong>维度</strong></th><th>免模型学习 (Model-Free)</th><th>有模型学习 (Model-Based)</th></tr></thead><tbody><tr><td><strong>核心思想</strong></td><td><strong>直接学习策略</strong></td><td><strong>先理解环境运作规则</strong></td></tr><tr><td>工作方式</td><td>试错→记下最佳动作</td><td>构建环境模拟器→规划行动</td></tr><tr><td>计算成本</td><td>低（不需模拟环境）</td><td>高（需建模环境动态）</td></tr><tr><td>适用场景</td><td>环境复杂难建模（如股票交易）</td><td>环境可精确仿真（如围棋）</td></tr><tr><td>代表算法</td><td>Q-Learning, DQN</td><td>动态规划, MCTS</td></tr><tr><td>—</td><td></td><td></td></tr></tbody></table><ul><li>免模型：当前状态 → 查表选最高Q值动作  </li><li>有模型：当前状态 → 模拟未来N步 → 选最优路径  </li></ul><h2 id="免模型学习"><a href="#免模型学习" class="headerlink" title="免模型学习"></a>免模型学习</h2><p><strong>案例：学骑电动车</strong></p><ul><li><strong>试错过程</strong><ul><li>右转时摔倒 → <strong>惩罚</strong>（痛觉信号）  </li><li>保持平衡前进 → <strong>奖励</strong>（速度感）  </li></ul></li><li><strong>关键特点</strong>：无需理解机械原理，靠肌肉记忆学习  </li></ul><h2 id="有模型学习"><a href="#有模型学习" class="headerlink" title="有模型学习"></a>有模型学习</h2><p><strong>案例：国际象棋对战</strong></p><ul><li><strong>建模过程</strong>：  <ul><li>先背棋谱（学习“兵走直线，象飞斜角”规则）  </li><li>大脑推演：“如果走车，对方可能有3种回应…”  </li></ul></li><li><strong>关键特点</strong>：依赖对环境的精确认知  </li></ul><p>免模型和有模型算法区别：</p><p><img src="/assets/img/ailearn/daily/03/3.png" alt=""></p><h1 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h1><h2 id="免模型案例：AlphaGo的走棋网络"><a href="#免模型案例：AlphaGo的走棋网络" class="headerlink" title="免模型案例：AlphaGo的走棋网络"></a>免模型案例：AlphaGo的走棋网络</h2><ul><li><strong>输入</strong>：棋盘当前状态  </li><li><strong>输出</strong>：直接评估落子位置价值  </li><li><strong>优势</strong>：省去推演计算，每秒决策100+次  </li><li><strong>工具复现</strong>：OpenAI Gym围棋环境  </li></ul><h2 id="有模型案例：特斯拉自动驾驶仿真"><a href="#有模型案例：特斯拉自动驾驶仿真" class="headerlink" title="有模型案例：特斯拉自动驾驶仿真"></a>有模型案例：特斯拉自动驾驶仿真</h2><ul><li><strong>环境模型</strong>：  <ul><li>物理引擎模拟雨天路滑  </li><li>神经网络生成行人行为  </li></ul></li><li><strong>优势</strong>：0风险试错百亿次  </li><li><strong>开发框架</strong>：CARLA仿真平台  </li></ul><h1 id="冷知识"><a href="#冷知识" class="headerlink" title="冷知识"></a>冷知识</h1><ul><li>DeepMind用免模型 <strong>DQN</strong> 玩打砖块游戏，2小时超越人类水平，4小时发现开发者未预设的 <strong>挖地道秘籍</strong>  </li><li>波士顿动力机器人摔倒时<strong>调整姿态的算法</strong>，本质是免模型的 <strong>策略梯度（PPO）</strong>  </li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://easyai.tech/ai-definition/reinforcement-learning/">一文学会强化学习-Reinforcement learning | RL</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;做一个有温度和有干货的技术分享作者 —— &lt;a href=&quot;https://qborfy.com&quot;&gt;Qborfy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们来学习 &lt;strong&gt;强化学习&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一句话核心：AI在试错中成长，像小孩学走路，通过奖励/惩罚信号找到最优行为策略&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="学习总结" scheme="https://www.qborfy.com/tags/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    <category term="5分钟AI" scheme="https://www.qborfy.com/tags/5%E5%88%86%E9%92%9FAI/"/>
    
  </entry>
  
</feed>
