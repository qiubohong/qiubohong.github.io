<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>个人技术栈(持续更新)</title>
    <url>/study/front-stack.html</url>
    <content><![CDATA[<h1 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h1><p>主要总结个人技术栈，会不停更新，直到部分被淘汰。</p>
<a id="more"></a>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>技术栈汇总<ul>
<li>语言<ul>
<li>JavaScript<ul>
<li>Typescript</li>
<li>Node.js</li>
</ul>
</li>
<li>CSS<ul>
<li>布局</li>
<li>动画</li>
<li>变量</li>
</ul>
</li>
<li>HTML<ul>
<li>语义化标签</li>
<li>meta标签</li>
</ul>
</li>
<li>Java</li>
<li>Python</li>
</ul>
</li>
<li>框架<ul>
<li>JavaScript<ul>
<li>Vue</li>
<li>React</li>
</ul>
</li>
<li>Node.js<ul>
<li>Egg.js</li>
<li>Nest.js</li>
</ul>
</li>
<li>Java<ul>
<li>Spring</li>
</ul>
</li>
<li>CSS<ul>
<li>Less</li>
<li>Sass</li>
</ul>
</li>
</ul>
</li>
<li>数据库<ul>
<li>Redis</li>
<li>Mysql</li>
<li>MoongoDB</li>
</ul>
</li>
<li>工程化<ul>
<li>构建工具<ul>
<li>Vite</li>
<li>Rollup</li>
<li>WebPack</li>
</ul>
</li>
<li>测试<ul>
<li>单元测试</li>
<li>E2E测试</li>
</ul>
</li>
<li>脚手架</li>
<li>性能优化</li>
</ul>
</li>
<li>主流技术<ul>
<li>JAMStack</li>
<li>低代码</li>
<li>ServerLess</li>
</ul>
</li>
<li>架构<ul>
<li>TDD开发模式</li>
<li>Monorepo</li>
<li>DDD领域设计</li>
</ul>
</li>
<li>后端<ul>
<li>Nginx<ul>
<li>Kong网关</li>
</ul>
</li>
<li>Docker<ul>
<li>K8s</li>
</ul>
</li>
</ul>
</li>
<li>移动端<ul>
<li>Hybird Native<ul>
<li>React native</li>
<li>Weex</li>
<li>Flutter</li>
<li>hippy</li>
</ul>
</li>
<li>移动端web<ul>
<li>PWA渐进式</li>
</ul>
</li>
<li>小程序<ul>
<li>Uniapp</li>
</ul>
</li>
</ul>
</li>
<li>算法<ul>
<li>排序</li>
</ul>
</li>
<li>软技能<ul>
<li>PPT</li>
</ul>
</li>
<li>AI领域<ul>
<li>图片转代码<ul>
<li>imgcook</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title>低代码系列——介绍</title>
    <url>/lowcode/index.html</url>
    <content><![CDATA[<h1 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h1><ul>
<li><a href="/lowcode/sandbox.html">《低代码系列——js沙箱设计》</a></li>
<li><a href="/lowcode/component.html">《低代码系列——组件描述DSL》(编写中)</a></li>
</ul>
<h1 id="低代码"><a href="#低代码" class="headerlink" title="低代码"></a>低代码</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>低代码，可以理解成开发人员为了快速完成页面开发而搭建一个快速构建页面平台，里面一般包括几个功能点：</p>
<ul>
<li>无需写代码即可完成页面UI布局</li>
<li>支持页面进行二次代码开发</li>
<li>支持页面或系统级别的导出或部署发布</li>
</ul>
<p>简单的说，就是快速、稳定的输出开发所需要的页面，减少重复性劳动，提高开发效率。</p>
<a id="more"></a>

<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>目前市面的低代码的实现方式主要有几种：</p>
<p>国内开源目前还在维护更新的：</p>
<ul>
<li><a href="https://github.com/baidu/amis" target="_blank" rel="noopener">百度 amis</a>  前端低代码框架，通过 JSON 配置就能生成各种页面。</li>
<li><a href="https://github.com/alibaba/lowcode-engine" target="_blank" rel="noopener">阿里 lowcode engine</a> 低代码引擎</li>
<li><a href="https://formilyjs.org/" target="_blank" rel="noopener">阿里 formilyjs</a> 表单编辑器</li>
<li><a href="https://github.com/steedos/steedos-platform/" target="_blank" rel="noopener">华炎魔方</a> 数据驱动低代码平台</li>
<li><a href="https://github.com/AnsGoo/openDataV" target="_blank" rel="noopener">OpenDataV </a>  纯前端的拖拽式、可视化、低代码数据可视化</li>
<li><a href="https://github.com/wangyuan389/mall-cook" target="_blank" rel="noopener">mall-cook</a> 商城低代码平台，可视化搭建H5、小程序多端商城</li>
<li><a href="https://github.com/nocobase/nocobase" target="_blank" rel="noopener">nocobase</a> 一个可伸缩性优先的开源无代码/低代码平台，用于构建内部工具</li>
</ul>
<p>基于后端api的低代码平台</p>
<ul>
<li><a href="https://github.com/strapi/strapi" target="_blank" rel="noopener">strapi</a> 领先的开源无头CMS，它是100%的JavaScript，完全可定制，开发者优先</li>
</ul>
<p>虽然有些项目不维护了，但是值得借鉴：</p>
<ul>
<li><a href="https://github.com/i5ting/imove" target="_blank" rel="noopener">imove 逻辑编排器</a> </li>
</ul>
<p>值得阅读一些文章</p>
<ul>
<li><a href="https://medium.com/@andreasmuelder/ai-powered-low-code-platform-by-example-how-to-use-chatgpt-to-abstract-from-domain-languages-625c3abf0e49" target="_blank" rel="noopener">AI驱动的无代码平台–如何使用chat GPT抽象域语言</a></li>
</ul>
<p>以上数据来源：<br><a href="https://github.com/taowen/awesome-lowcode" target="_blank" rel="noopener">github/awesome-lowcode 国内低代码平台从业者交流</a></p>
<h2 id="资料收集"><a href="#资料收集" class="headerlink" title="资料收集"></a>资料收集</h2><h3 id="组件相关"><a href="#组件相关" class="headerlink" title="组件相关"></a>组件相关</h3><ul>
<li><a href="https://juejin.cn/post/6986824393653485605" target="_blank" rel="noopener">如何设计可视化搭建平台的组件商店？</a></li>
<li><a href="https://juejin.cn/post/7127440050937151525" target="_blank" rel="noopener">浅谈低代码平台远程组件加载方案</a></li>
<li>Web components标准</li>
</ul>
<h3 id="拖拽相关"><a href="#拖拽相关" class="headerlink" title="拖拽相关"></a>拖拽相关</h3><ul>
<li><a href="https://juejin.cn/post/6908502083075325959" target="_blank" rel="noopener">可视化拖拽组件库一些技术要点原理分析</a></li>
<li><a href="https://juejin.cn/post/6918881497264947207" target="_blank" rel="noopener">可视化拖拽组件库一些技术要点原理分析（二）</a></li>
<li><a href="https://juejin.cn/post/6929302655118344200" target="_blank" rel="noopener">可视化拖拽组件库一些技术要点原理分析（三）</a></li>
<li><a href="https://juejin.cn/post/7129311619963682830" target="_blank" rel="noopener">可视化拖拽组件库一些技术要点原理分析（四）</a></li>
</ul>
<h1 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h1><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2>
<div class="mxgraph-container">
    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/lowcode.drawio&quot;}"></div>
</div>


<h2 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h2><blockquote class="pullquote mindmap mindmap-md"><ul>
<li>低代码平台<ul>
<li>核心模块<ul>
<li>编辑器</li>
<li>编译引擎</li>
</ul>
</li>
<li>平台能力<ul>
<li>管理能力<ul>
<li>系统</li>
<li>页面</li>
</ul>
</li>
<li>版本控制<ul>
<li>页面版本控制</li>
<li>页面发布流程</li>
</ul>
</li>
<li>权限登录<ul>
<li>登录</li>
<li>权限</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>

<h2 id="编辑器设计"><a href="#编辑器设计" class="headerlink" title="编辑器设计"></a>编辑器设计</h2><blockquote class="pullquote mindmap mindmap-md"><ul>
<li>编辑器<ul>
<li>组件描述<ul>
<li>DSL</li>
</ul>
</li>
<li>画布布局</li>
<li>拖拽</li>
<li>组件快速引入<ul>
<li>组件引入插件</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>

<h2 id="编译引擎"><a href="#编译引擎" class="headerlink" title="编译引擎"></a>编译引擎</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>低代码</tag>
      </tags>
  </entry>
  <entry>
    <title>一次性完整学完搭建PWA项目</title>
    <url>/today/20230301.html</url>
    <content><![CDATA[<blockquote>
<p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com" target="_blank" rel="noopener">Qborfy</a></p>
</blockquote>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在开发一个简单的个人记录网站，技术栈是使用 Vite + Vue3，由于使用的单台服务器，有时候服务器会被限制带宽，所以平时都会比较访问比较慢。所以想实现一个离线应用，而 PWA 应用则是目前最佳方案。</p>
<p>本文涉及知识点如下：</p>
<ul>
<li>PWA 的概念</li>
<li>Service Worker使用</li>
<li>用构建工具搭建 PWA 应用</li>
</ul>
<a id="more"></a>

<h1 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h1><blockquote>
<p>渐进式 Web 应用（Progressive Web App，PWA）是一个使用 web 平台技术构建的应用程序，但它提供的用户体验就像一个特定平台的应用程序。 ——<a href="https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps" target="_blank" rel="noopener">MDN 渐进式 Web 应用（PWA）</a></p>
</blockquote>
<p>正如上文所描述一样 PWA 最终目的让你的 web 网站可以像 app 应用一样可以给到用户去离线体验，简单点说，就是没有网络，你也可以正常访问该网站的一些资源。</p>
<p>PWA从技术上分为三个部分：</p>
<ul>
<li>主应用，就是平时我们开发网站所包含的内容，有：html，js，css等</li>
<li>Web app manifests，主要为<code>manifest.json</code>，提供浏览器安装 PWA 所需的信息，例如应用程序名称和图标等</li>
<li>Service Worker，主要为js文件，提供基本的离线缓存资源能力</li>
</ul>
<h2 id="manifest-json"><a href="#manifest-json" class="headerlink" title="manifest.json"></a>manifest.json</h2><p><code>manifest.json</code>描述web网站的信息（如名称，作者，图标和描述）的JSON文件，具体例子如下所示。</p>
<p><code>manifest.json</code>是需要在网站中html文件中 head中引用，如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"manifest"</span> <span class="attr">href</span>=<span class="string">"/manifest.json"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>完整的<code>manifest.json</code>示例：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"网站完整名称"</span>, </span><br><span class="line">  "short_name": "网站简称", // 在没有足够空间显示 Web 应用程序的全名时使用</span><br><span class="line">  "start_url": ".", // 从启动应用程序时加载的 URL。如果以相对 URL 的形式给出，则基本 URL 将是 manifest 的 URL</span><br><span class="line">  "display": "standalone", // 访问网站窗口展示模式，如：fullscreen/standalone</span><br><span class="line">  "background_color": "#fff", // 背景颜色</span><br><span class="line">  "description": "网站描述",</span><br><span class="line">  "icons": [ // 网站图标</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"images/touch/homescreen48.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"48x48"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"images/touch/homescreen72.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"72x72"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"images/touch/homescreen96.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"96x96"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"images/touch/homescreen144.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"144x144"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"images/touch/homescreen168.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"168x168"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"images/touch/homescreen192.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"192x192"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>了解基本的描述文件，下面我们将进入<code>Service Worker</code>作为其中整个控制中心，我们将在下面进行着重了解。</p>
<h1 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>我们先来看看官方定义：</p>
<blockquote>
<p>Service worker 是一个注册在指定源和路径下的事件驱动 worker。它采用 JavaScript 文件的形式，控制关联的页面或者网站，拦截并修改访问和资源请求，细粒度地缓存资源。你可以完全控制应用在特定情形（最常见的情形是网络不可用）下的表现。 —— <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">MDN Service Worker</a></p>
</blockquote>
<p>进行简单总结一下  Service Woker是什么：</p>
<ul>
<li>是一个区别于主 JavaScript 线程，运行在其他单独线程，但是必须要注册到主 JavaScript 线程中</li>
<li>是用JavaScript编写的</li>
<li>可以拦截并修改访问和资源请求，从而实现资源缓存</li>
</ul>
<p><strong>出于安全考量，Service worker 只能由 HTTPS 承载，毕竟修改网络请求的能力暴露给中间人攻击会非常危险，如果允许访问这些强大的 API，此类攻击将会变得很严重。</strong></p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>Service Woker的生命周期如下：</p>
<ol>
<li>注册，使用 ServiceWorkerContainer.register() 方法首次注册 service worker</li>
<li>下载，页面首次加载后会下载ServiceWorker或者过去 24 小时没有被下载会再次下载</li>
<li>安装，首次启用 service worker，页面会首先尝试安装，如果现有 service worker 已启用，新版本会在后台安装，但仍不会被激活——这个时序称为 worker in waiting。</li>
<li>激活，首次启用 service worker，安装结束后会直接激活，新版本的service worker会直到所有已加载的页面不再使用旧的 service worker 才会激活新的 service worker，但是可以通过ServiceWorkerGlobalScope.skipWaiting() 可以更快地进行激活。</li>
</ol>
<p><img src="/assets/img/sw-lifecycle.svg" alt></p>
<p>Service Worker提供几个事件用来监听生命周期的变化，如下：</p>
<ul>
<li><code>self.addEventListener(&quot;install&quot;)</code> 该事件触发时的标准行为是准备 service worker 用于使用，例如使用内建的 storage API 来创建缓存，并且放置应用离线时所需资源。</li>
<li><code>self.addEventListener(&quot;activate&quot;)</code> 事件触发的时间点通常是清理旧缓存以及其他与你的 service worker 的先前版本相关的东西。</li>
<li><code>self.addEventListener(&quot;fetch&quot;)</code>  事件触发的时间点是每次获取 service worker 控制的资源时，都会触发 fetch 事件 </li>
</ul>
<p><strong>这里的<code>this</code>代表的是 Service Worker 本身对象。</strong></p>
<h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><p>了解完后，我们需要知道 Service Worker 有哪些常用的 API接口，或者当我们需要去实现一个 PWA 会用到哪些 API 接口，具体如下：</p>
<ul>
<li><code>navigator.serviceWorker.register()</code> 主 JavaScript 线程注册  Service Worker 方法</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache" target="_blank" rel="noopener"><code>Cache</code></a> 与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CacheStorage" target="_blank" rel="noopener"><code>CacheStorage</code></a> 用来控制缓存</li>
</ul>
<h2 id="尝鲜使用"><a href="#尝鲜使用" class="headerlink" title="尝鲜使用"></a>尝鲜使用</h2><h3 id="第一步-写个-demo站点"><a href="#第一步-写个-demo站点" class="headerlink" title="第一步 写个 demo站点"></a>第一步 写个 demo站点</h3><p>我们肯定需要有一个站点，里面有 html/css/js文件，代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"manifest"</span> <span class="attr">href</span>=<span class="string">"./manifest.json"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Service Worker测试页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./test.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>测试 Service Worker<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./test.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">        // 这里开始注册 Service Worker</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="第二步-注册-Service-Worker"><a href="#第二步-注册-Service-Worker" class="headerlink" title="第二步 注册 Service Worker"></a>第二步 注册 Service Worker</h3><p>这一步有两个 事情：</p>
<ul>
<li>写Service Worker的相关逻辑的js文件 (且叫<code>sw.js</code>)</li>
<li>将<code>sw.js</code>注册到html文件中<br>具体代码如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册 Service worker</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> <span class="built_in">window</span>.navigator) &#123;</span><br><span class="line">    <span class="keyword">const</span> registerServiceWorker = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"serviceWorker"</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> registration = <span class="keyword">await</span> navigator.serviceWorker.register(<span class="string">"./sw.js"</span>, &#123;</span><br><span class="line">                    scope: <span class="string">"/"</span>,</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">if</span> (registration.installing) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">"正在安装 Service worker"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (registration.waiting) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">"已安装 Service worker installed"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (registration.active) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">"激活 Service worker"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(<span class="string">`注册失败：<span class="subst">$&#123;error&#125;</span>`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    registerServiceWorker();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sw.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// self等同于 this</span></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'install'</span>);</span><br><span class="line">    <span class="comment">// ... 安装完成 可以开始拦截请求加入缓存 cache 中</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'activate'</span>);</span><br><span class="line">    <span class="comment">// ... 激活完成 可以开始拦截请求加入缓存 cache 中</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="第三步-缓存管理"><a href="#第三步-缓存管理" class="headerlink" title="第三步 缓存管理"></a>第三步 缓存管理</h3><p>缓存管理包括两部分，一个是缓存资源，另外一个同步更新资源，在 ServiceWorker 代码中是通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache" target="_blank" rel="noopener"><code>Cache</code></a> 与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CacheStorage" target="_blank" rel="noopener"><code>CacheStorage</code></a>去控制，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sw.js</span></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 确保 Service Worker 不会在 waitUntil() 里面的代码执行完毕之前安装完成</span></span><br><span class="line">    event.waitUntil(</span><br><span class="line">        <span class="comment">// 创建了叫做 v1 的新缓存</span></span><br><span class="line">        caches.open(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">            cache.addAll([</span><br><span class="line">                <span class="string">'./index.html'</span>, <span class="comment">// 相对于 sw.js 的路径 缓存 index.html</span></span><br><span class="line">            ]);</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存优先</span></span><br><span class="line"><span class="keyword">const</span> cacheFirst = <span class="keyword">async</span> (request) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 从缓存中读取 respondWith表示拦截请求并返回自定义的响应</span></span><br><span class="line">    <span class="keyword">const</span> responseFromCache = <span class="keyword">await</span> caches.match(request);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'responseFromCache'</span>, responseFromCache);</span><br><span class="line">    <span class="keyword">if</span> (responseFromCache) &#123;</span><br><span class="line">        <span class="keyword">return</span> responseFromCache</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fetch(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">"fetch"</span>, (event) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 拦截请求</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'caches match'</span>,);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fetch'</span>, event.request.url);</span><br><span class="line">    event.respondWith(cacheFirst(event.request));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="动态缓存"><a href="#动态缓存" class="headerlink" title="动态缓存"></a>动态缓存</h4><p>当然，上面是将固定的资源进行缓存，如果是需要对整个页面请求资源进行缓存管理，那么可以通过<code>fetch</code>事件拦截请求实现动态缓存，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存优先</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; request </span></span><br><span class="line"><span class="comment"> * @returns </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> cacheFirst = <span class="keyword">async</span> (request) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 从缓存中读取 respondWith表示拦截请求并返回自定义的响应</span></span><br><span class="line">    <span class="keyword">const</span> responseFromCache = <span class="keyword">await</span> caches.match(request);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'responseFromCache'</span>, responseFromCache);</span><br><span class="line">    <span class="keyword">if</span> (responseFromCache) &#123;</span><br><span class="line">        <span class="keyword">return</span> responseFromCache</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果缓存中没有，就从网络中请求</span></span><br><span class="line">    <span class="keyword">const</span> responseFromServer = <span class="keyword">await</span> fetch(request);</span><br><span class="line">    <span class="keyword">const</span> cache = <span class="keyword">await</span> caches.open(cacheName);</span><br><span class="line">    <span class="comment">// 将请求到的资源添加到缓存中</span></span><br><span class="line">    cache.put(request, responseFromServer.clone());</span><br><span class="line">    <span class="keyword">return</span> responseFromServer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">"fetch"</span>, (event) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 拦截请求</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'caches match'</span>,);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fetch'</span>, event.request.url);</span><br><span class="line">    event.respondWith(cacheFirst(event.request));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>缓存成功后，可以在 DevTools找到 网络请求状态，会标识是从 Service Worker 获取资源，具体如下图：</p>
<p><img src="/assets/img/20230301.png" alt="Alt text"></p>
<h3 id="第四步-更新缓存池"><a href="#第四步-更新缓存池" class="headerlink" title="第四步 更新缓存池"></a>第四步 更新缓存池</h3><p>当你的Service Worker  js文件有更新，需要删除旧的缓存，同时启动新的 Service Worker cache，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> deleteCache = <span class="keyword">async</span> (key) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> caches.delete(key);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> deleteOldCaches = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> cacheKeepList = [<span class="string">"v2"</span>];</span><br><span class="line">  <span class="keyword">const</span> keyList = <span class="keyword">await</span> caches.keys();</span><br><span class="line">  <span class="keyword">const</span> cachesToDelete = keyList.filter(<span class="function">(<span class="params">key</span>) =&gt;</span> !cacheKeepList.includes(key));</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(cachesToDelete.map(deleteCache));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">"activate"</span>, (event) =&gt; &#123;</span><br><span class="line">  event.waitUntil(deleteOldCaches());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>讲完了这些，可能还需要实际体验一把，可以访问<a href="https://qborfy.com/code/serviceworker/index.html" target="_blank" rel="noopener">在线Service Worker Demo</a>，源码在这里<a href="https://github.com/qiubohong/qiubohong.github.io/tree/master/code/serviceworker/index.html" target="_blank" rel="noopener">Github qborfy/service worker</a>。</p>
<h1 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h1><p>上面讲述了 Service Worker 的概念和使用，但是在实际项目中，如果要按照这一套去实现，会遇到很多问题，如：经过打包后我们的 js , css等文件是动态生成的，从而导致每次都需要更新 Service Worker的 Cache 版本池。</p>
<p>所以需要结合构建工具去让项目更快支持 PWA应用开发，具体有以下几个。</p>
<h2 id="Vite构建"><a href="#Vite构建" class="headerlink" title="Vite构建"></a>Vite构建</h2><p>Vite官方推荐使用插件<a href="https://github.com/vite-pwa/vite-plugin-pwa" target="_blank" rel="noopener">vite-plugin-pwa</a>，使用如下：</p>
<p><strong>注意： <code>vite</code>版本需要 3+</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i vite-plugin-pwa -D</span><br></pre></td></tr></table></figure>

<p>调整<code>vite</code>的配置文件<code>vite.config.js</code>，最小配置如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; VitePWA &#125; <span class="keyword">from</span> <span class="string">'vite-plugin-pwa'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    VitePWA(&#123;</span><br><span class="line">      registerType: <span class="string">'autoUpdate'</span>, <span class="comment">// 注册更新模式方式  默认是autoUpdate，将会自动更新，其他还有prompt和skipWaiting</span></span><br><span class="line">      injectRegister: <span class="string">'auto'</span>, <span class="comment">// 控制如何在应用程序中注册ServiceWorker 默认值是 'auto' ，其他如：'inline' 则是注入一个简单的注册脚本，内联在应用程序入口点中</span></span><br><span class="line">      manifest: &#123; <span class="comment">// manifest.json 文件配置</span></span><br><span class="line">        name: <span class="string">'qborfy study website'</span>,</span><br><span class="line">        short_name: <span class="string">'qborfyStudy'</span>,</span><br><span class="line">        description: <span class="string">'qborfy study website'</span>,</span><br><span class="line">        theme_color: <span class="string">'#ffffff'</span>,</span><br><span class="line">        icons: [</span><br><span class="line">          &#123;</span><br><span class="line">            src: <span class="string">'favicon.png'</span>,</span><br><span class="line">            sizes: <span class="string">'192x192'</span>,</span><br><span class="line">            type: <span class="string">'image/png'</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            src: <span class="string">'favicon.png'</span>,</span><br><span class="line">            sizes: <span class="string">'512x512'</span>,</span><br><span class="line">            type: <span class="string">'image/png'</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最终会在 <code>npm run build</code>后，完成以下几个事情：</p>
<ul>
<li>生成<code>registerSW.js</code>，用来注册<code>Service Worker</code>的<code>sw.js</code>文件</li>
<li>生成<code>sw.js</code>文件，在 <code>index.html</code>引入</li>
<li>生成<code>manifest.webmanifest</code>，在 <code>index.html</code>引入，声明网站的信息，可以在<code>manifest</code>配置项调整</li>
<li>生成<code>workbox.xxx.js</code>，用来管理缓存使用策略的代码，可以通过<code>strategies</code>去配置</li>
</ul>
<p>其他更多帮助文档可以到官方文档查看, <a href="https://vite-pwa-org.netlify.app/guide/" target="_blank" rel="noopener">vite-plugin-pwa官方文档</a></p>
<h2 id="Webpack构建"><a href="#Webpack构建" class="headerlink" title="Webpack构建"></a>Webpack构建</h2><p>Webpack作为前端最主流的构建工具，当然也有对应插件去实现，那就是<a href="https://github.com/GoogleChrome/workbox/tree/v7/packages/workbox-webpack-plugin" target="_blank" rel="noopener">workbox-webpack-plugin插件</a>，其实是Chrome自己开源的<a href="https://github.com/GoogleChrome/workbox/" target="_blank" rel="noopener">workbox工具库</a>中支持的插件之一。</p>
<p>具体用法如下：</p>
<ol>
<li><p>安装依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install workbox-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>webpack.config.js增加插件配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> WorkboxPlugin = <span class="built_in">require</span>(<span class="string">'workbox-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> WorkboxPlugin.GenerateSW(&#123;</span><br><span class="line">            clientsClaim: <span class="literal">true</span>, <span class="comment">// 快速启用服务</span></span><br><span class="line">            skipWaiting: <span class="literal">true</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在index.html注册 service worker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (&apos;serviceWorker&apos; in navigator) &#123;</span><br><span class="line">    window.addEventListener(&apos;load&apos;, async () =&gt; &#123;</span><br><span class="line">        console.log(&apos;page load...&apos;);</span><br><span class="line">        let res = await navigator.serviceWorker.register(&apos;/service-worker.js&apos;);</span><br><span class="line">        console.log(res, &apos;serviceWorker res&apos;);</span><br><span class="line">        if (res) &#123;</span><br><span class="line">            console.log(&apos;register success!&apos;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.log(&apos;register fail!&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>更多帮助可以到<a href="https://developer.chrome.com/docs/workbox/modules/workbox-webpack-plugin/" target="_blank" rel="noopener">workbox 官方文档</a>中查看</p>
<h2 id="workbox工具库"><a href="#workbox工具库" class="headerlink" title="workbox工具库"></a>workbox工具库</h2><p>其实上面两个插件都是基于 Chrome 开源的 <a href="https://github.com/GoogleChrome/workbox/" target="_blank" rel="noopener">workbox工具库</a>去做二次封装实现的，接下来我们对<code>workbox.js</code>做一个简单的了解，方便后续如果我们需要自己去开发符合项目的 service worker控制。</p>
<blockquote>
<p>Service Worker有很多抽象的概念和 API，如：网络请求！缓存策略！缓存管理！预缓存！等等， Workbox的作用就是将复杂的 API 进行抽象，使更易于使用。</p>
<p>Workbox 是一组简化常见服务工作线程路由和缓存的模块。每个可用模块都解决 Service Worker 开发的特定方面。 Workbox 旨在使 Service Worker 的使用尽可能简单，同时允许在需要时灵活地满足复杂的应用程序要求。</p>
</blockquote>
<p>如何使用<code>Workbox</code>，官方提供两种方式：</p>
<ul>
<li>结合构建工具使用，如上面的 Vite 或者  Webpack</li>
<li>没有构建工具，官方提供了<a href="https://developer.chrome.com/docs/workbox/modules/workbox-sw/" target="_blank" rel="noopener">workbox-sw</a>，让你可以利用 workbox api去实现自己的 service worker策略</li>
</ul>
<p>这里简单使用一下，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sw.js</span></span><br><span class="line"><span class="comment">// 引入 workbox importScripts是 Service Worker  中的全局方法，用于引入外部脚本</span></span><br><span class="line">importScripts(<span class="string">'https://storage.googleapis.com/workbox-cdn/releases/6.4.1/workbox-sw.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面就可以直接使用workbox对象的方法，如：workbox.precaching.*， workbox.routing.*等</span></span><br><span class="line"><span class="comment">// 这里表示当请求的资源是图片时，使用 CacheFirst 策略，也就是优先从缓存中读取，如果缓存中没有，就从网络中请求</span></span><br><span class="line">workbox.routing.registerRoute(</span><br><span class="line">    (&#123; request &#125;) =&gt; request.destination === <span class="string">'image'</span>,</span><br><span class="line">    <span class="keyword">new</span> workbox.strategies.CacheFirst()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>其他使用说明文档可以到<a href="https://developer.chrome.com/docs/workbox" target="_blank" rel="noopener">workbox 官方文档</a>中查看。</p>
<h1 id="其他相关"><a href="#其他相关" class="headerlink" title="其他相关"></a>其他相关</h1><p>这里我还收集了一些开发 PWA 后续可能会用到的点，大家可以看看。</p>
<h2 id="Service-Worker其他"><a href="#Service-Worker其他" class="headerlink" title="Service Worker其他"></a>Service Worker其他</h2><p>本文主要是想通过 PWA 去优化个人网站的访问速度，PWA 不仅仅只能做缓存优化，还包括一下几点：</p>
<ul>
<li>通知 Notification，可以在后台接受服务器通知，然后告知用户</li>
<li>通讯 Message，可以和主 JS 线程通讯</li>
<li>后台更新，可以在用户没有访问页面的时候进行后台定时更新</li>
</ul>
<h2 id="如何发布一个-PWA-应用"><a href="#如何发布一个-PWA-应用" class="headerlink" title="如何发布一个 PWA 应用"></a>如何发布一个 PWA 应用</h2><ul>
<li><a href="https://chromeos.dev/en/publish/pwa-in-play" target="_blank" rel="noopener">如何发布一个PWA应用到Google Play Store</a></li>
<li><a href="https://learn.microsoft.com/en-us/microsoft-edge/progressive-web-apps-chromium/how-to/microsoft-store" target="_blank" rel="noopener">如何发布一个PWA应用到Microsoft Store</a></li>
<li><a href="https://developer.oculus.com/documentation/web/pwa-submit-app/" target="_blank" rel="noopener">如何发布一个PWA应用到Meta Quest Store</a></li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>Service Worker 缓存空间限制，Chrome 没有限制大小， Safari 限制50MB</li>
<li>当第一次访问页面，资源的请求是早于 Service Worker 的，所以静态资源是无法缓存的；只有当 Service Worker 安装完毕，用户第二次访问页面的时候，这些资源才会被缓存起来；所以 Service Worker 真正生效是在第三次访问</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.csdn.net/huangpb123/article/details/89498418" target="_blank" rel="noopener">Service Worker ——这应该是一个挺全面的整理</a></li>
<li><a href="https://juejin.cn/post/7039258299086143524" target="_blank" rel="noopener">vite pwa项目使用</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps" target="_blank" rel="noopener">MDN 渐进式 Web 应用（PWA）</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers" target="_blank" rel="noopener">如何使用一个 Service Worker</a></li>
<li><a href="https://developer.chrome.com/docs/workbox" target="_blank" rel="noopener">workbox 官方文档</a></li>
<li><a href="https://vite-pwa-org.netlify.app/" target="_blank" rel="noopener">Vite-plugin-pwa官方文档</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客添加GitHub评论功能</title>
    <url>/today/20230228.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>其实从今年开始运营这个博客，我一直想增加一些新的交互功能，如：评论，之前一直有些问题没搞定，现在终于通过 Google 搜索解决问题了， 其实也算是每天学习一些新东西。</p>
<p>解决问题：给 Hexo 博客新增 Github评论功能</p>
<p>为什么选择 Github 呢？是因为 Github 对于偏向开发人员基本上属于一个必注册网站，而我博客的内容又偏向于技术，所以才会采取这个。</p>
<a id="more"></a>

<h1 id="Gitalk"><a href="#Gitalk" class="headerlink" title="Gitalk"></a>Gitalk</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>引入 Github评论功能，网上有很多现成的方案，这里就一一列举了，我采用了最主流的库——<a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">Gitalk.js</a>，教程详细，不仅仅只能用于 Hexo，还可以适用于任何网站。</p>
<blockquote>
<p>Gitalk 是一个基于 GitHub Issue 和 Preact 开发的评论插件。 —— <a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">Gitalk.js</a></p>
</blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用起来也非常简单，其实就是页面找个放置评论的位置，将对应资源引入，然后直接初始化使用即可。代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"gitalk-container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">var gitalk = new Gitalk(&#123;</span><br><span class="line">  clientID: 'GitHub Application Client ID', //  申请的GitHub Application Client ID.</span><br><span class="line">  clientSecret: 'GitHub Application Client Secret',  //  申请的GitHub Application Client Secret.</span><br><span class="line">  repo: 'GitHub repo', //  这里填写 Github的仓库名</span><br><span class="line">  owner: 'GitHub repo owner',  //  这里填写 Github的账户名</span><br><span class="line">  admin: ['GitHub repo owner and collaborators, only these guys can initialize github issues'], //  这里填写 Github的账户名</span><br><span class="line">  id: location.pathname,      // Ensure uniqueness and length less than 50</span><br><span class="line">  distractionFreeMode: false  // 类似 Facebook 的无干扰模式</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">gitalk.render('gitalk-container')</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如何申请Github Application授权登录，只需要在<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">这里申请即可</a>，只需要注意信任域名为自己的域名即可，如下图：</p>
<img src="/assets/img/2023-07-17.png" style="width:50%">


<h2 id="hexo使用"><a href="#hexo使用" class="headerlink" title="hexo使用"></a>hexo使用</h2><p>以<code>yilia-plus</code>主题为例子，其他主题只需要放到对应位置即可，具体步骤如下所示：</p>
<ol>
<li>在文件夹<code>layout/_partial/post</code>新增文件 <code>gitalk.ejs</code>，内容如下：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"gitalk-container"</span> <span class="attr">style</span>=<span class="string">"padding: 0px 30px 0px 30px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">if(<span class="tag">&lt;<span class="name">%=theme.gitalk.enable%</span>&gt;</span>)&#123;</span></span><br><span class="line">	var gitalk = new Gitalk(&#123;</span><br><span class="line"><span class="xml">  	clientID: '<span class="tag">&lt;<span class="name">%=theme.gitalk.ClientID%</span>&gt;</span>',</span></span><br><span class="line"><span class="xml">  	clientSecret: '<span class="tag">&lt;<span class="name">%=theme.gitalk.ClientSecret%</span>&gt;</span>',</span></span><br><span class="line"><span class="xml">  	repo: '<span class="tag">&lt;<span class="name">%=theme.gitalk.repo%</span>&gt;</span>',</span></span><br><span class="line"><span class="xml">  	owner: '<span class="tag">&lt;<span class="name">%=theme.gitalk.githubID%</span>&gt;</span>',</span></span><br><span class="line"><span class="xml">  	admin: ['<span class="tag">&lt;<span class="name">%=theme.gitalk.adminUser%</span>&gt;</span>'],</span></span><br><span class="line"><span class="xml">  	id: '<span class="tag">&lt;<span class="name">%=</span> <span class="attr">page.date</span> %&gt;</span>',</span></span><br><span class="line"><span class="xml">  	distractionFreeMode: '<span class="tag">&lt;<span class="name">%=theme.gitalk.distractionFreeMode%</span>&gt;</span>',</span></span><br><span class="line">    proxy: 'https://test.com/proxy', // 这个是坑（Gitalk 本身提供了代理服务，但是国内经常无法访问），由于Github 采用的 OAuth 协议，所以需要我们自己写一套服务去支撑</span><br><span class="line">&#125;)</span><br><span class="line">gitalk.render('gitalk-container') </span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在主题中找到<code>layout/_partial/post/article.ejs</code>中想放置评论位置，加入判断是否启用 <code>gitalk</code>，代码如下：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span>(<span class="attr">theme.gitalk.enable</span>)&#123; %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%-</span> <span class="attr">partial</span>('<span class="attr">post</span>/<span class="attr">gitalk</span>', &#123;</span></span><br><span class="line"><span class="tag">      <span class="attr">key:</span> <span class="attr">post.slug</span>,</span></span><br><span class="line"><span class="tag">      <span class="attr">title:</span> <span class="attr">post.title</span>,</span></span><br><span class="line"><span class="tag">      <span class="attr">url:</span> <span class="attr">config.url</span>+<span class="attr">url_for</span>(<span class="attr">post.path</span>)</span></span><br><span class="line"><span class="tag">    &#125;) %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在主题根目录配置文件<code>_config.yml</code> 打开<code>gitalk</code>配置，如下：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#6、gitalk评论</span></span><br><span class="line"><span class="attr">gitalk:</span></span><br><span class="line"><span class="attr">  enable:</span>  <span class="literal">true</span></span><br><span class="line"><span class="attr">  githubID:</span>  <span class="string">xxxxxx</span>  <span class="comment"># 配置项基本于 GitTalk保持一致</span></span><br><span class="line"><span class="attr">  repo:</span>  <span class="string">'xxxxx'</span></span><br><span class="line"><span class="attr">  ClientID:</span>  <span class="string">'xxxxxx'</span></span><br><span class="line"><span class="attr">  ClientSecret:</span>  <span class="string">'xxxxx'</span></span><br><span class="line"><span class="attr">  adminUser:</span>  <span class="string">xxxx</span></span><br><span class="line"><span class="attr">  distractionFreeMode:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h2 id="Gitalk-提示-“NetError”"><a href="#Gitalk-提示-“NetError”" class="headerlink" title="Gitalk 提示 “NetError”"></a>Gitalk 提示 “NetError”</h2><p>其实是 Gitalk 内置了 proxy 代理服务去请求完成 Github OAuth 鉴权服务，但是由于国内会经常无法正常请求该代理服务，所以需要我们自己去完成 Github OAuth 鉴权，这里我简单写了一下代码，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>)</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'koa-bodyparser'</span>)</span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>)</span><br><span class="line"><span class="comment">// github application的配置</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    client_id: <span class="string">'xxxxx'</span>,</span><br><span class="line">    client_secret: <span class="string">'xxxxxxxxx'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> koa()</span><br><span class="line">app.use(bodyParser())</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">'/proxy'</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 获取Github OAuth鉴权回调的 code 值</span></span><br><span class="line">    <span class="keyword">const</span> &#123; code &#125; = ctx.request.body</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'code'</span>, code)</span><br><span class="line">    <span class="keyword">const</span> params = &#123;</span><br><span class="line">        client_id: config.client_id,</span><br><span class="line">        client_secret: config.client_secret,</span><br><span class="line">        code: code</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> axios.post(<span class="string">'https://github.com/login/oauth/access_token'</span>, params)</span><br><span class="line">        <span class="keyword">const</span> access_token = res.data.split(<span class="string">'&amp;'</span>)[<span class="number">0</span>].split(<span class="string">'='</span>)[<span class="number">1</span>]</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'res.data'</span>, res.data)</span><br><span class="line">        <span class="comment">// 请求成功后返回access_token 去获取 Github 相关信息</span></span><br><span class="line">        ctx.body = &#123;</span><br><span class="line">            access_token</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">        ctx.body = &#123; <span class="attr">err</span>: err &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(router.routes())</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3003</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server is running at http://localhost:3003'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://github.com/gitalk/gitalk/issues/359" target="_blank" rel="noopener">Error: Network Error怎么解决</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试100道手写题（7）—— 循环轮播图</title>
    <url>/face100/7-loop-pic.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>循环轮播图，基本上大家用的都是现有组件，如果要让你自己设计实现一个，其实最主要的两个点：循环算法和滚动动画</p>
<p>手写难度：⭐️⭐️</p>
<p>涉及知识点：</p>
<ul>
<li>循环算法，最低复杂度</li>
<li>CSS 动画</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>学习总结</tag>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试100道手写题（6）—— 虚拟滚动</title>
    <url>/face100/6-visual-scroll.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>虚拟滚动在前端中是一个很常见的解决方案，由于浏览器对于内存的限制，当页面需要展示大量 DOM 节点（如：列表数据超过 10 万）的时候，如果完整渲染整个 DOM 树，当页面数据需要更新重新渲染的时候就会出现滚动卡顿，这个时候就需要虚拟滚动去模拟浏览器原生滚动事件，从而避免这个卡顿情况。</p>
<p>手写难度：⭐️⭐️⭐️</p>
<p>涉及知识点：</p>
<ul>
<li>滚动监听事件 wheel/move</li>
<li>事件节流</li>
<li>滚动偏移量 offset</li>
<li>按需渲染计算方案</li>
</ul>
<a id="more"></a>

<h1 id="虚拟滚动"><a href="#虚拟滚动" class="headerlink" title="虚拟滚动"></a>虚拟滚动</h1><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><ul>
<li>步骤 1： 监听虚拟滚动容器的 <code>wheel</code>或<code>touchmove</code> 事件</li>
<li>步骤 2： 创造子容器用于填充父容器，使得父容器可以滚动</li>
<li>步骤 3： 提供一个渲染子元素 item函数，返回 dom 节点</li>
<li>步骤 4： 计算每个元素的高度，然后计算出总共应该渲染多少个子元素 item</li>
<li>步骤 5： 当发生滚动事件的时候，更新子容器的偏移高度，然后触发 步骤 4</li>
</ul>
<h2 id="抽象方案"><a href="#抽象方案" class="headerlink" title="抽象方案"></a>抽象方案</h2><p>定义一个类<code>Scroll</code>，接收参数为：</p>
<ul>
<li><code>el</code> 列表容器 DOM 节点</li>
<li><code>list</code> 列表数据</li>
<li><code>itemRender</code> 子元素渲染函数</li>
<li><code>itemHeight</code> 子元素高度</li>
</ul>
<p>使用例子为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> scroll = <span class="keyword">new</span> Scroll(&#123;</span><br><span class="line">    el: <span class="built_in">document</span>.getElementById(<span class="string">'scroll'</span>),</span><br><span class="line">    list: [],</span><br><span class="line">    itemRender: <span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> child = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">        child.innerText = <span class="string">`第<span class="subst">$&#123;item&#125;</span>个div`</span>;</span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>同时需要支持以下函数:</p>
<ul>
<li><code>update</code> 列表数组更新， 触发重新渲染</li>
</ul>
<p>虚拟滚动列表执行步骤：</p>
<ol>
<li>构造函数初始化，如：<code>start</code> <code>end</code> 代表位置</li>
<li><code>bindEvents</code> 监听滚动事件，触发后续渲染<code>render</code></li>
<li><code>init</code> 初始化一个内置容器，用来放置子元素，从而不影响父容器的高度，使得父容器可以滚动</li>
<li><code>render</code>计算容器滚动高度和元素 item 渲染高度，判断应该渲染哪部分元素 item</li>
</ol>
<p>简易版源码实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scroll</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(&#123; el, list, itemRender, itemHeight = <span class="number">30</span> &#125;) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$list = el; <span class="comment">// 列表容器</span></span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">        <span class="keyword">this</span>.itemRender = itemRender;</span><br><span class="line">        <span class="keyword">this</span>.itemHeight = itemHeight;</span><br><span class="line">        <span class="keyword">this</span>.start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.bindEvents();</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init() &#123;</span><br><span class="line">        <span class="comment">// 创建一个子容器，用于渲染列表项</span></span><br><span class="line">        <span class="keyword">const</span> childContainer = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">        childContainer.style.position = <span class="string">'relative'</span>;</span><br><span class="line">        childContainer.style.width = <span class="string">'100%'</span>;</span><br><span class="line">        childContainer.style.boxSizing = <span class="string">'border-box'</span>;</span><br><span class="line">        childContainer.style.paddingTop = <span class="string">'0px'</span>;</span><br><span class="line">        childContainer.style.overflow = <span class="string">'hidden'</span>;</span><br><span class="line">        childContainer.style.height = <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.list.length * <span class="keyword">this</span>.itemHeight&#125;</span>px`</span>;</span><br><span class="line">        <span class="keyword">this</span>.$list.appendChild(childContainer);</span><br><span class="line">        <span class="keyword">this</span>.$child = childContainer;</span><br><span class="line">        <span class="keyword">this</span>.render();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bindEvents() &#123;</span><br><span class="line">        <span class="keyword">let</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> updateOffset = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.render();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.$list.addEventListener(<span class="string">'scroll'</span>, updateOffset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    update() &#123;</span><br><span class="line">        <span class="keyword">this</span>.render();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; list, itemRender, itemHeight &#125; = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">const</span> &#123; scrollTop, clientHeight &#125; = <span class="keyword">this</span>.$list;</span><br><span class="line">        <span class="keyword">const</span> start = <span class="built_in">Math</span>.floor(scrollTop / itemHeight);</span><br><span class="line">        <span class="keyword">const</span> gap = <span class="built_in">Math</span>.ceil(clientHeight / itemHeight);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'start'</span>, start)</span><br><span class="line">        <span class="keyword">if</span> (start &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> end = start + gap * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (start === <span class="keyword">this</span>.start &amp;&amp; end === <span class="keyword">this</span>.end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end &gt; list.length) &#123;</span><br><span class="line">            end = list.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新子容器的高度和偏移量</span></span><br><span class="line">        <span class="keyword">this</span>.$child.style.height = <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.list.length * <span class="keyword">this</span>.itemHeight&#125;</span>px`</span>;</span><br><span class="line">        <span class="keyword">this</span>.$child.style.paddingTop = <span class="string">`<span class="subst">$&#123;start * itemHeight&#125;</span>px`</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> item = list[i];</span><br><span class="line">            <span class="keyword">const</span> $item = itemRender(item);</span><br><span class="line">            $item.style.height = <span class="string">`<span class="subst">$&#123;itemHeight&#125;</span>px`</span>;</span><br><span class="line">            fragment.appendChild($item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.$child.innerHTML = <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">this</span>.$child.appendChild(fragment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样子看起来虚拟滚动是不是十分简单，但是其实有些功能还需要优化，具体如下：</p>
<ul>
<li>节流触发滚动函数，避免每次滚动都进行更新</li>
<li>列表缓存，减少列表渲染样式更新</li>
<li>提前进行更新渲染，减少因为滚动导致的更新等等</li>
</ul>
<p>完整代码我放到 github 上，大家感兴趣可以去看看<a href="https://github.com/qiubohong/hundred-interview-questions/blob/main/6-visual-scroll" target="_blank" rel="noopener">Github Router完整实现</a></p>
<p><a href="https://qborfy.com/code/face/visualscroll/index.html" target="_blank" rel="noopener">Demo体验可以看这里</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://juejin.cn/post/6844904183582162957" target="_blank" rel="noopener">《新手也能看懂的虚拟滚动实现方法》</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>学习总结</tag>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试100道手写题（5）—— Router路由</title>
    <url>/face100/5-router-component.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前端路由，大家都使用过，那么有没有想过它是怎么实现的吗？如：Vue-Router 或者 React-Router。或许有个大概印象，但是真正要自己去实现还是没有什么思路，那么这篇文章将完整的实现思路去实现一次。</p>
<p>手写难度：⭐️⭐️⭐️</p>
<p>涉及知识点：</p>
<ul>
<li>history api 和监听事件</li>
<li>onhashchange 监听事件</li>
<li>Web Component 自定义组件</li>
</ul>
<a id="more"></a>

<h1 id="路由管理"><a href="#路由管理" class="headerlink" title="路由管理"></a>路由管理</h1><p>路由管理，是指的 web 应用在浏览器下根据不同的url地址展示不同的内容或者页面。</p>
<p>不管是 Vue-Router 或者  React-Router，基本上都是基于浏览器两种路由控制有一定了解，如下：</p>
<ul>
<li>hash，代表网页中的一个位置，通常用来做锚点使用，后面被用于单页web 应用的路由控制</li>
<li>history，代表网页的历史记录，同时提供接口操作浏览器的曾经在标签页或者框架里访问的会话历史记录</li>
</ul>
<p>下面我们对两个进行简单了解。</p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><blockquote>
<p>Hash，通常是指的浏览器 URL 地址中带#的值，如：<code>URL = https://baidu.com/#/page1</code>，那么 <code>URL.hash=&#39;#/page1&#39;</code></p>
</blockquote>
<p>Hash 常用的 的几个方法：</p>
<p><strong><code>hashchange</code></strong></p>
<blockquote>
<p>当 URL 的片段标识符更改时，将触发hashchange事件</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'hashchange'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'The hash has changed!'</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p><strong><code>调整 hash</code></strong></p>
<p>除了监听改变之外，我们还需要对Hash 自由调整，如：添加或者修改，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location.hash = <span class="string">'#/page2'</span></span><br></pre></td></tr></table></figure>

<h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><blockquote>
<p><code>History</code> 接口允许操作浏览器的曾经在标签页或者框架里访问的会话历史记录。</p>
</blockquote>
<p><code>History</code> 提供的 API 接口：</p>
<ul>
<li><code>pushState(state, unused, url)</code>  按指定的名称和 URL（如果提供该参数）将数据 push 进会话历史栈  如：<code>history.pushState({page: 1}, &quot;title 1&quot;, &quot;?page=1&quot;)</code></li>
<li><code>replaceState(state, unused, url)</code>  按指定的数据、名称和 URL（如果提供该参数），更新 history 栈上最新的条目 如：<code>history.replaceState({page: 3}, &quot;title 3&quot;, &quot;?page=3&quot;);</code></li>
<li><code>back()</code> 转到浏览器会话历史的上一页 等价于 <code>history.go(-1)</code></li>
<li><code>forward()</code> 转到浏览器会话历史的下一页 等价于 <code>history.go(1)</code></li>
</ul>
<p>还有一个比较重要的事件就是 <code>onpopstate</code>，用来监听浏览器的历史记录发生变化的。</p>
<h1 id="Router-实现"><a href="#Router-实现" class="headerlink" title="Router 实现"></a>Router 实现</h1><p>在了解完路由管理机制，接下来我们对  <code>Vue-Router</code>  和  <code>React-Router</code> 的功能实现做一个总结，一个基础的 <code>Router</code> 应该具备以下功能：</p>
<ul>
<li>路由中心，负责注册、匹配、存储等功能</li>
<li><code>router-view</code> 和 <code>router-link</code>组件实现</li>
<li>跳转api</li>
</ul>
<p>Router基本功能流程要点如下：</p>

<div class="mxgraph-container">
    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/router-flow.drawio&quot;}"></div>
</div>



<p>接下来我们就按照每个功能模块进行简单实现。</p>
<h2 id="路由中心"><a href="#路由中心" class="headerlink" title="路由中心"></a>路由中心</h2><p>路由中心功能分为两块，一是注册管理，二是监听匹配。</p>
<h3 id="注册管理"><a href="#注册管理" class="headerlink" title="注册管理"></a>注册管理</h3><p>注册管理，顾名思义就是将所有路由对应页面组件配置统一管理，当路由改变的时候，可以直接从配置找到对应页面组件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册路由</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; routes </span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; mode </span></span><br><span class="line"><span class="comment"> * @returns </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRouter</span>(<span class="params">routes, mode=<span class="string">'history'</span></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 保存路由</span></span><br><span class="line">    <span class="keyword">const</span> matcherMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> route <span class="keyword">of</span> routes) &#123;</span><br><span class="line">        matcherMap.set(route.name, route)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加路由</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addRoutes</span>(<span class="params">routes</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> route <span class="keyword">of</span> routes) &#123;</span><br><span class="line">            matcherMap.set(route.name, route)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除路由</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">removeRoutes</span>(<span class="params">routes</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> route <span class="keyword">of</span> routes) &#123;</span><br><span class="line">            matcherMap.delete(route.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取路由</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getRoutes</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> matcherMap</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取路由</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getRoute</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> matcherMap.get(name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> router = &#123;</span><br><span class="line">        addRoutes,</span><br><span class="line">        removeRoutes,</span><br><span class="line">        getRoutes,</span><br><span class="line">        getRoute</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> router</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="路由匹配"><a href="#路由匹配" class="headerlink" title="路由匹配"></a>路由匹配</h3><p>这里我们就简单实现一下，将 <code>path</code>作为 map 的 key 去存储，忽略一下比较复杂的情况，如： query 中 params和  <code>/path/:id</code>等情况</p>
<p>因此我们只需要通过获取 <code>matcherMap</code> 对象中对应的组件即可。</p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>组件渲染，其实在 Vue 或者 React 中都有对应渲染组件的方法，这里为了更简单实现例子，我们使用了<code>Web Component</code>规范去实现自定义组件<code>&lt;router-view&gt;</code>展示和渲染组件。</p>
<p>分为两个功能点：</p>
<ol>
<li>自定义组件<code>&lt;router-view&gt;</code></li>
<li>匹配到路由组件后渲染对应组件</li>
</ol>
<h3 id="lt-router-view-gt-组件实现"><a href="#lt-router-view-gt-组件实现" class="headerlink" title="&lt;router-view&gt;组件实现"></a><code>&lt;router-view&gt;</code>组件实现</h3><p>这里使用 WebCompoent 去实现，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义路由组件</span></span><br><span class="line">customElements.define(<span class="string">'router-view'</span>, <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">const</span> template = <span class="built_in">document</span>.createElement(<span class="string">'template'</span>);</span><br><span class="line">        template.id = <span class="string">'router-view'</span>;</span><br><span class="line">        template.innerHTML = <span class="string">'&lt;div&gt;&lt;slot name="content"&gt;&lt;/slot&gt;&lt;/div&gt;'</span>;</span><br><span class="line">        <span class="keyword">const</span> templateContent = template.content;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> shadowRoot = <span class="keyword">this</span>.attachShadow(&#123; <span class="attr">mode</span>: <span class="string">"open"</span> &#125;);</span><br><span class="line">        shadowRoot.appendChild(templateContent.cloneNode(<span class="literal">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="渲染对应组件"><a href="#渲染对应组件" class="headerlink" title="渲染对应组件"></a>渲染对应组件</h3><p>当监听到</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由回调</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> route = match(<span class="built_in">window</span>.location)</span><br><span class="line">    <span class="keyword">if</span> (currentRoute &amp;&amp; currentRoute.path === route.path) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!route) &#123;</span><br><span class="line">        <span class="comment">// 路由不存在，跳转到首页</span></span><br><span class="line">        push(<span class="string">'/'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (route) &#123;</span><br><span class="line">        currentRoute = route</span><br><span class="line">        <span class="keyword">const</span> component = route.component</span><br><span class="line">        <span class="comment">// 渲染组件</span></span><br><span class="line">        <span class="built_in">document</span>.querySelector(<span class="string">'router-view'</span>).innerHTML = <span class="string">`&lt;<span class="subst">$&#123;component&#125;</span> slot="content"&gt;&lt;/<span class="subst">$&#123;component&#125;</span>&gt;`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码我放到 github 上，大家感兴趣可以去看看<a href="https://github.com/qiubohong/hundred-interview-questions/blob/main/5-router-component" target="_blank" rel="noopener">Github Router完整实现</a></p>
<p><a href="https://qborfy.com/code/face/router/index.html#/" target="_blank" rel="noopener">Demo体验可以看这里</a></p>
<h1 id="额外知识点"><a href="#额外知识点" class="headerlink" title="额外知识点"></a>额外知识点</h1><h2 id="WebComponent"><a href="#WebComponent" class="headerlink" title="WebComponent"></a>WebComponent</h2><blockquote>
<p>Web Component 是一套不同的技术，允许你创建可重用的定制元素（它们的功能封装在你的代码之外）并且在你的 web 应用中使用它们。 —— <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_components" target="_blank" rel="noopener">Web Component</a></p>
</blockquote>
<p>简单的理解，就是浏览器可以允许你自定义HTML 标签，且包含自定义的 CSS 样式和 JS 脚本逻辑。里面有三个点学习：</p>
<ul>
<li>Custom element（自定义元素），通过 JS 可以自定义 HTML 标签</li>
<li>Shadow DOM（影子 DOM），可以将HTML DOM 树以附加 Shadow DOM到自定义 HTMl 标签中，从而不影响原本 HTML DOM 树结构</li>
<li>HTML template（HTML 模板），支持<template> 和 <slot> 元素，使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用</slot></template></li>
</ul>
<h3 id="实践例子"><a href="#实践例子" class="headerlink" title="实践例子"></a>实践例子</h3><ol>
<li>自定义HTML 标签代码如下：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMl</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="comment">// 必须首先调用 super 方法</span></span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 shadow root</span></span><br><span class="line">        <span class="keyword">const</span> shadow = <span class="keyword">this</span>.attachShadow(&#123;<span class="attr">mode</span>: <span class="string">'open'</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 spans</span></span><br><span class="line">        <span class="keyword">const</span> wrapper = <span class="built_in">document</span>.createElement(<span class="string">'h1'</span>);</span><br><span class="line">        wrapper.innerHTML = <span class="string">'测试自定义元素'</span>;</span><br><span class="line"></span><br><span class="line">        shadow.appendChild(wrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首次被插入到文档 DOM 节点上时被调用</span></span><br><span class="line">    connectedCallback() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'首次被插入到文档 DOM 节点上时被调用'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当 custom element 从文档 DOM 中删除时，被调用</span></span><br><span class="line">    disconnectedCallback() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'当 custom element 从文档 DOM 中删除时，被调用'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当 custom element 被移动到新的文档时，被调用</span></span><br><span class="line">    adoptedCallback() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'当 custom element 被移动到新的文档时，被调用'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加、删除或者修改某个属性时被调用</span></span><br><span class="line">    attributeChangedCallback(name, oldValue, newValue) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'增加、删除或者修改某个属性时被调用'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注册组件标签，这里比较重要</span></span><br><span class="line">customElements.define(<span class="string">'custom-html'</span>, PopUpInfo);</span><br></pre></td></tr></table></figure>

<p>实际应用如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里就会展示h1 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">custom-html</span>&gt;</span><span class="tag">&lt;/<span class="name">custom-html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 <code>template</code>模板 + <code>slot</code>插槽<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用模板 --&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"template"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- slot 通过 name 确定放在哪里 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"title"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自定义标签使用示范 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article-page</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- slot 标识使用哪个插槽 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">"title"</span>&gt;</span>这是标题<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">"content"</span>&gt;</span>这是内容<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">article-page</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="class"><span class="keyword">class</span> <span class="title">Article</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span></span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">constructor</span>()&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">super</span>();</span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> template = <span class="built_in">document</span>.getElementById(<span class="string">'template'</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> templateContent = template.content;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> shadowRoot = <span class="keyword">this</span>.attachShadow(&#123;<span class="attr">mode</span>: <span class="string">'open'</span>&#125;).appendChild(templateContent.cloneNode(<span class="literal">true</span>));</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        customElements.define(<span class="string">'article-page'</span>, Article);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History" target="_blank" rel="noopener">MDN History资料</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_components" target="_blank" rel="noopener">Web Component 自定义组件</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>学习总结</tag>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端架构成长之路——微前端系列(二)之qiankun框架实战</title>
    <url>/framework/frontend-microapp-2.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前有写过专门一篇关于微前端架构的基础知识——<a href="https://qborfy.com/framework/frontend-microapp-1.html" target="_blank" rel="noopener">《前端架构成长之路——微前端架构理论篇》</a>，但是里面主要讲几个点：</p>
<ul>
<li>微前端是什么，具体能做些什么</li>
<li>微前端的一些主流框架</li>
<li>微前端拆分项目的一些原则</li>
</ul>
<p>那么其实对于微前端应用还是有些不太清楚，下面就用微前端架构去对某个古老项目进行框架升级，这其实也是微前端架构主要特性之一，对项目升级的方案之一。</p>
<a id="more"></a>

<p>在使用 <code>qiankun</code>  框架之前，脑子里有几个疑问：</p>
<ul>
<li><code>qiankun</code> 是怎么做到将不同框架的项目放在一起，是通过打包，还是其他方式：<ul>
<li><code>qiankun</code> 是有<code>1个主基座</code> + <code>N 个微应用</code></li>
<li><code>qiankun</code> 利用路由控制，去加载不同的微应用，微应用与主应用之间消除跨域问题</li>
<li><code>qiankun</code> 需要在子应用里加入生命周期钩子函数提供给主应用调用</li>
</ul>
</li>
</ul>
<p>搞明白后，我们就可以开始进行项目实战，</p>
<h1 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h1><p>由于本次是将老项目升级到新版本框架中，因此将采用 Monorepo 架构对新老项目进行统一管理。项目结构大概 如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qiankun-demo</span><br><span class="line">├── apps # 应用层</span><br><span class="line">|  ├── main #  基座项目</span><br><span class="line">|  |  ├── ...</span><br><span class="line">|  ├── old #  老版项目</span><br><span class="line">|  |  ├── ...</span><br><span class="line">|  └── new #  新版项目</span><br><span class="line">|     ├── ...</span><br><span class="line">├── README.md</span><br><span class="line">├── nx.json #  nx.js 管理Monorepo</span><br><span class="line">├── package.json</span><br><span class="line">├── pnpm-lock.yaml</span><br><span class="line">├── pnpm-workspace.yaml</span><br></pre></td></tr></table></figure>

<h2 id="main-基座项目"><a href="#main-基座项目" class="headerlink" title="main-基座项目"></a>main-基座项目</h2><p> <code>qiankun</code> 的基座项目和普通 web 项目初始化没有什么区别，你可以基于 <code>React</code>  或  <code>Vue</code> 作为基座项目框架都可以，但是需要入口文件需要做一下调整，下面我以 <code>Vue+Vite</code> 项目为例:</p>
<p>步骤一： 初始化项目</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm create vite@latest main-vue -- --template vue</span><br><span class="line"><span class="meta">#</span> 添加 qiankun</span><br><span class="line">npm i qiankun -S</span><br></pre></td></tr></table></figure>

<p>步骤二：在<code>main.ts</code>准备好基座项目以及注册微应用</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; registerMicroApps, start , runAfterFirstMounted, setDefaultMountApp&#125; <span class="keyword">from</span> <span class="string">'qiankun'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./style.css'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Step1 初始化应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">createApp(App).mount(<span class="string">'#app'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Step2 注册子应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">registerMicroApps(</span><br><span class="line">    [</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">'old-web'</span>, <span class="comment">// 注册后子应用的名字 老项目启动端口为8080</span></span><br><span class="line">            entry: <span class="string">'//localhost:8080'</span>, <span class="comment">// 这里可以根据环境变量配置</span></span><br><span class="line">            container: <span class="string">'#subapp-viewport'</span>,</span><br><span class="line">            activeRule: <span class="string">'/old'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">'new-web'</span>, <span class="comment">// 注册后子应用的名字 新项目启动端口为8090</span></span><br><span class="line">            entry: <span class="string">'//localhost:8090'</span>,</span><br><span class="line">            container: <span class="string">'#subapp-viewport'</span>,</span><br><span class="line">            activeRule: <span class="string">'/new'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// qiankun 生命周期钩子 - 加载前</span></span><br><span class="line">        beforeLoad: [</span><br><span class="line">            (app) =&gt; &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'[LifeCycle] before load %c%s'</span>, <span class="string">'color: green;'</span>, app.name);</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">        beforeMount: [</span><br><span class="line">            (app) =&gt; &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'[LifeCycle] before mount %c%s'</span>, <span class="string">'color: green;'</span>, app.name);</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">        afterMount: [</span><br><span class="line">            (app) =&gt; &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'[LifeCycle] after mount %c%s'</span>, <span class="string">'color: green;'</span>, app.name);</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">        beforeUnmount: <span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'[LifeCycle] before Unmount %c%s'</span>, <span class="string">'color: green;'</span>, app.name);</span><br><span class="line">        &#125;,</span><br><span class="line">        afterUnmount: [</span><br><span class="line">            (app) =&gt; &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'[LifeCycle] after unmount %c%s'</span>, <span class="string">'color: green;'</span>, app.name);</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;,);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Step3 设置默认进入的子应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// setDefaultMountApp('/old');</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Step4 启动应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">start();</span><br><span class="line"></span><br><span class="line">runAfterFirstMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[MainApp] first app mounted'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="microapp-微应用"><a href="#microapp-微应用" class="headerlink" title="microapp-微应用"></a>microapp-微应用</h2><p>微应用其实改动代码不多，只是需要将qiankun 所需要的接口(<code>bootstrap</code>, <code>mount</code> <code>unmount</code>) 暴露出来即可</p>
<p>步骤一： 新建 <code>public-path.js</code> 代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主要用来区分 qiankun 加载资源路径</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.__POWERED_BY_QIANKUN__) &#123;</span><br><span class="line">  __webpack_public_path__ = <span class="built_in">window</span>.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤二： 在 <code>app.js</code> 加入<code>qiankun</code>的接口，将 render 函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>)</span><br><span class="line"><span class="keyword">var</span> ReactDom = <span class="built_in">require</span>(<span class="string">'react-dom'</span>)</span><br><span class="line"><span class="keyword">var</span> ReactRouter2 = <span class="built_in">require</span>(<span class="string">'react-router'</span>)</span><br><span class="line"><span class="keyword">var</span> RouteConfig = <span class="built_in">require</span>(<span class="string">'./config/RouteConfig'</span>)</span><br><span class="line"><span class="keyword">var</span> Utils = <span class="built_in">require</span>(<span class="string">'radmin'</span>).Utils</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createHistory &#125; <span class="keyword">from</span> <span class="string">'history'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./public-path.js'</span></span><br><span class="line"><span class="keyword">import</span> ReactRouter, &#123; Router, Route, useRouterHistory &#125; <span class="keyword">from</span> <span class="string">'react-router'</span></span><br><span class="line"><span class="keyword">var</span> appHistory = useRouterHistory(createHistory)(&#123; <span class="attr">queryKey</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'../less/index.less'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。</span></span><br><span class="line"><span class="comment"> * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[react15] react app bootstraped'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">props = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[react15] props from main framework'</span>, props);</span><br><span class="line">  <span class="keyword">const</span> &#123; container &#125; = props;</span><br><span class="line">  <span class="comment">// 这里判断 container 是否qiankun 携带进来的</span></span><br><span class="line">  ReactDom.render(&lt;ReactRouter2.Router routes=&#123;Utils.combineConfig(RouteConfig)&#125; history=&#123;appHistory&#125; /&gt;, container ? container.querySelector('#react15Root') : document.getElementById('react15Root'))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export async function unmount(props) &#123;</span><br><span class="line">  const &#123; container &#125; = props;</span><br><span class="line">  ReactDOM.unmountComponentAtNode(</span><br><span class="line">    container ? container.querySelector('#react15Root') : document.getElementById('react15Root'),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">// 独立的时候可自主运行</span><br><span class="line">if (!window.__POWERED_BY_QIANKUN__) &#123;</span><br><span class="line">  bootstrap().then(mount);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">  window.bootstrap = bootstrap;</span><br><span class="line">  window.mount = mount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤三： 在<code>webpack.config.js</code>调整打包配置，将 <code>app.js</code>暴露到<code>window</code>中:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: [</span><br><span class="line">        path.resolve(__dirname, <span class="string">'./src/js/app'</span>)</span><br><span class="line">    ],</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'hot'</span>),</span><br><span class="line">        filename: <span class="string">'app.js'</span>,</span><br><span class="line">        library: <span class="string">`<span class="subst">$&#123;packageName&#125;</span>-[name]`</span>,</span><br><span class="line">        libraryTarget: <span class="string">'umd'</span>,</span><br><span class="line">        globalObject: <span class="string">'window'</span>,</span><br><span class="line">        jsonpFunction: <span class="string">`webpackJsonp_<span class="subst">$&#123;packageName&#125;</span>`</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到了这里，基本上就可以完成项目改造工作了，但是后续还需要其他一些改动点，如：</p>
<ol>
<li>基座项目需要切换为真实域名，可以按照构建环境变量去切换</li>
<li>微应用需要注意资源使用相对路径</li>
<li>针对不同打包工具，都需要将<code>bootstrap</code> <code>mount</code> 函数进行暴露到 <code>window</code> 对象中，因为 <code>qiankun</code> 会拦截代理 <code>window</code>去运行微应用</li>
<li>需要解决不同应用之间的登录态等问题</li>
</ol>
<h1 id="qiankun-的缺陷"><a href="#qiankun-的缺陷" class="headerlink" title="qiankun 的缺陷"></a>qiankun 的缺陷</h1><p>虽然 qiankun 使用起来很简单，但是在实际应用还是存在一些缺陷，但是在将其引入到项目中的时候，需要考虑这些点：</p>
<ul>
<li>对于 jQuery 老项目支持度不够，即使有解决方案，但是需要对 qiankun 整个框架原理深入了解才能明白如何解决</li>
<li>沙箱隔离机制并不完美，如：写 css 代码挂载到 document.body，会导致样式污染</li>
<li>通讯机制较简单，基于一个全局的 globalState 对象，去提供给到各个微应用去使用</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://qiankun.umijs.org/zh" target="_blank" rel="noopener">qiankun官网</a></li>
<li></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>架构系列</tag>
      </tags>
  </entry>
  <entry>
    <title>前端架构——利用chatgpt成为架构师（1）</title>
    <url>/framework/framework-with-chatgpt-1.html</url>
    <content><![CDATA[<blockquote>
<p>“有时我对 ChatGPT 的理解能力感到惊讶，但是更多时候，我不得不拼命推动它，朝着我想要的方向前进。它有时会产生意料之外的结果，让我感到非常沮丧。”</p>
<p>“它像一个吸收了所有人类知识、但需要别人帮忙才能把这些知识串起来的应届毕业生。”</p>
<p>“看来我今年的工作是安全的。但是，我需要好好学习 ChatGPT，精通它的使用，让我明年也是安全的。”</p>
<p>最适用现在AI技术的一句话 —— <strong>AI 与人类不是竞争关系，它未必会减少机会，反而可能带来更多的机会。</strong></p>
</blockquote>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
        <tag>架构系列</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试100道手写题（4）—— 深浅拷贝</title>
    <url>/face100/4-deep-clone.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>深浅拷贝经典前端面试题，不仅仅只是实现逻辑，更加是对整个Javascript语言的实现背后一套理论，从基础数据类型到原型链一整套知识体系的熟悉程度，下面我们就从简单到困难一一实现。</p>
<p>手写难度：⭐️⭐️⭐️</p>
<p>涉及知识点：</p>
<ul>
<li>数据类型在内存空间的存储</li>
<li>原型以及原型链（这是实现拷贝一个重要知识点，如何拷贝自定义的类实例对象）<ul>
<li>如何拷贝一个原型对象 如： <code>a = {}; clone(a.__proto__)</code></li>
</ul>
</li>
<li>数组的判断</li>
<li>日期/正则等其他内置对象的拷贝</li>
<li>函数的拷贝</li>
</ul>
<a id="more"></a>

<h1 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h1><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>凡是遇到问题，多问一次自己为什么？—— 为什么在Javascript中会有【深拷贝】｜ 【浅拷贝】 区分的操作呢？</p>
<p>首先，我们回想一下，一开始我们学习语言的第一件事是什么（Hello World除外），是数据类型，Javascript中数据类型有以下几种：</p>
<ul>
<li>基础数据类型：number, string, boolean等</li>
<li>引用数据类型：object, array, date等</li>
</ul>
<p>然后，就是变量赋值，如： a = 1，b = new Date()，在 JavaScript 中分为两种：</p>
<ol>
<li>基础数据类型，值都有固定的大小，保存在栈内存中，由系统自动分配存储空间在栈内存空间的值，我们可以直接进行操作，因此基础数据类型都是按照值访问</li>
<li>复杂数据类型，值都保存在堆内存中的对象，引用类型的值都是按引用访问的，所以在操作对象时，实际上是操作对象的引用而不是实际的对象。引用可以理解为保存在栈内存中的一个地址，该地址指向堆内存中的一个实际对象</li>
</ol>
<p>因此，在复制值的时候，两种类型操作不一样，如下：</p>
<ol>
<li>基础类型复制，会在栈空间新建一个空间去进行复制</li>
<li>引用类型复制，系统会为新的变量自动分配一个新的栈内存空间这个栈内存空间保存着与被复制变量相同的指针，尽管他们在栈内存中的内存空间的位置互相独立但是在堆内存中访问到的对象实际上是同一个，因此，当我们改变其中一个对象的值时，实际上就是改变原来的对象</li>
</ol>
<p>简单的总结一下：</p>
<ol>
<li>基础类型的值长度是固定的，所以可以在栈空间分配存储空间，当进行复制的时候，可以直接在栈空间内新建一个存储空间进行赋值</li>
<li>引用类型的值长度是不固定的，所以需要在栈空间分配一个指针，然后在堆内存空间分配一个对象，将指针指向改对象，当进行复制的时候，需要在栈空间新建一个指针，然后指向之前在堆内存建的对象</li>
</ol>
<p>了解完为什么后，再去实现浅拷贝和深拷贝就会理所当然了。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>浅拷贝和深拷贝，在了解完【为什么】后，就很容易理解两者的区别：</p>
<ul>
<li>浅拷贝只会对引用类型的值做第一层堆内存进行拷贝</li>
<li>深拷贝除了会复制新建栈空间的值，同时还在将指向堆内存中对象进行新建</li>
</ul>
<p>那么为什么不都用深拷贝去实现就好了，那是因为在浅拷贝机制可以有效利用存储空间，同时浅拷贝的也存在一定应用场景：</p>
<ul>
<li>当需要统一管理引用值的变化时候，如：当 fetch 一个请求返回 json 数据后，当我们对其做修改调整后，其实不需要做深拷贝的</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>实现原理：只对引用类型数据做第一层值进行拷贝</p>
<p>步骤：</p>
<ol>
<li>判断数据类型，需要将所有引用类型数据判断一次</li>
<li>根据不同引用类型，将引用类型数据值进行复制新建一次，利用<code>Object.assign</code>或 <code>new +     return new obj.constructor(obj);</code> 进行复制进行</li>
<li>其中针对自定义类，如：<code>new A()</code>，需要通过继承其原型链，利用 <code>Object.getPrototypeOf</code></li>
<li>基础类型直接返回</li>
</ol>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型判断 主要基于 Object.prototype.toString.call</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Object]'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Array]'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为原型对象 如 a = new A();  a.__proto__ === A.prototype</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrototype</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Ctor = obj &amp;&amp; obj.constructor;</span><br><span class="line">    <span class="keyword">const</span> proto = (<span class="keyword">typeof</span> Ctor === <span class="string">'function'</span> &amp;&amp; Ctor.prototype) || <span class="built_in">Object</span>.prototype;</span><br><span class="line">    <span class="keyword">return</span> obj === proto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果不是对象类型 直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(obj === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isArray(obj) || isArrayBuffer(obj)) &#123;</span><br><span class="line">        <span class="keyword">return</span>  obj.slice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isObject(obj)) &#123;</span><br><span class="line">        <span class="comment">// 区分是内置 Object  还是自定义的类</span></span><br><span class="line">        <span class="keyword">if</span>(obj.constructor === <span class="built_in">Object</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrototype(obj)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">new</span> obj.constructor());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 自定义类新建实例化对象 保留原型链 从而保留原型方法或属性</span></span><br><span class="line">            <span class="keyword">const</span> newObj = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj));</span><br><span class="line">            <span class="comment">// 获取对象的所有属性</span></span><br><span class="line">            <span class="keyword">const</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(obj);</span><br><span class="line">            keys.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">                newObj[key] = obj[key];</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> newObj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他类型可以通过 new + constructor 来实现浅拷贝</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> obj.constructor(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>实现原理： 需要对整个对象的进行深度遍历赋复制新建，从而实现修改新建值不会影响到原有的值</p>
<p>步骤：</p>
<ol>
<li>数据类型判断和浅拷贝一致</li>
<li>针对不同引用类型需要遍历+递归实现值的拷贝新建</li>
</ol>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj, map = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果不是对象类型 直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(obj === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是 WeakMap 直接抛出异常 因为 WeakMap 无法遍历</span></span><br><span class="line">    <span class="keyword">if</span>(isWeakMap(obj)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'WeakMap can not be cloned'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isPrototype(obj)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">new</span> obj.constructor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相互引用的对象会导致死循环</span></span><br><span class="line">    <span class="keyword">if</span>(map.has(obj)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isArrayBuffer(obj)) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj.slice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isArray(obj)) &#123;</span><br><span class="line">        <span class="keyword">const</span> newArr = [];</span><br><span class="line">        map.set(obj, newArr);</span><br><span class="line">        obj.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            newArr.push(deepClone(item, map));</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isSet(obj)) &#123;</span><br><span class="line">        <span class="keyword">const</span> newSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        map.set(obj, newSet);</span><br><span class="line">        obj.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            newSet.add(deepClone(item, map));</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> newSet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isMap(obj)) &#123;</span><br><span class="line">        <span class="keyword">const</span> newMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">        map.set(obj, newMap);</span><br><span class="line">        obj.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">            newMap.set(key, deepClone(value, map));</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> newMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isRegx(obj)) &#123;</span><br><span class="line">        <span class="keyword">const</span> newRegx = <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj.source, obj.flags);</span><br><span class="line">        map.set(obj, newRegx);</span><br><span class="line">        <span class="keyword">return</span> newRegx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isDate(obj)) &#123;</span><br><span class="line">        <span class="keyword">const</span> newDate = <span class="keyword">new</span> <span class="built_in">Date</span>(obj.getTime());</span><br><span class="line">        map.set(obj, newDate);</span><br><span class="line">        <span class="keyword">return</span> newDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isError(obj)) &#123;</span><br><span class="line">        <span class="keyword">const</span> newError = <span class="keyword">new</span> <span class="built_in">Error</span>(obj.message);</span><br><span class="line">        map.set(obj, newError);</span><br><span class="line">        <span class="keyword">return</span> newError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isObject(obj)) &#123;</span><br><span class="line">        <span class="comment">// 区分是内置 Object  还是自定义的类</span></span><br><span class="line">        <span class="keyword">if</span>(obj.constructor === <span class="built_in">Object</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> newObj = &#123;&#125;;</span><br><span class="line">            map.set(obj, newObj);</span><br><span class="line">            <span class="comment">// 获取对象的所有属性 包括不可枚举属性</span></span><br><span class="line">            <span class="built_in">Reflect</span>.ownKeys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">                newObj[key] = deepClone(obj[key], map);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> newObj;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrototype(obj)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">new</span> obj.constructor());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 自定义类新建实例化对象 保留原型链 从而保留原型方法或属性</span></span><br><span class="line">            <span class="keyword">const</span> newObj = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj));</span><br><span class="line">            map.set(obj, newObj);</span><br><span class="line">            <span class="comment">// 获取对象的所有属性</span></span><br><span class="line">            <span class="keyword">const</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(obj);</span><br><span class="line">            keys.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">                newObj[key] = deepClone(obj[key], map);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> newObj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他类型可以通过 new + constructor 来实现拷贝返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> obj.constructor(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>浅拷贝和深拷贝作为前端面试经常会出现的题目，在做这篇题目之前，我对浅拷贝和深拷贝的其实是缺失的，即使网上的答案也只是做了一部分，当我深入阅读<code>lodash.Clone</code>和<code>lodash.deepClone</code>的源码才发现这里面隐藏的一些知识点，这里做一个阅读前和阅读后：</p>
<p>阅读源码前：</p>
<ul>
<li>浅拷贝只需要通过 Object.assigin就可以实现拷贝，但是从来没想过数据类型判断的重要性，包括自定义类对应实例的拷贝</li>
<li>深拷贝只需要解决数组遍历，以及解决循环依赖问题即可，忘记了还有Map/Set等新一代数据类型的遍历</li>
</ul>
<p>阅读源码后：</p>
<ul>
<li>数据类型判断才是拷贝的重要依据，根据不同类型需要做不同逻辑拷贝，而且 JavaScript 中的数据类型真的有很多，不仅只有 array object，还有常见Date，Regexp，或者冷门的 ArrayBuffer等</li>
<li>自定义类的拷贝也很复杂，同时也引出了原型对象(<strong>proto</strong> prototype)的拷贝，这里也加深我对JavaScript 原型的理解</li>
</ul>
<p>JavaScript 数据实例拷贝背后的原理，其实是 JavaScript 中不同数据类型存储值的方式需要去做不一样的处理，而引用类型最终在 JavaScript 中的实现就是依赖于原型和原型链去实现的。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://github.com/lodash/lodash/blob/master/.internal/baseClone.js#L236" target="_blank" rel="noopener">lodash baseClone 浅拷贝和深拷贝的基础实现方法</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>学习总结</tag>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试100道手写题（3）—— EventBus</title>
    <url>/face100/3-event-bus.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>EventBus作为发布订阅设计模式的经典应用场景，很值得我们去学习研究它的实现原理。</p>
<p>手写难度：⭐️⭐️</p>
<a id="more"></a>

<p>可以直接去看完整源码地址（记得给个star），地址如下：</p>
<p><a href="https://github.com/qiubohong/hundred-interview-questions/tree/main/3-event-bus" target="_blank" rel="noopener">https://github.com/qiubohong/hundred-interview-questions/tree/main/3-event-bus</a></p>
<h1 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>EventBus其实是一个技术概念，主要是通过事件订阅方式解决不同情况下消息通讯问题，不仅仅在前端，还在Native（Android）等各个地方都有在使用。</p>
<p>EventBus 可以分成下面四个部分：</p>
<ul>
<li>订阅者 Subscriber： 监听某类事件，当发布者触发该类事件后执行所需要的事件。</li>
<li>发布者 Publisher：当满足某些条件，发布触发订阅者的事件。</li>
<li>消息 Event：其实就需要传递的消息或事件本身。</li>
<li>消息中心 EventStore: 负责存储消息与订阅者的对应关系，有消息触发时，负责通知订阅者。</li>
</ul>
<p>几者的关系如下图所示：</p>

<div class="mxgraph-container">
    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/event-bus.drawio&quot;}"></div>
</div>


<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>上面是讲了一些概念性，但是在实际开发中，EventBus其实已经很多地方在使用了，如：</p>
<ul>
<li>Vue2中的<code>$emit</code> <code>$on</code>其实就是利用EventBus实现的，同时还可以使用去实现跨组件实现通讯</li>
<li>Node.js中的的<code>EventEmitter</code>，支持<code>on</code> <code>emit</code>，可以利用其解决<code>回调地狱</code>问题</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>EventBus主要有几个方法：</p>
<ul>
<li><code>on(event, func)</code> 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。</li>
<li><code>emit(event, ...args)</code> 按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false。</li>
<li><code>once(event, func)</code> 为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。</li>
<li><code>off(event, func)</code> 移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。</li>
<li><code>offAll(event)</code> 移除所有事件的所有监听器</li>
</ul>
<p>下面是实现代码:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventBus</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// 消息队列 存储事件和回调</span></span><br><span class="line">        <span class="keyword">this</span>.listeners = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订阅事件</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; event </span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; callback </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    on(event, callback) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.listeners[event]) &#123;</span><br><span class="line">            <span class="keyword">this</span>.listeners[event] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.listeners[event].push(callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注销事件</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; event </span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; callback </span></span><br><span class="line"><span class="comment">     * @returns </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    off(event, callback) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.listeners[event]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.listeners[event] = <span class="keyword">this</span>.listeners[event].filter(<span class="function"><span class="params">listener</span> =&gt;</span> listener !== callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发布触发事件</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; event </span></span><br><span class="line"><span class="comment">     * @param  &#123;...any&#125; args </span></span><br><span class="line"><span class="comment">     * @returns </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    emit(event, ...args) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.listeners[event]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.listeners[event].forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener(...args));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只触发一次的事件</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; event </span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; callback </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    once(event, callback) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.listeners[event]) &#123;</span><br><span class="line">            <span class="keyword">this</span>.listeners[event] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> onceCallback = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">            callback(...args);</span><br><span class="line">            <span class="keyword">this</span>.off(event, onceCallback);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.listeners[event].push(onceCallback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注销某个事件的所有回调</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; event </span></span><br><span class="line"><span class="comment">     * @returns </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    offAll(event) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.listeners[event]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.listeners[event] = [];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> eventBus = <span class="keyword">new</span> EventBus();</span><br><span class="line">    eventBus.on(<span class="string">'test'</span>, (a, b) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a, b);</span><br><span class="line">    &#125;);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        eventBus.emit(<span class="string">'test'</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>EventBus模式使用上需要注意的问题：</p>
<ul>
<li>如果<code>on</code>注册多次，可能会导致一次<code>emit</code>就会执行多次函数，导致无法定位到哪里注册多，因此使用的时候，需要考虑什么时候把事件<code>off</code></li>
<li><code>off</code>需要明确指出函数对象，所以我们的注册函数建议都通过声明函数去实现，而不是匿名函数，减少注销事件的麻烦</li>
<li><code>on</code>注册事件，事件名建议使用静态常量，而不是字符串，更加容易管理事件中心</li>
</ul>
<h1 id="额外知识"><a href="#额外知识" class="headerlink" title="额外知识"></a>额外知识</h1><h2 id="为什么Vue3实例不再支持-emit-on"><a href="#为什么Vue3实例不再支持-emit-on" class="headerlink" title="为什么Vue3实例不再支持 emit on"></a>为什么Vue3实例不再支持 <code>emit</code> <code>on</code></h2><p>官方解释如下：</p>
<ul>
<li>Vue 1.x的时候是实现类似Angular的组件事件系统，利用<code>$dispatch</code>与<code>$broadcast</code>实现向上和向下发送事件来进行通信</li>
<li>在Vue 2中，取消了<code>$dispatch</code>与<code>$broadcast</code>，从而能更多状态驱动的数据流，其实就是单向数据流的状态扭转，</li>
<li>Vue2中， <code>$emit</code>用于触发由父组件的声明事件，<code>$on</code> <code>$off</code> <code>$once</code>都是这类事件的扩展，但是这仅仅是一个过程，且很少被使用</li>
<li>因此，没有充分的理由去让它们暴露在组件实例上，所以最终决定将删除<code>$on</code> <code>$off</code> <code>$once</code>等实例方法</li>
</ul>
<p>解决方案：</p>
<ol>
<li>使用<code>vue3-bus</code>，基于Vue插件机制</li>
<li>不借助Vue插件实现的，官方推荐的<a href="https://github.com/developit/mitt" target="_blank" rel="noopener">mitt</a></li>
</ol>
<p>原文地址：<a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0020-events-api-change.md" target="_blank" rel="noopener">active-rfcs/0020-events-api-change.md</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://juejin.cn/post/6844904101331877895" target="_blank" rel="noopener">从发布订阅模式入手读懂Node.js的EventEmitter源码</a></li>
<li><a href="https://www.runoob.com/nodejs/nodejs-event.html" target="_blank" rel="noopener">Node.js EventEmitter</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>学习总结</tag>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试100道手写题（2）—— throttle与debounce</title>
    <url>/face100/2-throttle-debouce.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前端面试100道手写题第二篇《throttle与debounce》，说一下为什么选这两个，其实大家都有在用，我们先来了解一下两个函数的作用：</p>
<ul>
<li>debounce 防抖，用于减少函数触发的频率，在一个delay时间内，如果触发delay时间归零，直到delay时间到才会触发函数</li>
<li>throttle 节流，用于限制函数触发的频率，每个delay时间间隔，最多只能执行函数一次</li>
</ul>
<p>选这两个手写的原因其实很简单，就是面试频率高，而且项目实战会经常用到，同时里面还会隐藏一些知识点和目前公共库的一些问题（见文章末尾）。</p>
<p>接下来就让我们开始手写撸代码吧！</p>
<p>手写难度：⭐️⭐️⭐️</p>
<a id="more"></a>

<p>不想看啰里吧嗦的文字，可以直接去看完整源码地址（记得给个star），地址如下：</p>
<p><a href="https://github.com/qiubohong/hundred-interview-questions/tree/main/2-debouce-throttle" target="_blank" rel="noopener">https://github.com/qiubohong/hundred-interview-questions/tree/main/2-debouce-throttle</a></p>
<h1 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h1><p>很多功能函数只要搞清楚他们的功能设计，基本上你就可以手写出完整的代码。<br>以<a href="https://github.com/lodash/lodash/blob/master/debounce.js" target="_blank" rel="noopener">lodash.debounce</a>为参考，接下来我们来拆解一下完整的debounce的功能具体有哪些：</p>
<ul>
<li>构造函数 <code>debounce(func, waitTime, maxWait, leading, trailing)</code><ul>
<li>func (Function): 要防抖的函数。</li>
<li>[wait=0] (number): 需要防抖的毫秒。</li>
<li>[leading=false] (boolean): 指定调用在防抖开始前。</li>
<li>[trailing=true] (boolean): 指定是否在最大等待时间过期后直接调用，简单点的当超过等待时间，则会触发函数</li>
<li>[maxWait=wait] (number): 设置最大等待时间过期。</li>
</ul>
</li>
<li>取消函数 <code>debounceReturn.cancel()</code> ， <code>debounceReturn</code>是执行完debounce函数返回的对象</li>
<li>状态函数 <code>debounceReturn.pending()</code></li>
<li>立即调用函数 <code>debounceReturn.flush()</code></li>
</ul>
<p>上面是<code>lodash</code>给出debounce的完整功能，但是如果是我们仅仅需要简易版本的throttle，应该如何实现呢？</p>
<p>拆解步骤一：实现一个简单版</p>
<p><code>debounce()</code>函数最简单功能就是，希望能在wait时间段禁止重复触发某个事件，第一个简易版如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce_easy</span>(<span class="params">func, waitTime</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 用于存储定时器</span></span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="comment">// 存储返回结果</span></span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="comment">// 如果定时器存在，就清除定时器</span></span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        <span class="comment">// 重新设置定时器</span></span><br><span class="line">        timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 执行函数，将当前作用域绑定的this和参数传递过去</span></span><br><span class="line">            result = func.apply(context, args);</span><br><span class="line">        &#125;, waitTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单元测试</span></span><br><span class="line"><span class="keyword">const</span> debounced = debounce_easy(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'debounce_easy:'</span>, value)</span><br><span class="line">    ++callCount;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;, <span class="number">32</span>);</span><br><span class="line"><span class="comment">// 这里等同于快速触发4次，只有最后一次生效 输出 debounce_easy: d</span></span><br><span class="line"><span class="keyword">const</span> results = [debounced(<span class="string">'a'</span>), debounced(<span class="string">'b'</span>), debounced(<span class="string">'c'</span>), debounced(<span class="string">'d'</span>)];</span><br><span class="line"><span class="keyword">let</span> lodashResults = [lodashDebouce(<span class="string">'a'</span>), lodashDebouce(<span class="string">'b'</span>), lodashDebouce(<span class="string">'c'</span>), lodashDebouce(<span class="string">'d'</span>)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// callCount: 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'callCount:'</span>, callCount)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// callCount: 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'callCount:'</span>, callCount)</span><br><span class="line">&#125;, <span class="number">160</span>);</span><br></pre></td></tr></table></figure>

<p>拆解步骤二：leading参数希望可以先执行一次函数，再进行防抖， 具体代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其实就是在定时器之前判断 leading和 timeout定期器是否不为空即可 关键代码如下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果leading为true，就立即执行函数</span></span><br><span class="line"><span class="keyword">if</span> (leading) &#123;</span><br><span class="line">    <span class="comment">// 如果定时器不存在，就执行函数，从而避免重复执行</span></span><br><span class="line">    <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">        invokeFunc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拆解步骤三：加上cancel等函数实现，这里能实现完基本上手写题就80分了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取消防抖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> cancel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(timeout)</span><br><span class="line">    lastArgs = lastThis = timeout = <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拆解步骤四：加上参数 <code>traling+maxWait</code> 函数，作用在当超过maxWait等待时间后，函数会</p>
<p>重点在于判断是否过了等待时间，所以需要记录每次执行的时间，当超过的时候判断是否有传参数<code>traling+maxWait</code></p>
<p>实现步骤如下流程所示：</p>

<div class="mxgraph-container">
    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/debounce.drawio&quot;}"></div>
</div>


<p>参数解释：</p>
<ul>
<li>lastArgs,  // 上一次调用时的参数</li>
<li>lastThis,  // 上一次调用时的this</li>
<li>result,  // 上一次调用的返回值</li>
<li>lastCallTime,  // 上一次调用的时间</li>
<li>lastInvokeTime = 0,  // 上一次执行的时间</li>
<li>leading = false,  // 是否立即执行</li>
<li>maxing = false,  // 是否有最大等待时间</li>
<li>trailing = true; // 是否在最后一次调用后执行</li>
</ul>
<h1 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h1><p><code>throttle</code>节流函数定义：就是无论频率多快，每过一段时间就执行一次。</p>
<p>在实现逻辑上其实是可以看做<code>debounce</code>的一种升级版，只需要保证debounce函数在超时后执行一次函数即可</p>
<p>只要针对debouonce函数设置一下参数即可，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait, leading = true</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> debounce(func, wait, &#123;</span><br><span class="line">        leading,</span><br><span class="line">        trailing: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">'maxWait'</span>: wait <span class="comment">// 超时时间和控制时间一致就可以了</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然我们也可以实现一个快速简单版，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle_eazy</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> lastInvokeTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">const</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">invokeFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            lastInvokeTime = <span class="built_in">Date</span>.now();</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        wait = +wait || <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 计算剩余时间</span></span><br><span class="line">        <span class="keyword">let</span> remainTime = wait;</span><br><span class="line">        <span class="comment">// 如果上次执行时间大于0，说明已经执行过了，计算剩余时间</span></span><br><span class="line">        <span class="keyword">if</span>(lastInvokeTime &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            remainTime = wait - (<span class="built_in">Date</span>.now() - lastInvokeTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果剩余时间小于等于0，说明可以执行了，重置上次执行时间</span></span><br><span class="line">        <span class="keyword">if</span> (remainTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            invokeFunc();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经开始计时，说明已经有定时器了，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则，开始计时</span></span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            invokeFunc();</span><br><span class="line">        &#125;, remainTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单元测试</span></span><br><span class="line">; (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> throttled = throttle(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello'</span>, count);</span><br><span class="line">    &#125;, <span class="number">200</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'触发i~'</span>, i * <span class="number">100</span>)</span><br><span class="line">            throttled();</span><br><span class="line">        &#125;, <span class="number">100</span> * i);</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 正确输出10</span></span><br><span class="line">        <span class="built_in">console</span>.log(count);</span><br><span class="line">    &#125;, <span class="number">2200</span>);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h1 id="额外知识点"><a href="#额外知识点" class="headerlink" title="额外知识点"></a>额外知识点</h1><h2 id="TDD开发模式"><a href="#TDD开发模式" class="headerlink" title="TDD开发模式"></a>TDD开发模式</h2><p>一般写这些工具函数，都需要提前想好单元测试怎么写，这就是涉及一种开发模式<a href="https://juejin.cn/post/6844903780970921991" target="_blank" rel="noopener">测试驱动开发（TDD）</a>，主要遵循以下两个原则：</p>
<ul>
<li>仅在自动测试失败时才编写新代码。</li>
<li>消除重复设计（去除不必要的依赖关系），优化设计结构（逐渐使代码一般化）。</li>
</ul>
<p>TDD的研发流程如下：</p>

<div class="mxgraph-container">
    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/tdd.drawio&quot;}"></div>
</div>


<h2 id="lodash的缺陷"><a href="#lodash的缺陷" class="headerlink" title="lodash的缺陷"></a>lodash的缺陷</h2><p>如果你正在使用lodash，你应该关注一下，因为lodash的github最后一次更新2021年4月24号，到目前为止已经有两年的时间没有更新，已经堆积很多issues，从上面解读源码的时候就发现一个<code>lodash.throttle</code>的一个bug，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> changeInput = throttle(<span class="function">(<span class="params">value: string</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;, <span class="number">1000</span>, &#123;</span><br><span class="line">  leading: <span class="literal">false</span>,</span><br><span class="line">  trailing: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 上述防抖函数将不会按照我们所设想的每隔1秒触发，而是会出现各种异常情况，如果触发频率够高可能会执行，如果触发频率低于1秒则不会执行，因为leading和trailing都设置为false，lodash源码没有针对这一情况进行处理，或者不支持trailing参数设置即可</span></span><br></pre></td></tr></table></figure>

<p>同时，lodash还有其他一些缺陷：</p>
<ul>
<li>lodash是支持tree shaking，但是这么写<code>import {throttle} from &#39;lodash&#39;</code> 会将整个lodash包都引入， 必须这么写<code>import throttle from &#39;lodash/throttle&#39;</code>才能做到按需加载</li>
<li>进入 npm 上的 lodash 包，它被列为 v4.17.21，并且已经 2 年多没有发布了：<a href="https://www.npmjs.com/package/lodash" target="_blank" rel="noopener">https://www.npmjs.com/package/lodash</a></li>
</ul>
<p>当然作为一个工具库lodash确实可以让我们少写很多代码，但是已经很长时间没有维护的问题还是需要关注的。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>Lodash源码：<a href="https://github.com/lodash/lodash/" target="_blank" rel="noopener">https://github.com/lodash/lodash/</a></li>
<li><a href="https://juejin.cn/post/6844903780970921991" target="_blank" rel="noopener">测试驱动开发（TDD）总结——原理篇</a></li>
<li><a href="https://news.ycombinator.com/item?id=35056136" target="_blank" rel="noopener">Hacker News——不要再使用的Lodash</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>学习总结</tag>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title>《高效能人士的7个习惯》，怎么做才能提高做事效率？</title>
    <url>/study/seven-habbit.html</url>
    <content><![CDATA[<h1 id="高效能人士的7个习惯"><a href="#高效能人士的7个习惯" class="headerlink" title="高效能人士的7个习惯"></a>高效能人士的7个习惯</h1><p>不管是工作还是学习，有些人做事的效率很高，而有些做事的效率就很低，那么有什么方式可以提高自己的工作效率，这本书主要就是讲如何去培养自己高效能的习惯，改变自己的做事和思考的方式。</p>
<a id="more"></a>
<h1 id="阅读摘要"><a href="#阅读摘要" class="headerlink" title="阅读摘要"></a>阅读摘要</h1><ul>
<li>如何使用本书<ul>
<li>不要浅尝即止，而是需要针对每个习惯去不断做练习，做到知行合一</li>
<li>结合每个章节末尾中行动指引，需要付诸行动，方便实战统计</li>
<li>有了新的体会或者实践了，需要去做分享，把自己当成老师</li>
<li>前三个习惯是培养自己的独立与自信</li>
<li>后三个习惯是扩大自己的影响力与搭建人际关系</li>
<li>最后一个习惯，是将前六个习惯加强，不断充电</li>
</ul>
</li>
<li>7个习惯的简要定义与架构图<ul>
<li>7个习惯的简要定义如下：<ul>
<li>习惯一：积极主动，采取主动，为过去、现在以及未来的选择负责，主动选择，摈弃被动（受害者），创造自己的人生</li>
<li>习惯二：以终为始，做事情基本上都需要有目标，并根据这个目标，全身心投入，同时领导工作的核心就是基于共有的使命、愿景和价值观，创造文化</li>
<li>习惯三：要事第一，需要明白什么是要事，不论其他的事情多紧迫，要事都是要排在第一位的</li>
<li>习惯四：双赢思维，基于互敬、互惠的思考框架，目的是分享资源，而不是敌对竞争，从互赖式的角度思考问题，重点是协助或者找人快速解决问题</li>
<li>习惯五：知彼解己，耐心倾听别人，坦诚对待别人，平衡两者，提高沟通效率</li>
<li>习惯六：统合综效，创造性合作，制造1+1&gt;2的效果</li>
<li>习惯七：不断更新，如何在四个生活基本面（身体、精神、智力、社会/情感）中，不断更新自己。</li>
</ul>
</li>
<li>7个习惯分为三个时期：<ul>
<li>依赖期：没有独立，没任何高效的习惯</li>
<li>独立期：拥有积极主动、以终为始，要事第一的习惯</li>
<li>互赖期：拥有双赢思维、知彼解己、统合综效的习惯</li>
</ul>
</li>
</ul>
</li>
<li>第1部分 思维方式与原则<ul>
<li>第一章 由内到外全面造就自己<ul>
<li>没有正确的生活，就没有真正卓越的人生。 —— 戴维·斯塔·乔丹（David Starr Jordan） ｜ 美国生物学家及教育家<ul>
<li>表达的是，如果你没有选择正确的生活方式，你就不可能会成功</li>
</ul>
</li>
<li>现实中的问题，协调工作与生活，总结如下：<ul>
<li>事业成功，牺牲家庭生活</li>
<li>很忙，不知道工作有什么意义</li>
<li>无法找到高效的员工，即使很多管理课程也无法回答我的问题</li>
<li>要做的事太多，时间不够用</li>
<li>嫉妒别人的成就</li>
<li>个性要强，希望能控制整个过程</li>
<li>婚姻变得平淡无趣，没有再有爱情的感觉</li>
<li>孩子不听话</li>
<li>教育孩子有自己的主动去工作，但是又不希望主动提醒</li>
<li>不断减肥，不断失败</li>
</ul>
</li>
<li>思维方式是如何影响我们的观点，进而影响我们的做出种种行为<ul>
<li>期望理论</li>
<li>自我实现预言</li>
<li>皮格马利翁效应</li>
</ul>
</li>
<li>要改变现在的生活，就要改变自己，最重要是改变自己对问题的看法</li>
<li>品德与魅力，孰轻孰重<ul>
<li>现在社会宣传个人魅力可以速成，往往忽略了品德的重要性，从而导致我们花很多在花言巧语，玩弄手段，拍马屁去速成魅力</li>
<li>其实这就是两种思维模式，但是却影响了很多人的选择</li>
</ul>
</li>
<li>思维模式是我们每个人基本的东西，可以比作人生地图，它会指引我们走向哪里</li>
<li>每个人的大脑中有两张地图：<ul>
<li>一张是反应现实中的地图，如：颜色、物质等</li>
<li>一张是依据思维模式的地方，如：价值观、世界观等</li>
</ul>
</li>
<li>所以个人魅力论只是改变一个人表面现象，而品德成功论则是从本质思维模式上去发生改变</li>
<li>一个人的思维方式越符合这些原则或者自然法则，就越能正确而高效地生活。原则如下：<ul>
<li>公平原则，平等与正义来源于此</li>
<li>诚信与正直，人类相互信任的基础</li>
<li>服务原则，就是贡献自我，从而到讲求品质和追求卓越</li>
<li>潜能原则，人类可以不断进步成长，再到释放潜能与施展才华</li>
</ul>
</li>
<li>我们不了解自己，也不理解自己，但是知道别人眼中的自己应该是什么样子的，不再健谈而是闲谈，不再开怀大笑而是挤出笑容，不再痛苦而是绝望，而这种缺陷让他们沦陷，与芸芸大众无所区别，丧失自己的独立性</li>
<li>教导孩子也要因时而异。在关系和气氛紧张的时候，教导会被视为一种评判与否定；关系融洽的时候，在私下里对孩子循循善诱效果会加倍。</li>
<li>我们需要新的、更深层次的思想水平，即基于原则的思维方式，它能正确引导我们实现高效能，改善人际关系，解决深层问题。</li>
<li>本书的核心思想：<ul>
<li>强调以原则为中心，以品德为基础，要求“由内而外”地实现个人效能和人际效能。</li>
</ul>
</li>
<li>实践测试：<ul>
<li>是否曾经做过推测发现自己判断过于武断？请描述该段经历</li>
<li>当时的推测是什么？</li>
<li>做过其他推测，将某一项采取什么行动？</li>
</ul>
</li>
<li>检验你的思维方式<ul>
<li>你是否到过其他地区？有没有觉得很奇怪的行为?</li>
<li>人们的行为是否是你的预期？你对他们的行为有什么看法？</li>
<li>回想你的旅游经历，认为当地人对你的看法？是否认为他们对你的看法与你对他们的看法很类似？</li>
<li>如果你在旅游中有机会认识当地人？你对他们的看法或推测会有什么改变？</li>
</ul>
</li>
<li>转换思维方式<ul>
<li>去上班的路径有分哪几种？是否有些路径比其他路径更加复杂？是否有一条路径比较方便？为什么方便、为什么不方便？</li>
<li>你是否发现过一条你以前不知道的路径？走不同路径的的新鲜感如何？</li>
<li>现在想一下你与他人打交道的方式，是否有好几种？你还会尝试哪些新的方式？</li>
</ul>
</li>
<li>影响你生活的五个原则<ul>
<li>请列出影响生活的五个原则？分别以什么样的方式影响？是积极的还是消极的<ul>
<li>影响我生活的五个原则，<ul>
<li>睡眠时间一定要够，如果不够的话很可能会导致接下来一段时间非常难受</li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>第二章 七个习惯概论<ul>
<li>习惯对我们的生活有极大的影响，因为它是一贯的，在不知不觉中，经年累月影响着我们的品德，暴露出我们的本性，左右着我们的成败。人的行为总是一再重复。因此卓越不是一时的行为，而是习惯。 —— 亚里士多德（Aristotle） ｜ 古希腊哲学家、文艺理论家<ul>
<li>表达的是习惯就是我们的生活方式，将会影响我们的方方面面，所以我们需要更加重视培养我们一些好的习惯。</li>
</ul>
</li>
<li>思想决定行动，行动决定习惯，习惯决定品德，品德决定命运。</li>
<li>习惯是由“知识”、“技巧”与“意愿”相互交织的结果。<ul>
<li>知识，是理论范畴，指点做什么、为什么这么做</li>
<li>技巧，是告诉我们怎么做</li>
<li>意愿，是推荐我们去做的动力源</li>
</ul>
</li>
<li>改变习惯是一个痛苦的过程，这往往需要我们有更高的目标，面对未来更美好的目标去牺牲当下的一些享受</li>
<li>7个习惯并不是分散开，而是一个系统养成习惯，会成螺旋上升的，从摆脱依赖到独立到互相依赖，最后利用更新学习去加强前面<ul>
<li>依赖期，以你为核心</li>
<li>独立期，以我为核心</li>
<li>互赖期，以我们为核心</li>
<li>自我更新，将上面的人生3个阶段包含起来，形成不断更新，螺旋上升的成长过程</li>
</ul>
</li>
<li>效能的定义，其实就是遵循”产出/产能平衡“原则<ul>
<li>鹅下金蛋的故事，金蛋是产出，而鹅才是资产或者产能，”重蛋轻鹅“则会失去资产最终无法获得可持续产出，”重鹅轻蛋“则会因为没有产出而饿死</li>
</ul>
</li>
<li>如何做到让女儿可以心甘情愿去打扫房间，其实就是打扫房间是产出，而女儿是能打扫房间的产能<ul>
<li>如果用强迫的方式让女儿打扫卫生，则会失去女儿的幸福，就是产能</li>
<li>如果不打扫，则没有产出</li>
<li>如果我们增加女儿的幸福感，如：答应她去一次她想去的地方，就是产能，从而促进她去打扫的动力</li>
</ul>
</li>
<li>效能是7个习惯的基础，只有搞明白效能的核心=产出/产能的平衡，才能更好的去培养习惯</li>
<li>7个习惯的评分项<ul>
<li>情感账户<ul>
<li>信守承诺</li>
<li>待人和蔼、体谅对方</li>
<li>不在背后说坏话</li>
</ul>
</li>
<li>产出、产能平衡<ul>
<li>在生活、工作保持适当的平衡</li>
<li>致力于某个项目，总是想着雇主的需求和厉害关系</li>
<li>努力工作，但是不会把自己搞的太疲惫</li>
</ul>
</li>
<li>积极主动<ul>
<li>能掌控自己的生活</li>
<li>注意力集中在能有所为的事情上，而不是集中在我无法控制的事情上</li>
<li>为情绪负责，而不是埋怨周围</li>
</ul>
</li>
<li>以终为始<ul>
<li>明白对生活的追求</li>
<li>生活和工作井然有序，很少陷入危机</li>
<li>每周都一个清晰的计划，注明我想完成的事情</li>
</ul>
</li>
<li>要事第一<ul>
<li>致力于完成自己的事情，不延误</li>
<li>不让日常琐事埋没真正重要的事务</li>
<li>每天做的事情都是有意义的，有利于我的生活目标</li>
</ul>
</li>
<li>双赢思维<ul>
<li>关心别人的成功，就像关心自己的成功一样</li>
<li>能与别人合作</li>
<li>遇到矛盾的时候，努力寻求有利于各方的解决方案</li>
</ul>
</li>
<li>知彼解己<ul>
<li>对他人的感觉很敏感</li>
<li>尽力理解别人的观点</li>
<li>试图从对方的角度，而不是从自己的角度看待问题</li>
</ul>
</li>
<li>统合综效<ul>
<li>赞赏别人的见解</li>
<li>寻求新的解决方案</li>
<li>鼓励别人表达他们的观点</li>
</ul>
</li>
<li>不断更新<ul>
<li>珍惜身体健康</li>
<li>建立和改善他人的人际关系</li>
<li>花时间和钱追求生活的意义和乐趣</li>
</ul>
</li>
</ul>
</li>
<li>实践问题<ul>
<li>列出一个好习惯和坏习惯<ul>
<li>好习惯：开始坚持每天记录事情和坚持学习</li>
<li>坏习惯：晚睡</li>
</ul>
</li>
<li>打破坏习惯的一切努力，立即行动的事情和过程<ul>
<li>打破晚睡的习惯的行为，就是早点上床，丢掉手机</li>
</ul>
</li>
<li>你处于人生哪个节点（依赖、独立、互赖），是什么行为或原因让你处于这个节点，你开始看到自己需要在哪方面需要努力吗？<ul>
<li>处于独立时期，往互赖期去走</li>
<li>人际关系，与人合作上在花时间去努力</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>第2部分 个人领域的成功：从依赖到独立<ul>
<li>第三章 习惯一 积极主动 —— 个人愿景的原则<ul>
<li>人性的本质是主动而非被动的，人类不仅能针对特定环境选择回应方式，更能主动创造有利的环境。</li>
<li>采取主动不等于胆大妄为、惹是生非或滋事挑衅，而是要让人们充分认识到自己有责任创造条件。</li>
<li>最令人鼓舞的事实，莫过于人类确实能主动努力以提升生命价值。——亨利·戴维·梭罗（Henry David Thoreau） ｜ 美国文学家及哲学家<ul>
<li>表达的是，主动是人类最大的优点，主动创造有利于自己的环境的从而提升生命的价值</li>
</ul>
</li>
<li>将自己从自己剥离出来，如在房间内，把自己想成一个灯，用心观察自己的，看看自己的状态是什么样子的？这就是客观的看待自己</li>
<li>社会之镜，从周边的对自己看法进行自我认知，这就等于面对哈哈镜看自己，看的不是真正的自己</li>
<li>环境与条件对我们影响巨大，但是不是决定性作用，可以决定我们的命运，目前主流三种外部因素决定论<ul>
<li>基因决定论，认为人的性格都是祖宗流传下来的，就是命由天定</li>
<li>心理决定论，认为人的性格是受父母言行决定，从童年培养的心理一直影响到现在</li>
<li>环境决定论，环境决定人的本性，例如公司、家庭甚至国家政策，社会环境等，都会影响到人</li>
</ul>
</li>
<li>其实外部因素决定论的基础是”刺激-回应“，有点像狗狗的实验，每天给定时按铃给狗狗吃饭，等过了一段时间后哪怕狗狗吃饱了，再次按铃它也会吃下饭</li>
<li>但是人类不只是动物，还有自由的思想，会在刺激-回应，选择是否回应</li>
<li>实际案例：维克多·弗兰克尔在二战被囚禁，遭遇各种刺激（如：侮辱、伤痛），通过脑子自我想象，超越肉体的禁锢，用独有的自我意识，发掘人类根本原则，就是人有选择的自由。</li>
<li>人类选择的自由，有四种特有的天赋：<ul>
<li>自我意识，知道自己是自己</li>
<li>想象力，超越现实，进行创造</li>
<li>良知，坚持自己的原则，判断对与错</li>
<li>独立意志，基于自我意识，不受外力自行其是的能力</li>
</ul>
</li>
<li>而环境决定论基本上源自于集体意识，集体意识是动物的本能，而人类与动物的区别，在于集体意识之上，拥有我们自由选择的能力</li>
<li>积极主动的定义：不仅仅是做事的态度，还是意味着要对自己的人生负责</li>
<li>积极主动应该要做的，营造有利的外部环境的积极性和责任感<ul>
<li>责任感，其实就是要回应，根据价值观去做不同选择回应</li>
</ul>
</li>
<li>积极主动要做的事情：<ul>
<li>不受外界影响，拥有自己的价值观去行事</li>
<li>理智胜于冲动，价值观是内在动力</li>
<li>昨日的选择决定了今日的我</li>
</ul>
</li>
<li>伤害并非是我们遭遇了悲痛的事情，而是我们对悲痛事情的回应</li>
<li>人生的三种价值观：<ul>
<li>经验价值观，来自自身经历</li>
<li>创造价值观，源于个人独创</li>
<li>态度价值观，面对绝境的回应，而这个恰恰是最重要的价值观</li>
</ul>
</li>
<li>逆境和困境往往能激发人的思维转换，从换个角度和观点看待世界、人、事情，重新审视生命的意义</li>
<li>采取主动的方式<ul>
<li>面试，可以采取主动去帮忙公司解决问题，这就是”解决方案式推销自己“，是事业成功的重要诀窍之一</li>
<li>培养责任感，主动积极去做自己的事情</li>
<li>变被动为主动，面对所有的事情提前去做</li>
</ul>
</li>
<li>积极行动与积极思考，不仅要面对现实，还要面对未来，需要有足够积极态度和能力去面对未来可能发生的一切</li>
<li>聆听自己的语言，判断是否自己是积极，还是消极的<ul>
<li>积极的人会说，有没有其他可能性？做不同的选择，控制情绪，有效的表达，选择恰当的回应，我选择，我更愿意，我打算？</li>
<li>消极的人会说，无能为力，气疯了，我就是这样，只能这么做，不能，不得不，要是。。。就好了</li>
</ul>
</li>
<li>积极主动更多的是行动，而不是想想而已</li>
<li>关注圈与影响圈，是判断一个人是否积极的标准<ul>
<li>关注圈，关注感兴趣的事情，如：家庭、技术、健康、子女等</li>
<li>影响圈，是能在自己控制范围内的事情</li>
</ul>
</li>
<li>积极主动的人会专注自己的影响圈，专心做自己能力所及的事情，使得影响圈不断扩大</li>
<li>消极被动的人会专注关注圈，关注周围的人和环境问题，抓住超出能力范围外的事情不放，怨天尤人，从而不断压缩自己的影响圈</li>
<li>关注圈与影响圈真正平衡点，关注圈不小于影响圈</li>
<li>什么才是自己能控制的事情呢？分为三种：<ul>
<li>直接控制，问题与自己有关系，可以通过培养良好的习惯去解决</li>
<li>间接控制，问题与他人有关系，通过改进施加影响去解决</li>
<li>无法控制，无能为力或无法解决，如：过去的问题，和现实的环境，以微笑面对现实，纵使有太多不满，也要泰然处之</li>
</ul>
</li>
<li>怎么做才能扩大影响圈？<ul>
<li>专注于自己的影响圈内的事情，积极主动去处理相关事宜</li>
<li>多说自己可以，由内到外去做事情，先改变个人行为，更充实，更具创造力，再施加影响去改变环境</li>
</ul>
</li>
<li>面对错误的选择，怎么处理？<ul>
<li>应该承认错误，改正并从中吸取教训，做到”失败是成功之母“</li>
</ul>
</li>
<li>影响圈的核心，就是做出承诺与信守承诺的能力，说到做到</li>
<li>掌控人生的途径：<ul>
<li>做出承诺，然后遵守承诺</li>
<li>确定目标，付诸实践</li>
</ul>
</li>
<li>知识、技巧和意愿都在影响圈内，改善任何一者都同时提升三者的平衡，当三者交集越大，那么习惯和原则就越完善，就越容易实现高效的人生</li>
<li>30天实践，按照下面的积极主动原则去生活<ul>
<li>全部精力都放到影响圈内</li>
<li>从各种小事做起，说到做到</li>
<li>学会照亮他人的蜡烛，而不是评判对错的判官</li>
<li>解决问题，而不是制造事端</li>
</ul>
</li>
<li>行动建议<ul>
<li>写下本周面临的挑战和问题，分别归入哪个圈子，回想一下你的回应是什么？<ul>
<li>挑战/问题    圈子（关注、影响）  回应（积极 or 消极）</li>
</ul>
</li>
<li>设法扩大自己的影响圈，做出了什么改变，克服了什么困难？</li>
<li>找一个难以解决的问题，判断是属于直接控制、间接控制，还是无法控制的问题，然后在影响圈内找到解决问题的第一步，然后付诸行动</li>
<li>有什么事情一直想做，但是缺乏时间，天赋或能力，为了克服这些弱点或痛点，你应当做什么？新的一周又能为其做什么事呢？</li>
<li>开发一项新的功能，你希望是什么？</li>
<li>能到世界某一个地方旅行，你希望是哪里？</li>
<li>改变生活中的某件事情，想改变哪个？</li>
<li>制定上面三个愿望的计划</li>
</ul>
</li>
</ul>
</li>
<li>第四章 习惯二 以终为始 —— 自我领导的原则<ul>
<li>和内在力量相比，身外之物显得微不足道。—— 奥利弗·温德尔·霍姆斯<ul>
<li>这句话表达的是，内心真正的需求和力量才是真正你所依靠的东西，所有外面的东西都无法影响到你。</li>
</ul>
</li>
<li>一个案例，如果你正在参加自己的葬礼，大家都在评论你的一生，那么需要你扪心自问，你准备过怎么样的一生</li>
<li>以终为始的定义<ul>
<li>做任何事情前，都要认清方向，避免在做事情的过程误入歧途</li>
<li>明确目标是比做事情还要重要的事情</li>
<li>只有明确的目标才能更加高效的工作</li>
</ul>
</li>
<li>以终为始的原则 —— 任何事情都是两次创造而成<ul>
<li>第一次创造，在头脑构思，是智力上的创造</li>
<li>第二次创造，是付诸实践，是体力上的创造</li>
</ul>
</li>
<li>问题：很多时候，我们的第一次创造都是被社会/环境/父母被动创造出来的， 这与我们主动设计的第一次创造是不同的</li>
<li>以终为始的原则 —— 自我领导<ul>
<li>自我领导是以终为始的基础</li>
<li>领导是第一次创造，是思想，怎么才能有效的把事情做好</li>
<li>领导是做正确的事情，管理是正确的做事</li>
</ul>
</li>
<li>有效的领导和有效的管理，是高效做事不可避免两个因素，其中有效的领导往往比有效的管理还要重要</li>
<li>改变人生剧本：成为自己的第一次创造者<ul>
<li>赢自己，才是真正赢得人生，每天都比昨天的自己做的更加好一点</li>
<li>教育孩子，不要忘记目的，不是为了教训，而是希望通过教训去教育孩子学会一些东西</li>
</ul>
</li>
<li>以终为始的需要树立正确的价值观，等同于个人宣言或个人承诺，如何树立：<ul>
<li>利用自我意识检查我们的地图或思维方式是否符合实际，是否基于正确原则</li>
<li>利用良知作为罗盘审视我们的行为</li>
<li>利用想象力制定我们的人生目标</li>
</ul>
</li>
<li>以终为始的做法，是以影响圈的核心 —— 观察世界的眼镜 ，去驱动我们人生四个成长方向：<ul>
<li>安全感，价值观，认同，情感归属，是自尊自重，与人生的基本能力</li>
<li>人生方向，是地图和内心的原则，是做事的决策原则</li>
<li>智慧，对生命认知，对平衡的感知，对事物间联系的理解，包括：判断力，洞察力，理解力</li>
<li>力量，行动力，达成目标的能力，培育有效的习惯代替顽固旧习</li>
</ul>
</li>
<li>生活重心=人生方向，每个人的生活重心都不一样，如：以家庭，以工作，以金钱等</li>
<li>选择不同的重心，导致生活方式和结果都不一样</li>
<li>识别自己的生活重心 —— 从上面几个方向可以识别出来</li>
<li>正确的生活重心 —— 以原则为重心，所有的选择都源自自己内心真正想要的<ul>
<li>需要编写的人生宣言</li>
</ul>
</li>
<li>左右脑的作用<ul>
<li>左脑，逻辑与语言能力，文字</li>
<li>右脑，创造与直觉能力，图像</li>
<li>整个大脑去解决问题，扩宽思路</li>
</ul>
</li>
<li>开发右脑的两种途径<ul>
<li>意外刺激打击，从左脑思维转换为右脑思维</li>
<li>自觉转换，通过想象一些场景，如：退休生活，给自己写死亡悼词，开动脑筋，尽最大的热情去想象和情感，以及每一个细节</li>
<li>心灵演练，就是开发右脑的一种方式</li>
</ul>
</li>
<li>如何撰写个人宣言，也就是人生目标<ul>
<li>确定正确行为，五个基本要素<ul>
<li>个人</li>
<li>积极</li>
<li>果断</li>
<li>可视</li>
<li>情感</li>
<li>例子，发现子女行为不当时，我（个人 ）能以智慧、爱心、坚定的立场与自制力（积极 ）及时应对（果断 ），结果让我深感欣慰（情感 ）。</li>
</ul>
</li>
</ul>
</li>
<li>心灵演练，是要做可视的，每天抽几分钟时间去想象自己可能面临的场景，越详细越好，然后身临其境的去体会那种感觉，最终让自己想出面对这种场景，应该遵循自己的价值观和人生诺言去做出选择</li>
<li>心灵演练的可视化和确认步骤是一个完整体系，具体包括如下：<ul>
<li>潜意识，也叫阈下意识，就是人无意识的行为</li>
<li>神经语言，</li>
<li>放松</li>
<li>自我谈话</li>
</ul>
</li>
<li>在做人生目标的时候，应该按照不同角色去思考，尽量兼顾全局，如：生活中的父母/丈夫等</li>
<li>人生目标案例：<ul>
<li>我的的使命是堂堂正正地生活，并且对他人有所影响，对社会有所贡献。</li>
<li>为完成这一使命，我会要求自己：</li>
<li>有慈悲心——亲近人群，不分贵贱，热爱每一个人。</li>
<li>甘愿牺牲——为人生使命奉献时间、才智和金钱。</li>
<li>激励他人——以身作则，证明人为万物之长，可以克服一切困难。</li>
<li>施加影响——用实际行动改善他人的生活。</li>
<li>为了完成人生使命，我将优先考虑以下角色：</li>
<li>丈夫——妻子是我这一生中最重要的人，我们同甘共苦，携手前行。</li>
<li>父亲——我要帮助子女体验乐趣无穷的人生。</li>
<li>儿子/兄弟——我不忘父子、手足的亲情，随时对他们施以援手。</li>
<li>基督徒——我信守对上帝的誓言，并为他的子民服务。</li>
<li>邻居——我要学习像耶稣一样爱和善待他人。</li>
<li>变革者——我能激发和催化团队成员的优异表现。</li>
<li>学者——我每天都学习很多重要的新知识。</li>
</ul>
</li>
<li>不管是个人/家庭/企业，都需要有自己的使命宣言</li>
</ul>
</li>
<li>第五章 习惯三 要事第一 —— 自我管理的原则<ul>
<li>重要之事决不可接受芝麻绿豆小事牵绊 —— 歌德<ul>
<li>表达的是，当你在做重要的事情的时候，不要被其他无关小事影响到你的注意力和时间</li>
</ul>
</li>
<li>如何分析哪些事是重要的？<ul>
<li>哪些事情能够彻底改变你的个人生活，但一直没做</li>
<li>哪些事情能够彻底改变你的工作局面，但一直没做</li>
</ul>
</li>
<li>习惯三是习惯一/二的具体实践<ul>
<li>习惯一 积极主动，告诉你需要掌控你自己的人生，自我意识的觉醒</li>
<li>习惯二 以终为始，去创造属于自己想要的东西，设定自己真正想要的东西</li>
<li>习惯三 要事第一，是让积极主动和以终为始的想法落地真正现实中，去努力实现自己想要的生活</li>
</ul>
</li>
<li>左脑进行管理，右脑进行领导</li>
<li>独立意志：有效管理的先决条件<ul>
<li>独立意志指的是做出决定和主动选择，并根据这些决定和选择采取具体行动的能力</li>
</ul>
</li>
<li>自我管理的实质就是自律和条理，是对计划的实施。</li>
<li>成功者能为失败者所不能为，纵使并非心甘情愿，但为了理想和目标，仍可以凭毅力克服心理障碍</li>
<li>时间管理理论演进<ul>
<li>第一代，利用便条和备忘录，在忙碌中调配时间与精力</li>
<li>第儿代，强调事项与日程表，反映时间管理已经注意到未来规划的重要性</li>
<li>第三代，讲求优先顺序的观念，依据轻重缓急四象限去制定短/中/长期目标，再逐日订制每日计划，有效时间获得更高效率</li>
<li>第四代，不再讲时间管理，而是注重个人管理，将重心从时间与事务中迁移到产出与产能的平衡中</li>
</ul>
</li>
<li>第四代时间管理实战，按照重要/紧急四象限去对事情分级：<ul>
<li>I类，重要紧急，如：危机/迫切问题/在限定时间内必须完成任务</li>
<li>II类，重要不紧急，如：预防性事情/建立关系/明确新的发展机会</li>
<li>III类，紧急不重要，如：接待访客/会议/迫切需要解决的事务/公共活动</li>
<li>IV 类，不紧急不重要，如：琐碎事情/信息/电话/消磨时间的活动/令人愉悦的活动</li>
</ul>
</li>
<li>上面四类事件，应该是平衡发展的，不管将重点倾向哪一方，忽略哪一方都形成很大的问题<ul>
<li>只处理重要紧急的问题，那么就会压力大，筋疲力尽，被危机牵着鼻子走</li>
<li>只处理紧急不重要问题，那么就会急功近利，巧言令色，轻视目标和计划，人际关系肤浅</li>
</ul>
</li>
<li>高效能的做法是：<ul>
<li>避免陷入第三类和第四类事情，不管是否紧急</li>
<li>花费更多时间在第二类事情上，去减少第一类事情的数量</li>
</ul>
</li>
<li>第二类事情包括：<ul>
<li>建立人际关系</li>
<li>建立人生目标</li>
<li>规划长期目标</li>
<li>原则：防患于未然</li>
</ul>
</li>
<li>用于对琐事说不，因为你要专注于主要事情，如果不说“不”，你将永远无法完成主要事情</li>
<li>自制力，源自于确定目标，只有确定目标后，确定以目标为中心去做主要事情，才能拥有独立意志</li>
<li>集大成的时间管理理论，强调产出与产能的平衡，着重第二类事务，以原则目标为中心</li>
<li>时间管理的六大标准<ul>
<li>和谐一致 个人理想/角色/目标/工作重点/计划/欲望/自制力，必须一致的</li>
<li>平衡功能 需要平衡不同角色的不同时间安排</li>
<li>围绕中心 不以时间的紧迫来的定优先级 而是通过事情的重要性定优先级，以一周为周期</li>
<li>以人为本 个人管理在于人，不在事，有效的管理有时候需要迁就别人，牺牲效率</li>
<li>灵活变通 管理方法并非一成不变，随环境或个人调整</li>
<li>便于携带 管理工具便于携带，随时可调整</li>
</ul>
</li>
<li>自我管理，安排第二类事情的的四个步骤<ul>
<li>确认角色，确定你的关键角色，记录你在下一周应该要角色和任务，</li>
<li>选择目标，按照不同角色确定你下一周要做的事情，同时确定哪些事是第二类事情（与长期目标关联）</li>
<li>安排进度，为每一项确定具体时间表，一般是周末两天开始制定</li>
<li>每日调整，每天不断更新和调整自己的时间表，根据突发事件/人际关系等，每天清晨审视自己的时间表</li>
</ul>
</li>
<li>所有事情都要付出实践，只有正在去做才能知道行不行</li>
<li>高效秘诀 —— 授权， 将责任分配给其他熟练的人，是管理上最大的成长</li>
<li>授权类型：<ul>
<li>指令型授权，关注重点是方法，为最后的结果负责，简单点说，就是怕别人做的不如自己做的好，还是希望按照自己的想法去做</li>
<li>责任型授权，关注最终的结果，给别人最大的自由，虽然过程很难，但是却能获得更好的结果，下面从五个方面达成共识<ul>
<li>预期成果，以结果为中心，详细描述结果和最终结果时间</li>
<li>指导方针，确定评估标准，避免成为指令型授权，从主导变成协助</li>
<li>可用资源，告知对方可以利用的资源，如：人力/技术/财务等</li>
<li>责任归属，制定业绩标准，评估最终结果</li>
<li>明确奖惩，评估结果后，确定好与不好的奖励与惩罚</li>
</ul>
</li>
</ul>
</li>
<li>信任是促进人进步最大动力</li>
<li>授权的大原则不变，但是要因人而异<ul>
<li>不成熟的人，目标不高，指示要详细，监督要频繁</li>
<li>成熟的人，目标要有挑战性，精简指示，减少监督</li>
</ul>
</li>
<li>以要事为中心的思维定式，是从重要性而不是紧迫性去观察一切事务</li>
<li>付诸行动，练习<ul>
<li>名人名言：成功的人习惯去做失败者不喜欢做的事，他们当然也不喜欢做，但是他们让这种不喜欢服从于对自己目标的追求</li>
<li>我的时间是怎么度过的</li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>第3部分 公众领域的成功：从独立到互赖<ul>
<li>第六章 人际关系的本质<ul>
<li>没有信任就谈不上友谊，没有诚实也谈不上信任。 —— “塞缪尔·约翰逊”<ul>
<li>这就是人际关系的本质就是信任，只有双方建立良好的信任，那么就可以维持互相的关系</li>
</ul>
</li>
<li>良好人际关系的基础是自制与自知之明。<ul>
<li>爱人之前，先爱自己</li>
<li>独立是建立良好关系的基础</li>
<li>修身是公众领域成功的基础</li>
</ul>
</li>
<li>“情感账户”，将人际关系中产出与产能平衡的原理<ul>
<li>增加情感账户存款的行为：<ul>
<li>礼貌，诚实，仁慈与信用</li>
</ul>
</li>
<li>减少情感账户存款的行为：<ul>
<li>粗鲁，轻蔑，威逼与失信</li>
</ul>
</li>
</ul>
</li>
<li>越是持久的关系，越需要不断的储蓄，就是需要不断维护关系，增加双方的信任感</li>
<li>孩子的教育就是最经典的例子，需要平时不断与其沟通，如下：<ul>
<li>聆听他的反馈</li>
<li>理解他的行为</li>
<li>在乎他，尊敬他</li>
</ul>
</li>
<li>速战速决是不切实际的，建立和维护关系都需要时间</li>
<li>建立和维护人际关系是一种长期的投资行为</li>
<li>7种投资人际关系的行为<ol>
<li>理解他人，是一切关系的基础，可以这么做：<ul>
<li>重视一个人，必须重视他所重视的事情</li>
<li>了解一个人的实际需求，给予帮助和支持</li>
</ul>
</li>
<li>注意细节，人际关系中，最重要的就是这些细节，如：忽视礼貌，不经意的失言等<ul>
<li>无论年龄和资历，哪怕最坚强和冷漠的外表下，都有一颗脆弱的心</li>
</ul>
</li>
<li>信守承诺，守信是获取信任的第一步，一次失信的代价是巨大的</li>
<li>明确期望，人际关系的障碍都源于角色和目标期望不一致<ul>
<li>正确的行为是明确提出要求，让相关的人都了解</li>
<li>要做到这一点需要投入很多时间和精力，但是却能减少后面很多麻烦和周折</li>
</ul>
</li>
<li>正直诚信，是其他感情投资的基础，有一说一，信守承诺，具体行为：<ul>
<li>避免背后攻击他人，同时维护不在场的人，如：别人正在批评某个人的问题，我们可以去寻找解决问题的方式</li>
<li>诚信意味着不欺骗，不使诈，不冒犯</li>
</ul>
</li>
<li>勇于道歉，诚心道歉会增加人与人之间的信任<ul>
<li>弱者才会残忍，只有强者才懂得温柔</li>
<li>一再道歉会显得不真诚，错误是人不可避免的，但是一直道歉反而会让你的诚信不断降低</li>
</ul>
</li>
<li>无条件的爱或者付出，有原则，有限度，有是非观念的爱，才是无条件的爱和付出<ul>
<li>成熟的人往往会无条件的付出，而不成熟的心理往往期望付出有所收获，叫有条件的付出</li>
</ul>
</li>
</ol>
</li>
<li>一对一的人际关系才是真正维护关系的正确认知，名人名言：“为一个人完全奉献自己，胜过拯救全世界而拼命。”<ul>
<li>其重点，一对一人际关系的维护，需要你有高尚的品格，而不是管理众人的技巧是完全不同的</li>
</ul>
</li>
<li>在互相依赖的关系，问题就代表机会，增加双方感情的机会</li>
<li>只有真正独立的人才能有效的相互依赖</li>
<li>付诸行动，实践互相依赖的行为<ul>
<li>正如身体经常需要食物以保持健康一样，人际关系也同样需要营养。</li>
</ul>
</li>
</ul>
</li>
<li>第七章 习惯四：双赢思维——人际领导的原则<ul>
<li>双赢者把生活看作一个合作的舞台，而不是角斗场，并不是：非强即弱，非弱即强</li>
<li>什么是双赢思维？就是利己利人，让大家有福同享，皆大欢喜。而不是以下其他思维：<ul>
<li>损人利己，目前大部分竞争模式所导致的，但是破解方法就是选择合适的双赢对象</li>
<li>舍己为人，还是遵循输赢模式，当一个和事佬，你赢了我认输，从而导致压抑自己，永远无法往前走</li>
<li>两败俱伤，价格战就是其中一种经典思维，但是往往不得好果</li>
<li>独善其身，是大部分人最终会选择的一种处理方式</li>
</ul>
</li>
<li>“如果实在无法达成共识，实现双赢，就不如好聚好散”</li>
<li>怎么做到双赢？五个要点：<ul>
<li>双赢品德是基础，就是双方的人品要信得过<ul>
<li>诚信</li>
<li>成熟</li>
<li>知足</li>
</ul>
</li>
<li>搭建双赢关系<ul>
<li>就是让双方搭建一个信任环境，有互相的情感，比如：喝酒聚餐等</li>
<li>“和赢/输模式的人打交道是对双赢的最大考验”</li>
<li>“交往过程本身就是很棒的投资”</li>
</ul>
</li>
<li>确定双赢协议，明确双方合作的职责，主要有以下几个点：<ul>
<li>预期结果，确定目标</li>
<li>指导方针，实现目标的方式</li>
<li>可用资源，人/财/时间等</li>
<li>任务考核，目标评估标准和时间</li>
<li>奖惩制度，根据考核确定奖惩</li>
<li>双赢管理培训/绩效协议，是培养双赢的明确指向灯</li>
</ul>
</li>
<li>需要双赢体系，创建一个好的双赢环境<ul>
<li>鼓励什么就会得到什么</li>
<li>从各个体系（培训/规划/预算/信息）去建立双赢</li>
<li>要为双赢协议创建有利的环境</li>
</ul>
</li>
<li>完成双赢过程，其实从互相为对方考虑，从而实现双赢<ul>
<li>从对方角度看问题</li>
<li>认清主要问题和顾虑</li>
<li>确定大家可以接受的结果</li>
<li>找到实现结果的各种可能途径</li>
</ul>
</li>
</ul>
</li>
<li>付诸行动，当你培养自己的双赢心态，发现一件美妙的事情，人际关系变得更加容易了。</li>
</ul>
</li>
<li>第八章 习惯五：知彼解己——移情沟通的原则<ul>
<li>寻找了解对方，然后争取对方了解自己，这个原则是人际交流有效的关键。</li>
<li>如何真正的了解对方？<ul>
<li>沟通的方式：读写听说，所以需要掌握好</li>
<li>倾听训练，是了解对方重中之重</li>
</ul>
</li>
<li>倾听训练，移情倾听，是要在情感和理智上深入理解对方<ul>
<li>先要同意对方的说法，理解对方的价值观，简单的说就是被对方影响，然后再去影响对方</li>
<li>这里需要你拥有一颗独立的心，所以习惯 1/2/3 是你独立的基础</li>
</ul>
</li>
<li>适时扮演知音，理解和感知对方，在不同时间和场景下，不同人在对待同一个事情会有不同的看法<ul>
<li>虽然有时候会费时间，但是人人都渴望知音，这方面的投资是值得</li>
</ul>
</li>
<li>表达也要技巧，要获得对方理解，品德&gt;感情&gt;理性<ul>
<li>表达自己不代表自吹自擂，而是根据对方的理解诉说自己的意见</li>
<li>知彼解己的习惯能帮你提升表达的准确度和连贯性</li>
</ul>
</li>
<li>一对一沟通，是需要不断练习，从而实现影响圈不断从内到外的扩大</li>
<li>练习沟通，需要做到：<ul>
<li>不要过于心急，要有耐心</li>
<li>尊重对方，理解对方</li>
</ul>
</li>
<li>当真正做到知彼解己的时候，你已经打开了通向创造性解决问题的大门</li>
<li>付诸行动<ul>
<li>如果你真的想寻求理解，就要丢掉诡计和伪善。</li>
</ul>
</li>
</ul>
</li>
<li>第九章 习惯六：统合综效——创造性合作的原则<ul>
<li>统合综效的心态，就是当有人和我意见不和，那么他肯定有我想不到的地方，值得我去琢磨，与所见略同的人沟通，有分歧才有收获</li>
<li>统合综效就是整体大于部分之和，简单点说就是 1+1&gt;=3</li>
<li>统合综效就是判断和尊重差异，取长补短，具体行为可以分为以下几点：<ul>
<li>敞开胸怀，博采众议</li>
<li>有担当，不怕失败，不断尝试</li>
</ul>
</li>
<li>课堂上的统合综效，要做到：<ul>
<li>鼓起勇气，诚恳交流，说别人不敢说的话，从而形成热切的交流氛围</li>
</ul>
</li>
<li>商业领域的统合综效，要做到：<ul>
<li>在相互尊重的基础上，去自由发言，各抒己见</li>
</ul>
</li>
<li>沟通三层次：<ul>
<li>相互提防</li>
<li>相互尊重</li>
<li>统合综效</li>
</ul>
</li>
<li>寻求第三条路，怎么在不放弃和不能做到统合综效之间去努力？<ul>
<li>在意见不合的时候，为了两个选择而争吵，其实还可以有第三个选择，就是大家一起努力去寻找第三个选择</li>
</ul>
</li>
<li>消极协作会导致1+1&lt;2的结果<ul>
<li>消极协作，就是大家彼此提防，玩弄权术，把对方踩在脚下才觉得自己胜利</li>
</ul>
</li>
<li>避免消极协作，就是无论做什么事都以原则为中心</li>
<li>统合综效最重要的一点，就是尊重差异<ul>
<li>重视不同个体的不同心理，情绪与智能，以及每个看到的世界都是不一样的</li>
</ul>
</li>
<li>化阻力为动力，这句话可以理解成两个：<ul>
<li>一是要化解阻力，</li>
<li>二是要增加动力，</li>
<li>两者缺一不可，只针对某一方面都达不到自己想要的结果</li>
</ul>
</li>
<li>以习惯四（双赢）为目标，以习惯五（知彼解己）为技巧，以习惯六（统合综效）为交往方式，就可以营造出一个可以畅所欲言的环境</li>
<li>不一定要表示赞同，而是表达肯定，以及理解对方的观点</li>
<li>付诸行动</li>
</ul>
</li>
</ul>
</li>
<li>第4部分 自我提升和完善<ul>
<li>第十章 习惯七：不断更新——平衡的自我提升原则<ul>
<li>人生最值得投资的就是磨练自己，因为生活和工作需要靠自己。</li>
<li>工作赚钱本身并不能带来经济上的安全感，具备良好的学习/思考/创造与适应能力，才能利于不败之地<ul>
<li>摆脱焦虑的做法，就是不断学习，让自己变得更加强大和自信</li>
</ul>
</li>
<li>不断更新，是从以下四个层面去更新<ul>
<li>身体，锻炼，营养，压力调节，如：健康饮食，充足休息和定期锻炼，有一个好的身体（耐性，韧性，力量等）才能应付每个星期繁重的工作压力</li>
<li>精神，实现价值，忠诚，学习与冥想，如：指引人生方向，是自己内心本质，核心和价值观的坚持，只有足够的信念，才能坚持去做正确的事情</li>
<li>智力，阅读，想象，写作与规划，如：要坚持学习（阅读优秀作品），要经常正确的表达自己能力和想法（写作），只有不断学习才能不断成为更好的自己，去面对更难的挑战</li>
<li>社会/情感，服务，移情，统合综效，内在安全感，如：理解和聆听别人，去做一些创造性合作，坚守原则和肯定自我，只有去搭建自己的社交网络，才能扩大自己的影响圈，最终实现自己的目标</li>
</ul>
</li>
<li>如何从负面情绪中走出来？<ul>
<li>找一个自己呆着比较舒服的地方，什么都不管，听 3 个小时自然的声音</li>
<li>回忆自己美好的时光，那些快乐的时光，点点滴滴的细节</li>
<li>找到正确的动机，做一些事情的动机，动机不纯（只为了自己的私欲）就会诸事不顺</li>
<li>最后把忧愁的情绪放飞掉，只保留积极的一面</li>
</ul>
</li>
<li>如何改变他人？<ul>
<li>以一个人的现有表现期许之，他不会有所长进。以他的潜能和应有成就期许之，他定能不负所望。</li>
</ul>
</li>
<li>四个层面应该平衡更新，哪一个都不需要落下，否则会形成致命的缺陷，从而无法实现最终目标</li>
<li>7 个习惯的的逻辑：<ul>
<li>当你变得积极主动，就可以自我领导和管理自己</li>
<li>当你越来越有效管理自己，就可以不断自我提升和完善自己</li>
<li>当你不断提升，你就能越来越理解其他人</li>
<li>当你越来越理解他人，那么就越有可能找到双赢的解决方案</li>
<li>当你在不断学习，那么上面就进入一个螺旋上升的趋势</li>
</ul>
</li>
<li>良知是一种天赋，帮助我们自己是否背离了正确的原则，然后引导我们向这些原则靠拢。</li>
<li>如何做到自律？<ul>
<li>远离垃圾食品，坚持锻炼</li>
<li>远离淫秽/粗俗/色情的东西</li>
<li>定期阅读励志文学作品</li>
<li>培养自己的良知</li>
</ul>
</li>
<li>付诸行动</li>
</ul>
</li>
<li>第十一章 再论由内而外造就自己<ul>
<li>七个习惯浇灌出来最高级的，最美好和最甘甜的果实，就是齐心协力，就是把自己，爱人，朋友和同事合力而为一。</li>
<li>刺激与回应之间存在一段距离，成长和幸福的关键在于如何处理这段距离</li>
<li>找一个可以大家坐下来沟通的地方，然后大家说出心中真正的想法，去真正理解大家</li>
<li>由内而外的努力才能让大家真正建立充满信任和坦诚的关系</li>
<li>把基于正确的原则的精神遗产传给后世子孙</li>
<li>付诸行动</li>
</ul>
</li>
</ul>
</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试100道手写题（1）—— 手写Promise实现</title>
    <url>/face100/1-promise-face.html</url>
    <content><![CDATA[<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>今年的金三银四面试，遇到了很多新的面试八股文，其实心里对手写题或者算法题有一定抵触，因为实际工作中基本上就不会用到这些东西，但是正因为这些基础八股文，才能真正验证一个人对技术有多热爱的程度。<br>也有可能近几年没有对这些基础知识进行巩固，所以干脆一狠心，先立个flag, 准备完成100道手写题。</p>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><a id="more"></a>

<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>Promise 对象用于表示一个异步操作的最终完成（或失败）及其结果值。  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">MDN Promise</a></p>
</blockquote>
<p>下面有一张图用来显示Promise的基本流程图（源自MDN）：</p>
<p><img src="/assets/img/promises.png" alt></p>
<p>如何快速理解Promise呢？就是必须给出一个最终结果的状态处理机制函数。</p>
<p>可以想象Promise是一个排队买奶茶的操作，当你进入排队中处于pending，轮到你的时候成功买到奶茶则是fulfilled，如果中途你走开了或者轮到你的时候没买奶茶，则是买奶茶失败rejected，最后则是无论如何你都离开奶茶店，这就是finally。</p>
<p>因此Promise的有三种状态：</p>
<ul>
<li>待定（pending）:  初始状态</li>
<li>已兑现（fulfilled）: 操作成功完成</li>
<li>已拒绝（rejected）：操作失败</li>
</ul>
<p>同时Promise在成功执行后完成执行注册在自身的Promise.prototype.then函数，如果失败后会调用Promise.prototype.catch。</p>
<p><strong>重要知识点：Promise其实是通过微任务队列(Microtasks)<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/queueMicrotask" target="_blank" rel="noopener">queueMicrotask()</a>的去实现的，所以会比setTimeout等定时器任务要优先，这一点在网上很多手写Promise都忘记去实现了。</strong></p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol>
<li>内置函数，需要实例化对象后才能调用</li>
</ol>
<ul>
<li>构建函数 <code>Promise(resolve, reject)</code> 创建一个Promise对象</li>
<li><code>Promise.prototype.then()</code> 为 promise 添加被兑现状态的回调函数，其以回调函数的返回值兑现 promise。若回调函数被调用，则兑现其返回值，否则兑现原来的 promise 兑现的值。  </li>
<li><code>Promise.prototype.catch()</code> 为 promise 添加一个被拒绝状态的回调函数，并返回一个新的 promise，若回调函数被调用，则兑现其返回值，否则兑现原来的 promise 兑现的值。  </li>
<li><code>Promise.prototype.finally()</code> 为 promise 添加一个回调函数，并返回一个新的 promise，这个promise的值将为原来promise的值。而传入的回调函数将在原 promise 被敲定（无论被兑现还是被拒绝）时被调用，同时需要等待then或catch执行完后才会被执行。</li>
</ul>
<ol start="2">
<li>静态函数，可以直接调用的</li>
</ol>
<ul>
<li><code>Promise.all(iterable)</code> 返回一个新的 <code>Promise</code> 对象，等到传入所有的 <code>Promise</code> 对象都成功，则表示成功，返回值的顺序与传入顺序一致，如果有任意一个 <code>Promise</code>则表示失败</li>
<li><code>Promise.allSettled(iterable)</code> 等到所有 <code>Promise</code> 都已敲定（每个 <code>Promise</code> 都已兑现或已拒绝），与all不同在于传入每个<code>Promise</code>都会被执行一次</li>
<li><code>Promise.any(iterable)</code> 当其中的任意一个 <code>Promise</code> 成功，就返回那个成功的 <code>Promise</code> 的值，与all相反</li>
<li><code>Promise.race(iterable)</code> 无论传入的 <code>Promise</code> 是执行成功或失败，都直接返回其结果</li>
<li><code>Promise.resolve(value)</code> 返回一个状态有value决定的Promise，如果value(带有then(resolve, reject)的对象)，则会执行then方法去判断状态，如果没有则将value直接返回成功调用的值</li>
<li><code>Promise.reject(reason)</code> 返回一个状态为已拒绝的 Promise 对象，其错误信息为reason</li>
</ul>
<p>以上就是Promise的全部基础知识点，接下来我们就来实现，同时业界内也有一个<a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise/A+规范</a>，大家也可以按照其规范去实现自己的Promise。</p>
<h1 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h1><p>在手写代码之前，我们需要明白<code>Promise</code>实现的基本原理：</p>
<ul>
<li>发布订阅模式，解决<code>Promise</code>的state发生变化后需要触发的事件，如：then 或 catch</li>
<li>链式调用，<code>Promise</code>所有的方法调后都会返回一个新的<code>Promise</code>对象</li>
</ul>
<p>其中关键代码在<code>then</code>函数的实现，主要是返回一个新的<code>Promise</code>对象，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Promise的三种状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> StatusType = &#123;</span><br><span class="line">    PENDING: <span class="string">'pending'</span>,</span><br><span class="line">    FULFILLED: <span class="string">'fulfilled'</span>,</span><br><span class="line">    REJECTED: <span class="string">'rejected'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 手写Promise</span></span><br><span class="line"><span class="comment"> * @author: Qborfy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; executor 为一个函数，该函数接受两个参数，分别是resolve和reject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">        <span class="comment">// 初始化状态为pending</span></span><br><span class="line">        <span class="keyword">this</span>.status = StatusType.PENDING;</span><br><span class="line">        <span class="comment">// 初始化成功的值</span></span><br><span class="line">        <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="comment">// 初始化失败的原因</span></span><br><span class="line">        <span class="keyword">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="comment">// 成功的回调函数</span></span><br><span class="line">        <span class="keyword">this</span>.onFulfilledCallbacks = [];</span><br><span class="line">        <span class="comment">// 失败的回调函数</span></span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 成功的回调函数</span></span><br><span class="line">        <span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 状态只能从pending到fulfilled或者rejected</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === StatusType.PENDING) &#123;</span><br><span class="line">                <span class="keyword">this</span>.status = StatusType.FULFILLED;</span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">                <span class="comment">// 依次执行成功的回调函数 使用queueMicrotask()去执行</span></span><br><span class="line">                <span class="keyword">this</span>.onFulfilledCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">                    queueMicrotask(fn(<span class="keyword">this</span>.value));</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 失败的回调函数</span></span><br><span class="line">        <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 状态只能从pending到fulfilled或者rejected</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === StatusType.PENDING) &#123;</span><br><span class="line">                <span class="keyword">this</span>.status = StatusType.REJECTED;</span><br><span class="line">                <span class="keyword">this</span>.reason = reason;</span><br><span class="line">                <span class="comment">// 依次执行失败的回调函数 使用queueMicrotask()去执行</span></span><br><span class="line">                <span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">                    queueMicrotask(fn(<span class="keyword">this</span>.reason));</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 立即执行executor函数</span></span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="comment">// 如果执行executor函数出错，直接执行reject</span></span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将then方法返回的promise的resolve和reject传入</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; onFulfilled </span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; onRejected </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="comment">// onFulfilled和onRejected都是可选参数</span></span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="keyword">throw</span> err &#125;;</span><br><span class="line">        <span class="comment">// 判断结果是否为promise，如果是promise，直接返回该promise，如果不是则返回一个新的promise</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">result, resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                result.then(resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> newPromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 如果状态完成，直接执行onFulfilled</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === StatusType.FULFILLED) &#123;</span><br><span class="line">                <span class="keyword">const</span> result = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">                resolvePromise(result, resolve, reject);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果状态失败，直接执行onRejected</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === StatusType.REJECTED) &#123;</span><br><span class="line">                <span class="keyword">const</span> result = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">                resolvePromise(result, resolve, reject);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果状态为pending，将onFulfilled和onRejected存入对应的回调函数数组中</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === StatusType.PENDING) &#123;</span><br><span class="line">                <span class="comment">// 同时将resolve和reject传入对应函数中</span></span><br><span class="line">                <span class="keyword">this</span>.onFulfilledCallbacks.push(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> result = onFulfilled(value)</span><br><span class="line">                    resolvePromise(result, resolve, reject)</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> result = onRejected(reason)</span><br><span class="line">                    resolvePromise(result, resolve, reject)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newPromise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行catch方法，返回一个新的promise</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; onRejected </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不管是成功还是失败，最终会执行finally方法，返回一个原来promise的结果</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; onFinally </span></span><br><span class="line"><span class="comment">     * @returns </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">finally</span>(onFinally) &#123;</span><br><span class="line">        <span class="comment">// 这里要将原来的value或reason返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">            onFinally()</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;, (reason)=&gt;&#123;</span><br><span class="line">            onFinally()</span><br><span class="line">            <span class="keyword">return</span> reason;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> resolve() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> reject() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> all() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> allSettled() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> any() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> race() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="number">1</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'then:'</span>, res)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'finally'</span>)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'then2:'</span>, res)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'then3:'</span>, res)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(p)</span><br><span class="line">    <span class="comment">// const p2 = new MyPromise((resolve, reject) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     JSON.parse('&#123;a&#125;')</span></span><br><span class="line">    <span class="comment">// &#125;).catch((res) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     console.log('catch:', res)</span></span><br><span class="line">    <span class="comment">// &#125;).finally(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     console.log('finally2')</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>这里就不粘贴完整源码了，完整源码请到github中查看，想看更多八股文手写题可以给个star收藏一下，Github会给你推送更新信息，地址如下：</p>
<p><a href="https://github.com/qiubohong/hundred-interview-questions/blob/main/1-promise/mypromise.js" target="_blank" rel="noopener">https://github.com/qiubohong/hundred-interview-questions/blob/main/1-promise/mypromise.js</a></p>
<h1 id="Promise在开发中遇到的问题"><a href="#Promise在开发中遇到的问题" class="headerlink" title="Promise在开发中遇到的问题"></a>Promise在开发中遇到的问题</h1><ul>
<li>并发Promise，用Promise.all，那么如何实现限制并发数呢?</li>
<li>await去等待Promise的结果，如果是reject结果，如何catch，或者用其他方式避免await的错误？</li>
<li>Promise的调用时机，即是一个非异步的Promise函数什么时候会被执行，为什么会比setTimeout等定时器优先更高？</li>
</ul>
<h1 id="额外知识点"><a href="#额外知识点" class="headerlink" title="额外知识点"></a>额外知识点</h1><h2 id="微任务（Microtasks）和任务（tasks）的区别"><a href="#微任务（Microtasks）和任务（tasks）的区别" class="headerlink" title="微任务（Microtasks）和任务（tasks）的区别"></a>微任务（Microtasks）和任务（tasks）的区别</h2><p>JavaScript中的<code>任务</code>指的是将代码按照下面的标准机制去形成一个个任务，加入到<strong>任务队列</strong>中，去等待被<strong>事件循环</strong>驱动调度。</p>
<ul>
<li>一段代码被直接执行时</li>
<li>触发了一个事件，将其回调函数添加到任务队列时</li>
<li>执行到一个由 setTimeout() 或 setInterval() 创建的 timeout 或 interval，以致相应的回调函数被添加到任务队列时</li>
</ul>
<p>而<code>微任务</code>则是通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/queueMicrotask" target="_blank" rel="noopener">queueMicrotask()</a>加入微任务队列中，在事件循环之前的安全时间执行的（当前事件循环无任何需要执行任务），同时事件循环会持续调用微任务直至队列中没有留存的，即使是在有更多微任务持续被加入的情况下。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>学习总结</tag>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title>ChatGPT工具收集</title>
    <url>/ideas/20230408.html</url>
    <content><![CDATA[<h1 id="chatGPT工具收集"><a href="#chatGPT工具收集" class="headerlink" title="chatGPT工具收集"></a>chatGPT工具收集</h1><ol>
<li>chatgpt-i18n: AI自动翻译i18n.json</li>
</ol>
<p>Github地址： <a href="https://github.com/ObservedObserver/chatgpt-i18n" target="_blank" rel="noopener">https://github.com/ObservedObserver/chatgpt-i18n</a></p>
<a id="more"></a>

<ol start="2">
<li>cli-gpt: 用 ChatGPT 开发一个能听懂人话的命令行工具</li>
</ol>
<p>Github地址： <a href="https://github.com/MagicCube/cli-gpt" target="_blank" rel="noopener">https://github.com/MagicCube/cli-gpt</a></p>
<ol start="3">
<li>通过可组合性⚡使用LLMS构建应用程序</li>
</ol>
<p>Github地址： <a href="https://github.com/hwchase17/langchain?utm_source=gold_browser_extension" target="_blank" rel="noopener">https://github.com/hwchase17/langchain?utm_source=gold_browser_extension</a></p>
<ol start="4">
<li>自己创建中文GPT</li>
</ol>
<p>Github地址： <a href="https://github.com/ymcui/Chinese-LLaMA-Alpaca?utm_source=gold_browser_extension" target="_blank" rel="noopener">https://github.com/ymcui/Chinese-LLaMA-Alpaca?utm_source=gold_browser_extension</a></p>
<h1 id="创业箴言"><a href="#创业箴言" class="headerlink" title="创业箴言"></a>创业箴言</h1><ol>
<li>5年独立开发者总结</li>
</ol>
<ul>
<li>激情是把双刃剑，能让你更加干活充满精力，但是却无法带来更多资产，反而更像一种赚钱的障碍</li>
<li>无法远离人情世故，创业或独立都需要自己去面对更多的人群，如：客户、供应商等</li>
<li>社区真正的价值<ul>
<li><strong>”你不知道你不知道什么“</strong>，这句话需要经常记住</li>
<li>社区带来的是知识，是一种宝贵的学习资源，还有一起创业时候的人脉</li>
<li>听听某人的故事或关于他们项目的一般性玩笑，可能会让我接触到新的营销策略、更好的入职策略或有助于加快我的开发工作流程的工具。当我遇到新问题时，它也给了我更广泛的经验来借鉴。</li>
</ul>
</li>
<li>创业选择值得吗？没有可观的收入和花费很多时间，后续怎么走等等</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>奇思妙想</tag>
      </tags>
  </entry>
  <entry>
    <title>工具收集</title>
    <url>/ideas/20230621.html</url>
    <content><![CDATA[<h1 id="Bark语音生成引擎"><a href="#Bark语音生成引擎" class="headerlink" title="Bark语音生成引擎"></a><a href="https://github.com/suno-ai/bark" target="_blank" rel="noopener">Bark语音生成引擎</a></h1><p>一个语音生成引擎，效果不错，可以在朗读的同时，发出大笑、叹息和哭泣，还可以生成音乐。</p>
<p>地址： <a href="https://github.com/suno-ai/bark" target="_blank" rel="noopener">https://github.com/suno-ai/bark</a></p>
<h1 id="STDF-移动端组件库"><a href="#STDF-移动端组件库" class="headerlink" title="STDF 移动端组件库"></a><a href="https://stdf.design/#/" target="_blank" rel="noopener">STDF 移动端组件库</a></h1><p>基于 Svelte 与 Tailwind 的移动页面组件库。</p>
<p>地址： <a href="https://github.com/dufu1991/stdf" target="_blank" rel="noopener">https://github.com/dufu1991/stdf</a></p>
<h1 id="MockingBird-AI合成语音"><a href="#MockingBird-AI合成语音" class="headerlink" title="MockingBird AI合成语音"></a><a href="https://github.com/babysor/MockingBird" target="_blank" rel="noopener">MockingBird AI合成语音</a></h1><p>给出语音，合成属于自己的语音包</p>
<p>地址： <a href="https://github.com/babysor/MockingBird" target="_blank" rel="noopener">https://github.com/babysor/MockingBird</a></p>
<p>适用教程： <a href="https://www.youtube.com/watch?v=eHRHfYeoZ3g" target="_blank" rel="noopener">https://www.youtube.com/watch?v=eHRHfYeoZ3g</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>奇思妙想</tag>
      </tags>
  </entry>
  <entry>
    <title>如何用vite+vue-next快速开发chrome插件</title>
    <url>/today/20230227.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前写过一篇文章<a href="https://qborfy.com/today/20230224.html" target="_blank" rel="noopener">《从开发chrome插件到插件系统设计》</a>，主要讲述了如何开发一个chrome插件和chrome插件设计，感兴趣的同学可以再去看看。</p>
<p>目前主流web应用都是基于Vue、React等现代框架去开发，Chrome插件本身而言其实也是一个web应用，看它的组成部分<code>popup.html</code> + <code>contentscript</code> + <code>background.js</code> ，只需要在开发的时候调整一下构建脚本基本上就可以利用Vue、React等现代框架去开发了。</p>
<p>接下来，我们就一步步开始实战。</p>
<a id="more"></a>

<h1 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>利用<code>vite</code>初始化项目命令快速搭建，具体如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pnpm create vite</span><br></pre></td></tr></table></figure>

<ol>
<li>在public目录下新建manifest.json</li>
</ol>
<p>内容如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"ngptcommit"</span>,</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"1.0"</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"ngptcommit自动生成git commit信息"</span>,</span><br><span class="line">    <span class="attr">"manifest_version"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"browser_action"</span>: &#123;</span><br><span class="line">        <span class="attr">"default_popup"</span>: <span class="string">"index.html"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"icons"</span>: &#123;</span><br><span class="line">        <span class="attr">"16"</span>: <span class="string">"images/favicon-16x16.png"</span>,</span><br><span class="line">        <span class="attr">"48"</span>: <span class="string">"images/favicon-32x32.png"</span>,</span><br><span class="line">        <span class="attr">"64"</span>: <span class="string">"images/android-chrome-192x192.png"</span>,</span><br><span class="line">        <span class="attr">"128"</span>: <span class="string">"images/android-chrome-192x192.png"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"background"</span>: &#123;</span><br><span class="line">        <span class="attr">"scripts"</span>: [</span><br><span class="line">            <span class="string">"background/background.js"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"permissions"</span>: [</span><br><span class="line">        <span class="string">"tabs"</span>,</span><br><span class="line">        <span class="string">"storage"</span>,</span><br><span class="line">        <span class="string">"http://*/*"</span>,</span><br><span class="line">        <span class="string">"https://*/*"</span>,</span><br><span class="line">        <span class="string">"activeTab"</span>,</span><br><span class="line">        <span class="string">"contextMenus"</span>,</span><br><span class="line">        <span class="string">"notifications"</span>,</span><br><span class="line">        <span class="string">"webRequest"</span>,</span><br><span class="line">        <span class="string">"webRequestBlocking"</span>,</span><br><span class="line">        <span class="string">"cookies"</span>,</span><br><span class="line">        <span class="string">"unlimitedStorage"</span>,</span><br><span class="line">        <span class="string">"webNavigation"</span>,</span><br><span class="line">        <span class="string">"identity"</span>,</span><br><span class="line">        <span class="string">"identity.email"</span>,</span><br><span class="line">        <span class="string">"identity.read"</span>,</span><br><span class="line">        <span class="string">"identity.write"</span>,</span><br><span class="line">        <span class="string">"identity.launch.webauthn"</span>,</span><br><span class="line">        <span class="string">"identity.launch.webauthn"</span>,</span><br><span class="line">        <span class="string">"identity.manage.accounts"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增插件必须的文件，如：<code>manifest.json</code>和 <code>background.ts</code> ，完整目录结构如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chrome-extension</span><br><span class="line">├── README.md</span><br><span class="line">├── index.html</span><br><span class="line">├── package.json</span><br><span class="line">├── public</span><br><span class="line">|  ├── images</span><br><span class="line">|  └── manifest.json</span><br><span class="line">├── src</span><br><span class="line">|  ├── App.vue</span><br><span class="line">|  ├── background.ts</span><br><span class="line">|  ├── components</span><br><span class="line">|  ├── main.ts</span><br><span class="line">|  ├── style.css</span><br><span class="line">|  └── vite-env.d.ts</span><br><span class="line">├── tsconfig.json</span><br><span class="line">├── tsconfig.node.json</span><br><span class="line">└── vite.config.ts</span><br></pre></td></tr></table></figure>

<h2 id="调整编译"><a href="#调整编译" class="headerlink" title="调整编译"></a>调整编译</h2><p>由于vite初始化项目只针对web应用设计，但是我们开发chrome插件还需要针对<code>background.ts</code> 去做编译，就是要做多入口编译，而且vite本身就是基于rollup为基础去实现的少量配置即可完成一个web应用打包。</p>
<blockquote>
<p>一套构建指令，它使用<strong><a href="https://rollupjs.org/" target="_blank" rel="noopener"><code>Rollup</code></a></strong> 打包你的代码，并且它是预配置的，可输出用于生产环境的高度优化过的静态资源。—— Vite官网介绍</p>
</blockquote>
<p>所以我们其实可以使用<code>Rollup</code>去打包我们的<code>background.ts</code> ，就是增加多一个入口文件，具体如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; defineConfig &#125; from &apos;vite&apos;</span><br><span class="line">import vue from &apos;@vitejs/plugin-vue&apos;</span><br><span class="line">import path from &apos;path&apos;</span><br><span class="line"></span><br><span class="line">// https://vitejs.dev/config/</span><br><span class="line">export default defineConfig(&#123;</span><br><span class="line">  plugins: [vue()],</span><br><span class="line">  build: &#123;</span><br><span class="line">    rollupOptions: &#123;</span><br><span class="line">      input: &#123;</span><br><span class="line">        index: path.resolve(__dirname, &apos;index.html&apos;),</span><br><span class="line">        background: &apos;src/background.ts&apos;,</span><br><span class="line">      &#125;,</span><br><span class="line">      output: &#123;</span><br><span class="line">        entryFileNames: `[name].js`,</span><br><span class="line">        assetFileNames: `[name].[ext]`,</span><br><span class="line">        chunkFileNames: `[name].js`,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>其中有几个地方需要说明一下：</p>
<ul>
<li><code>output</code>： 设置不加<code>hash</code>值，后续调试的时候插件不会出现加载不到文件的错误</li>
<li><code>rollupOptions</code>：基本上和<code>Rollup</code>的配置项一模一样，所以有<code>Rollup</code>基础的基本上可以直接上手配置，而且也完全兼容<code>Rollup</code>的插件生态</li>
</ul>
<p>接下来就是调整<code>package.json</code>中<code>scripts</code>命令，需要针对background新增两个命令，具体如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"@node-gptcommit/chrome-extension"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.0"</span>,</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"rimraf dist &amp;&amp; vite"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"vue-tsc &amp;&amp; vite build"</span>,</span><br><span class="line">    <span class="attr">"preview"</span>: <span class="string">"vite preview"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dev:background</code> 代表开发模式</li>
<li><code>build:background</code> 代表生产模式</li>
</ul>
<p>到了这里基本上就完成了项目的搭建，接下来就进入开发阶段。</p>
<h1 id="项目开发"><a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h1><h2 id="UI开发"><a href="#UI开发" class="headerlink" title="UI开发"></a>UI开发</h2><ol>
<li>引入ui库 <code>tdesign-vue-next</code> ，tdesign是腾讯出品的全端组件库，从桌面到移动，再到小程序，应有尽有，大家可以去尝尝鲜<a href="https://tdesign.tencent.com/" target="_blank" rel="noopener">https://tdesign.tencent.com/</a></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pnpm add tdesign-vue-next</span><br></pre></td></tr></table></figure>

<ol>
<li>开发UI，这里就直接撸代码就行，就不展开来讲，主要需要注意的是，需要和background.js通讯的部分，比如需要和chatgpt发送信息，获取返回内容，具体如下:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const getSummary = () =&gt; &#123;</span><br><span class="line">    // 发送通讯，获取总结</span><br><span class="line">    chrome.runtime.sendMessage(</span><br><span class="line">        &#123;</span><br><span class="line">            type: &apos;summary&apos;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                diffs: []</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        (response) =&gt; &#123;</span><br><span class="line">            console.log(response)</span><br><span class="line">        &#125;,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编写background-ts"><a href="#编写background-ts" class="headerlink" title="编写background.ts"></a>编写background.ts</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; getSummary &#125; from &apos;@node-gptcommit/summarize&apos;</span><br><span class="line">// 监听收到通讯，发起总结请求</span><br><span class="line">chrome.runtime.onMessage.addListener(async (request: any, sender: any, sendResponse: any) =&gt; &#123;</span><br><span class="line">    const &#123; type = &apos;fetch&apos;, data &#125; = request;</span><br><span class="line">    if (type === &apos;summary&apos;) &#123;</span><br><span class="line">        getSummary(data).then(res=&gt;&#123;</span><br><span class="line">						sendResponse(res);</span><br><span class="line">				&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>在开发中遇到一个问题，就是如何快速调试chrome插件：</p>
<ol>
<li><code>build</code>后会，构建完的文件会有带<code>hash</code>值，如：<code>index.33addf.js</code>，导致chrome重新加载插件的时候出错，如：</li>
</ol>
<p><img src="/assets/img/20230227.png" alt="20230227"></p>
<p>解决方案很简单，就是利用rollupOptions设置输出文件不带hash值即可。</p>
<ol start="2">
<li>没法实时调试插件，每次都需要<code>build</code>后才能去调试，这里需要更改构建方式，因为我们build出来的页面才是我们需要的，所以我们需要在<code>build</code>时候增加<code>--watch</code>，然后真正发布构建的时候关闭<code>watch</code>，调整后，<code>package.json</code>内容如下：</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"@node-gptcommit/chrome-extension"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.0"</span>,</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"vue-tsc &amp;&amp; vite build --watch"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"rimraf dist &amp;&amp; vue-tsc &amp;&amp; vite build"</span>,</span><br><span class="line">    <span class="attr">"preview"</span>: <span class="string">"vite preview"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>项目源码Github地址：<a href="https://github.com/qiubohong/node-gptcommit" target="_blank" rel="noopener">node-ngptcommit</a>，觉得有帮助的同学帮忙给个star给鼓励一下~❤️</p>
<p>后面基本上就是按照正常项目去开发即可，本文总结几个要点：</p>
<ul>
<li>chrome插件开发和正常web应用不太应用，既包括了html页面，也包括background.js的js库开发模式</li>
<li>Vite的核心点其实是Rollup，如果掌握Rollup基本上对vite做二次配置也很容易入手</li>
<li>为什么使用Vue，因为有大量的UI库和相关生态可以使用，能提高开发效率</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>2023年读书计划</title>
    <url>/study/2023-read-plan.html</url>
    <content><![CDATA[<h1 id="2023年读书计划"><a href="#2023年读书计划" class="headerlink" title="2023年读书计划"></a>2023年读书计划</h1><p>今年给自己的制定的计划，主要读书目标有以下几类：</p>
<ul>
<li>给自己的创业带来理论帮助</li>
<li>给自己的职业带来成长</li>
<li>给自己的更加开阔的视野</li>
<li>解答一些人生疑惑</li>
<li>提高自己的做事效率</li>
<li>提高自己的表达能力或演讲能力</li>
<li>搭建自己的股市交易系统<a id="more"></a>

</li>
</ul>
<h2 id="个人发展"><a href="#个人发展" class="headerlink" title="个人发展"></a>个人发展</h2><ul>
<li>已读<ul>
<li>百万富翁快车道，待写阅读后总结</li>
</ul>
</li>
<li>在读<ul>
<li>每周工作4小时，需要再次阅读后写总结</li>
<li>致所有疯狂的家伙：维珍创始人自传，需要再次阅读后写总结</li>
<li>高效人士的7个习惯，需快速阅读一遍后，再精读一遍</li>
</ul>
</li>
<li>待读<ul>
<li>金字塔表达力：用麦肯锡方法提升写作力和演讲力（实战图解版）</li>
<li>人性的弱点</li>
<li>乌合之众</li>
<li>王阳明心学——知行合一</li>
</ul>
</li>
</ul>
<h2 id="经济学"><a href="#经济学" class="headerlink" title="经济学"></a>经济学</h2><ul>
<li>已读</li>
<li>在读</li>
<li>待读<ul>
<li></li>
</ul>
</li>
</ul>
<h2 id="股市交易"><a href="#股市交易" class="headerlink" title="股市交易"></a>股市交易</h2><ul>
<li>已读</li>
<li>在读</li>
<li>待读<ul>
<li>思考的框架</li>
<li>海龟交易法则</li>
<li>投资的原则</li>
<li>我如何从股市赚了200万</li>
<li>股市投资的24堂必修课</li>
<li>我来教你变富</li>
</ul>
</li>
</ul>
<h2 id="技能类"><a href="#技能类" class="headerlink" title="技能类"></a>技能类</h2><ul>
<li>已读</li>
<li>在读<ul>
<li>Vue源码</li>
</ul>
</li>
<li>待读<ul>
<li>领域驱动设计</li>
</ul>
</li>
</ul>
<h2 id="人文类"><a href="#人文类" class="headerlink" title="人文类"></a>人文类</h2><ul>
<li>在读<ul>
<li>天道</li>
</ul>
</li>
<li>待读<ul>
<li>三体</li>
<li>人类简史</li>
</ul>
</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Typescript基础：如何更好的生成Typescript声明文件.d.ts</title>
    <url>/today/20230226.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Typescript已经被前端广泛使用，如果你的项目还没有使用，建议赶紧使用起来，真的会对你的项目有足够的提升：</p>
<ul>
<li>让你的每个变量都有变量声明</li>
<li>让你的每个方法找到其源头</li>
<li>让你能提前使用一些超前的JavaScript语法，如：注解(装饰器)<code>@controller</code> 等语法糖</li>
</ul>
<p>但是使用的过程也会带来一些痛苦，比如你要做一个js lib库，如果用<code>Typescript</code> 开发确实可以帮助其他者快速使用，但是如果你没有注意Typescript的声明文件规范，很容易出现以下使用情况：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会直接从src目录去寻找</span></span><br><span class="line"><span class="keyword">import</span> &#123; IClient &#125; <span class="keyword">from</span> <span class="string">'xxx-lib/src/client.d.ts'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 而我们所期待的使用是</span></span><br><span class="line"><span class="keyword">import</span> &#123; IClient&#125; <span class="keyword">from</span> <span class="string">'xxx-lib'</span></span><br></pre></td></tr></table></figure>

<p>所以我们需要学习一下，如何更好的生成我们的Typescript声明文件。</p>
<a id="more"></a>

<h1 id="Typescript声明文件"><a href="#Typescript声明文件" class="headerlink" title="Typescript声明文件"></a>Typescript声明文件</h1><blockquote>
<p>声明文件：当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。</p>
</blockquote>
<p>从官网定义而言，<code>声明文件.d.ts</code>就是用来给IDE编辑器解析<code>Typescript</code>代码声明的地方。</p>
<h2 id="学习声明"><a href="#学习声明" class="headerlink" title="学习声明"></a>学习声明</h2><p>目前Typescript提供各种类型，我们常用的有以下几种：</p>
<ul>
<li><code>declare var</code> 声明全局变量，如：<code>declare var jQuery: (selector: string) =&gt; any;</code> ，我们就可以在全局中使用<code>jQuery</code> 变量而不会报错</li>
<li><code>declare function</code> 声明全局方法</li>
<li><code>declare class</code> 声明全局类</li>
<li><code>declare enum</code> 声明全局枚举类型</li>
<li><code>declare namespace</code> 声明（含有子属性的）全局对象</li>
<li><code>interface</code> 和 <code>type</code> 声明全局类型</li>
</ul>
<p>其中，<code>declare</code>基本上都根据<code>Typescript</code> 中会自动生成，而<code>interface</code>和<code>type</code>则需要我们自己声明，自己使用。</p>
<h2 id="生成声明文件"><a href="#生成声明文件" class="headerlink" title="生成声明文件"></a>生成声明文件</h2><p>当你完成一个lib库开发，这个时候需要对外提供你声明文件，如：<code>import foo from &#39;foo&#39;</code></p>
<p>如果你需要对自己的<code>npm包</code>制作声明文件，具体有以下几个步骤：</p>
<ol>
<li>在<code>package.json</code>中的<code>types</code>和<code>typings</code> ，如：<code>&quot;types&quot;:&quot;dist/typings/index.d.ts&quot;</code></li>
<li>在项目根目录创建<code>typings</code> ，新建一个<code>index.d.ts</code> 用来暴露你lib库相关的声明</li>
<li>在<code>typescript.json</code>配置文件中，添加入口，如：<code>&quot;includes&quot;:[&quot;./typings/index.d.ts&quot;]</code></li>
</ol>
<p><strong>PS:</strong> <code>types</code>和<code>typings</code> 两者在package.json具有相同意义</p>
<p><code>package.json</code>示例如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"@node-gptcommit/git-utils"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"关于git的一些工具函数"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"dist/index.js"</span>,</span><br><span class="line">  <span class="attr">"types"</span>: <span class="string">"./dist/typings/index.d.ts"</span>,</span><br><span class="line">  <span class="attr">"typings"</span>: <span class="string">"./dist/typings/index.d.ts"</span>,</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"tsc -p tsconfig.release.json --outDir dist &amp;&amp; cp -r typings dist"</span></span><br><span class="line">  &#125;,</span><br><span class="line">	<span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">		<span class="attr">"@types/node"</span>: <span class="string">"^16"</span>,</span><br><span class="line">		<span class="attr">"tslib"</span>: <span class="string">"^2.2.0"</span>,</span><br><span class="line">		<span class="attr">"typescript"</span>: <span class="string">"^4.7.2"</span></span><br><span class="line">	&#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"simple-git"</span>: <span class="string">"^3.17.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"qborfy"</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"MIT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>typescript.json</code> 示例如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"include"</span>: [</span><br><span class="line">    <span class="string">"src/*"</span>,</span><br><span class="line">    <span class="string">"typings/index.d.ts"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"baseUrl"</span>: <span class="string">"."</span>,</span><br><span class="line">    <span class="attr">"rootDir"</span>: <span class="string">"."</span>,</span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"ES2019"</span>,</span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"ESNext"</span>,</span><br><span class="line">    <span class="attr">"moduleResolution"</span>: <span class="string">"node"</span>,</span><br><span class="line">    <span class="attr">"strict"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"esModuleInterop"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"noImplicitOverride"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"noUnusedLocals"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"useUnknownInCatchVariables"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"declaration"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"declarationDir"</span>: <span class="string">"dist"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"exclude"</span>: [<span class="string">"node_modules"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="index-d-ts实现"><a href="#index-d-ts实现" class="headerlink" title="index.d.ts实现"></a>index.d.ts实现</h2><p>前面基本知道Typescript声明和如何在package.json标注好当前npm包会使用哪个声明文件，那么接下来，我们应该如何一个index.d.ts，主要靠以下几个：</p>
<ul>
<li><code>export</code> 导出变量</li>
<li><code>export namespace</code> 导出（含有子属性的）对象</li>
<li><code>export default</code> ES6 默认导出</li>
<li><code>export =</code> commonjs 导出模块</li>
</ul>
<p><strong>PS:</strong> 只有只有 <code>function</code>、<code>class</code>和 <code>interface</code> 支持<code>export default</code> </p>
<p><code>index.d.ts</code>示范：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// index.d.ts</span><br><span class="line">// 将src中的声明文件引入过来</span><br><span class="line">export * from &apos;../src/index&apos;;</span><br><span class="line"></span><br><span class="line">// 导出声明的函数</span><br><span class="line">export declare function bar(): string;</span><br></pre></td></tr></table></figure>

<p>使用<code>demo.js</code>示范：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//demo.js</span><br><span class="line">// 使用就如下 bar就是一个函数</span><br><span class="line">import &#123; bar &#125; from &apos;libs&apos;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>

<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>发布声明文件一般有两种做法：</p>
<ul>
<li>一种是发布到<code>@types/xxx</code> ，在<code>types</code>目录下新建一个<code>package.json</code>去维护，不推荐</li>
<li>另外一种是和<code>npm包</code>一起发布，目前基本上大多数都采用这种，本文也使用采用这种</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html" target="_blank" rel="noopener">《Typescript官网：声明文件》</a></li>
<li><a href="https://ts.xcatliu.com/basics/declaration-files.html" target="_blank" rel="noopener">《Typescript中文教程》</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>MonoRepo实战：pnpm+nx搭建MonoRepo项目</title>
    <url>/today/20230225.html</url>
    <content><![CDATA[<h1 id="MonoRepo实战：pnpm-nx搭建MonoRepo项目"><a href="#MonoRepo实战：pnpm-nx搭建MonoRepo项目" class="headerlink" title="MonoRepo实战：pnpm+nx搭建MonoRepo项目"></a>MonoRepo实战：pnpm+nx搭建MonoRepo项目</h1><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前有写过几篇关于monorepo的文章，具体如下：</p>
<ul>
<li><a href="https://qborfy.com/today/20230107.html" target="_blank" rel="noopener">从npm版本依赖到Monorepo大仓项目</a></li>
<li><a href="https://qborfy.com/today/20230119.html" target="_blank" rel="noopener">从lerna到初步了解和使用Nx(一)</a></li>
<li><a href="https://qborfy.com/today/20230219.html" target="_blank" rel="noopener">从pnpm工具了解整个npm包核心管理原理</a></li>
</ul>
<p>再次复习一下<code>MonoRepo</code>的概念：</p>
<blockquote>
<p>Monorepo是包含多个不同项目的单一存储库，且不同项目之间具有明确定义的关系。</p>
</blockquote>
<p>之前大多数是理论知识，能让我们知道<code>pnpm</code> 和<code>nx</code> 是什么，但是具体要到项目实战就有点懵，不知道从而下手，下面我们就一步步开始搭建<code>pnpm</code>+<code>nx</code>的Monorepo仓库。</p>
<p>PS：这里将会从已有项目中去开始踩坑，这里用的是之前做一个<a href="https://github.com/qiubohong/node-gptcommit.git" target="_blank" rel="noopener">node-gptcommit</a>命令行工具+一个chrome插件，将两个项目放到一个Monorepo仓库去管理。 </p>
<a id="more"></a>
<h1 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h1><h2 id="第一步，项目结构调整"><a href="#第一步，项目结构调整" class="headerlink" title="第一步，项目结构调整"></a>第一步，项目结构调整</h2><p>先来看看原先<code>node-gptcommit</code> 项目结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node-gptcommit</span><br><span class="line">├── bin</span><br><span class="line">|  └── ngptcommit.js</span><br><span class="line">├── dist</span><br><span class="line">|  ├── ...</span><br><span class="line">├── src</span><br><span class="line">|  ├── ...</span><br><span class="line">├── test</span><br><span class="line">|  ├── ...</span><br><span class="line">├── jest.config.js</span><br><span class="line">├── babel.config.js</span><br><span class="line">├── package.json</span><br><span class="line">├── pnpm-lock.yaml</span><br><span class="line">├── rollup.config.ts</span><br><span class="line">├── tsconfig.json</span><br><span class="line">└── tslint.json</span><br><span class="line">├── README.en.md</span><br><span class="line">├── README.md</span><br></pre></td></tr></table></figure>

<p>再看一下<code>node-gptcommit-chrome</code>项目的目录结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node-gptcommit-chrome</span><br><span class="line">├── dist</span><br><span class="line">|  ├── ...</span><br><span class="line">├── src</span><br><span class="line">|  ├── ...</span><br><span class="line">├── test</span><br><span class="line">|  ├── ...</span><br><span class="line">├── index.html</span><br><span class="line">├── package.json</span><br><span class="line">├── public</span><br><span class="line">├── tsconfig.json</span><br><span class="line">├── tsconfig.node.json</span><br><span class="line">└── vite.config.ts</span><br><span class="line">├── README.md</span><br></pre></td></tr></table></figure>

<p>接下来我们把项目结构做一下调整，将两个项目的代码挪到<code>packages</code>目录下，同时在新项目中初始化<code>npm init</code> ，大概结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node-gptcommit</span><br><span class="line">├── apps # 应用层</span><br><span class="line">|  ├── chrome-extension # chrome插件</span><br><span class="line">|  |  ├── ...</span><br><span class="line">|  └── node-cli # 命令行工具</span><br><span class="line">|     ├── ...</span><br><span class="line">├── libs # 封装好的lib库</span><br><span class="line">|  └── summarize # 总结AI客户端 </span><br><span class="line">|     ├── ...</span><br><span class="line">├── README.md</span><br><span class="line">├── package.json</span><br></pre></td></tr></table></figure>

<h2 id="第二步，项目初始化"><a href="#第二步，项目初始化" class="headerlink" title="第二步，项目初始化"></a>第二步，项目初始化</h2><p>前提条件准备：</p>
<ul>
<li>安装全局<code>pnpm</code></li>
<li>升级node版本到16.19.0+，这里可以通过pnpm去管理node版本</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先安装全局pnpm 后续需要根据pnpm + workplace去管理</span></span><br><span class="line">npm install pnpm -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换node版本</span></span><br><span class="line">pnpm env use --global 16</span><br></pre></td></tr></table></figure>

<h3 id="2-1-创建pnpm-workplace"><a href="#2-1-创建pnpm-workplace" class="headerlink" title="2.1 创建pnpm workplace"></a>2.1 创建pnpm workplace</h3><ol>
<li>新建<code>pnpm workplace</code>工作空间文件<code>pnpm-workspace.yaml</code> ，具体如下:</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">packages:</span></span><br><span class="line">  <span class="comment"># 会将packages下面归纳给到pnpm工作空间进行管理</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'packages/*'</span></span><br><span class="line">	<span class="comment"># 排除下面的目录</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'!**/test/**'</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>子项目互相依赖的时候，可以通过<code>workplace:</code> 协议去设置依赖，支持一下几种写法：</li>
</ol>
<ul>
<li><code>“npm_name”: “workplace: *”</code>  所有版本都依赖本地工作空间</li>
<li><code>“npm_name”: “workplace: npm_name@1.0.0”</code> 指定版本写法</li>
<li><code>“npm_name”: “workplace: ../npm_name”</code>  相对路径写法</li>
</ul>
<p>因此<code>apps</code> 中的应用层加入对公共库<code>libs</code>的依赖，如在<code>apps/node-cli</code> 将</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">	"dependencies": &#123;</span><br><span class="line">    "@node-gptcommit/summarize": "workplace: *",</span><br><span class="line">    ...</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>子项目中需要对<code>package.json</code> 中的<code>scripts</code> 中做统一管理，如下：</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	"scripts": &#123;</span><br><span class="line">    "build": "xxx", //按照各自的项目填写对应的构建脚本</span><br><span class="line">    "dev": "xxx",</span><br><span class="line">    "test": "xxx"</span><br><span class="line">  &#125;,</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-引入nx，实现按序打包"><a href="#2-2-引入nx，实现按序打包" class="headerlink" title="2.2 引入nx，实现按序打包"></a>2.2 引入<code>nx</code>，实现按序打包</h3><ol>
<li>全局安装和在项目根目录下安装 <code>nx</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局安装方便后面调试项目使用</span></span><br><span class="line">pnpm install nx -g</span><br><span class="line"><span class="comment"># 项目nx初始化 注意目录不能已经安装nx或者有nx.json</span></span><br><span class="line">npx nx@latest init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 官网里 npx nx@latest init 一直有问题，回头去定位看看</span></span><br></pre></td></tr></table></figure>

<p><code>nx</code>在<code>monorepo</code> 架构中里主要解决几个问题：</p>
<ul>
<li>解决项目中互相依赖问题，就是构建顺序问题，其任务流有点像管道的概念</li>
<li>解决项目中打包缓存问题，比如：一些公共包没有多大变动，就不需要再次打包</li>
<li>提供一些快捷工具快速引入一个子项目或公共包</li>
</ul>
<p>还需要转变一个观点：</p>
<p><strong>重要提示：nx会接手项目的所有打包流程，因此所有相关的命令都由nx进行触发</strong></p>
<ol start="2">
<li>自动生成的 <code>nx.json</code> 解析认知 ，</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	"workspaceLayout": &#123; // 工作空间配置</span><br><span class="line">	    "appsDir": "apps", // 应用层文件夹</span><br><span class="line">	    "libsDir": "libs" // 公共库文件夹</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">  "targetDefaults": &#123; // 统一的配置项，用于覆盖每个项目中的project.json配置</span><br><span class="line">    "build": &#123; // 统一构建选项</span><br><span class="line">      "dependsOn": ["^build"], // 当构建的时会自动将依赖的其他子项目也进行构建build</span><br><span class="line">      "inputs": ["production", "^production"] // 构建</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "tasksRunnerOptions": &#123; // 任务执行器选项</span><br><span class="line">    "default": &#123; // 默认的任务执行器的选项</span><br><span class="line">      "runner": "nx/tasks-runners/default", // 任务执行器</span><br><span class="line">      "options": &#123;</span><br><span class="line">	      "parallel": 5, // 构建并发线程个数</span><br><span class="line">        "cacheableOperations": ["build", "lint", "test"] // 可缓存的操作</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>nx.json</code> 主要用来配置子项目的构建顺序和控制缓存，比如：</p>
<ul>
<li>构建顺序：在项目中<code>apps</code>进行<code>build</code>操作时候会依赖<code>libs</code>项目中的<code>build</code> ，就可以在<code>targetDefaults</code>中配置<code>&quot;dependsOn&quot;: [&quot;^build&quot;]</code>，举个例子：<ul>
<li>当<code>apps</code>的子项目<code>node-cli</code>在运行build操作</li>
<li>会提前将依赖的<code>libs</code>中的<code>summarize</code>子项目也进行<code>build</code></li>
</ul>
</li>
<li>控制缓存：提高构建速度，利用缓存，但是有时候我们并不需要每个构建命令都去缓存，这个时候就可以用<code>tasksRunnerOptions</code>中的<code>cacheableOperations</code>去控制</li>
</ul>
<p><code>nx.json</code> 的其他详细配置可以到官网中查看<a href="https://nx.dev/reference/nx-json" target="_blank" rel="noopener">nx.json</a>。</p>
<ol start="3">
<li>调整根目录<code>package.json</code>中<code>scripts</code>，后续将采用<code>nx</code>去进行分发构建任务： </li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "scripts": &#123;</span><br><span class="line">    "build": "nx run-many --target=build",</span><br><span class="line">    "dev": "nx run-many --target=dev",</span><br><span class="line">    "test": "nx run-many --target=test"</span><br><span class="line">  &#125;,</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>nx一些命令工具，如使用<code>nx graph</code> 可以看到Monorepo中子项目相互依赖情况，如下图所示：<br><img src="/assets/img/2023-03-29.png" alt="Untitled"><br>更多使用命令，可以到官网查看：<a href="https://nx.dev/reference/commands" target="_blank" rel="noopener">nx命令脚本</a></li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到了这里，我们完成Monorepo基本架构的搭建，后续工作就依据不同的业务或代码进行重设计代码结构。</p>
<p>Monorepo架构有个很明显好处，就当你的项目需要新增一个子项目或者依据现有的功能进行剥离成功公共组件，将会很轻松就实现。比如说，当我的node-gptcommit需要新增一个桌面端，那么我就可以根据现有的libs库快速开发完成。</p>
<p>在<code>pnpm</code>+<code>nx</code> 搭建Monorepo项目中，我们可以学习到几个点：</p>
<ul>
<li>使用<code>pnpm</code> 替代<code>yarn</code>或<code>npm</code> 管理<code>node_modules</code> ，不仅快，而且会比较稳定，因为它不允许代码引入一些未在<code>package.json</code>使用的<code>npm</code>包</li>
<li>使用<code>pnpm</code> 同时支持一些<code>libs</code> 被其他apps的子应用依赖，如: <code>&quot;@node-gptcommit/git-utils&quot;: &quot;workplace: *”</code></li>
<li><code>nx</code> 在使用上会需要一些门槛，尤其需要理解其中几个点：<ul>
<li>第一，子项目互相依赖，<code>nx</code>可以在build构建的时候将另外一个包也同时build构建</li>
<li>第二，<code>nx</code>会取代掉我们平时在根目录使用<code>yarn build</code>或<code>npm build</code> 的习惯，而是采用<code>nx build</code></li>
<li>第三，<code>nx</code> 提供一些常用的命令行，如：<code>nx graph</code> 能让我们快速解决Monorepo架构常见的依赖问题</li>
</ul>
</li>
</ul>
<p>本博文项目Github源码地址： <a href="https://github.com/qiubohong/node-gptcommit" target="_blank" rel="noopener">node-gptcommit</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://nx.dev/recipes/adopting-nx/adding-to-monorepo#installing-nx" target="_blank" rel="noopener">nx官方教程：在yarn/npm/pnpm的workplace项目中添加nx</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>从开发chrome插件到插件系统设计</title>
    <url>/today/20230224.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近ChatGPT的技术概念很火热，我开发了一个<a href="https://github.com/qiubohong/node-gptcommit" target="_blank" rel="noopener">node-gptcommit</a>开源项目，主要利用GPT用来自动生成git commit的信息。</p>
<p>但是通过命令行工具来生成preview感觉有点不太友好，因此在想有没有另外一种可能将其变得更加好用，然后想到一个场景：</p>
<ul>
<li>在合mr的时候，以及代码review，很多git commit 文件，需要一一个看</li>
</ul>
<p>在这个时刻，自动生成commit信息就显得很有用，因此我的方案就是将<code>node-gptcommit</code>做成chrome插件，然后帮助MR的开发者能够快速了解此次MR的所有内容。</p>
<p>当然仅仅是开发一个chrome插件大家上网随便搜一下就知道怎么开发，因此为了本文更加有干货，需要更加深入的知识，所以本文分为两部分：</p>
<ul>
<li>Chrome插件开发，如何快速开发一个插件</li>
<li>Chrome插件架构设计，了解Chrome插件背后的架构设计，以及前端插件架构体系</li>
</ul>
<a id="more"></a>
<h1 id="Chrome插件开发"><a href="#Chrome插件开发" class="headerlink" title="Chrome插件开发"></a>Chrome插件开发</h1><p>Chrome插件是一种浏览器扩展程序，可以增强浏览器的功能和用户体验。Chrome插件可以添加新的工具栏、菜单、快捷键、热键等，还可以修改网页的行为和外观，以及与网页交互，实现各种功能。常见的Chrome插件包括广告拦截器、翻译插件、下载管理器、音乐播放器等。</p>
<p>开发Chrome插件其实很简单，因为Chrome的插件主要描述文件<code>mainfest.json</code>，还有包含在里面的一些其他文件，具体如下：</p>
<ul>
<li>manifest.json文件，用于指定插件的名称、版本号、描述等信息，以及指定插件的各种权限和资源</li>
<li>popup.html文件，主要用于显示插件的弹出窗口，提供用户界面和交互功能</li>
<li>content scripts文件，用于向网页注入JavaScript代码，从而实现与网页的交互。这些脚本可以访问网页的DOM和JavaScript对象，并且可以向网页发送消息和接收来自网页的消息。</li>
<li>background scripts文件，用于在Chrome插件的后台运行JavaScript代码，可以与popup、contentscript等通讯，可以实现发起网络请求、拦截用户访问请求等操作</li>
</ul>
<p>一个标准的Chrome插件目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my-extension/</span><br><span class="line">├── _locales/</span><br><span class="line">│   ├── en/</span><br><span class="line">│   │   └── messages.json</span><br><span class="line">│   └── zh/</span><br><span class="line">│       └── messages.json</span><br><span class="line">├── css/</span><br><span class="line">│   └── popup.css</span><br><span class="line">├── img/</span><br><span class="line">│   ├── icon128.png</span><br><span class="line">│   ├── icon48.png</span><br><span class="line">│   └── icon16.png</span><br><span class="line">├── js/</span><br><span class="line">│   ├── background.js</span><br><span class="line">│   ├── content.js</span><br><span class="line">│   └── popup.js</span><br><span class="line">├── popup.html</span><br><span class="line">├── manifest.json</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure>

<p>其中，各个文件夹和文件的作用如下：</p>
<ul>
<li><code>_locales/</code>：存放插件的本地化文件，用于支持不同语言版本的插件。</li>
<li><code>css/</code>：存放插件的CSS样式文件。</li>
<li><code>img/</code>：存放插件的图标文件。</li>
<li><code>js/</code>：存放插件的JavaScript文件，包括background scripts、content scripts和popup scripts等。</li>
<li><code>popup.html</code>：插件的popup页面。</li>
<li><code>manifest.json</code>：插件的配置文件，用于指定插件的名称、版本号、描述等信息，以及指定插件的各种权限和资源。</li>
<li><code>README.md</code>：插件的说明文档，用于介绍插件的功能和使用方法等。</li>
</ul>
<h2 id="manifest-json"><a href="#manifest-json" class="headerlink" title="manifest.json"></a>manifest.json</h2><p>manifest.json是Chrome插件的配置文件，用于指定插件的名称、版本号、描述等信息，以及指定插件的各种权限和资源。</p>
<p>下面是一个完整的<code>manifest.json</code>文件的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;manifest_version&quot;: 2,</span><br><span class="line">  &quot;name&quot;: &quot;My Chrome Extension&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;This is a description of my Chrome extension.&quot;,</span><br><span class="line">  &quot;icons&quot;: &#123;</span><br><span class="line">    &quot;16&quot;: &quot;icon16.png&quot;,</span><br><span class="line">    &quot;48&quot;: &quot;icon48.png&quot;,</span><br><span class="line">    &quot;128&quot;: &quot;icon128.png&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;background&quot;: &#123;</span><br><span class="line">    &quot;scripts&quot;: [&quot;background.js&quot;]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;content_scripts&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;matches&quot;: [&quot;*://*.example.com/*&quot;],</span><br><span class="line">      &quot;js&quot;: [&quot;content.js&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;permissions&quot;: [</span><br><span class="line">    &quot;tabs&quot;,</span><br><span class="line">    &quot;*://*.example.com/*&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>manifest_version：指定manifest.json文件的版本号，一般为2</li>
<li>name：指定插件的名称</li>
<li>version：指定插件的版本号</li>
<li>description：指定插件的描述</li>
<li>icons：指定插件的图标，这里16、 48、128指的是需要展示在不同场景插件的图标</li>
<li>browser_action：可以配置的popup页面和图标</li>
<li>permissions：插件需要的权限，例如访问浏览器标签页，以及只允许在<code>*://.example.com/</code>域名才有效</li>
</ul>
<p>还有两个相对复杂配置项：</p>
<ul>
<li>content_scripts: content_scripts指定插件需要向<code>*://.example.com/</code>注入JavaScript代码，代码位于<code>content.js</code>文件中</li>
<li>background：指定插件的<code>background.js</code>文件为background scripts</li>
</ul>
<h2 id="popup-html"><a href="#popup-html" class="headerlink" title="popup.html"></a>popup.html</h2><p>就是一个简单html文件，里面需要插件的UI展示，demo如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>My Chrome Extension<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"popup.css"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"popup.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is my first Chrome extension.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"myButton"</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>popup.html文件可以包含任何HTML、CSS和JavaScript代码，用于构建插件的用户界面和交互功能。在上面的例子中，popup.html文件包含一个标题、一段文本和一个按钮，按钮的点击事件可以在popup.js文件中进行处理。需要注意的是，popup.html文件的UI通常比较简单，因为其主要作用是提供与用户的交互和反馈。</p>
<p>除了HTML、CSS和JavaScript代码外，popup.html文件还可以包含其他类型的资源文件，例如图片、音频或视频文件等。这些资源文件可以放置在相应的目录下，并在HTML代码中使用相应的路径引用。在实际开发中，可以根据需要对popup.html文件进行扩展和修改，以实现更复杂的用户界面和交互功能。</p>
<h2 id="content-scripts"><a href="#content-scripts" class="headerlink" title="content_scripts"></a>content_scripts</h2><p><code>content_scripts</code>你可以当成用户页面内的js，Content scripts常用于修改网页的行为和外观，以及与网页交互，实现各种功能。例如，可以通过content scripts实现自动填充表单、隐藏广告、添加自定义菜单等功能。下面是一个简单的content_scripts的例子，使得当用户进入Google搜索页面时，输入框默认输入“Hello World!”：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// manifest.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"My Content Script"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0"</span>,</span><br><span class="line">  <span class="string">"manifest_version"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">"content_scripts"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"matches"</span>: [<span class="string">"&lt;https://www.google.com/*&gt;"</span>],</span><br><span class="line">      <span class="string">"js"</span>: [<span class="string">"content.js"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// content.js</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'input[name="q"]'</span>).value = <span class="string">'Hello World!'</span>;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们在manifest.json文件中指定了一个content_scripts，用于在用户进入<code>https://www.google.com/*</code>网页时自动向Google搜索框中输入<code>“Hello World!”</code>。具体实现的代码在content.js文件中，使用document.querySelector()函数获取到输入框，并将其value属性设置为“Hello World!”。</p>
<p>需要注意的是，<code>content_scripts</code>只能访问网页的DOM和JavaScript对象，并不能直接访问插件的资源和API。如果插件需要向网页发送消息或从网页接收消息，可以使用<code>chrome.runtime.sendMessage()</code>和<code>chrome.runtime.onMessage()</code>等API实现。</p>
<h2 id="backgroundjs"><a href="#backgroundjs" class="headerlink" title="backgroundjs"></a>backgroundjs</h2><p><code>backgroundjs</code>是运行在后台的一个js文件，里面可以实现各种监听，如：tab监听、插件初始化、sendmessage、onmessage等事件，下面我们来实现一个简单的发送网络请求：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chrome.runtime.onMessage.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">request, sender, sendResponse</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (request.type === <span class="string">'fetch'</span>) &#123;</span><br><span class="line">    fetch(request.url)</span><br><span class="line">      .then(<span class="function"><span class="params">response</span> =&gt;</span> response.text())</span><br><span class="line">      .then(<span class="function"><span class="params">data</span> =&gt;</span> sendResponse(&#123; <span class="attr">success</span>: <span class="literal">true</span>, data &#125;))</span><br><span class="line">      .catch(<span class="function"><span class="params">error</span> =&gt;</span> sendResponse(&#123; <span class="attr">success</span>: <span class="literal">false</span>, error &#125;));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>常用的监听事件有：</p>
<ul>
<li><code>chrome.runtime.onMessage.addListener()</code>, 监听插件传递过来的的消息事件</li>
<li><code>chrome.runtime.onInstalled.addListener()</code>, 监听插件的安装事件</li>
<li><code>chrome.runtime.onStartup.addListener()</code>, 监听插件的启动事件</li>
<li><code>chrome.tabs.onUpdated.addListener()</code>, 监听浏览器标签页更新事件</li>
</ul>
<p>当然对应的事件都需要在<code>manifest.json</code>中<code>permissions</code>去配置才能开启。</p>
<h1 id="Chrome插件设计架构"><a href="#Chrome插件设计架构" class="headerlink" title="Chrome插件设计架构"></a>Chrome插件设计架构</h1><p>既然弄明白了如何开发一个Chrome插件，那么作为一个合格的程序员，我们不仅要知道是什么，还要知道为什么，这才能让你不断地进步。</p>
<p>我们回头再来思考一下，插件有什么用，以及为什么要有插件？</p>
<blockquote>
<p>插件最大的作用就是扩展主应用App的功能，同时支持可插拔特性，就是有没有插件，都不会影响现有主应用功能正常使用。</p>
</blockquote>
<p>接下来我们来思考，如何我来开发一个chrome插件系统，我应该如何设计呢？下面是简易Chrome插件系统的架构图：</p>

<div class="mxgraph-container">
    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/chrome-extends.drawio&quot;}"></div>
</div>


<p>有了上面的架构，我们可以大概知道实现一个插件系统需要几个功能点：</p>
<ul>
<li>插件管理，需要有插件上传、加载、版本机制等功能</li>
<li>暴露能力，需要确定暴露哪些API能力，同时还需要展示插件的UI</li>
<li>隔离环境，需要确保插件的隔离性，不影响主应用的运行，这里就需要我们去用iframe的模式去执行</li>
</ul>
<h2 id="插件系统设计"><a href="#插件系统设计" class="headerlink" title="插件系统设计"></a>插件系统设计</h2><p>有了对chrome的插件架构有一定了解后，如果这个时候需要我们需要对某个平台去实现一个插件系统，我们应当如何入手以及设计？</p>
<p>在做插件系统之前，我们需要再明确一下插件的定义：</p>
<blockquote>
<p>插件是平台核心功能的一种扩展，是在平台生命周期流程中的不同节点去扩展或调整功能</p>
</blockquote>
<p>接下来，我们按照几个步骤去实现插件：</p>
<h3 id="插件系统的定位"><a href="#插件系统的定位" class="headerlink" title="插件系统的定位"></a>插件系统的定位</h3><p>我们的插件肯定依附于某个平台或应用上的，因此我们需要先对平台能力做一个定位，就以Chrome为例子，chrome浏览器作为展示网页为核心功能。</p>
<p>那么如果去设计一个插件系统，肯定是围绕着网页展示的扩展功能去做插件系统设计。</p>
<h3 id="插件系统的基础能力"><a href="#插件系统的基础能力" class="headerlink" title="插件系统的基础能力"></a>插件系统的基础能力</h3><p>插件系统的基础能力包括以下几点：</p>
<ul>
<li>插件管理，需要插件管理界面，面对开发者：，提供上传、版本管理等功能，面对使用者：需要提供安装、查询、删除等功能</li>
<li>插件开发，需要给开发者提供工具、文档、规范、发布流程等方便的信息</li>
</ul>
<h3 id="插件系统架构设计"><a href="#插件系统架构设计" class="headerlink" title="插件系统架构设计"></a>插件系统架构设计</h3><p>针对不同平台，可能需要插件架构是不一样的，如：Chrome，采用的并行机制，不同插件可以在同一时间加载、输出。</p>
<p>前端领域很多有插件实现架构，按照执行顺序可以大概分为如下几种：</p>
<table>
<thead>
<tr>
<th align="left">插件架构</th>
<th align="left">描述</th>
<th align="left">适⽤场景</th>
<th align="left">框架或应用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">顺序执行</td>
<td align="left">显然就是从头执行到尾，不断对内容做修改</td>
<td align="left">⼤多数场景</td>
<td align="left">babel plugin</td>
</tr>
<tr>
<td align="left">瀑布流</td>
<td align="left">上一层输出就是下一层输入，这里就是管道概念</td>
<td align="left">管道</td>
<td align="left">Gulp</td>
</tr>
<tr>
<td align="left">洋葱</td>
<td align="left">不仅关注输入，而且关心输出，还可以随时直接输出</td>
<td align="left">进出</td>
<td align="left">Koa</td>
</tr>
<tr>
<td align="left">并发执⾏</td>
<td align="left">多个输入，对多个插件输出做一个总结输出</td>
<td align="left">⽆序任务</td>
<td align="left">webpack complier</td>
</tr>
</tbody></table>
<p><strong><em>(这里参考自<a href="https://www.zaozao.run/video/c61/c61-4" target="_blank" rel="noopener">前端早早聊 2023年前端插件设计专场 【洋葱：插件化设计在前端领域的应用】</a>)</em></strong></p>
<p>同时，从架构上还需要考虑以下几点：</p>
<ul>
<li>插件接口，指的是哪些平台哪些接口Hook，允许插件访问或改变</li>
<li>插件管理器，指的平台如何管理插件，包括更新、审核、插件的文件模式等。</li>
<li>插件加载器，指的平台如何加载插件，是在加载过程需要如何塞入暴露能力等。</li>
<li>插件生命周期，指的是一个插件有哪些生命周期节点，如：安装、加载、运行、卸载、禁用等</li>
</ul>
<h3 id="插件系统的安全和稳定性"><a href="#插件系统的安全和稳定性" class="headerlink" title="插件系统的安全和稳定性"></a>插件系统的安全和稳定性</h3><p>我们不仅要考虑插件功能实现，还需要考虑插件的安全和稳定性，主要从以下几方面入手：</p>
<ul>
<li>插件的安全验证，指的是如何限制非法插件的使用</li>
<li>插件的权限控制，指的是如何限制插件的权限</li>
<li>插件的资源隔离，指的是如何确保插件其运行环境不可以访问平台其他非暴露资源</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过本文，我们不仅学会了Chrome插件的开发，还对插件系统的设计有一定的认知，我们回顾一下：</p>
<ul>
<li>Chrome插件开发，主要组成部分为：manifest.json，popup.html，content_scripts和background.js</li>
<li>插件系统设计，主要考虑的点：管理、开发工具和文档、暴露能力、安全与稳定</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://chrome.google.com/webstore/category/extensions?hl=zh-CN" target="_blank" rel="noopener">Chrome应用商店</a></li>
<li><a href="https://developer.chrome.com/docs/extensions/mv3/getstarted/" target="_blank" rel="noopener">Chrome插件开发文档</a></li>
<li><a href="https://www.zaozao.run/video/c61" target="_blank" rel="noopener">前端早早聊 2023年前端插件专场</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>不要再使用轮询了，请用SSE服务端推送完成页面实时更新</title>
    <url>/today/20230223.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近开发一个页面碰到一个需求，需要对部分数据需要实时更新状态，面对这样子的场景，我们通常有以下几个方案：</p>
<ul>
<li>轮询，利用setTimeout定时轮询</li>
<li>WebSocket，利用长链接保持与服务通讯</li>
<li>SSE，服务端推送机制</li>
</ul>
<a id="more"></a>

<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>我们先简单认识一下这三者的区别：</p>
<h2 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h2><p>轮询就是利用setTimeout的定时器，定时向服务器发起请求，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timeout = <span class="number">0</span>;</span><br><span class="line">functon rollRequest(requestFunc, times, immediately)&#123;</span><br><span class="line">    <span class="keyword">if</span>(timeout !== <span class="number">0</span>)&#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(immediately)&#123;</span><br><span class="line">        requestFunc &amp;&amp; requestFunc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        requestFunc &amp;&amp; requestFunc();</span><br><span class="line">        rollRequest(requestFunc, times, <span class="literal">false</span>);</span><br><span class="line">    &#125;, times);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>无用请求过多，可能每次请求返回的内容都是相同</li>
<li>实时性不可控，如果内容更新了，但是页面无法及时更新</li>
</ul>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>针对上面轮询的缺点，WebSokcet长链接就能很好解决，如：</p>
<ul>
<li>建立链接后，当服务器发现数据发生变化后才返回</li>
<li>可控性高，客户端和服务端都可以互相通信</li>
</ul>
<p>具体实现代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">`wss://127.0.0.1:8081`</span>);</span><br><span class="line"></span><br><span class="line">ws.send(<span class="string">"这是一条消息："</span> + count);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听消息</span></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line">ws.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="keyword">var</span> WebSocketServer = <span class="built_in">require</span>(<span class="string">'ws'</span>).Server,</span><br><span class="line">wss = <span class="keyword">new</span> WebSocketServer(&#123; <span class="attr">port</span>: <span class="number">8181</span> &#125;);</span><br><span class="line">wss.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ws</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'client connected'</span>);</span><br><span class="line">    ws.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(message);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>可能实现方案对于一个页面数据更新有点太重了，主要包括以下几点：</p>
<ul>
<li>需要有完整链路认证，如：鉴权、登录等</li>
<li>心跳机制实现，前后端都需要设置</li>
<li>前后端需要规定数据返回规范</li>
<li>服务端需要日志记录</li>
</ul>
<h2 id="SSE服务端推送"><a href="#SSE服务端推送" class="headerlink" title="SSE服务端推送"></a>SSE服务端推送</h2><p>SSE全称Server-sent Events，是HTML 5 规范的一个组成部分，它主要由两部分组成：</p>
<ul>
<li>第一部分是服务端和浏览器的通讯协议</li>
<li>第二部分是前端需要利用<code>EventSource</code>去监听返回数据</li>
</ul>
<p>对比WebSocket：</p>
<table>
<thead>
<tr>
<th>SSE</th>
<th>WebSocket</th>
</tr>
</thead>
<tbody><tr>
<td>单向：仅服务端能发送消息</td>
<td>双向：客户端、服务端双向发送</td>
</tr>
<tr>
<td>仅文本数据</td>
<td>二进制、文本都可</td>
</tr>
<tr>
<td>常规HTTP协议</td>
<td>WebSocket协议</td>
</tr>
</tbody></table>
<p>实现一个SSE代码如下：<br><strong>浏览器：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>SSE Demo测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>SSE返回内容<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> eventSource = <span class="keyword">new</span> EventSource(<span class="string">'http://localhost:3000/sse'</span>);</span></span><br><span class="line"><span class="javascript">        eventSource.onmessage = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>).innerHTML = <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>).innerHTML + <span class="string">`&lt;p&gt;<span class="subst">$&#123;event.data&#125;</span>&lt;/p&gt;`</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>服务端：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a server</span></span><br><span class="line"><span class="keyword">const</span> server = http.createServer()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听路由</span></span><br><span class="line">server.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'request'</span>, req.url)</span><br><span class="line">    <span class="keyword">if</span> (req.url === <span class="string">'/sse'</span>) &#123;</span><br><span class="line">        <span class="comment">// Set CORS headers</span></span><br><span class="line">        res.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>)</span><br><span class="line">        res.setHeader(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'GET, OPTIONS'</span>)</span><br><span class="line">        res.setHeader(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Content-Type'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set SSE headers</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/event-stream'</span>)</span><br><span class="line">        res.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'no-cache'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Send a ping approx every 2 seconds</span></span><br><span class="line">        res.write(<span class="string">"retry: 10000\n\n"</span>);</span><br><span class="line">        res.write(<span class="string">"event: connecttime\n\n"</span>);</span><br><span class="line">        res.write(<span class="string">"data: 第一次发送:"</span> + (<span class="keyword">new</span> <span class="built_in">Date</span>()) + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟收到消息推送给客户端</span></span><br><span class="line">        interval = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            res.write(<span class="string">"data: 后续更新"</span> + (<span class="keyword">new</span> <span class="built_in">Date</span>()) + <span class="string">"\n\n"</span>);</span><br><span class="line">        &#125;, <span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (req.url === <span class="string">'/index.html'</span> || req.url === <span class="string">'/'</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果是html文件，返回html文件</span></span><br><span class="line">        res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>)</span><br><span class="line">        <span class="keyword">const</span> html = fs.readFileSync(<span class="string">'./public/index.html'</span>);</span><br><span class="line">        res.end(html)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listen</span></span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Server started on port 3000'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><p>兼容性问题，但是目前绝大部分浏览器是支持的，如果不支持可以采用降级方案——轮询</p>
</li>
<li><p>会长期占用一个http链接，</p>
<ul>
<li>可能会导致浏览器(chrome最大http请求数是6)无法发起其他请求，这里注意是一个坑，需要设置一个超时时间，如果长时间无返回数据更新可以关闭链接</li>
<li>解决方案，升级到http2协议可解决http请求数限制问题，放到后面《如何搭建http2网站》讲解</li>
</ul>
</li>
<li><p>客户端无法主动向服务器发起请求，可能造成后续问题定位难点</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>前端实时更新需求，有多个解决方案，下面进行总结：</p>
</li>
<li><p>目前最常用的轮询，是最稳定的，但是却无法做到实时</p>
</li>
<li><p>WebSocket可以实时，但是需要服务端和客服端长期保持一致，如果哪一方断了将无法继续</p>
</li>
<li><p>SSE是服务推送，可以满足大部分场景，但是也需要谨慎使用，避免占用过多链接导致其他无法发送请求</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://mp.weixin.qq.com/s/K8g2PNO4Ixc1LrUafXunPQ" target="_blank" rel="noopener">数据不够实时：试试长连接？</a></p>
</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>Node冷门知识点—— node.js支持import语法</title>
    <url>/share/nodejs-module.html</url>
    <content><![CDATA[<h1 id="js模块化"><a href="#js模块化" class="headerlink" title="js模块化"></a>js模块化</h1><p>前端主流模块化规范，目前有以下几种：</p>
<ul>
<li>CommonJS， Node.js提出的规范</li>
<li>ECMAScript Module，ESM，由ECMAScript组织提出的JavaScript标准规范</li>
<li>已淘汰的有：CMD、AMD等，再就综合体UMD（支持各种规范的集合体）</li>
</ul>
<p>因此，主流有两种规范<code>CommonJS</code>和<code>ESM</code>两种规范，但是由于Node.js不支持<code>ESM</code>规范，导致很多时候我们的项目里面并存两种规范的代码，从而出现下面这种情况：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在node端执行构建的时候</span></span><br><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">'loadsh'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在浏览器端实现的时候</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'loadsh'</span>;</span><br></pre></td></tr></table></figure>

<p>这样子开发就很容易出现痛点，往往我们的解决方案就是通过各种构建工具去解决，如：<code>webpack</code> <code>vite</code>，尤其是我们在写项目中写node.js编译脚本，经常需要切换。</p>
<p>但是从Node.js V14+版本后，它开始支持ESM规范啦，你可以直接在Node.js中使用<code>import</code> <code>export</code>等语法了，终于等到这一天😭。</p>
<a id="more"></a>
<p>PS: 其实早在Node.js V8.5版本就已经加入该特性了，只不过一直需要通过全局变量<code>–experimental-modules</code>去开启这一特性，由于不稳定性大多数项目都没有开启，不过自从16+后，我们就可以大胆放心在项目中使用了，不过一些古老的项目建议暂时不用开启。</p>
<h1 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h1><p>我们先从官网上去看相关使用说明：</p>
<blockquote>
<p> Node.js 有两个模块规范：<code>CommonJS</code>模块规范 和 <code>ECMAScript</code>模块规范<br>开发者可以通过 <code>.mjs</code> 文件扩展名、<code>package.json</code>中设置<code>type=module</code>或<code>node xxx.js --input-type</code> 标志告诉 Node.js 使用 <code>ECMAScript</code>规范去执行代码。 如果没这些设置，Node.js 将使用 <code>CommonJS</code> 去执行。<a href="https://nodejs.org/docs/latest-v16.x/api/esm.html" target="_blank" rel="noopener">Node.js Modules: ECMAScript modules</a></p>
</blockquote>
<p>通过上述我们就可以知道几个使用方式：</p>
<ol>
<li>将文件后缀改为<code>.mjs</code>，node.js加载的时候自动会用<code>ESM</code>规范</li>
<li>在项目中<code>package.json</code>新增配置项<code>&quot;type&quot;:&quot;module&quot;</code>，那么整个项目中的.js文件都会按照<code>ESM</code>规范去执行</li>
<li>增加执行参数<code>--input-type</code>也可以实现相同效果</li>
</ol>
<h2 id="各种使用方式"><a href="#各种使用方式" class="headerlink" title="各种使用方式"></a>各种使用方式</h2><ol>
<li>常规方式：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; readFile &#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Demo <span class="keyword">from</span> <span class="string">'./Demo.mjs'</span>; <span class="comment">// 绝对路径或相对路径都可以</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> readFile;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> readFile;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>带参数的使用：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于参数不同， 这个会让`foo.mjs`被加载两次，而不会利用缓存中的`foo.mjs`</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./foo.mjs?query=1'</span>; <span class="comment">// loads ./foo.mjs with query of "?query=1"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./foo.mjs?query=2'</span>; <span class="comment">// loads ./foo.mjs with query of "?query=2"</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>支持<code>data:</code>格式URL的形式</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'data:text/javascript,console.log("hello!");'</span>; <span class="comment">// text/javascript 会将后面的内容当成js模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; test &#125; <span class="keyword">from</span> <span class="string">'data:text/javascript,function test()&#123;console.log("test")&#125;;export &#123;test&#125;;'</span>; <span class="comment">// 这里我们是不是扩宽思路，直接加载在线js呢？</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'data:application/json,"world!"'</span> assert &#123; <span class="attr">type</span>: <span class="string">'json'</span> &#125;; <span class="comment">// application/json 则是json</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// application/wasm for Wasm</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>assert断言(实验特性)<br>将文件强制加载为某种格式内容，如：<code>json</code> <code>javascript</code> <code>webassembly</code>等</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fooData <span class="keyword">from</span> <span class="string">'./foo.json'</span> assert &#123; <span class="attr">type</span>: <span class="string">'json'</span> &#125;;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>加载commonjs规范模块</li>
</ol>
<p>当然肯定也支持加载commonjs规范的模块，用法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> cjs &#125; <span class="keyword">from</span> <span class="string">'cjs'</span>; <span class="comment">// module.exports 导出</span></span><br><span class="line"><span class="keyword">import</span> cjsSugar <span class="keyword">from</span> <span class="string">'cjs'</span>; <span class="comment">// module.exports</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">'cjs'</span>;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>import() 异步导入<br>这种用法就很正常，不需要实时加载，等到需要用的时候再加载</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">default</span>: barData &#125; =</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'./bar.json'</span>, &#123; <span class="attr">assert</span>: &#123; <span class="attr">type</span>: <span class="string">'json'</span> &#125; &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>支持从http/https引入(实验特性)</p>
</li>
</ol>
<p>目前属于实验特性，有限制，比如：</p>
<ul>
<li>不支持http2/3协议</li>
<li>http协议只能用于127.0.0.1等本地ip地址</li>
<li>Cookie、Authorization等信息不会携带发送</li>
<li>只会加载执行远端的js文件，而不会加载远端中依赖其他文件</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> worker_threads <span class="keyword">from</span> <span class="string">'node:worker_threads'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; configure, resize &#125; <span class="keyword">from</span> <span class="string">'https://example.com/imagelib.mjs'</span>;</span><br><span class="line">configure(&#123; worker_threads &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>唯一的限制：当开启ESM规范后，你只允许填写<code>import</code>或<code>export</code>，不允许使用<code>require</code>或<code>module.exports</code>，会报一下错误:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">const a  = require('a')</span><br><span class="line">           ^</span><br><span class="line">ReferenceError: require is not defined in ES module scope, you can use import instead</span><br><span class="line">    at file:///Users/borfyqiu/Desktop/study/github/qiubohong.github.io/code/demo-rollup/test.mjs:4:12</span><br><span class="line">    at ModuleJob.run (node:internal/modules/esm/module_job:193:25)</span><br><span class="line">    at async Promise.all (index 0)</span><br><span class="line">    at async ESMLoader.import (node:internal/modules/esm/loader:530:24)</span><br><span class="line">    at async loadESM (node:internal/process/esm_loader:91:5)</span><br><span class="line">    at async handleMainPromise (node:internal/modules/run_main:65:12)</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实这个也不算是冷门知识，只要稍微对Node.js有做持续关注，基本上都可以了解到该特性。</p>
<p>但是作为不关注的人，很容易就陷入自己的知识误区，会一直认为Node.js不支持ESM规范，甚至会吐槽Node.js为什么不支持呢？</p>
<p>所以这里有一句话需要提醒自己—— 【书山无路勤为径，学海无涯苦作舟】。</p>
<blockquote>
<p>做一个有温度的技术分享作家 —— qborfy</p>
</blockquote>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://nodejs.org/docs/latest-v16.x/api/esm.html" target="_blank" rel="noopener">Node ESM官方说明文档</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>《百万富翁快车道》，我们应该如何快速转到一百万呢？</title>
    <url>/study/book-million.html</url>
    <content><![CDATA[<h1 id="百万富翁快车道"><a href="#百万富翁快车道" class="headerlink" title="百万富翁快车道"></a>百万富翁快车道</h1><p>讲述的作者从失业游民到百万富翁的经历的一些过程，可以帮人开阔一些思维模式，从人行道、慢车道、快车道的方式去讲述一个人如何转到一百万。</p>
<p>如果想要快速赚到一百万，这里没有教你实际的方案，但是告诉你一些思维模式，所以我这边简单通过思维导图去进行汇总。</p>
<a id="more"></a>

<h1 id="阅读摘要"><a href="#阅读摘要" class="headerlink" title="阅读摘要"></a>阅读摘要</h1><ul>
<li>百万富翁快车道<ul>
<li>第1篇 轮椅上的财富<ul>
<li>主流思想<ul>
<li>是通过定投基金去获取年收益或者打工赚钱升工资，存钱获得一百万</li>
<li>缺点：等到你老了，你才会富有</li>
</ul>
</li>
<li>第一章 伟大的欺骗<ul>
<li>平凡不是什么值得向往的事情，应该远离它。—— 朱迪.福斯特</li>
<li>缓慢致富是一场失败的游戏</li>
<li>重新定义退休，将年轻包括在内</li>
<li>真正的黄金岁月是你的青春、充满活力的岁月</li>
<li>个人总结：<ul>
<li>认识到目前通过工资赚钱存钱是一条缓慢的道路</li>
<li>疑问: 是否有其他道路可以实现快速致富呢？</li>
</ul>
</li>
</ul>
</li>
<li>第二章 怎么逆转缓慢致富<ul>
<li>人生的目的不是在芸芸众生中苟且偷生，而是要在疯狂中寻找自我。 —— 马可·奥勒留</li>
<li>觉醒的瞬间：看到一个年轻人开着昂贵的跑车，心想要嘛是富二代，要嘛是贷款买的，直到去咨询他是做什么工作的，但是他给我的答案告诉我，“我是一个发明家”</li>
<li>问自己的问题：如果不受任何约束，我会住在这个国家的何地？</li>
<li>用劳动时间换金钱，如果不劳动就没有金钱</li>
<li>快车道，寻找一条没有人认识到的路，去开发</li>
<li>假的“捷径”——卖掉这条路，换取一笔钱，然后用这笔钱去消费，这条捷径问题就是你只能拿到一笔钱，然后快速花完</li>
<li>真正的快车道——能持续赚钱，赚钱的速度会越来越快（赚钱速度是成指数型的），而且会让你工作时间越来越短</li>
<li>什么时候换道路——当你已经赚够了，或者不再需要这条路的时候</li>
<li>记住：变化可能发生在一瞬间</li>
</ul>
</li>
</ul>
</li>
<li>第2篇 财富不只是一条路，而是一场旅行<ul>
<li>第三章 旅行在财富之路上<ul>
<li>千里之行，始于足下 —— 老子</li>
<li>追足财富如同旅行，如果只专注于目的地，而忘记整个旅行过程所需要的东西和所看到的东西，你可能因为各种原因而而无法到达目的地，或者到了目的地却怀疑自己为什么要来这里？</li>
<li>要注重整个全局，而不是注重某些特定的方面，所以要进快车道，你需要对自己有一个完整的认知，以及这条道路可能涉及到方方面面</li>
<li>“财富是一个过程，而不是结果。” 如何理解这句话，书中拿烹饪作为例子，制作好吃的一道菜，重要的是过程，比如火候、配料多少、材料等等，财富就是制作的过程，而不是那道好吃的菜。正比如财富不是钱，而是赚钱的过程。“过程才是通往财富的路途，目的地作为结果虽光芒闪耀，但实现它全靠过程。”</li>
<li>财富之路实现的公式：<ul>
<li>路线图，目前有哪些道路可以到达财富</li>
<li>交通工具，就是自己，需要成为什么样的自己</li>
<li>财富道路，选择什么样的路，这条路可能很难走但是很快</li>
<li>速度，等于执行力，就是将想法付诸实践</li>
</ul>
</li>
<li>道路基本上都是收费，其实就是需要你承担风险和付出代价，比如创业踩坑，导致某些地方失败</li>
<li>关键是路要靠自己走，不能外包给其他人</li>
</ul>
</li>
<li>第四章 财富路线图<ul>
<li>如果你不知道去哪里，任何一条路都是你的选择 —— 刘易斯·卡罗尔</li>
<li>你目前的生活情况，是你现有的财富路线图的结果，因为这是你的信念导致，比如：你认为定投基金能给带你财富，那么你的行为就会反应这种信念</li>
<li>信念是推动行动的强大机制，所以我们要培养自己一些良好的信念系统，就是每个人选择走的路线和关键思维方式(=思维路标)</li>
<li>3个财务路线图：<ul>
<li>人行道，目的地=贫穷，</li>
<li>慢车道，目的地=平庸，</li>
<li>快车道，目的地=财富，</li>
</ul>
</li>
<li>财务路线图，主要由关键思维模式形成，也就是思维路标：<ul>
<li>对债务的看法，控制债务，还是债务控制你</li>
<li>对时间的看法，时间的重要性，你能自由控制时间吗</li>
<li>对教育的看法，教育在生活中有什么作用，你觉得还需要继续教育吗？</li>
<li>对金钱的看法，金钱在生活中有什么作用，是玩具还是工具，是不缺少还是缺少</li>
<li>对财富的看法，如何定义财富？是金钱、资产还是自由可控制的时间？</li>
<li>主要收入来源，收入来源是什么？工资，还是房租，还是创业的利润？</li>
<li>主要财富增长，如何增加财富？是升职，还是增加第二份收入?</li>
<li>财富公式，你的积累财富的公式是什么？是工资收入+投资理财收入？还是创业利润增加+固定理财收益？</li>
<li>责任与控制，生活和财富受你控制吗？</li>
<li>对人生的看法，你计划过人生吗？有未来十年甚至二十年的计划吗？为了理想会放弃现在的享受吗？</li>
</ul>
</li>
<li>升级路线，升级现有的信念系统，才能更好升级现有的生活</li>
</ul>
</li>
</ul>
</li>
<li>第3篇 贫穷：人行道路线图<ul>
<li>第五章 人行道：最多人走的路线<ul>
<li>当你是第一个信念有别于他人的人，你通常会说：“我是对的，其他的人是错的”。这种处境令人非常不愉快，这种想法在令人振奋的同时也会招致攻击。 —— 拉里·埃里森</li>
<li>走人行道的人的信念：享受当下，不考虑明天的安危，更加具体的思维路标如下：<ul>
<li>债务的看法：现在就要，哪怕是通过刷信用卡、贷款等</li>
<li>时间的看法：觉得时间不重要，上班多久无所谓，下班后就刷手机</li>
<li>教育的看法：毕业后就完成所有的学习，后面就不需要再继续学习了</li>
<li>金钱的看法：享受当下，金钱是生不带来死不带去，有一分钱花一分钱</li>
<li>收入的来源：追逐金钱，哪里钱多去哪里，没有未来计划</li>
<li>财富的增长：不知道什么是净资产？也不明白财富增长的意义是什么</li>
<li>财富的意义：没什么意义？只是死后的一堆玩具</li>
<li>财富的公式：财富=收入+债务</li>
<li>人生的目的：为今天而活，不为明天烦恼</li>
<li>责任与控制：全都是别人的错误，埋怨人生，埋怨社会，无任何责任心</li>
<li>生命的感悟：人生苦短，不去理会未来的事情，总期待中彩票发大财</li>
</ul>
</li>
<li>人行道的特征：大量贷款，消费享乐主义，透支未来，无任何存款，埋怨社会，期待运气</li>
<li>人行道的引力：正在拉你入贫穷深渊，让财务脱离控制，如：失业让你顿时没法维持生活，因为你净资产为0</li>
<li>如何脱离人行道？<ul>
<li>真正意识到你在人行道上，非常简单的判断：你不工作后，你剩余的钱能够支撑你一年的正常开销，比如：我个人一年正常开销需要20万</li>
<li>需要明白金钱解决不了金钱的问题，举个例子：你现在的美好生活绝大部分是依赖于贷款，如：买车、买衣服，你以为能靠工资收入达到收支平衡，但是一旦失业，你就无法维持现有的平衡，这就是人行道的所需要面临问题，因此你需要通过改变生活的方式让自己脱离人行道</li>
<li>人行道的“富人”，他们有很高的收入，但是他们的开销一样很大，因为他们坚信能够永远有持续的高收入，但是一旦经济危机爆发，他们将和贫穷的人一样没有任何抵抗力</li>
<li>想要脱离人行道唯一的途径，就是进行财务管理，提高财务自律，也就是提高自己对财务的控制力，怎么做？<ul>
<li>不透支未来的财富，如：刷信用卡、花呗等</li>
<li>控制消费欲望，拥有自己的消费观，如：衣服很好看，但是请确保自己使用它的场景有哪些？数码产品很新颖，但是请确保买它的意义是什么？</li>
<li>管理账单，不需要详细记录每天的消费，但是需要对大额消费有一定记录，比如：超过200元的消费记录</li>
<li>如果有大额贷款（&gt;1万），需要更加详细管理他们，包括：还款日期、利息，制定归还计划等</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>第六章 你的财富中毒了吗<ul>
<li>财富是充分体验生活的能力。—— 亨利·戴维·梭罗<ul>
<li>理解的意思是说真正的财富是你拥有足够的时间去体验完整的生活，而不是指的单纯的物质，如：车、钱等</li>
</ul>
</li>
<li>社会对财富的定义：财富是由物质财产构成的，这是一个错误的观念</li>
<li>财富有三个部分组成(FFF):<ul>
<li>家庭或人际关系(Family Or Friend)，是与人构建紧密的关系，说的通俗一点，就是你的人脉</li>
<li>健康(Fitness)，是指的身体健康，拥有活力的身体和心态，身心健康才是你根本上的财富</li>
<li>自由(Freedom)，是指的从时间上、空间上的你用自由支配的权限，你拥有多少可以自由控制的时间你就拥有多少财富，用俗语说：一寸光阴一寸金，寸金难买寸光阴</li>
</ul>
</li>
<li>很富有的假象：<ul>
<li>拥有入门级的豪华轿车，出入一些高级餐厅</li>
<li>但是你却住在一个破烂的公寓，每天都得工作10几个小时</li>
</ul>
</li>
<li>虚假的财富是如何破坏真正的财富<ul>
<li>你购买很多物质这类虚假的财富，你以为自己很富有，但是其实你却需要每天工作10几个小时的时间去偿还这些债务，这破坏你的自由，也破坏了你的关系，同时还破坏了你的健康，让你距离真正的财富越来越远</li>
</ul>
</li>
</ul>
</li>
<li>第七章 你滥用金钱，金钱就会报复你<ul>
<li>金钱买不到幸福，但是当你痛苦的时候，它会让你感到非常的舒服。 —— 克莱尔·布思·卢斯<ul>
<li>这句话用很简单的语言就可以表达，钱不是万能的，但是没钱是万万不能</li>
</ul>
</li>
<li>金钱与幸福的关系，需要有一个平衡点，而这个平衡点可以FFF财富规则去进行执行</li>
<li>现代版的奴隶：<ul>
<li>社会定义的正常生活标准：8点起床上班，18点下班，周一到周五是工作日，周末是休息</li>
<li>而恰恰这个“正常”就是一个现代版奴隶的生活标准</li>
</ul>
</li>
<li>不要乱花钱，要正确的使用金钱，那么金钱就能给带来幸福，比如：<ul>
<li>金钱能买到自由去看着你的孩子长大</li>
<li>金钱能买到自由让你无拘无束</li>
<li>金钱是财富公式和自由的卫士，强有力地守护着财富的孪生兄弟——健康和社会关系</li>
</ul>
</li>
<li>不要乱花钱的就是不要陷入消费陷阱中，购买一些不需要的东西，如：豪华轿车、名贵手表和衣服等</li>
<li>人行道的恶性循环：工作收入&gt;偿还债务&gt;透支消费&gt;被迫工作</li>
<li>思考能不能负担起=负担不起，因为你这是在一个美好未来的假设去做透支，如：<ul>
<li>如果我涨薪了</li>
<li>如果我抵押贷款没有做调整</li>
<li>如果我的股票上涨了10%</li>
</ul>
</li>
<li>买的起不等于用得起，比如：买了一辆豪华轿车，你需要加油、保养、保险等开销，同时你还需要有时间可以出去旅游</li>
<li>如何逃离消费主义的诱惑呢？—— 财富与健康，两者都需要将生活方式从短期思维（即时享乐）转向长期思维（延迟享乐），这是唯一能够阻断生活方式被奴役的篱笆。</li>
<li>重复一次，从短期思维（即时享乐）转向长期思维（延迟享乐），做长期规划，并且长期坚持下去，获得成就感大于及时享乐</li>
<li>社会中充满了各种诱饵（及时享乐），一旦你吃了这个诱饵，你就会被鱼钩钓上从而难以脱身，鱼钩就是需要被债务缠身，被工作奴役</li>
</ul>
</li>
<li>第八章 幸运儿的游戏<ul>
<li>我相信运气，并且相信付出更多的努力，就会有更多的运气。 —— 托马斯·杰斐逊<ul>
<li>这句话的意思，是想告诉我们运气很重要，但是要获得运气你需要做很多努力的准备工作，否则即使运气来了，你也无法承担。</li>
</ul>
</li>
<li>“有钱人运气好”这种信念，是走人行道的信念，是一种消极的观念，可以不断打击的你意志<ul>
<li>虽然真的有人可以运气好中彩票或者遇到一只股票大涨，但是这不是可持续的财富收入源</li>
</ul>
</li>
<li>要想获得运气，就要更好地经营过程，因为只有过程才蕴含着机会。<ul>
<li>我们往往忽略过程，更加在意结果，运气是在努力的过程才会出现的，如果你不努力，运气是不会从你身边经过的</li>
</ul>
</li>
<li>如何脱离人行道呢? 这里有3个关键点<ul>
<li>赚钱不是靠运气，运气是需要你不断努力获取的一种结果</li>
<li>赚钱最重要的不是结果，而是赚钱的过程，你需要不断优化赚钱的思路或者模式</li>
<li>不要相信别人能给你带来赚钱的机会，因为赚钱思维需要靠自己去探索和思考，否则凭实力赚来的钱，会凭实力搞没有掉</li>
</ul>
</li>
<li>第九章 致富需要承担责任<ul>
<li>伟大的代价就是责任。 —— 温斯顿·丘吉尔<ul>
<li>这句话的意思，如果你要成为一个伟大的人，那么你所需要付出的代价就是你的责任心</li>
<li>通俗点讲，要想成功，你必须负责</li>
</ul>
</li>
<li>人行道的人的观念，相信别人，但是事情一旦出现意外就责怪别人，除了依靠运气和注重结果两个原因外，责怪他人是停留在人行道上的第三个原因</li>
<li>受害者法则：只要不放弃控制权，没有人能让你成为受害者。<ul>
<li>简单理解的话，当你把金钱交给基金经理，那么你很有可能成为承担损失的受害者</li>
<li>成为受害者的第一要素，就是逃避和放弃，不愿意争取主导权，将选择权放在其他人身上</li>
</ul>
</li>
<li>从不拿房地产作为致富工具，因为这里具备太多不可控的因素</li>
<li>致富需要先承担责任，然后才是问责<ul>
<li>承担责任，是你犯错后，需要承担错误的结果，如果还继续犯错，则表示你没有承担该责任</li>
<li>问责，是从犯错的过程吸取教训，调整行为</li>
</ul>
</li>
<li>什么是责任？分成两个步骤：<ul>
<li>责任在于，我的钱包被偷了，这是我的过错</li>
<li>问责则是，以后我会采取预防措施，确保它不会再次发生</li>
</ul>
</li>
<li>当你对自己开始问责的时候，就是你开始能自主控制自己生活的时候</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>第4篇 平庸：慢车道路线<ul>
<li>第十章 你一直被谎言误导：慢车道<ul>
<li>一个普通人每周辛苦工作50小时，50年后被迫退休，然后被送进养老院，希望在病痛缠身之前有尊严地死去，这不算疯狂吗？ —— 史蒂夫·布西密<ul>
<li>普通人认为正确的选择，是辛苦工作，获得薪资，维持温饱，然后持续这样子生活直到退休</li>
<li>希望老年时光是没有任何病痛</li>
<li>这个观念如同希望这个世界一层不变那么疯狂</li>
</ul>
</li>
<li>慢车道的观点：牺牲今天的幸福，把希望寄托在未来</li>
<li>慢车道最大劣势<ul>
<li>需要等你老了，你才能买得起你想要的东西，如：豪车、旅游、自由</li>
<li>60岁的百万富翁远远比不上25岁的百万富翁</li>
</ul>
</li>
<li>转变思维：在年轻的时候就获得财富，趁你拥有健康、活力、能量的时候纵情享受</li>
<li>慢车道无法承担经济风险：<ul>
<li>失去工作，将无法继续人生计划，因为你没有其他收入来源</li>
<li>股票下跌，你的资产将缩水</li>
<li>房地产下跌，你的房子将无法给带来任何收益</li>
</ul>
</li>
<li>慢车道的思维路标：<ul>
<li>对债务的看法：避免一切债务</li>
<li>对时间的看法：工作时间越久，赚的钱越多</li>
<li>对教育的看法：教育很重要，因为能帮助获取更高的薪资</li>
<li>对金钱的看法：金钱很重要，要省着点花，还尽可能存钱</li>
<li>主要收入来源：工资</li>
<li>主要财富增长：投资收入，依赖时间去投入，如：定投基金、房地产的升值空间</li>
<li>对财富的看法：重复工作获取收入，加上投资，期待能早点退休</li>
<li>财富的公式：  = 工作+市场投资</li>
<li>对人生的目的：希望能在晚年享受舒适的退休生活</li>
<li>责任与控制：  责任是养家糊口，但是工作却依赖公司，希望经济环境良好</li>
<li>对人生的意义：放弃梦想和理想，不冒任何风险，只期待公司和经济环境能变得更好一点</li>
</ul>
</li>
<li>一个故事揭露上班一族的最大缺陷：你会为了一份工资，而忘记你本来是为了更好的生活而赚这份工资的<ul>
<li>故事讲得是一个著名小提琴家在地铁站用几百万的小提琴去演奏，而上班的人完全不会停下脚步来欣赏</li>
<li>现实就是：你为了赚钱，必须周一到周五全身心的投入工作，而忘了除了工作之外，还有很多美好的事物</li>
</ul>
</li>
<li>慢车道最大的痛点就是：时间不等人<ul>
<li>当你有了小孩，你为了赚钱无法陪小孩，而小孩是不会因为你赚钱而停止长大，所以你将会丢失掉大部分陪小孩子长大的时间，如：她第一次学会叫人、第一次学脚踏车等</li>
<li>而你需要等到周末才有时间去陪她，甚至有可能因为其他原因，周末也没时间陪</li>
</ul>
</li>
<li>生活会从各方面来展示对平庸的慢车道生活的谴责：<ul>
<li>需要过各种节俭的生活来存钱</li>
<li>没有自己自由的时间</li>
<li>变得越来越平庸，从而导致生活越来越痛苦</li>
<li>一场意外就会让生活失去控制</li>
</ul>
</li>
</ul>
</li>
<li>第十一章 不平等的交易：你的工作<ul>
<li>每天一心一意的工作8小时，你可能最终会成为老板，然后每天工作12小时。罗伯特·弗罗斯特<ul>
<li>这句话不要为了工作而工作，8小时，12小时，你用尽所有的时间都在工作上，你还能拥有其他东西吗？</li>
</ul>
</li>
<li>工作，就是将你驯服成，将工作当成常态，会让你受到控制，并且平衡你的心态</li>
<li>你的财务计划不应该以工作为中心，6个现象将表明你是否处于慢车道中：<ul>
<li>打工在吞噬你的时间，而且通过打工你将需要几十年的时间才能转到一百万</li>
<li>经验受限，你打工所获取的经验永远只能用在当前这份工作上，你只是公司机器上一个螺丝钉</li>
<li>无法控制，随时都有可能失去工作的可能性，而且打工只能维持你目前的生活水平</li>
<li>办公室政治，除了完成工作外，你需要面对各种人情世故，为的就是那份很少工资的工作</li>
<li>高额税收，你的工资要上缴社保、公积金、税收等，最后才轮到你</li>
<li>收入独裁，你的工资不是你说了算，没有一个老板愿意主动给员工加薪，哪怕加也只是10%，即使你跳槽也会因为当前的工资而收到限制涨幅</li>
</ul>
</li>
<li>所以打工是永远不可能致富的，只能维持你的日常生活，不能让你的生活上一个档次</li>
</ul>
</li>
<li>第十二章 慢车道为什么无法致富<ul>
<li>应该有人告诉我们，在我们的生命的开始，便已经走向死亡。我们可以将生命过得极致，充分利用生命中每一天每一分钟。就这样子做！无论你要做什么，现在就做！明天是有限的。 —— 米歇尔·兰顿<ul>
<li>这句话就是告诉我们，从我们生下来那天，我们的生命就已经在倒计时了，你必须享受当下的每一分每一秒，过你自己想要的生活，而不是为了打工而勉强自己。</li>
</ul>
</li>
<li>慢车道是无法致富的，因为你的财富增长公式=你的收入+投资收益，套入数学公式中，这两个变量完全没在你的控制范围内，那么你怎么做都无法提高你的财富</li>
<li>每天工作8个小时，只能50年后才能拥有100万，想一想是不是有点无法接受</li>
<li>你无法控制你的薪水，因为你无法控制你的雇主，你的公司，因为公司天生为了压榨劳动力，公司的本质就是为了控制你，利用你的低廉价值去创造更高的价值</li>
<li>慢车道中的“复利”其实就是利用时间制造一种假象，让你以为你的钱可以赚钱，但是这种赚钱的速度很慢，甚至比不上通胀的速度<ul>
<li>一万元能买一栋房子，利息5%，利用复利公式，到了50年后，你可以拿到300万，但是你已经70多岁，请问你拿这笔钱怎么办？</li>
<li>第二个问题就是如何保证每年都有5%的收益呢</li>
</ul>
</li>
<li>基金定投无法让你致富的原因：<ul>
<li>因为它无法控制收益，无法稳定收益，也无法快速收益</li>
<li>另外一个原因就是它很可能亏损</li>
</ul>
</li>
<li>任何窃取时间和无力带来时间自由的东西都是负债<ul>
<li>打工是在窃取你的时间，但是却无法带来给你足够的时间自由</li>
<li>基金定投也是一样，以时间为借口，牺牲足够多的时间，才能换来未来可能会收益的老年自由</li>
</ul>
</li>
<li>慢车道会削弱你的控制力，会让你将希望寄托在别人，如：你希望老板可以多涨薪，你希望股市能够上涨等</li>
</ul>
</li>
<li>第十三章 徒劳的抗争：教育<ul>
<li>妨碍我学习的唯一障碍就是我接受的教育。 —— 阿尔伯特·爱因斯坦<ul>
<li>从这句话可以看出，其实是当前我们接受的教育是让他不要学习超出范围内的知识，从而限制学习</li>
</ul>
</li>
<li>打工人唯一可以拿出来抗争的就是教育，就是学历，如：我们从本科、硕士、博士，对应的工资是不一样<ul>
<li>所以，我们打工就不断学习和接受教育，从而去获得更多的工资</li>
</ul>
</li>
<li>慢车道的观点：提升内在价值（就是我们能给公司带来什么价值），就能创造财富<ul>
<li>但是却忽略一点，教育所需要的时间以及金钱，比如助学贷款等，需要你后面花费大量时间去偿还</li>
</ul>
</li>
<li>教育的缺陷：如果你选择接受的教育是某个特定技能，你只能学习到这些，即使你的技能特别高升，但是没有公司愿意要，那么你所受的教育压根就无法创造财富<ul>
<li>举个例子，比如二十年前，大家都愿意去选土木专业，因为那个时候国家正在大兴基建，需要大量人才，但是现在土木出来只能去工地搬砖</li>
</ul>
</li>
<li>正如最近的例子，大部分大学生找不到工作，不愿意去做清洁、美甲、理发、工厂等工作，反而被讽刺为脱不下孔乙己的长袍，这就是你浪费了大量的时间在教育，而教育却无法给任何回报</li>
</ul>
</li>
<li>第十四章 大师们的虚伪<ul>
<li>以前都说笨人难聚财，现在每个人都这样子。 —— 阿德莱·史蒂文森<ul>
<li>这里想表达的是，你不愿意相信自己能赚钱，反而期待别人可以带你赚钱，目前社会中大部分的人都是这样子。</li>
</ul>
</li>
<li>实践悖论，大部分提供意见的人，自己本身都做不到，反而去指导别人</li>
<li>他们的说法就是，只照我说的做，别学我怎么做<ul>
<li>基金理财的骗局，就是这样子，让你们把钱交给他们，同时还收取你们的管理费，最终还有可能亏损，请问定投基金的你们是傻子吗？</li>
</ul>
</li>
<li>当你们遇到基金亏损的时候，基金经理给你的建议就只有希望经济不要再衰退，希望经济能反弹，这一切与他们没有任何关系</li>
<li>指引你走上慢车道的大师们，需要你相信慢车道，因为他们靠你发财</li>
</ul>
</li>
<li>第十五章 慢车道的胜利，一场关于希望的赌博<ul>
<li>我宁愿活在失败的后悔中，也不想后悔从未尝试过。 —— MJ·德马科<ul>
<li>这句话表达了，勇于尝试，而不是拘泥于现有的一切，等到老了才来后悔当初为什么没那么做。</li>
</ul>
</li>
<li>慢车道最危险的赌注，就是将你的时间赌上，然后消耗时间去等待一个可能的希望</li>
<li>慢车道的7个风险：<ul>
<li>健康风险，假如你在65岁成为了百万富翁，那个时候你是否是健康的，有精力去享受你想享受的？</li>
<li>工作风险，慢车道成功的前提条件是你接下来几十年里都拥有高薪，不会面临裁员、公司破产以及经济下滑等风险</li>
<li>房屋风险，希望房屋可能一直上涨</li>
<li>公司风险，没有几家公司能一直保持上涨的趋势，而将财富寄托在一家公司上，很有可能导致竹篮打水一场空</li>
<li>生活方式风险，慢车道的生活标准就不享受任何东西，希望你存足够的钱等到你退休</li>
<li>经济风险，希望你能每年保持8%的利润增长，相信买入并持有，但是在经济下滑大环境下压根不可能</li>
<li>人行道风险，慢车道的人很容易陷入人行道，因为当你的生活和工作不受控制，那么你会希望控制某些东西，从而陷入消费主义中</li>
</ul>
</li>
<li>慢车道，是一场漫长且充满不可控风险的赛道，它会慢慢吞噬掉你的时间、自由、健康、和人际关系等<ul>
<li>它让你慢慢变得平庸，因为你赚的钱就是平庸的</li>
<li>它是不可控的，因为它所依赖的变量：工资和投资，都不在你可控制的范围</li>
</ul>
</li>
<li>个人净收入=个人收入-个人支出，慢车道的缺点，在于它不要求你提高个人收入，而是希望你不断压缩个人支出达到净收入的增长，这显然是不符合人性的，而且也没法真正达到净收入得到增长<ul>
<li>真正的收入增长在于，你个人收入在快速增长，同时你控制个人正常支出，从而实现个人净收入达到增长</li>
</ul>
</li>
<li>战胜慢车道的“秘密出口”<ul>
<li>成为明星，提高名气或者影响力，能让你的工资成指数型上涨</li>
<li>加班到成为管理层，拥有公司期权，让你一夜暴富</li>
<li>熬时间，终于成为中产阶级</li>
</ul>
</li>
<li>慢车道和快车道百万富翁的区别<ul>
<li>慢车道需要30年或者更长时间才能累积100万，而快车道只需10年或者更少时间</li>
<li>慢车道住的房子是小区套房，而快车道则住豪宅</li>
<li>慢车道拥有MBA等各种学位，而快车道则是请MBA的工人</li>
<li>慢车道让市场控制他们的资产，如股票等，而快车道则可以自主控制自己的资产，且有能力提高自己的资产能力，如：公司的利润等</li>
<li>慢车道为了时间而工作，而快车道让时间为他们工作</li>
<li>慢车道是员工，快车道是老板</li>
<li>慢车道是买保险，快车道是提供保险的人</li>
<li>慢车道是利用基金和股票致富，而快车道则是利用股票保持他们的钱</li>
<li>慢车道让别人控制他们的财富，而快车道控制别人的财富</li>
<li>慢车道看重钱，快车道看重时间</li>
<li>慢车道将房产视为自己的资产，快车道将房子看为住处</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>第5篇 财富：快车道路线图<ul>
<li>第十六章 财富的快捷：快车道<ul>
<li>如果知道得越多，你就会做的越好。 —— 吉米·罗恩<ul>
<li>这句话表达的意思是，你知道的知识越多，那么你离成功就越近，也就越能做成事。</li>
</ul>
</li>
<li>快车道是什么？（总算到正文了）<ul>
<li>快车道是一种商业和生活方式的策略，将工作和生活可以无限平衡，从而创造最佳的环境去实现快速致富和非凡的生活</li>
<li>按我理解，快车道是一种选择方式，当你在工作和生活做选择的时候，需要平衡两者，而快车道就是能无限平衡这两者的选择</li>
</ul>
</li>
<li>快车道的几个特征<ul>
<li>可控制的平衡，工作和生活的控制权都在你手上，你可以掌握他们而达到无限平衡的可能</li>
<li>业务上，你是管理者，你敬业，就好像你给老板打工一样，你需要拼命去工作，因为这是为了你自己</li>
<li>生活方式，你需要融合信念、过程和行动，就是知行合一，不可以再像打工那样子摸鱼</li>
<li>快速制造财富，能让你快速创建更多的财富</li>
</ul>
</li>
<li>投入创业，是快车道的一种方式，也是一种生活方式，前期需要全身心投入，然后进入高速路，快速抵达财富目的地，最终实现自由</li>
<li>快车道的思维路标：<ul>
<li>对债务的看法：对我建立的系统或发展系统有用的债务，是可以接受的</li>
<li>对时间的看法：时间是我最重要的资产，比金钱还重要</li>
<li>对教育的看法：停止学习就等于停止成长，就等于和财富说拜拜</li>
<li>对金钱的看法：金钱很重要，无处不在，但是它代表的是我所创造东西的价值仅此而已</li>
<li>主要收入来源：通过生意运转和投资得来</li>
<li>主要财富增长：创业获得价值资产（资产是可以不断赚钱的），然后利用现有的资产去不断增值</li>
<li>对财富的看法：建立现金流和资产评估的业务系统</li>
<li>财富的公式：  财富=净利润+资产价值</li>
<li>财富的策略：  付出越多，在时间、金钱和个人成就上就得到越多</li>
<li>人生目的地：  获得被动收入，即通过创业，也通过投资</li>
<li>责任与控制：  生活将是我自己控制的，财务计划也是我的责任，应该视情况而做出不同选择</li>
<li>人生的看法：  无论梦想如何与众不同，但是有钱会让梦想成真</li>
</ul>
</li>
<li>快车道，是财富的工业革命，就是从人类发展史而言，工业革命让人类快速发展，而快车道对于个人就是一场工业革命，能让你快速致富</li>
<li>快车道，是一个商业系统，而慢车道是一个工作<ul>
<li>通俗点，快车道是你的事业，而慢车道则是一份工作</li>
</ul>
</li>
</ul>
</li>
<li>第十七章 转换团队和剧本<ul>
<li>一个人只关心自己的人，只能做出很小的成就。 —— 本杰明·富兰克林<ul>
<li>这句话表达的是，一个人的力量终究有限，你需要结合团队的力量才能完成一个人不可能完成的事业</li>
</ul>
</li>
<li>快车道的核心思维：成为生产者，如：不要去买产品，而是成为生产产品的，不要去抵押贷款，而是成为能提供贷款的人等</li>
<li>生产者的思维：<ul>
<li>当你在看广告的时候，应该思考的是这个广告是如何宣传产品，以及诱惑消费者的</li>
<li>如果要提供这个商品会需要什么样子的流程？</li>
<li>这个公司盈利吗？盈利模式是什么？</li>
</ul>
</li>
<li>生产的模式：创新思维、利用系统处理业务<ul>
<li>远见的视野和创新的思维，怎么做到呢？你需要更多的知识领域，去提高你的知识边界</li>
<li>核心是生意，而不是工作，实现的是自我雇佣</li>
<li>形成一套商业系统=时间*金钱，随着时间的不断增加，你的资产会不断增加</li>
</ul>
</li>
</ul>
</li>
<li>第十八章 富人发财的真相<ul>
<li>只有那些甘愿冒险不断前行的人，才清楚自己能走多远。 —— 托马斯·艾略特<ul>
<li>这句话表达的是，愿意探索自己未知领域的人，并且不停的往前走，才能走得更远，离成功也就越来越近。</li>
</ul>
</li>
<li>要弄清楚如何致富或者发大财？大部分人的答案是：中彩票、成为明星、富二代等，但这些就仅仅只是想想而已的答案。</li>
<li>真正弄明白发财的真相，需要转变思维，将赚钱=工资+投资，转变成为：赚钱=净利润+资产价值<ul>
<li>净利润=销售数量*利润率，这个就比较简单理解了</li>
<li>资产价值=净利润*行业乘数，那么如何理解行业乘数呢？<ul>
<li>行业乘数，其实就是股票里的市盈率、市净率等公式表达，就是当前你公司的估值公式因子</li>
</ul>
</li>
</ul>
</li>
<li>最重要一点就是，净利润是可以由我们自己去控制的，我们通过各种方式去控制净利润的增长，而不是像工资完全不是我们所能控制的，因为老板是不会允许员工的工资上涨过快<ul>
<li>比如网站，我们可以提供访问量和转化率，从而实现净利润的增长</li>
</ul>
</li>
<li>财富的双刃剑，净收入和净利润的矛盾点，需要注意点是，不能一昧的追求净利润，要注重提高净收入后才去考虑净利润的提升</li>
<li>财富的变现，需要合适的时机，将你的资产变成现金流，这个是财富的最终目的地</li>
</ul>
</li>
<li>第十九章 破解财富和时间的联姻<ul>
<li>时间是你生命中的一枚硬币。这是你唯一的一枚硬币，只有你确定它如何花出去，你要注意不要让别人替你花掉它。 —— 卡尔·桑德堡<ul>
<li>这句话表达的是，你生命最重要的财产是你的时间，也是你生下来就唯一拥有的财产，你可以学会怎么花时间，以及要确保不要被其他人忽悠去花费大量时间做无意义的事情。</li>
</ul>
</li>
<li>真正的财富计划，是让你能够从时间中脱离出来，不是用时间换财富，而是当你不需要花时间在上面的时候，它依然能够源源不断在帮你制造财富，这就是工业化的财富，也可以叫被动收入计划。</li>
<li>摇钱树计划，你需要去种一下一颗能随时给你生成金钱果实的树，不管你此时此刻在做什么，它都依然在茂盛的成长。</li>
<li>摇钱树幼苗计划有哪些，具体以下作为参考:<ul>
<li>租赁系统，除了房子出租，还有其他租赁行业，如：音乐小说版权、汽车、专利发明、漫画等也是租赁的一种形式展示</li>
<li>计算机或软件系统，可以是一个网站，也可以是一个软件或者app，某些高质量的东西上架到强大的分销系统（应用商店）</li>
<li>内容系统，=信息系统，可以整合信息，也可以是写作，作曲等，结合互联网的分销系统去实现</li>
<li>分销系统，是一种将产品转移到消费者的系统，比如：星巴克、iphone中应用商店等</li>
<li>人力资源系统，雇佣更多的人产生更多的利润，但是也需注意可能产生更多的支出代价，如：亚马逊<ul>
<li>亚马逊为什么会是人力资源系统呢？</li>
<li>它是一个计算机系统支撑并有人力资源系统运营的分销系统，因为虽然做的是电商网站，其实管理的是开电商的人</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>第二十章 招募你的自由战士<ul>
<li>摇钱树计划，最重要的种子，就是金钱，金钱本身就是摇钱树的种子</li>
<li>如果你要种一个摇钱树，你需要金钱这个种子<ul>
<li>通俗的讲，就是需要启动资金，需要去存储赚取人生的第一桶金</li>
<li>没有这个基础，所有的摇钱树计划都是浮空的，没有空手套白狼的做法</li>
</ul>
</li>
<li>如何积累你的人生第一桶金呢？<ul>
<li>改变你的消费观念，每花去的一笔钱，都有其意义所在</li>
<li>尽可能快的存储你的钱</li>
<li>同时要想尽一切办法，让钱生钱，哪怕是小钱</li>
</ul>
</li>
<li>复利，不是做定投基金，而是要把钱尽量投入到固定收益的地方，实现真正可以看得到的复利</li>
</ul>
</li>
<li>第二十一章 真正的财富定律——影响力<ul>
<li>与其努力成功，不如努力成为有价值的人。 —— 阿尔伯特·爱因斯坦<ul>
<li>表达的是，成功这个定义太广泛了，没有具体实际含义，而价值却能具体化，当你对他人有价值，那么其实你就是成功的。</li>
</ul>
</li>
<li>吸引力定律，就是一个虚假的神秘理论<ul>
<li>什么是吸引力定律，就是说当你想要成功，不断的想，那么成功就会靠近你</li>
</ul>
</li>
<li>真正成功的定律是影响力，而不是吸引力<ul>
<li>当你能影响百万人的时候，你就可以赚到一百万</li>
</ul>
</li>
<li>财富公式：净利润=销售单位（规模）+单位利润（等级）</li>
<li>规模造就百万富翁，等级也造就百万富翁。规模和等级相结合就会造就亿万富翁。</li>
<li>如果你不知道如何提高影响力，那么朝影响力大的人靠近，自然而然就会有影响力。</li>
<li>扩大规模，提高等级，这是快车道的精神核心，你越有办法做大数字，就越容易获得财富。<ul>
<li>这种模式，不仅仅适用于做生意，适用各方各面，包括工作上，当你做的事情影响范围越大，那么你的工作价值也就越高</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>第6篇 获取财富的工具：自己<ul>
<li>第二十二章 首先管好你自己<ul>
<li>有果必有因，他们早就在春天就播下了种子。 —— 亨利·戴维·梭罗<ul>
<li>这句话表达的是，当某个结果发生在你身上，其实是你当初做的选择导致的，所以如果我们想要某种结果，需要我们在早期就做出选择=种下种子</li>
</ul>
</li>
<li>优先付钱给自己的理论是正确的，但是如果仅靠工资收入来做，等于要求残疾的人去爬楼梯一样不可能</li>
<li>因为你的工资是先给政府过一道，再到老板那边过一道，最终才轮到你，如果你还有房贷、车贷、信用卡等，可能压根就不会轮到你</li>
<li>做到优先付钱给自己，你需要先拥有自己，你需要拥有一家公司，可以自由控制你的时间和财务</li>
<li>如何做到拥有自己：<ul>
<li>创建一家有限责任公司，而不是个体户无限责任</li>
<li>选择一个实体，怎么选择，可以从下面几个点去考虑：<ul>
<li>业务退出策略是？上市？还是卖给私人投资者？</li>
<li>资产增长策略是什么?</li>
<li>最坏情况下，你的责任风险是什么?</li>
<li>现在就筹备资金，还是等到将来？</li>
<li>打算雇佣员工吗？</li>
<li>计划招募合作伙伴吗？</li>
<li>打算快速赚钱，还是等会再说？</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>第二十三章 生活的方向盘——需要自己掌控<ul>
<li>如果你的生活结果是由你的选择造成的，不管你是有意识还是无意识的。如果你能控制选择的过程，你就能控制你的生活中的方方面面。你会发现自由其实就是来自掌控你自己。 —— 罗伯特·班尼特<ul>
<li>表达的是，目前的生活都是我们自己选择，有些是被动，有些是主动，如果你能将一些被动的选择转化为主动，就能控制你自己的生活，那么你就自由了。</li>
<li>当然第二层意思是，你要学会思考某些选择造成后果，每天都需要回顾一下今天的选择是导致后面哪些选择可以更加主动或者被动</li>
</ul>
</li>
<li>贫穷的主要原因，其实是来源于你错误的选择，比如：你花了很多钱买了一些不必要的东西导致贷款累累，你将时间花在无所谓的事情上，而不是去提升自己等</li>
<li>问题的核心，每次遇到问题，我们都需要抱着解决问题的态度去弄清楚此次问题的核心是什么？举几个例子<ul>
<li>由于暴饮暴食，胆固醇提高，处理问题：去医院开处方药，解决问题：不暴饮暴食</li>
<li>旅行中汽车漏油导致油不够，处理问题：去加油站加油，解决问题：修复漏油的地方</li>
</ul>
</li>
<li>快速致富不是一次偶然的选择可以成就，而是数百万次的选择而促成的，而贫穷也是一样的。</li>
<li>如果你不够快乐，那么你需要考虑重新选择。</li>
<li>没有人愿意选择贫穷，那么为什么会变得贫穷，是因为不断做出错误的选择，慢慢的陷入贫穷的泥潭中。</li>
<li>人生的方向盘，是你在手上，你要学会控制，而要理性的去选择方向，叛逆或者错误的选择很容易，但是也很容易让你陷入深渊。</li>
<li>今天的选择会影响终身，所以更加多思考人生的选择</li>
<li>哪怕是你在日常生活中所做的最小的选择，都会不断地改变你的生活习惯和生活方式。</li>
<li>无论哪个年龄段，你都要审视一下生活，分析一下你生活有哪些岔路，你选择哪条道，都会影响之后的生活。</li>
<li>随着时间的推移，能量会逐渐消退，因为那些旧的选择依然让你深陷泥潭难以自拔</li>
</ul>
</li>
<li>第二十四章 将你的挡风玻璃擦拭干净<ul>
<li>在我们看清楚自己之前，不能想当然地贸然行事。 —— 夏洛特·吉尔曼<ul>
<li>表达的是，如果我们连自己的想法都没有弄清楚，一头脑就往里冲，往往失败的就是最后的结果。</li>
</ul>
</li>
<li>什么东西会影响我们的选择：<ul>
<li>认知选择（思维模式），认知是指的你相信某个想法，可能会按照这种思维模式去做选择</li>
<li>行动选择（选择阅读），行动是指的你的执行力，虽然你相信某个选择，但是可能行动上缺乏导致无法执行</li>
</ul>
</li>
<li>认知选择是行动选择的动力，而是行动选择是认知选择的一种结果，先要培养认知选择，才能更好的行动选择</li>
<li>如何提高自己的认知选择或者擦拭我们的挡风玻璃(认知边界)：<ul>
<li>用肯定式的语言去确定我们的选择，如：<ul>
<li>将“从不”和“不能”的词汇从语言里剔除，</li>
<li>”我能“ ”这是有可能的“  ”我会超越“ ”我将“等肯定式语言填充自己的生活中</li>
</ul>
</li>
</ul>
</li>
<li>如何做更好的选择，可以参考的技巧如下：<ul>
<li>更坏情况分析，WCCA<ul>
<li>WCCA能帮你远离哪些错误（导致严重的后果）的选择</li>
</ul>
</li>
<li>加权平均决策矩阵，WADM<ul>
<li>WADM能帮你做出更好的选择</li>
</ul>
</li>
</ul>
</li>
<li>更坏情况分析WCCA，换个容易记名字，叫事前三思，怎么做：<ul>
<li>做出选择前，确定三个问题：<ul>
<li>选择最坏的后果是什么</li>
<li>后果的概率是多少</li>
<li>是可以承担的风险吗？</li>
</ul>
</li>
<li>基本上做一件事，在脑子快速过一遍，就可以避免一些错误的选择</li>
</ul>
</li>
<li>加权平均决策矩阵WADM，换个名字，叫分数判断，怎么做：<ul>
<li>确定使用的场景，是人生比较重要的场景，如：上哪个大学，报考哪个专业，是否辞职跳槽，是否创业等等</li>
<li>需要用笔+纸做详细记录</li>
<li>步骤一，罗列出所有的选择，如：上哪所大学</li>
<li>步骤二，做出这些选择的考虑的决定因素，如：大学里的食堂、住宿、师资、费用、地点等</li>
<li>步骤三，给这些决定性因素对做出选择影响权重有多少，可以设置1-10，如：食堂2，住宿5等</li>
<li>步骤四，给每个选择里的因素打分（1-10分），如：广州大学的食堂5分，暨南大学的食堂6分等</li>
<li>步骤五，将因素打分<em>权重得出分数，如：广州大学的食堂2</em>5=10，暨南大学的食堂得分是2*6=12等</li>
<li>步骤六，计算每个选择的得分，得出更好的选择，如：广州大学118分，暨南大学218（更好的选择）</li>
<li>在这个过程，最重要的是你要如实的给各个因素赋予权重和评分，否则这个判断就不准确</li>
</ul>
</li>
<li>世界不会记得你的过去，只有你自己记得和在乎你的过去，所以需要将注意力从过去（不管是荣耀还是失败）离开，转移到当下</li>
<li>不是忘记过去，而是要从过去吸取教训，主要从下面几点思考失败：<ul>
<li>从中学习到什么</li>
<li>将来我能改变什么</li>
<li>应该忘记什么</li>
</ul>
</li>
<li>如果你的过去定义了你的存在，那么你就不可能成为你未来要成为的人。</li>
</ul>
</li>
<li>第二十五章 排除阻碍你的绊脚石<ul>
<li>奚落是庸才对天才的颂歌。 —— 奥斯卡·王尔德<ul>
<li>表达的是，被人嘲笑是成功路上的最大障碍，但是我们面对这种嘲笑，因为这是对我们行为最大的肯定</li>
</ul>
</li>
<li>生活中的例子，幼儿园问谁会唱歌，大多数人都举手了，而中学里问谁会唱歌，大多数都没有举手，因为幼儿园没有人告诉他们不能，而中学大部分人都有人告诉他们不能</li>
<li>你追求的东西越非凡，那么越需要挣脱平凡的束缚就越大，如：奥维尔·莱特（Orville Wright）和威尔伯·莱特（Wilbur Wright）发明飞机时候受到的束缚，怎么可能飞行</li>
<li>你将会遇到一个阻碍和绊脚石：<ul>
<li>朋友和家人，因为他们不愿意相信有这么一条路可以快速致富</li>
<li>售卖慢车道的教育机构</li>
<li>认命的父母</li>
<li>房子是最好的投资的信念</li>
<li>定投基金的信念</li>
</ul>
</li>
<li>要避开那些不赋予你目标的绊脚石：<ul>
<li>觉得有些东西行不通，已经有人在做了</li>
<li>为什么要自寻烦恼</li>
</ul>
</li>
<li>逃离不利的环境：<ul>
<li>环境因素，包括：天气、文化等</li>
<li>你的工作，如果你正在做一项你十分讨厌，且浪费时间的工作</li>
<li>避免逆风行走，如果有，则逃离它</li>
</ul>
</li>
<li>制造顺风或加速的环境<ul>
<li>甄别当前的阻碍来自哪里因素，是否可以忽略、逃离等</li>
<li>靠近向往快车道或者已经在快车道的人</li>
<li>重要的另一半，你需要说服她，或者离开她</li>
</ul>
</li>
</ul>
</li>
<li>第二十六章 你的原始燃料：时间<ul>
<li>时间不是商品，不可以像一块蛋糕那样被传来传去。时间是生活中的一种存在。当有人想请你花点时间时，其实是在要你生活的一部分。 —— 安托瓦妮特·博斯科<ul>
<li>表达的是你的生活就是时间，如果你想拥有自己的生活，你就必须学会管理时间。</li>
</ul>
</li>
<li>现象：大家会为了某个优惠活动，而去排很长的队伍，他们认为自己的时间不值钱</li>
<li>时间对于所有人来说都是公平，你需要重视你自己的时间，不要浪费它</li>
<li>时间是有限的，而金钱是无限的，你用有限的东西，去排队去浪费3个小时时间，只为了那几块钱优惠吗？</li>
<li>你的生命公式：生命=可自由支配的时间+受到约束的时间</li>
<li>受到约束的时间：花在可以赚钱上的时间</li>
<li>可自由支配的时间：不花在赚钱上的时间</li>
<li>最理想的状态，在于你花在赚钱上的时间，赚来的钱可以让你拥有足够多的自由自配时间</li>
<li>最浪费时间的行为：就是你的寄生性债务<ul>
<li>简单的说，就是你在透支消费，比如：今天买了一件很好的手机，一件很好的衣服等等，但是需要你刷信用卡，从而导致你不得不为了它继续工作，偿还这笔债务</li>
</ul>
</li>
<li>如何避免，每次消费之前，先看一下，这笔钱需要你工作多少天才能赚回来</li>
<li>从源头控制自己的消费：<ul>
<li>巧克力饼干法则，如果饼干没有放入购物车，那么就不会到你家里，你不会吃了，而如果你没吃则不会变成脂肪，造成肥胖</li>
<li>控制债务最源头的地方，就是要控制你的即时满足感<ul>
<li>即时满足感就是当你需要购买的时候，你需要立即满足，会给人一种快感，但是没什么用，因此你要学会如何控制或者降低即时满足感</li>
<li>不要养成即时满足感的习惯</li>
</ul>
</li>
</ul>
</li>
<li>贫穷最大缺点：忽视自由可支配的时间</li>
<li>奉行快车道原则的人在决策时会优先考虑时间，因为这是我们最有价值的资产。</li>
<li>想要快速致富，改变观念，你的时间才是你最大的财富。</li>
</ul>
</li>
<li>第二十七章 换掉脏机油<ul>
<li>人们忘掉了在学校所学的东西之后，剩下的就是教育。 —— 阿尔伯特·爱因斯坦<ul>
<li>表达的是，学校教的知识在随着时间的流逝会忘记，但是你不能忘记的是你要持续的去学习，去教育。</li>
</ul>
</li>
<li>举个例子，你的汽车需要经常换机油，才能跑得更好更久，那么学习就是机油，知识在不断更新换代，那么只有不断学习才不会被社会淘汰</li>
<li>慢车道（打工的人）将教育用来提升自己的内在价值，简单的说，就是提升各种打工技能</li>
<li>快车道（当老板的）将教育用来搭建和发展自己的业务体系，简单的说，就是搭建自己的生意模式</li>
<li>如何去学习，主要有以下几个步骤：<ul>
<li>解决最大的问题，我不知道怎么去做？ 这是大多数人放弃的理由，但是只要坚持下去，没有什么事情是不会做的</li>
<li>无需天赋，只要坚定的信念和不断的努力，就可以成为某一领域的专家</li>
</ul>
</li>
<li>你能做的最好的投资就是投资你自己，应该勇敢为知识付费</li>
<li>在去学习的路上，还有一个大阻碍：我没有时间，那么如何利用时间呢，以下有几个常见的场景：<ul>
<li>堵车的时候，听有声书籍或财经新闻</li>
<li>运动的时候，看相关教育视频</li>
<li>等车的时候，可以读一些有用的书</li>
<li>洗手间的时候，可以学一些新的东西，这段时间是所有打工人最佳学习时间</li>
<li>上班的时候，利用工作休息时间段去学习</li>
<li>看电视或刷抖音或玩游戏，这段时间是不是可以直接利用起来，戒掉这些浪费时间的习惯</li>
</ul>
</li>
<li>设定学习目标，如：今年要完成12本书，那么一个月就是一本，做起来一点都不难吧</li>
<li>去参加各种论坛或沙龙会议，其实并没有什么用，同时还要花钱去听营销</li>
</ul>
</li>
<li>第二十八章 冲击红线<ul>
<li>如果事情看上去是受控的，就意味着你做得不够快。 —— 马里奥·安德莱逖<ul>
<li>表达的是，如果你是一步步的把控事情的进度，那么你就会落后人很多，有时候需要有勇气去快速前进，你才能超越很多人。</li>
</ul>
</li>
<li>红线，是底线，是承担责任，你必须要对你的系统和业务负责人，甚至付出一定代价。</li>
<li>负责任，指的是不是因为兴趣才来的，而是因为你要做出一些东西出来，你需要对此负责。</li>
<li>兴趣让你看上去富有，承担责任使你变得富有。</li>
<li>需要做好十足准备和马力，不断拉开与别人（大多数人）的距离</li>
<li>要走上快车道，快速致富，你必须学会以下几点：<ul>
<li>必须学会承担风险</li>
<li>必须学会经历痛苦与不适</li>
<li>必须学会面对恐惧，那种害怕失败的恐惧</li>
</ul>
</li>
<li>学会承担可控的风险，主要将做一件事的风险点都要想好，然后自己是否可以承担失败后果<ul>
<li>面临一个个失败，从中吸取教训，而不是因为恐惧而逃避</li>
</ul>
</li>
<li>学会识别风险：明智可控的风险、无谓失控的风险<ul>
<li>无谓失控的风险，最大一个特征就是赌博心理，你在没有做任何准备的情况去赌一个可能发生的概率性问题，你没有为提高概率而做努力</li>
<li>明智可控的风险，就是做一个事情，有一定运气成分在，但是你已经做好十足准备或已经做了很多事情去提高成功的概率</li>
</ul>
</li>
<li>禁止“明天做”，能让你不会被这一行为受限<ul>
<li>“明天做”这一理由让大多人一直停留在原地不动</li>
<li>不要等，等到哪些时候才可以做呢？永远不会有完美的时间</li>
</ul>
</li>
<li>机会就在身边，机会以变革和挑战的面目出现<ul>
<li>一个机会，就是最近IT行情不好，大家都找不到工作，所以需要一个面试小程序给到大家信心</li>
</ul>
</li>
<li>时机极少是完美的，等待会让人变得平庸，不要用一生的时间坐等完美时刻的来临。</li>
<li>现在就是走上快车道的时机，不要再犹豫了。</li>
</ul>
</li>
</ul>
</li>
<li>第7篇 通向财富之路<ul>
<li>第二十九章 通向财富的正确道路<ul>
<li>选择上哪条路，就会到达哪个地点。方法决定结果。—— 亨利·艾默生·福斯迪克<ul>
<li>表达的是，其实一开始就等于是终点，努力只是在于你能走多远，做事的方法才是事情的成败的因素。</li>
</ul>
</li>
<li>正确的快速致富的道路，并不是从路边摊开始，那么什么才是正确的财富之路?<ul>
<li>必须接近或者遵循影响力规律的路</li>
</ul>
</li>
<li>影响力规律：为了赚百万美元，你必须影响百万人</li>
<li>快车道创业的5条戒律，你需要经常用这几条戒律检查自身：<ul>
<li>需求戒律</li>
<li>进入戒律</li>
<li>控制戒律</li>
<li>规模戒律</li>
<li>时间戒律</li>
</ul>
</li>
</ul>
</li>
<li>第三十章 需求戒律<ul>
<li>如果我们不是为了生活变得更加容易，那又会是什么？ —— 乔治·艾略特<ul>
<li>表达的是，目前我们所做的和努力的，都是希望生活变得更加美好，请不要忘记这个宗旨。</li>
</ul>
</li>
<li>商业的胜利，最根本的就是为了解决需求，给用户提供有价值的的业务或商品，能解决问题的业务才会有利润，否则将不可持久。</li>
<li>消费者的思维是对我有什么好处，生产者的思维是对别人有什么好处，寻找他人的需求</li>
<li>转变做生意的想法，不是为了赚钱，而是为了解决需求，寻找做生意的机会，其实就是在寻找市场需求</li>
<li>改变思维模式，寻找需求、痛点、问题、服务缺陷和情绪，  而不是为了满足自己才去做某件事</li>
<li>市面上有大量追逐金钱者的成功案例，但他们已经失去了真正快速致富的通道，他们会为了钱不断改变自己，直到为了钱放弃自由和自己</li>
<li>改变做法，不要去追逐金钱，而是吸引金钱，只要你能满足大量需求，就可以吸引到大量金钱</li>
<li>如何做到满足需求呢，具体有以下几种做法：<ul>
<li>让他们感觉更好，服务</li>
<li>帮助他们解决问题，技能</li>
<li>教育他们，培训机构</li>
<li>让他们看起来更棒（健康、营养、衣着、装束），服装、理发</li>
<li>给他们安全感（住房、安全、健康），饮水机的安全设定</li>
<li>产生积极情绪（爱、快乐、欢乐、自信），游乐园、电影、小说</li>
<li>满足口腹之欲，好吃的餐饮店</li>
<li>让事情变得容易，咨询公司</li>
<li>给他们梦想和希望，孵化公司</li>
</ul>
</li>
<li>你喜欢做的事情，不一定是市场所需要，所以不能将你的爱好转变为事业，因为很容易陷入失败</li>
<li>喜欢做的事情一旦与赚钱挂上关系，就会失去本身的意义<ul>
<li>运动员喜欢运动，但是高峰期后就无法再参与</li>
<li>艺术家们画画会需要迎合市场需求，而失去对艺术的热爱</li>
</ul>
</li>
<li>激情与喜欢并没太多关系，激情来自最终目标和原因，它是驱动快车道的行动力</li>
<li>需求一个强大理由，来让自己充满激情面对每一天<ul>
<li>强大的理由，是不想一辈子碌碌无为，平凡打工过一生</li>
<li>强大的理由，看到一些平凡的人在一些事情上是多么的卑微，我不想太卑微，所以我需要成长</li>
<li>强大的理由，我需要一个安静且舒适的环境，能自由过自己想要的生活，这一切都需要钱</li>
</ul>
</li>
<li>激情源自梦想，你要为梦想寻找动机，找到一条能把梦想变为现实的路，这才是正确的路</li>
<li>如何寻找你的激情？<ul>
<li>首先，激情源于激动或不满</li>
<li>其次，保持住你对现在的激动或者不满的情绪</li>
<li>最后，将其转换去做某件的动力源，每当想放弃的时候，想一想当时的激动或不满</li>
</ul>
</li>
</ul>
</li>
<li>第三十一章 进入戒律<ul>
<li>我们的计划搞错了方向，因为没有设定目标。当人们不知道自己该驶向哪个港口时，任何方向的风都不合适。 —— 塞内卡（Seneca）民间谚语<ul>
<li>表达的是，如果我们的人生没有任何目标，或者做某件事没有任何目标，那么无论你怎么做，都是会走向失败的。</li>
</ul>
</li>
<li>进入戒律，第一条，记住进入任何领域都有壁垒，当领域竞争激烈那么致富效果就会减弱，同时如果壁垒够高，那么该领域可以走得更远更强大</li>
<li>低壁垒的行业，往往赚不到钱，如果想要赚到钱，就必须成为第一名</li>
<li>如何判断是否符合进入戒律：<ul>
<li>你所做的生意是不是一个过程，而不是一个结果，如：你购买一套电商平台，这是结果，以为可以开启电商但是却不是，真正电商是需要你去确定货源、用户群、购买意愿、售后等一系列过程</li>
<li>任何短时间可以完成的生意，都是不符合进入戒律的</li>
<li>大家都在做的事情的，或者这门生意很多人都在进入，就不应该进入，这也是进入戒律之一</li>
<li>容易做的生意，也不要去做，因为门槛低，容易失去控制</li>
</ul>
</li>
<li>如果你想快速致富，就不能像大家那样子去做</li>
</ul>
</li>
<li>第三十二章 控制戒律<ul>
<li>靠人不如靠自己 —— 约翰·盖伊<ul>
<li>表达的是，很多事情只有掌握在自己手里，事情才不会失控。</li>
</ul>
</li>
<li>要坐在驾驶位，而不是副驾驶位搭乘便车。</li>
<li>如何做到控制呢？举几个例子：<ul>
<li>创立公司，而不是去公司打工</li>
<li>创建出售连锁品牌，而不是加盟</li>
<li>管理对冲基金，而不是投资</li>
<li>出售股票，而不是购买股票</li>
<li>为别人提供直销，而不是做这个</li>
<li>出售使用权，而不是购买使用权</li>
</ul>
</li>
<li>乘客只能赚零头，而驾驶者却能赚大钱，大钱和零头的区别在于，一个赚2万，一个赚20万</li>
<li>乘客容易失去控制，如果驾驶者赶你下车，你将毫无办法，如：你是一个电商，在淘宝开店，万一哪天淘宝封你的店铺，那么你就会失去所有</li>
<li>训练鲨鱼思维，而不是孔雀鱼，就是吃别人，而不是被别人吃<ul>
<li>要的是更大的图景，而不是眼前的利润</li>
<li>深入思考自己的信念体系，改变思维模式</li>
<li>考虑全部，而不是局部</li>
<li>去引导，而不是跟随</li>
<li>思考如何创新，而不是复制</li>
<li>网络营销，是需要有自己的品牌后才需要的事情，而不是为了别人的品牌去参与网络营销</li>
<li>多层次的网络营销，包括：销售、激励、团队精神，和社交</li>
<li>你需要创建自己的品牌，控制它，创建属于自己的金字塔</li>
</ul>
</li>
</ul>
</li>
<li>第三十三章 规模戒律<ul>
<li>要想在商业上获得成功，你只需要做对一次。 —— 马克·库班<ul>
<li>表达的是你创业能够成功，在于你把握住了某一次机会，但是需要为了这次机会做好所有的准备，而这一次机会恰恰足够让你翻盘。</li>
</ul>
</li>
<li>思考，你希望在限速15的公路前进，还是限速150的公路上前进。</li>
<li>创业就要去做大规模的生意，就好比打棒球，要努力完成全垒打，而不是做一个次安打</li>
<li>规模是什么？<ul>
<li>规模是销售数量，如：你每个月固定销售量是多少，</li>
<li>规模是服务范围，如：你服务的范围是你的小区，还是你的街道，还是城市，全国甚至全球</li>
<li>规模是品牌影响力，如：兰博基尼和现代车的价格，你是做低端，还是高端</li>
</ul>
</li>
<li>规模就是杠杆，用你现在拥有的东西去撬动更大的范围的事业</li>
<li>判断是否违反规模戒律：<ul>
<li>净收入是否有上限，如：每月2000元~20万</li>
<li>这门生意的资产价值是多少？</li>
<li>生意可以影响多少人？客户群是谁？</li>
<li>生意模式是否可以复制，或者开连锁扩大销售范围？</li>
<li>最好的情况下可以销售多少件？</li>
<li>最好的情况下单件的最大利润是多少？是否有量级？</li>
</ul>
</li>
<li>规模戒律是影响力定律的一个因子，影响力定律则是快速致富的方法</li>
<li>影响力定律三大障碍：规模、量级和渠道<ul>
<li>最大的障碍是规模，如果你的行业规模不是给百万人提供服务，那么你无法影响到百万人</li>
<li>量级，指的是你能给多少人提供服务，通常如果规模够大，那么你就有足够大的量级</li>
<li>渠道，等于你的资源或者货源，如果你没有好的资源，你自然就无法做到影响到其他人</li>
</ul>
</li>
<li>如何运用影响力定律：<ul>
<li>选择一条可以打破规模或量级的道路，并掌握来源</li>
<li>如果无法掌控源头，那么就为源头服务</li>
<li>要从大处着眼，考虑规模和量级，分析财富公式并检查变量情况，如：最大销售量和最大利润是多少</li>
</ul>
</li>
</ul>
</li>
<li>第三十四章 时间戒律<ul>
<li>我有很多想法，却缺少时间。我希望我能活到百岁左右，我也就满足了。 —— 托马斯·爱迪生<ul>
<li>表达的是，想做的事情很多，唯一缺少的是时间，而时间则是许多事情能够做成功的重要因素。</li>
</ul>
</li>
<li>时间戒律，指的是快车道的生意是能让你从工作时间脱离出来，能够自主运行且开花结果，自主赚钱。</li>
<li>满足时间戒律的要点：<ul>
<li>当我不在场的时候，生意是否可以有序自动地运转</li>
<li>我的边际收益是否足够多，可以让我雇人去做<ul>
<li>边际收益：增加一单位产品所产生的利润</li>
</ul>
</li>
<li>我的经营是否得益于这是一颗摇钱树业务</li>
<li>如何让生意经营不占用自己的时间</li>
</ul>
</li>
<li>打工是用时间换钱，有些生意也是如此，比如：开水果店、餐饮等</li>
<li>时间戒律就是提高效率，让工作的时间尽可能的短，同时产生更多的效益</li>
</ul>
</li>
<li>第三十五章 快速致富的3条大道<ul>
<li>如果你为别人干活而得不到回报，你就无法过上好生活。 —— 约翰·伍登<ul>
<li>表达的是，如果你依赖别人而活，你就无法稳定的生活</li>
</ul>
</li>
<li>在快速致富的选择，使用WADM（权重分数判断）去考虑各个方面得分数，做出最适合的选择</li>
<li>快车道精髓：5条戒律<ul>
<li>不应该投资没有需求的生意</li>
<li>不应该用时间去交换金钱</li>
<li>不应该在一个有限的规模的行业做生意</li>
<li>不应该放弃控制权</li>
<li>不应该将一个初创的生意当成结果，而是运营它的过程才是结果</li>
</ul>
</li>
<li>3条高速路快车道<ul>
<li>互联网生意</li>
<li>创新产品或服务</li>
<li>创造规模效应</li>
</ul>
</li>
<li>互联网生意，规模天生就是全球且防止别人进入的门槛，有以下几种：<ul>
<li>提供订阅服务，提供服务、信息等付费订阅</li>
<li>提供内容服务，免费提供，增加广告收入</li>
<li>引导性销售，提供引导销售服务，如：携程、美团等</li>
<li>社交网络，利用搭建社交，形成网络依赖服务</li>
<li>中介系统，提供中间商服务收费，如：PayPal</li>
<li>广告联盟，提供广告渠道给广告商</li>
<li>电子商务，通过搭建平台，吸引商铺和消费者进行消费，如亚马逊和淘宝</li>
</ul>
</li>
<li>创新产品或服务，创新包括：制造或销售<ul>
<li>创新不是发明一个工具，而是对一个已有的产品进行改进和提高，并推进市场，如：净水器，可以思考做一些改进，与其他人不同，插座做的更好看和好用</li>
<li>创新双重挑战：制造和销售，如：写一本书是制造，而将它卖给人则是销售，需要市场营销、推广、演讲等扩大它的知名度</li>
</ul>
</li>
<li>创造规模效应，利用创造大规模实现快速致富的效果，比如：买一栋房子出租是有限的，但是买50栋就能快速致富<ul>
<li>连锁经营，可以开小便利店，但是利用规模效应，可以重复开很多所，就可以实现快速致富</li>
<li>因为一个小规模的生意并不能产生大的利润，如果不断叠加，就可以产生量级利润，这就是量变导致质变</li>
</ul>
</li>
</ul>
</li>
<li>第三十六章 找到你的金光大道<ul>
<li>开始时，人们拒绝相信一个新奇的事情，之后人们开始希望能够做到，然后他们看到那件事情确实可以做到，最终那件事做成了。所有人开始问，为何这件事几个世纪了都没人去做。—— 弗朗西斯·霍奇森·伯内特<ul>
<li>表达的是，人们一般不会愿意相信自己认知外的事情，直到开始动手去实现后，才发现确实是可以做到的。</li>
</ul>
</li>
<li>机遇是什么<ul>
<li>机遇，就像一个待满足的需求，正在那里等着别人去发现，如: 路边有人正在抱怨、论坛上正在争吵的事情</li>
<li>机遇，就是对一个”不方便“提出的解决方案，让人感觉到舒适</li>
<li>机遇，就是简化流程，提供更好的服务</li>
</ul>
</li>
<li>怎么做<ul>
<li>有人正在做这件事，那么你只需要比他做得更好</li>
<li>成功的生意往往不是因为新奇的创意，关键是要比别人做的更好</li>
<li>成功的生意可以采用已有的点子、服务和产品，只需要做得更好，或者采用新的做法</li>
</ul>
</li>
<li>找到大道的办法<ul>
<li>利用一些词汇，如：讨厌、不喜欢、烦恼、为什么、不得不、希望、试过、槽糕透了等，去收集需求和机遇</li>
<li>发现这些问题需求，向大家提出解决方案并确保赚钱，因为解决问题就等于解决了自己赚钱的问题</li>
</ul>
</li>
<li>在失败中开辟一条新路，失败并不可怕，重要的是要失败中吸取经验，或许你就能从中找到你真正走上财富的路</li>
<li>失败是经常的事情，但是不要忘记你自己的梦想</li>
</ul>
</li>
<li>第三十七章 为你的路设定终点<ul>
<li>悲剧不是你未能达到目标，而是你根本没有设定目标。 —— 本杰明·梅斯<ul>
<li>表达的是如果你没有设定目标，而一直努力的话，你的努力终究会白费掉。</li>
</ul>
</li>
<li>需要想清楚你的终点是什么，快车道致富是一种手段，如：你想要自由自在的生活在不缺钱的日子里，没有领导压迫，当老婆跟你要钱的时候你可以随时提供</li>
<li>再次确定金钱的重要性，你所想要的一切梦想，都需要付出代价，而这个代价就是金钱</li>
<li>实现自由享受符合你期望的生活方式的两个策略：<ul>
<li>一是一大笔钱，利息足够你日常开销</li>
<li>二是你的商业系统产生的被动收入能够支持你的生活，同时也能继续维持系统的运转</li>
</ul>
</li>
<li>设定终点的4个步骤：<ul>
<li>定义生活方式，就是你最理想的生活<ul>
<li>住多大的房子</li>
<li>想要多少辆汽车</li>
<li>一年多少次旅游</li>
<li>孩子的上什么学校等等</li>
</ul>
</li>
<li>评估这种生活的成本，大概需要多少钱<ul>
<li>一个一线城市的大平层，全款1000万，水电物业费费等一个月3000</li>
<li>3辆汽车，大概40万一辆 120万，每个月开销8千，</li>
<li>旅游，每个月1000</li>
<li>私立学校：每个月2000</li>
<li>生活成本：每个月3万</li>
<li>总计：每个月5万左右</li>
</ul>
</li>
<li>设定目标，建立金钱系统和生意收入目标<ul>
<li>创立一个商业系统，按照40%收入、40%返回给到商业系统维持，20%维持生活，那么商业系统至少每个月需要产生利润25万</li>
</ul>
</li>
<li>实现，找到方法并去做<ul>
<li>先定一个小目标，然后再换中目标，最后才换成大目标，一步步走才不会因为困难而无法前进</li>
<li>找指数基金做智能定投，实现每年5%的收益</li>
<li>创建自己的金钱系统，</li>
</ul>
</li>
</ul>
</li>
<li>快车道规则，必须拥有丰富的财务知识，从而避免不必要财富损失风险</li>
<li>为了财富稳定，必须学会金钱的规则，基本的财务和经济学知识</li>
<li>节流是慢车道，而是快车道是开源节流</li>
</ul>
</li>
</ul>
</li>
<li>第8篇 加速累积财富<ul>
<li>第三十八章 成功的速度<ul>
<li>创意只是神经速度，此处无他。 —— MJ·德马科<ul>
<li>表达的是，很多想法只是在大脑里经过，你没有去实现，那么它就只是大脑的一个神经细胞动了一下而已。</li>
</ul>
</li>
<li>速度的策略，是象棋，而不是跳棋<ul>
<li>速度是实现，是推进，是去操作，而不是想象</li>
<li>象棋的玩法是多维度的，而跳棋则是单维度的思考</li>
<li>如一款电商产品，大多数人认为价格低就可吸引消费者，但是从来没有想过其他方面，如：营销、质量、服务、售后、物流速度等</li>
<li>速度，就是快速将你的商业系统快速搭建起来，而不是单方面的去实现</li>
</ul>
</li>
<li>如果想真正获得成功，你需要加快速度将脑子里想法落地，而不是去看电视剧，同时需要坚持不懈，要控制进度</li>
<li>创意是结果，而执行是过程，过程是要牺牲、努力、纪律和坚持。</li>
<li>快车道的速度可以让生意按照指数倍增，使净收入和资产价值实现爆发式增长。</li>
</ul>
</li>
<li>第三十九章 烧掉商业计划，立即开始行动<ul>
<li>除非你立即采取行动，否则即便有全世界最棒的创意也没有用。想喝牛奶的人不能只是坐在养牛场的一把椅子上，等着奶牛过来喂奶。—— 柯蒂斯·格兰特<ul>
<li>表达的是，光有想法不行动，即使你是天才也没法成功</li>
</ul>
</li>
<li>只有将创意落地，你才知道创意是否行得通</li>
<li>世界会告诉你怎么走，哪条路是对的，但是前提需要你去行动起来</li>
<li>风险投资看重的是执行，而不是你的商业计划书写的多牛逼</li>
<li>当你的执行结果非常好，那么投资自然而然就会拥抱过来，从而获得更多资金</li>
</ul>
</li>
<li>第四十章 步行者会让你发财<ul>
<li>如果你做的不错，客户会口口相传。口碑很重要。 —— 杰夫·贝佐斯<ul>
<li>表达的是，当你的生意服务很好，形成了口碑，那么接下来你就继续保持原样，生意范围会越来越广。</li>
</ul>
</li>
<li>所有的生意客户服务目标只有一个，就是提供帮助、支持和解决方案。</li>
<li>积极面对客户投诉，及时处理投诉，是快速形成口碑的重要方式</li>
<li>如何识别投诉：<ul>
<li>变化，就是当你的产品发生变化，引起老用户不适应，这需要你去平衡，因为改变总会影起不适应</li>
<li>期望，当你的产品无法满足用户的期望，就会引起投诉，这个时候你需要紧急去处理</li>
<li>无效投诉，当你产品没有这类功能，用户不断提出来，你需要计算他们的次数，然后去增加该类功能</li>
<li>欺诈投诉，针对这类投诉，就是优雅回应，解释立场，然后继续处理自己的事情</li>
</ul>
</li>
<li>制作超越客户期望的服务，如何制作：<ul>
<li>收集客户的期望</li>
<li>告诉雇佣的员工，告诉他们给他们发工资是客户，而不是老板</li>
</ul>
</li>
<li>客户服务战略将影响公司的成长，必须满足客户期望，从而获得忠诚的客户</li>
<li>制作一个强大的公司品牌，让竞争对手不敢进来，打出气势，吓跑潜在对手</li>
</ul>
</li>
<li>第四十一章 把搭便车者扔出去<ul>
<li>人才是一家公司的最大资产，不管这家公司是造车的还是做化妆品的。一家公司的人有多好，这家公司就有多棒。 —— 玫琳凯·艾施<ul>
<li>表达的是，人才对公司来说是最重要的，拥有多少人才，就表示这家公司能走多远。</li>
</ul>
</li>
<li>管理公司，不仅仅有人才，还会有骗子，需要谨慎骗子，同时将其扔出去</li>
<li>找到一个互补的合伙人至关重要，然后要互相信任，相互理解，相互尊重</li>
<li>律师和会计师是第二重要的合作伙伴，需要谨慎再谨慎去选择，即使信任也要小心，这叫防人之心不可无</li>
<li>做法之一，就是先信任，再验证，需要花点心思去做筛选</li>
<li>必须雇佣能够遵循你商业模式定律的员工：<ul>
<li>员工必须落实你的客户服务理念</li>
<li>不管产品多好，如伟大的技术，都弥补不了糟糕的客服体验</li>
<li>不管服务多好，也无法遮盖产品的缺点</li>
</ul>
</li>
</ul>
</li>
<li>第四十二章 成为别人的救星<ul>
<li>市场不会因为一个好产品而被拯救，但是一个坏产品足以很快摧毁它。 —— 亨利·福特<ul>
<li>表达的是，一锅汤很容易被一颗老鼠屎弄坏，但是要做一个锅好汤不仅仅需要一个好食材就可以做到。</li>
</ul>
</li>
<li>平庸的产品无法创造足够利润，因为大家都在做同样的事情</li>
<li>做生意要有合适的理由，不能是因为不知道做啥才做这个，也不是因为喜欢才去做<ul>
<li>合适的理由是：解决一个问题或者满足某个需求</li>
</ul>
</li>
<li>做生意应该选择有差异化的产品或者某个行业问题的解决方案</li>
<li>有时候要忽略选择竞争对手的，不能把竞争对手在做什么当做自己的优先事项</li>
<li>什么时候需要留意竞争对手，需要留意的是竞争对手的弱点，然后将其作为自己产品的差异点</li>
<li>95%的注意力应该放在你的产品创新上</li>
</ul>
</li>
<li>第四十三章 打造品牌而不是生意<ul>
<li>每个人脖子上都挂着一个看不见的标牌，上面写着”让我觉得自己很重要“。在和人们打交道时候，千万不可忘记这件事。 —— 玫琳凯·艾施<ul>
<li>表达的是，每个人都有自己的品牌，希望别人看得见，所以品牌对于人或者商品而言都是很重要的。</li>
</ul>
</li>
<li>品牌是商品不会平庸化最佳策略，品牌是汇聚忠诚粉丝最有效的力量</li>
<li>品牌代表产品的形象，如：沃尔沃是安全，法拉利是速度等</li>
<li>品牌是需要独特的，在销售上需要一个独一无二的主张</li>
<li>如何开发独特的品牌<ul>
<li>发掘优点，比别人不一样的地方，解决或者更好解决别人的问题</li>
<li>独一无二，销售策略要足够独特，给消费者足够吸引力或者说服自己的能力，给消费者足够的选择</li>
<li>要具体，给出证据，你的产品有足够的优点，但是你需要给出证据证实这些优点</li>
<li>简短、清晰、明智，就是能被人快速记住</li>
<li>把你的销售主张放进所有的营销资料中</li>
<li>说到做到，商业的承诺要说到做到，否则没有人会给你第二次机会</li>
</ul>
</li>
<li>品牌首先要做到的引起注意，如何引起注意：<ul>
<li>极化，观点或者信息极端化，就是要表明你的态度，如：你坚持用Vue的原因是因为Vue的开源作者是中国人</li>
<li>冒风险，冒风险的策略之一是性吸引</li>
<li>调动情绪，能够与用户共鸣，触发他们的喜怒哀乐</li>
<li>鼓励互动，让用户投票或者选择，或者增加他们的评论</li>
<li>不落俗套，就是不大众化，新颖吸引人的注意力</li>
</ul>
</li>
<li>给消费者带来的，是这里有什么是我需要的，怎么做</li>
<li>就是把产品的特点翻译为好处<ul>
<li>调换角色，你把自己当成客户，是什么样的人群（CEO、学生、大妈等），确定他们真正的需求是什么</li>
<li>确定特点，确定需求后就是从产品分离出自己的特点</li>
<li>明确优势，然后确定这些特点有什么优势</li>
<li>将特点翻译成好处，最后将这些特点翻译成对用户有好处的东西</li>
</ul>
</li>
<li>用价格做品牌的武器，这也是目前大家都知道一个事情，就是原价999，现价499</li>
<li>价格代表不仅仅是成本，还是价值和用途的表现<ul>
<li>同时注意不要让价格毁掉你的品牌，低价格的东西会让你品牌变得廉价和大众化</li>
</ul>
</li>
<li>手提包的成本不到100元，却可以卖到1000元，因为它的品牌和营销做得好</li>
<li>控制消费者的大脑，同时也就获得客户</li>
</ul>
</li>
<li>第四十四章 选择”一夫一妻制“<ul>
<li>没有配马鞍，马儿就跑不远。没有加压力，蒸汽就无法推动任何东西。没有管道，尼亚加拉大瀑布的水就无法发电。专注、投入和自律，才能让生命更加伟大。 —— 哈里·艾默生·福斯迪克<ul>
<li>表达的是，成功的必需条件是，专注、投入和自律，如果这都做不到，那么你的成功就只是一次偶然，而不是必然，终究还是会失去。</li>
</ul>
</li>
<li>创业就和结婚一样，需要一夫一妻，而不是多撒网就可以多捕鱼，需要你的时间和精力都花在一个地方上</li>
<li>只有专注才有多样化，因为只有专注做一件事，才能把它做好</li>
<li>只有专注做一件事，成功之后，才会逐步衍生到其他方面，最后做成多样化</li>
</ul>
</li>
<li>第四十五章 为你的致富计划充满电<ul>
<li>选择可以马上做出，后果则伴随一生。 —— MJ·德马科<ul>
<li>表达的是我们每时每刻都在做出选择，而这些选择的结果则会形成我们的生活。</li>
</ul>
</li>
<li>如何给我们致富计划添加一个超级充电器：<ul>
<li>公式，财富是一个过程，而不是结果，是一个公式，结合了信仰、选择、行动、生活方式构成的系统性过程</li>
<li>认同，认同缓慢致富是完全错误的，认同快速致富是存在的，承认无计划不是一个好计划，认同运气是全心投入的结果</li>
<li>弃旧迎新，放弃原有的思维，停止我们一直在做的事情，重点是从消费者变成生产者</li>
<li>时间，时间是快车道宝贵的资产，尤其是自由可支配的时间，投资可产生自由可支配的时间的活动，把时间作为关键因素去搭建自己的商业系统</li>
<li>杠杆，可控制的杠杆=可控制的财务计划，能让你快速致富</li>
<li>资产和收入，财富是可以通过生意让收入和资产价值成指数型增长，同时不奢侈浪费消费，就可以打造出百万富翁</li>
<li>数字，赚钱的目标是什么，想要一个什么样的生活将其量化成数字，然后将相关目标放在自己随处可见的地方</li>
<li>影响力，记住影响力定律，你在能够控制的环境里，你影响几百万人，你就可以赚几百万元</li>
<li>导向，选择哪条路，选择快车道你就可以快速致富，拥有年轻的身体和更多的自由时间，现在做出改变，同时要对每个选择有责任心，要能承担责任</li>
<li>脱钩，你创业的东西必须具备自我成长性，能够与你的工作时间脱钩</li>
<li>激情和目的，激情能让你为了目的打满鸡血，同时也让你对一些不满的行为愤怒不已，不仅仅是因为喜欢而已</li>
<li>教育，不要停止学习，你现在所了解远远满不足了未来的目标，你需要不停的学习去加强你的业务系统的建设和运作。同时，学习信息也是你的财务之旅的燃油，抽出时间来学习。</li>
<li>道路，不要迷惑到底应该选择哪个行业，而是应该训练发现需求和问题的大脑，当你尝试去解决某个问题或者需求的时候，你就已经在走进一个行业里</li>
<li>控制，你需要有足够的掌控权，有完整的财务计划，才能做一条吃鱼的鲨鱼，而不是一条被吃的孔雀鱼</li>
<li>满足，要选需求，而不是选喜爱，要去解决问题，金钱才不断向你涌过来</li>
<li>自动化，让你的生意自动化成长，与你的时间脱钩</li>
<li>复制，你的商业模式应该是可以复制的，从而形成规模效应，能够快速影响数百万人</li>
<li>成长，你的业务可要从各方面去成长，而不是只有单一个特点，要做成品牌，同时需要聚焦某个业务，而不是多点开花</li>
<li>退出，制定一个退出策略，快车道的终点是实现被动收益系统，而释放这个系统最好的方式通过清算兑现巨大的财富</li>
<li>退休、回报或东山再起，好好放松一下，然后再选择去做什么</li>
</ul>
</li>
<li>不要让过去影响现在的选择，快车道上的人总是充满坎坷，如：背着贷款、每天都要上班没时间、我家人不太赞同我做这个等等</li>
<li>最后的答复是，不要因为这些借口影响到你，我们已经浪费太多时间了，我们需要行动，现在就行动。</li>
</ul>
</li>
<li>总结 回答一些直接的问题<ul>
<li>如何降低创业失败的风险<ul>
<li>找到市场的需求或者问题的空白区，再去做，即使有人已经做了，我们只要做的更好，花更多时间在上面，我们一样可以成功</li>
</ul>
</li>
<li>快车道指南，我着重采取几条我认为重要的<ul>
<li>不要为了节省钱而浪费时间</li>
<li>不要为了周末而工作五天</li>
<li>不要以为时间很充裕</li>
<li>不要停止学习</li>
<li>不要让生活被寄生性债务缠身，如：信用卡、花呗、分期贷款等</li>
<li>不要做消费者，而是生产者</li>
<li>不要追逐金钱，而不是追逐需求</li>
<li>不要相信每个人，要给他们证明自己的机会</li>
<li>不要轻易踏足低门槛或容易做的生意</li>
<li>不要做业务，而是做品牌</li>
<li>不要关注产品的营销信息，而是关注它能够用户带来的好处</li>
<li>不要做多头主义，要聚焦</li>
<li>不要做单一产品（如跳棋规则），要做从多方面思考产品（如象棋）</li>
<li>不要超前消费，而是寻找机会扩展自己能力范围</li>
<li>要具备基本的金融知识</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="阅读总结"><a href="#阅读总结" class="headerlink" title="阅读总结"></a>阅读总结</h1><p>读完《百万富翁快车道》，这是我第一本按照思维导图的方式去完整读完的书籍，收获颇丰，主要是从思维模式发生了改变，这一点是在学校里永远都不会有老师教给的思维模式。老师只会告诉你知识是什么，但是却不会告诉你知识是怎么用的，为什么要有知识，这个很难去讲，因为他们也不懂，他们所教的知识也是从上一代老师传下来，从师范学校里学的应该这么去教。</p>
<p>《快车道》这本书，给我们明确的指出了人生赚钱的三条路：</p>
<ul>
<li>人行道，有多少钱花多少钱，甚至超前预支消费，如：用贷款买车、买房、买奢侈品等等，然后你花完后发现根本就存不下任何钱，因为你已经掉入了社会给你设置好的消费陷阱，你需要不断消耗你的时间去赚钱填补超前消费这个坑，如果你不断挖坑（提前消费），那么你将无法抵抗任何风险，即使你是大明星（年入几百万）或者底层的农民（年入几百元），一旦失去收入，你就直接破产，面对人生的失败。</li>
<li>慢车道，尽量少花钱，然后相信定投基金这种谎言，依赖别人，靠打工赚钱和定期存储金钱，这是大部分普通人相信的道理，就是靠存钱或定投基金可以到老年退休后可以好好享受生活，但是这种思维是一种极大幸运概率的思维，因为你的收入控制权不在你手上，而是在很多人手上，比如领导每年都能给你加薪，公司不裁员，爸妈不要生大病花钱，孩子不需要额外的开销等等，这种选择你无法抵抗任何大一点的风险，因为一旦风险来临，你之前所做的一切（存钱计划）将灰飞烟灭，而且你的生活质量一直处于低水平，因为你不敢花钱。</li>
<li>快车道，尽量快的赚钱和尽可能的少花钱，这种选择可以在短时间快速赚钱，然后可以持续不断的赚钱思维，开始很难，但是后面就会越来越容易，因为你已经搭建完自己能控制的商业系统，它将同一个摇钱树一样不断给你提供越来越多的金钱，你只需要控制好它（财务计划）就好，当然这个选择需要遵循很多戒律，如：需求、进入、规模、控制、时间等，同时需要你去制造影响力，还要从消费者转化为生产者的思维。</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title>GPT-4都来了，我们还需要刷算法题和背八股文吗？</title>
    <url>/ideas/20230312.html</url>
    <content><![CDATA[<h1 id="2023年的面试寒冬"><a href="#2023年的面试寒冬" class="headerlink" title="2023年的面试寒冬"></a>2023年的面试寒冬</h1><p>从去年到今年各个大厂都在不断裁员，导致今年IT互联网行情很差，很多朋友都缺乏面试机会或者面试不通过。</p>
<p>程序员一旦要开始面试，很多朋友都开始循环以下几个步骤：</p>
<ul>
<li>刷算法题，如：LeetCode各种困难程度的题目</li>
<li>背诵各种八股文，如：浏览器请求一个URL的完整过程</li>
<li>复习各种冷门知识，如：Promise.race(谁先返回就获取谁的结果，后面直接不处理)或Promise.allSettled(结果为Iterator对象，实现next())</li>
</ul>
<p>也许以往这种复习模式还算不错，因为目前大多数面试流程基本上都是会问上述问题，而面试官问这些问题的最终目的是什么：</p>
<ul>
<li>算法题，主要考的是逻辑思维能力</li>
<li>八股文，主要考的是基础知识是否足够扎实，知识深度是否足够</li>
<li>冷门知识，主要考的是知识广度，你除了目前使用知识点外还能拥有其他知识面</li>
</ul>
<p>后续一些项目经验讲述，主要目的在于测试你是否真的参与到项目中，但是这个往往都是容易被忽略的点，这个放到后面再讲。</p>
<p>当下最火的IT技术，ChatGPT智能机器人出来后，它不像普通搜索引擎一样，需要去大量的结果去找到自己的答案。而是直接将答案提供给到你，让你可以更加快速实现功能。</p>
<p>如果ChatGPT普及开来，那么面试是否还需要考算法题和八股文吗？</p>
<p>或者换个问题，<strong>当AI技术可以代替绝大部分基础开发工作的时候，面对这种技术变更，作为普通开发者，我们应该如何做技术成长规划呢？</strong></p>
<a id="more"></a>

<h1 id="怎么办"><a href="#怎么办" class="headerlink" title="怎么办"></a>怎么办</h1><h2 id="看清楚问题"><a href="#看清楚问题" class="headerlink" title="看清楚问题"></a>看清楚问题</h2><p>作为普通的开发人员，我们平时大部分开发工作说的不好听一点，其实都是在复制粘贴，简单点说就是在搬砖，从A地方搬到B地方，举几个例子:</p>
<ul>
<li>利用框架封装好的东西去开发项目，是否有尝试过自己去实现一个框架，如：Vue、React</li>
<li>实现某一个功能的时候，要嘛从现有项目中拷贝，要嘛从网上找对应答案，比如：需要从一个url获取参数，你会自己实现一个，还是拷贝呢？</li>
<li>遇到问题，第一反应基本上先从网上找答案，找到答案看看能否解决，如果可以就不会再往下深入学习</li>
</ul>
<p>以上基本上就是我们普通开发的发展路线——尽量不去开发轮子，也没有时间和兴趣去开发轮子。</p>
<p>当chatGPT智能机器人出现之后，你会发现你会的机器人都会，而且它还能实现你不能实现的功能，那么我们可以大胆猜测未来会有这么一个产品：</p>
<blockquote>
<p>一个低代码智能化平台，只需要资深开发者去输入一些关键性的业务代码，同时优化生成出来的代码逻辑。</p>
</blockquote>
<p>举个更简单的例子，原本你手动搬的砖，现在有机器人可以实现自动搬了，或者说当马车被汽车替代了，那么马夫的工作自然也就被司机所替代。</p>
<p>那么问题就很简单了，现状的问题是：</p>
<p><strong>大厂或小厂都在裁员，不需要那么多搬砖工了，而你还在为了更快搬砖，去提高自己的搬砖能力，如：刷算法题、基础知识等，不就等于在锻炼自己臂力让自己能搬更多的砖吗？</strong></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>既然清楚问题了，针对这个问题能有什么解决方案呢？其实是有的，就在于自己的选择。</p>
<h3 id="成为少数人"><a href="#成为少数人" class="headerlink" title="成为少数人"></a>成为少数人</h3><p>怎么理解成为少数人呢？主要有两种方式：</p>
<p><strong>第一种方式，无可替代或者很难替代。</strong></p>
<p>你的工作只有你能做，或者你做的工作很难。还是以搬砖为例：</p>
<ul>
<li>可以在高楼层搬砖</li>
<li>可以在深海里搬砖</li>
</ul>
<p>简单的说，除了开发业务功能外，你还掌握了其他的技能，说出来可能大家会骂人，如：</p>
<ul>
<li>写一手漂亮的PPT，能把PPT做堪比艺术品</li>
<li>项目管理能力强，能把握项目进度</li>
<li>有产品思维，你实现的功能比产品经理想得还完整</li>
<li>其他软技能…</li>
</ul>
<p><strong>第二种方式，成为专家</strong></p>
<p>这种方式需要天赋+机会+努力，缺一不可，简单来说，就是大家搬砖用的工具都是你制作的，如：</p>
<ul>
<li>Vue/React的作者，将很难被淘汰</li>
<li>公司内部的架构师们，项目的整体架构和轮子都由他搭建的，或者公司需要他们去新搭建一套轮子</li>
</ul>
<p>那么如何成为专家呢？不管是从网上还是现实中，都有很多实现路线，我这里简单总结一下:</p>
<ul>
<li>努力学习，扩展技术栈，日复一日的坚持学习知识</li>
<li>深入业务领域，将技术与业务结合，不断创造一些新的方案或架构</li>
<li>扩大自己的影响范围，等待机会，创造一套属于自己的架构体系</li>
</ul>
<h3 id="离开搬砖"><a href="#离开搬砖" class="headerlink" title="离开搬砖"></a>离开搬砖</h3><p>如果真的继续干这一行，吃技术饭很难混下来，那么只有选择离开，但是离开也分不同的分开，下面简单说几句。</p>
<p><strong>第一种离开，改变自己，拥抱新方向</strong><br>当汽车来临的时候，马夫无法继续工作了，那么为何不直接投入汽车司机的行业呢？</p>
<p>既然AI技术已经开始成熟投入使用了，那么作为开发者有什么理由不提前进入AI领域，去尝试一种新的方向呢？</p>
<p>比如：</p>
<ul>
<li>彻底转行成为AI开发，这里门槛有点高，但是可以去尝试</li>
<li>利用AI开发工具，成为AI的使用者是不是更加合适呢？</li>
</ul>
<p><strong>第二种离开，永远离开，投入新领域</strong><br>AI的到来，会实现很多基础开发工作，那么我不做开发了，是不是就不用被淘汰了呢？</p>
<p>正如所说，天涯何处无芳草，哪里都可以混口饭吃。</p>
<p>不要做21世纪的孔乙己，脱不下身上的长袍。</p>
<p>举几个例子：</p>
<ul>
<li>转技术培训，前提是你在IT开发待的足够久</li>
<li>创业当老板，从打工思维变老板思维，前提是得有钱有资源</li>
<li>早餐摊，卖粥，足以养活一家人，前提是身体健康</li>
</ul>
<p>总之，心态不要奔溃，被裁员也好，面试不通过也好，这只是当前整个大背景下的一个波浪，更何况目前AI的技术并没有那么发达。</p>
<p>如果以时间为维度，你这次的失败，只是你几十年人中的一个小片段。</p>
<p>如果以空间为维度，你我皆是蝼蚁，宇宙何其庞大，你抬头看片星空，是否心情会更加放松一点。</p>
<p>最后，推荐大家去看一本书《百万富翁的快车道》，名字很俗，但是却能给我们带来一种新的思想模式：</p>
<ul>
<li>财富不是金钱等物质，而是你所能控制的时间+你的健康+人脉</li>
<li>人生的每个选择，都是你的信念系统做出的，如果你要财富，则需要不断优化自己本身的信念系统</li>
</ul>
<h1 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h1><p>本文是个人一些想法，仅供参考。</p>
<blockquote>
<p>做一个有温度的技术分享作者 —— Qborfy</p>
</blockquote>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>奇思妙想</tag>
      </tags>
  </entry>
  <entry>
    <title>可以从ChatGPT学到什么（二）—— 利用AI自动生成git commit信息</title>
    <url>/today/20230221.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>自从上一次写完<a href="https://qborfy.com/today/20230216.html" target="_blank" rel="noopener">可以从ChatGPT学到什么(一)</a>，简单对ChatGPT有一定了解后，其背后的技术原理是基于OpenAI GPT-3协议去实现的智能对话的。</p>
<p>再加上我看到国外有很多相关基于GPT开发的开源应用，因此萌生了自己动手搞一个，加上之前自己翻译了一篇文章<a href="https://qborfy.com/translate/use-gpt3-auto-git-commit.html" target="_blank" rel="noopener">有了GPT-3，再也不用手写commit message</a>，他是基于Rust语言写，想着直接对着他照搬一个到Node.js版本，通过这种小项目实践，我们可以学习到：</p>
<ul>
<li>OpenAI提供了哪些模型算法</li>
<li>不同模型算法分别可以应用到哪些场景</li>
<li>真正调用OpenAI需要注意哪些事项</li>
</ul>
<a id="more"></a>
<p>接下来我们开始动手吧！这里基本前提是你得拥有OpenAI API keys，可以到[OpenAI]。</p>
<p>首先我们先来看看<a href="https://github.com/qiubohong/node-gptcommit" target="_blank" rel="noopener">node-gptcommit</a>是做什么的。</p>
<h1 id="node-gptcommit"><a href="#node-gptcommit" class="headerlink" title="node-gptcommit"></a>node-gptcommit</h1><p><a href="https://github.com/qiubohong/node-gptcommit" target="_blank" rel="noopener">node-gptcommit</a>是基于<a href="https://github.com/zurawiki/gptcommit" target="_blank" rel="noopener">gptcommit</a>实现思路去开发的node版本工具命令，可以根据项目中git的diff文件列表去生成git commit信息。</p>
<p>具体效果可以参考以下步骤：</p>
<ol>
<li>安装</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install node-gptcommit -g</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设置openai的apikey</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ngptcommit config --set openai.apiKey=sk-xxxxx</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>开始使用</li>
</ol>
<p>请到某个git仓库的根目录使用，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd xxx</span><br><span class="line"></span><br><span class="line">ngptcommit preview</span><br></pre></td></tr></table></figure>

<p>就可以看到具体返回的信息，具体下文所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;🤖 GPT-3 返回的总结内容如下:&quot;</span><br><span class="line"></span><br><span class="line">feat: </span><br><span class="line"></span><br><span class="line">- 更新项目配置，加强 TypeScript 的选项。</span><br><span class="line">- 添加了包含了推荐和 Prettier 的扩展，设置特定规则和排除的 `tslint.json` 文件。</span><br><span class="line">- 包含了文档配置的 `typedoc.js` 文件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 在新的 `tsconfig.json` 中添加严格的 TypeScript 选项。</span><br><span class="line">- 在新的 `tslint.json` 文件中添加了推荐和 Prettier 的扩展。</span><br><span class="line">- 配置了特定规则的排除和 false 选项。</span><br><span class="line">- 添加了文档配置的 `typedoc.js` 文件。</span><br></pre></td></tr></table></figure>

<h1 id="OpenAI使用说明"><a href="#OpenAI使用说明" class="headerlink" title="OpenAI使用说明"></a>OpenAI使用说明</h1><p>OpenAI API说明文档，地址：<a href="https://platform.openai.com/docs/" target="_blank" rel="noopener">openai docs</a>。</p>
<p>首先，我们需要了解几个概念：</p>
<ul>
<li><code>Model</code> 模型，是AI算法模型，根据不同模型可以推算出不同的结果</li>
<li><code>Completion</code> 任务结果，指的调用模型后返回的结果</li>
<li><code>apiKey</code> api秘钥，openai对调用api方的鉴权token</li>
</ul>
<h2 id="Model模型"><a href="#Model模型" class="headerlink" title="Model模型"></a>Model模型</h2><p>OpenAI提供了几个模型，主要分别以下几种：</p>
<p>基于<code>GPT-3</code>模型开发的模型：</p>
<ul>
<li><code>GPT-3.5-turbo</code>，最新的GPT-3.5模型，主要针对对话聊天的自然语言和代码处理，也能处理传统的任务，成本只有<code>text-davinci-003</code>十分之一</li>
<li><code>text-davinci-003</code>，对各类型语言都友好支持，比其他模型更加擅长输出更多更长更高质量的文案，而且还会在文案补全相关逻辑</li>
</ul>
<p>除了<code>GPT-3</code>模型，openAI还提供了几个其他模型（包括：beta版本），如下：</p>
<ul>
<li><a href="https://platform.openai.com/docs/guides/images" target="_blank" rel="noopener"><code>DALL·E</code></a>，根据自然语言生成图片。</li>
<li><a href="https://github.com/openai/whisper" target="_blank" rel="noopener"><code>Whisper</code></a>，语音识别模型，已经开源的模型</li>
<li><a href="https://platform.openai.com/docs/guides/embeddings" target="_blank" rel="noopener"><code>Embeddings</code></a>，检测词语的关联关系，能实现搜索、分类、推荐、异常检测、多样性测试、标签等</li>
<li><a href="https://platform.openai.com/docs/guides/code" target="_blank" rel="noopener"><code>Codex</code></a>，基于GPT-3生成专门针对代码优化的模型，最擅长的是Python语言，精通十几种语言，包括JavaScript、Go、Perl、PHP、Ruby、SWIFT、TypeScrip、SQL，甚至是Shell等。</li>
<li><a href="https://platform.openai.com/docs/guides/moderation/overview" target="_blank" rel="noopener"><code>Moderation</code></a>，按照OpenAI内容安全使用策略，识别内容是否非法，如:涉黄、暴力、自残等。<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2></li>
</ul>
<ol>
<li>安装依赖</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install openai</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>初始化</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Configuration, OpenAIApi &#125; <span class="keyword">from</span> <span class="string">'openai'</span>;</span><br><span class="line"><span class="keyword">const</span> config = <span class="keyword">new</span> Configuration(&#123;</span><br><span class="line">    apiKey,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">this</span>.openai = <span class="keyword">new</span> OpenAIApi(config);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>根据不同模型调用</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gpt-3.5-turbo</span></span><br><span class="line"><span class="keyword">const</span> prompt = <span class="string">'请问你是谁？'</span>;</span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="keyword">this</span>.openai.createChatCompletion(&#123;</span><br><span class="line">    model: <span class="string">"gpt-3.5-turbo"</span>,</span><br><span class="line">    messages: [&#123;</span><br><span class="line">        role: <span class="string">"user"</span>, <span class="comment">// system: 机器人, user: 用户, assistant: 助手</span></span><br><span class="line">        content: prompt</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// debug('调用openai接口返回内容：', response.data)</span></span><br><span class="line"><span class="keyword">return</span> response.data.choices[<span class="number">0</span>]?.message?.content ?? <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成一张黑色暹罗猫的图片</span></span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> openai.createImage(&#123;</span><br><span class="line">  prompt: <span class="string">"a black  cat"</span>,</span><br><span class="line">  n: <span class="number">1</span>,</span><br><span class="line">  size: <span class="string">"1024x1024"</span>,</span><br><span class="line">&#125;);</span><br><span class="line">image_url = response.data.data[<span class="number">0</span>].url;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p>生成猫的图片：</p>
<div>
<img src="/assets/img/20230314.png" width="200px">
</div>

<p>了解到OpenAI提供了如此多的API，是否可以利用他们来开发一些辅助工具来提升我们开发幸福感呢？</p>
<p>目前已经有很多这种开源小工具了，比如：<a href="https://github.com/zurawiki/gptcommit" target="_blank" rel="noopener">gptcommit</a>， <a href="https://github.com/JimmyLv/BibiGPT" target="_blank" rel="noopener">BibiGPT</a>，<a href="https://github.com/Nutlope/roomGPT?utm_source=gold_browser_extension" target="_blank" rel="noopener">roomGPT</a>等。</p>
<p>接下来我们以<a href="https://github.com/zurawiki/gptcommit" target="_blank" rel="noopener">gptcommit</a>为参考，尝试自己去实现。</p>
<h1 id="开发ngptcommit的背后"><a href="#开发ngptcommit的背后" class="headerlink" title="开发ngptcommit的背后"></a>开发ngptcommit的背后</h1><h2 id="gptcommit实现原理"><a href="#gptcommit实现原理" class="headerlink" title="gptcommit实现原理"></a>gptcommit实现原理</h2><p>gptcommit是基于Rust开发，但是从看代码的过程中发现Rust其实和Typescript差不多类似的语法，所以很容易上手。</p>
<p>下面有张图，大概就是gptcommit实现的过程：</p>

<div class="mxgraph-container">
    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/gptcommit.drawio&quot;}"></div>
</div>


<h2 id="Node命令行工具"><a href="#Node命令行工具" class="headerlink" title="Node命令行工具"></a>Node命令行工具</h2><p>既然知道了gptcommit实现原理，那么要开发一个node的命令行工具，具体有哪些步骤呢？</p>
<ol>
<li>在<code>package.json</code>里配置命令行名称<code>bin:xxx</code>:</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    "bin": &#123;</span><br><span class="line">        "ngptcommit": "bin/ngptcommit.js"</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>针对命令行工具，node.js要求在文件开头必须表明<code>#!/usr/bin/env node</code>：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env node</span><br><span class="line"></span><br><span class="line">import run from &apos;../dist/cli.js&apos;;</span><br><span class="line">run();</span><br></pre></td></tr></table></figure>

<p>到了这里，我们基本就开始动手撸代码了，这里我还推荐一些npm包，能帮你快速开发命令行工具，有以下这些：</p>
<ul>
<li>rollup，比webpack更加适合开发js库的构建工具</li>
<li>debug，更好打印debug日志，而不是所有都console.log</li>
<li>cac，非常轻量的库，能帮你更快开发一个命令行工具</li>
<li>picocolors，可以将在命令行输出的带颜色文字</li>
<li>progress，可以在命令行显示进度条</li>
</ul>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ol>
<li>国内openAI无法连接上？<br>需要在代码预先判断连接，设置一个10秒超时，避免已经失败了，还要再继续去请求。</li>
</ol>
<ol start="2">
<li><p>openAI访问频率有限制，如何解决？<br>需要加上每次请求后等待缓冲时间，避免因为多次请求导致失败。利用<code>p_limit</code>库，加上每次请求利用setTimeout设置缓冲等待时间，避免多次高并发请求，后续可以优化模板内容，避免多次重复请求。</p>
</li>
<li><p>失败重试如何实现？<br>通过失败次数，加上递归自己，实现通过失败次数实现失败重试。</p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过开发这个工具，对OpenAI的有了更深入的了解，也明白为什么会有人说以后会出现一个岗位，叫<strong>AI驯服师</strong>或者<strong>AI提问者</strong>。</p>
<p>目前我个人对OpenAI类似的AI，可以认知到点如下：</p>
<ul>
<li>要学习如何向AI提问，更高效的向AI提问，可能会成为未来的一种趋势</li>
<li>AI更多是一种辅助工具，而不是会替换现有的岗位上的人，能帮忙人更高效的完成当前的工作</li>
<li>会有越来越多AI平台出现，甚至可能会出现一种大语言模型，或者面向AI编程语言，只需要写少量代码实现功能</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://platform.openai.com/docs/" target="_blank" rel="noopener">OpenAI相关文档</a></li>
<li><a href="https://github.com/zurawiki/gptcommit" target="_blank" rel="noopener">gptcommit</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>30分钟搞懂Rollup+Typescript构建工程</title>
    <url>/today/20230222.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在研究一个ngptcommit命令行工具，然后想通过<code>Rollup</code>+<code>Typescript</code>去编译的时候，发现对<code>Rollup</code>和<code>Typescript</code>的编译配置有点陌生，所以希望通过本文能够对其有个系统的认知。</p>
<p>本文主要是项目编译基础知识，明白其为什么要这么配置，同时能够将项目完整跑起来。</p>
<p>参考项目地址为:<a href="https://github.com/qiubohong/node-gptcommit" target="_blank" rel="noopener">node-gptcommit</a>。</p>
<a id="more"></a>

<p>为什么不用<code>Webpack</code>和<code>Vite</code>呢？因为这两个对于一个命令行工具来说有点过于重了，有点啥像杀鸡焉用宰牛刀的感觉。</p>
<h1 id="Rollup"><a href="#Rollup" class="headerlink" title="Rollup"></a>Rollup</h1><blockquote>
<p>Rollup是JavaScript模块打包工具，可以将现代化代码编译成更加复杂的代码，如：库或应用。默认使用 JavaScript ES6 修订版中包含的代码模块的新标准化格式，而不是以前的特殊解决方案，如 CommonJS 和 AMD等。 —— <a href="https://rollupjs.org/introduction/" target="_blank" rel="noopener">Rollup 官网</a></p>
</blockquote>
<p>了解Rollup的打包核心思想：主要是将代码编译成符合ES模块规范的代码包，当然也可以用其相关的插件实现CommonJS规范。</p>
<p>接下来我们将通过下面几个步骤去完整了解Rollup：</p>
<ul>
<li><p>Rollup组成部分</p>
</li>
<li><p>Rollup执行构建原理流程</p>
</li>
<li><p>结合Typescript实战</p>
<h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h2><p>一般我们实际使用场景是不会通过命令行去编译某个文件，而是针对整个项目去编译构建，因此一个完整<code>Rollup</code>构建项目主要有以下几个部分组成：</p>
</li>
<li><p><code>rollup</code> npm包，用于执行构建命令源头，可以安装本地项目，也可以安装全局命令，但是一般是跟着项目走</p>
</li>
<li><p><code>rollup.config.js</code> roll的配置文件，是所有命令的入口，也是学习Rollup的核心基础之一</p>
</li>
<li><p>插件部分，rollup有丰富的插件生态，如：Babel 编译代码，运行 JSON 文件等，可以让rollup完成更多复杂构建功能</p>
</li>
<li><p>输出插件，在rollup代码分析完成之后，才可以修改代码相关事项</p>
</li>
</ul>
<p>这基本上就是<code>Rollup</code>项目构建所组成的部分了，接下来我们进行一一学习。</p>
<h3 id="Rollup命令"><a href="#Rollup命令" class="headerlink" title="Rollup命令"></a>Rollup命令</h3><p>在项目中，我们常用的命令有以下几种：</p>
<ul>
<li><code>rollup -c</code> 使用配置文件（如果使用参数但是值没有 指定, 默认就是 rollup.config.js）执行构建</li>
<li><code>rollup -c -w</code> 监听入口文件并在文件改变时重新构建</li>
<li><code>rollup -c --environment BUILD:production</code> 可以设置环境变量，会设置<code>process.env.BUILD = &#39;production&#39;</code></li>
</ul>
<p>通过我们会在<code>package.json</code>中的<code>scripts</code>设置如下命令：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">        <span class="attr">"dev"</span>: <span class="string">"rollup -c -w"</span>,</span><br><span class="line">        <span class="attr">"build"</span>: <span class="string">"rollup -c --environment BUILD:production"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本上就已经满足绝大部分项目需求了，如果有些项目需要更多命令配置，可以到官网查看命令行参数:<a href="https://rollupjs.org/command-line-interface/" target="_blank" rel="noopener">Rollup命令行参数说明</a>。</p>
<h4 id="非命令行使用Rollup"><a href="#非命令行使用Rollup" class="headerlink" title="非命令行使用Rollup"></a>非命令行使用Rollup</h4><p>还有一种<code>Rollup</code>的使用，就是通过代码引用<code>Rollup</code>实现，比如在<code>scripts/build.js</code>，去引用<code>rollup</code>，然后深度参与Rollup构建前后的一些事项，满足项目构建的自定义功能。</p>
<p>一般代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> rollup = <span class="built_in">require</span>(<span class="string">'rollup'</span>);</span><br><span class="line"><span class="comment">// 有关选项的详细信息，请参见下文</span></span><br><span class="line"><span class="keyword">const</span> inputOptions = &#123;...&#125;;</span><br><span class="line"><span class="keyword">const</span> outputOptions = &#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">build</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个 bundle</span></span><br><span class="line">  <span class="keyword">const</span> bundle = <span class="keyword">await</span> rollup.rollup(inputOptions);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(bundle.watchFiles); <span class="comment">// 该 bundle 依赖的文件名数组</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在内存中生成输出特定的代码</span></span><br><span class="line">  <span class="comment">// 您可以在同一个 bundle 对象上多次调用此函数</span></span><br><span class="line">  <span class="keyword">const</span> &#123; output &#125; = <span class="keyword">await</span> bundle.generate(outputOptions);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> chunkOrAsset <span class="keyword">of</span> output) &#123;</span><br><span class="line">    <span class="keyword">if</span> (chunkOrAsset.type === <span class="string">'asset'</span>) &#123;</span><br><span class="line">      <span class="comment">// 对于assets，包含</span></span><br><span class="line">      <span class="comment">// &#123;</span></span><br><span class="line">      <span class="comment">//   fileName: string,              // asset 文件名</span></span><br><span class="line">      <span class="comment">//   source: string | Uint8Array    // asset 资源</span></span><br><span class="line">      <span class="comment">//   type: 'asset'                  // 表示这是一个 asset</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Asset'</span>, chunkOrAsset);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 对于chunks, 包含</span></span><br><span class="line">      <span class="comment">// &#123;</span></span><br><span class="line">      <span class="comment">//   code: string,                  // 生成的JS代码</span></span><br><span class="line">      <span class="comment">//   dynamicImports: string[],      // chunk 动态导入的外部模块</span></span><br><span class="line">      <span class="comment">//   exports: string[],             // 导出的变量名</span></span><br><span class="line">      <span class="comment">//   facadeModuleId: string | null, // 该chunk对应的模块的ID</span></span><br><span class="line">      <span class="comment">//   fileName: string,              // chunk的文件名</span></span><br><span class="line">      <span class="comment">//   imports: string[],             // chunk 静态导入的外部模块</span></span><br><span class="line">      <span class="comment">//   isDynamicEntry: boolean,       // 该 chunk 是否是动态入口点</span></span><br><span class="line">      <span class="comment">//   isEntry: boolean,              // 该 chunk 是否是静态入口点</span></span><br><span class="line">      <span class="comment">//   map: string | null,            // sourcemaps(如果存在)</span></span><br><span class="line">      <span class="comment">//   modules: &#123;                     // 此 chunk 中模块的信息</span></span><br><span class="line">      <span class="comment">//     [id: string]: &#123;</span></span><br><span class="line">      <span class="comment">//       renderedExports: string[]; // 导出的已包含变量名</span></span><br><span class="line">      <span class="comment">//       removedExports: string[];  // 导出的已删除变量名</span></span><br><span class="line">      <span class="comment">//       renderedLength: number;    // 模块中剩余代码的长度</span></span><br><span class="line">      <span class="comment">//       originalLength: number;    // 模块中代码的原始长度</span></span><br><span class="line">      <span class="comment">//     &#125;;</span></span><br><span class="line">      <span class="comment">//   &#125;,</span></span><br><span class="line">      <span class="comment">//   name: string                   // 命名模式中使用的 chunk 的名称</span></span><br><span class="line">      <span class="comment">//   type: 'chunk',                 // 表示这是一个chunk</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Chunk'</span>, chunkOrAsset.modules);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 或者将bundle写入磁盘</span></span><br><span class="line">  <span class="keyword">await</span> bundle.write(outputOptions);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build();</span><br></pre></td></tr></table></figure>

<p>然后<code>package.json</code>中的<code>scripts</code>设置如下命令：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">        <span class="attr">"build"</span>: <span class="string">"node scripts/build.js"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p><code>rollup.config.js</code>一般会放在项目根目录下，如果放在其他目录下，需要在命令行上指定对应路径，如：<code>rollup -c xxx/rollup.config.js</code>。</p>
<p>Rollup配置文件中，我们需要关心的配置项主要有以下几个：</p>
<ul>
<li><code>input</code> 入口文件，Rollup将从这里去扫描解析代码，生成代码依赖树，支持多个</li>
<li><code>output</code> 输出配置项，主要是指的Rollup编译输出什么格式的代码，这里涉及多个配置项</li>
<li><code>plugins</code> 依赖的插件列表，需要哪些插件去扩展Rollup构建能力，不同插件配置内容也不同，后面会讲述常用的几个插件</li>
<li><code>external</code> 忽略打包模块列表，如：有些公共库，我们不需要构建进来</li>
<li><code>cache</code> 构建缓存，是否开启构建缓存，提高构建速度，依据配置内容可以才去不同缓存策略</li>
</ul>
<p>需要注意的一个点，<code>Rollup</code>是支持多套配置，比如：用来生成<code>umd</code>规范的代码文件用来支持浏览器，再就生成<code>cjs</code>给node使用的js文件。</p>
<p>针对上面几个常用的配置项，我们来一一分析它们的用法，其他的配置项可以到官网查看:<a href="https://rollupjs.org/configuration-options/" target="_blank" rel="noopener">Rollup完整配置项</a>。</p>
<h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><p>input最常见的问题就是多个入口文件，毕竟单一入口文件就很简单解决了，那么遇到有多个入口文件的时候，<code>input</code>该如何配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  ...,</span><br><span class="line">  input: &#123;</span><br><span class="line">    a: <span class="string">'src/main-a.js'</span>,</span><br><span class="line">    <span class="string">'b/index'</span>: <span class="string">'src/main-b.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    ...,</span><br><span class="line">    entryFileNames: <span class="string">'entry-[name].js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<ul>
<li><code>input</code>配置的key值会作为<code>output</code>中配置<code>entryFileNames</code>中<code>name</code>的值</li>
<li>最终会输出两个文件<code>entry-a.js</code>和<code>entry-b/index.js</code></li>
</ul>
<h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><p><code>output</code>相比较<code>input</code>会复杂很多，但是我们所关心的主要配置项如下：</p>
<ul>
<li><p><code>output.dir</code>， 构建好的代码文件放d到哪个文件夹中</p>
</li>
<li><p><code>output.file</code>，针对单一入口，指定生成的文件名，如：<code>index.esm.js</code> <code>index.cjs.js</code>等</p>
</li>
<li><p><code>output.format</code>，按照哪个代码规范去生成，目前主要有：</p>
<ul>
<li><code>cjs</code> 为CommonJS规范，适用于 Node 环境和其他打包工具</li>
<li><code>es</code> 为ES规范，适用于其他打包工具以及支持 <code>&lt;script type=module&gt;</code> 标签的浏览器</li>
<li><code>umd</code> 通用模块定义，生成的包同时支持 <code>amd</code>、<code>cjs</code> 和 <code>iife</code> 三种格式</li>
<li>其他有<code>amd</code> <code>iife</code>等</li>
</ul>
</li>
<li><p><code>output.globals</code>，用来忽略打包（umd 或 iife 规范）后的代码的代码依赖，比如：代码中依赖<code>jquery</code>，且<code>jquery</code>在代码使用<code>$</code>标识，则可以配置:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">output:&#123;</span><br><span class="line">    globals: &#123;</span><br><span class="line">        jquery: <span class="string">'$'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>output.name</code>， 以umd 或 iife 规范打包后的代码，需要注册在全局对象中的名字</p>
</li>
<li><p><code>output.plugins</code>，针对输出后的代码需要进行插件扩展，如：压缩代码</p>
</li>
<li><p><code>output.chunkFileNames</code>，对代码分割中产生的 chunk 文件自定义命名，默认值是：<code>[name]-[hash].js</code></p>
</li>
<li><p><code>output.exports</code>，指定导出模式，有几个值：</p>
<ul>
<li><code>default</code>，等于最终导出等于<code>export default xxx</code>，这里适用于单个文件入口</li>
<li><code>named</code>，等于<code>export default {xxx1, xxx2}</code>，适用于多个入口文件</li>
<li><code>none</code>，没有<code>export</code>，适用于打包web应用，不需要对外抛出对象</li>
</ul>
</li>
<li><p><code>output.externalLiveBindings</code>， 是否给外部依赖生成动态绑定代码，简单的说就是是否需要将外部依赖的npm包通过转义来引入</p>
</li>
<li><p><code>output.freeze</code> 指定是否使用 Object.freeze() 冻结动态访问的引入对象的命名空间，禁止修改外部的依赖对象属性</p>
</li>
<li><p><code>output.sourcemap</code> 是否生成sourcemap文件</p>
</li>
</ul>
<p>Typescript主要知识点：</p>
<h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><p>Rollup plugin有很多，这里我们分成两块去学习，一个是如何配置plugin，另外一个是如何开发一个plugin。</p>
<h4 id="配置plugin"><a href="#配置plugin" class="headerlink" title="配置plugin"></a>配置plugin</h4><p>这块内容就相对比较简单了，主要在于如何找到适合的plugin，以及它们的配置项是怎么样的。</p>
<p>第一个问题，到哪里找插件，Rollup官网提供一个地方去找对应plugin，<a href="https://github.com/rollup/awesome" target="_blank" rel="noopener">awesome Rollup插件</a></p>
<p>第二个文件，如何配置plugin，具体如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> typescript <span class="keyword">from</span> <span class="string">'rollup-plugin-typescript2'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [&#123;</span><br><span class="line">    plugins:[</span><br><span class="line">        typescript()</span><br><span class="line">    ]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<h4 id="开发plugin"><a href="#开发plugin" class="headerlink" title="开发plugin"></a>开发plugin</h4><p>在官网有详细的教程，这里我们简单学会如何快速完成一个插件。</p>
<p>首先，我们需要对Rollup执行流程有一个完整的理解，如下图生命周期钩子函数所示：</p>
<p><img src="/assets/img/rollup-plugin-flow.png" alt></p>
<p>Rollup对外提供的生命周期钩子函数：</p>
<ul>
<li>读取配置项 options</li>
<li>开始构建 buildStart</li>
<li>解析代码 resolveId，这里可以自定义一个解析代码器</li>
<li>加载代码 load</li>
<li>加载缓存模块 shouldTransformCacheModule</li>
<li>转义代码中 transform</li>
<li>将代码解析ES模块化后 modulePared</li>
<li>解析异步加载，如：import(()=&gt; xxx) resolveDynamicImport</li>
<li>构建结束 buildEnd</li>
<li>监听改变中 watchChange</li>
<li>关闭监听后 closeWatcher</li>
</ul>
<p>接下来我们来完成一个插件，就是在代码构建前，将<code>__helloworld__</code>换成<code>&quot;hello qborfy!&quot;</code>，避免代码解析出错，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// replaceHelloWorld.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">replaceHelloWorld</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: <span class="string">'replace-helloworld'</span>, <span class="comment">// 插件名称</span></span><br><span class="line">        transform ( code, id ) &#123; <span class="comment">// 当进入转换的时候</span></span><br><span class="line">            <span class="keyword">if</span> (id === <span class="string">'replace-helloworld'</span>) &#123;</span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">                code = code.replace(<span class="regexp">/__helloworld__/g</span>, <span class="string">`"hello qborfy!"`</span>)</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    code, </span><br><span class="line">                    map: <span class="literal">null</span>, <span class="comment">// 这里不影响sourcemap生成 具体可以看https://rollupjs.org/plugin-development/#source-code-transformations</span></span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来在rollup.config.js中引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> replaceHelloWorld <span class="keyword">from</span> <span class="string">'./replaceHelloWorld.js'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (&#123;</span><br><span class="line">  input: <span class="string">'virtual-module'</span>, <span class="comment">// resolved by our plugin</span></span><br><span class="line">  plugins: [replaceHelloWorld()],</span><br><span class="line">  output: [&#123;</span><br><span class="line">    file: <span class="string">'bundle.js'</span>,</span><br><span class="line">    format: <span class="string">'es'</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>有两种方式去管理插件，一个是在项目直接管理维护，另外一种是通过发布npm包管理，这个取决插件是否有公用性即可。</p>
<h1 id="Typescript"><a href="#Typescript" class="headerlink" title="Typescript"></a>Typescript</h1><p>在本文中不讨论Typescript的具体用法，我们将学习如何将Typescript代码转为JavaScript。</p>
<p>如何将一个Typescript代码转义为JavaScript呢？Typescript本身提供了一个工具<code>typescript</code>，因此我们针对其来学习一番。</p>
<p>如何使用typescript呢？ 可以到官网<a href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html" target="_blank" rel="noopener">TypeScript使用说明文档</a>。</p>
<p>我们这里简单总结一下，在项目中使用Typescript，构建工具一般有以下几个步骤：</p>
<ul>
<li><code>npm install typescript -D</code> 安装Typescript工具</li>
<li><code>npm install @babel/core -D</code> 结合babel对Typescript进行转义</li>
<li>配置文件<code>tsconfig.json</code>，配置一些Typescript编译功能</li>
<li><code>npm install eslint -D</code>，结合<code>eslint</code>对代码语法做检测</li>
<li>配置文件<code>eslint.json</code>，配置代码检测标准</li>
</ul>
<h2 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h2><p>tsconfig.json一般是放到项目根目录，如果放到其他目录，需要修改对应地址， 配置文件主要几个部分：</p>
<ul>
<li><code>compilerOptions</code> 编译时的一些配置内容</li>
<li><code>watchOptions</code> 当监听文件变化时候需要配置一些内容</li>
<li><code>include</code> 哪些文件需要编译，如：<code>&quot;include&quot;: [&quot;src/**/*&quot;, &quot;tests/**/*&quot;]</code></li>
<li><code>exclude</code> 对某些文件进行忽略，不做编译，如：<code>&quot;exclude&quot;: [&quot;src/js/*&quot;]</code></li>
<li><code>extends</code> 继承其他配置文件，如：<code>&quot;extends&quot;: [&quot;./base.json&quot;]</code></li>
</ul>
<p>目前我们主要使用的还是<code>compilerOptions</code>，里面主要的配置项有：</p>
<ul>
<li><code>paths</code> 将部分路径进行缩写，比如：<code>&quot;@App/*&quot;: [&quot;src/*&quot;]</code>，后续使用<code>@App</code>，就会解析成<code>src</code></li>
<li><code>target</code> 代码转义哪个ES标准下，如：ES2017,ES2018,ES2019等</li>
<li><code>module</code> 代码模块化遵循哪个标准，如：ESNext，CommonJS等</li>
<li><code>strict</code> 是否使用严格模式检测代码质量</li>
<li><code>lib</code> 编译的有时候需要依赖一些全局变量，比如：Document对象，这个时候需要设置为<code>DOM</code>，或者使用<code>Map</code>对象，这个时候需要<code>ESNext</code></li>
<li><code>declaration</code> 是否给每个文件都生成 声明文件<code>.d.ts</code></li>
<li><code>noImplicitOverride</code> 设置后可以提醒继承类<code>override</code>同名方法时候，需要标注<code>override</code>关键字</li>
<li><code>noUnusedLocals</code> 不允许有未使用的变量</li>
<li><code>esModuleInterop</code> 可以修复由于ES规范和其他规范混合使用导致的引用错误</li>
<li><code>useUnknownInCatchVariables</code> 支持catch中error设置为Unknown类型</li>
<li><code>resolveJsonModule</code> 支持json文件引入为一个模块</li>
</ul>
<p>对<code>Rollup</code>和<code>Typescript</code>都有一定了解后，接下来我们就来实战<code>Rollup</code>+<code>Typescript</code>工程化项目。</p>
<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><ol>
<li>初始化项目<br>新建一个文件夹<code>demo-rollup</code>，后续命令如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir demo-rollup</span><br><span class="line"></span><br><span class="line">npm init</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装依赖</li>
</ol>
<ul>
<li>安装rollup相关依赖</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pnpm add rollup -D</span><br></pre></td></tr></table></figure>

<ul>
<li>安装Typescript相关依赖</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pnpm add typescript tslib -D</span><br></pre></td></tr></table></figure>

<ul>
<li>安装babel</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pnpm add @babel/core @babel/preset-env @babel/plugin-proposal-class-properties -D</span><br></pre></td></tr></table></figure>

<ul>
<li>安装rollup相关插件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pnpm add @rollup/plugin-babel -D #babel插件</span><br><span class="line">pnpm add @rollup/plugin-commonjs -D #转成commonjs的插件</span><br><span class="line">pnpm add rollup-plugin-typescript2 -D #typescript插件</span><br></pre></td></tr></table></figure>

<ul>
<li>安装其他依赖</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pnpm add rimraf -D</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>配置rollup.config.js</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> typescript <span class="keyword">from</span> <span class="string">'rollup-plugin-typescript2'</span>; <span class="comment">// 处理typescript</span></span><br><span class="line"><span class="keyword">import</span> babel <span class="keyword">from</span> <span class="string">'@rollup/plugin-babel'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">    &#123;</span><br><span class="line">        input: <span class="string">'src/index.ts'</span>,</span><br><span class="line">        plugins: [</span><br><span class="line">            typescript(), <span class="comment">// typescript 转义</span></span><br><span class="line">            babel(&#123;</span><br><span class="line">                babelrc: <span class="literal">false</span>,</span><br><span class="line">                presets: [[<span class="string">'@babel/preset-env'</span>, &#123; <span class="attr">modules</span>: <span class="literal">false</span>, <span class="attr">loose</span>: <span class="literal">true</span> &#125;]],</span><br><span class="line">                plugins: [[<span class="string">'@babel/plugin-proposal-class-properties'</span>, &#123; <span class="attr">loose</span>: <span class="literal">true</span> &#125;]],</span><br><span class="line">                exclude: <span class="string">'node_modules/**'</span>,</span><br><span class="line">            &#125;)</span><br><span class="line">        ],</span><br><span class="line">        output: [</span><br><span class="line">            &#123; <span class="attr">file</span>: <span class="string">'dist/index.js'</span>, <span class="attr">format</span>: <span class="string">'cjs'</span> &#125;,</span><br><span class="line">            &#123; <span class="attr">file</span>: <span class="string">'dist/index.esm.js'</span>, <span class="attr">format</span>: <span class="string">'es'</span> &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>配置tsconfig.json</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"include"</span>: [<span class="string">"./src/*"</span>],</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"ES2019"</span>,</span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"ESNext"</span>,</span><br><span class="line">    <span class="attr">"moduleResolution"</span>: <span class="string">"node"</span>,</span><br><span class="line">    <span class="attr">"strict"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"esModuleInterop"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"noImplicitOverride"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"noUnusedLocals"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"resolveJsonModule"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"useUnknownInCatchVariables"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"typeRoots"</span>: [<span class="string">"./types"</span>, <span class="string">"./node_modules/@types"</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"types"</span>: [<span class="string">"jest"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>配置package.json</li>
</ol>
<p>添加dev和build命令脚本，如下所示：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "main": "dist/index.js",</span><br><span class="line">  "type": "module", // rollup新增的配置项</span><br><span class="line">  "scripts": &#123;</span><br><span class="line">    "dev": "rimraf dist &amp;&amp; rollup -c rollup.config.ts -w",</span><br><span class="line">    "build": "rimraf dist &amp;&amp; rollup -c rollup.config.ts"</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>编写demo代码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// sum.ts</span><br><span class="line">export default function sum(a: number, b:number)&#123;</span><br><span class="line">  return a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.ts</span><br><span class="line">import sum from &apos;./sum&apos;;</span><br><span class="line"></span><br><span class="line">console.log(sum(1, 2));</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>测试运行</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pnpm run dev</span><br><span class="line"></span><br><span class="line">pnpm run build</span><br></pre></td></tr></table></figure>

<p>查看生成<code>dist/index.js</code> 和 <code>dist/index.esm.js</code>。</p>
<p>完整项目源码地址:<a href="https://github.com/qiubohong/qiubohong.github.io/tree/master/code/demo-rollup" target="_blank" rel="noopener">demo-rollup</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>Node冷门知识点——require(&#39;node:path&#39;)</title>
    <url>/share/node-modules.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>今天在看Vite的源码时候，发现有个用法很神奇，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> path, &#123; resolve &#125; <span class="keyword">from</span> <span class="string">'node:path'</span></span><br><span class="line"><span class="keyword">import</span> &#123; fileURLToPath &#125; <span class="keyword">from</span> <span class="string">'node:url'</span></span><br><span class="line"><span class="keyword">import</span> &#123; readFileSync &#125; <span class="keyword">from</span> <span class="string">'node:fs'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; version &#125; = <span class="built_in">JSON</span>.parse(</span><br><span class="line">  readFileSync(<span class="keyword">new</span> URL(<span class="string">'../../package.json'</span>, <span class="keyword">import</span>.meta.url)).toString(),</span><br><span class="line">)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>源码地址在:<a href="https://github.com/vitejs/vite/blob/main/packages/vite/src/node/cli.ts" target="_blank" rel="noopener">vite/src/node/cli.ts</a></p>
<p>因此想要研究一下为什么要用<code>node:path</code>，而不是直接应用 <code>import path from &#39;path&#39;</code>呢？下面就来好好分析一下。</p>
<a id="more"></a>

<h1 id="require机制"><a href="#require机制" class="headerlink" title="require机制"></a>require机制</h1><p>首先，我们需要先搞清楚<code>require</code>加载流程:</p>
<ul>
<li>加载核心模块，如：fs、path等，其实在node运行的时候，已经放到内存中了</li>
<li>加上对应文件后缀，优先级为：test.js &gt; test.json &gt; test.node</li>
<li>搜索路径，如果有指定路径则按照路径去找，如：require(‘./test’) 则在当前目录寻找</li>
<li>如果没有指定路径，则从当前目录下往上去找 node_modules文件夹，然后从文件夹里去遍历寻找对应模块名，如果找不到则到上一层node_modules去找，直到最顶层目录</li>
<li>首次会加载比较慢，后面node.js 会将缓存相关信息到内存避免二次查询</li>
</ul>
<p>所以当我们加载内置模块的时候，如：<code>require(&#39;fs&#39;)</code>时候，其实是直接用node内存的变量</p>
<h1 id="Node-ModuleName"><a href="#Node-ModuleName" class="headerlink" title="Node:ModuleName"></a>Node:ModuleName</h1><p>接下来我们再到官网中去找一下这个定义，<a href="https://nodejs.org/api/module.html#modules-nodemodule-api" target="_blank" rel="noopener">node:module API</a>的使用说明：</p>
<blockquote>
<p>可以使用<code>node：前缀</code>来标识核心模块，在这种情况下，它会绕过所需的缓存。例如，<code>require(&#39;node:fs&#39;)</code>将始终返回内置的fs模块，即使存在该名称所需的<code>.cache</code>条目也是如此。</p>
</blockquote>
<h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><p>从上面大概清楚两种用法的实际意义，那么两者分别使用场景呢？或者说<code>Node:ModuleName</code>有什么意义呢？</p>
<ul>
<li>直接使用<code>require(&#39;fs&#39;)</code>，需要等node.js将所有核心模块加载完成后才可以使用，这个可以通过<a href="https://nodejs.org/api/module.html#modulebuiltinmodules" target="_blank" rel="noopener"><code>module.builtinModules</code></a>去判断是否加载完成</li>
<li>使用<code>require(&#39;node:fs&#39;)</code>，则不需要等待，可以直接调用内置模块，但是却无法使用缓存</li>
</ul>
<p>因此，如果是对启动速度有要求的功能，建议直接<code>require(&#39;node:fs&#39;)</code>模式，其他正常调用即可。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>从pnpm工具了解整个npm包核心管理原理</title>
    <url>/today/20230219.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>今年在github前端领域star上升速度比较主要有以下几个：</p>
<ul>
<li>Svelte, 一个将MVVM架构放到构建应用程序的编译阶段实现的框架，让你开发更少的代码实现更多的功能</li>
<li>Typescript, 几乎所有的前端框架不约而同的支持了Typescript，一个JavaScript的超集，支持变量类型声明</li>
<li>pnpm，一个现代化的npm包管理工具，采用link方式去全局管理包，这是本文介绍的重点。</li>
</ul>
<p>因此，选一个和我们项目中开发相关的作为一个知识扩展点，应该就是pnpm了。</p>
<a id="more"></a>
<p>其实从事前端这么多年，自从npm包出现以后，前端工程化就一路顺畅，但是随之也带来很多问题，包括但不限于：</p>
<ul>
<li>版本管理难</li>
<li>安装速度慢</li>
<li>多个项目安装依赖占用空间大</li>
<li>…</li>
</ul>
<p>那么其实我们应该了解完整的npm包管理生态，然后才可以得知为什么pnpm打击了哪些痛点，以及如何应用到我们的实际项目中。</p>
<h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><p>之前已经在<a href="https://qborfy.com/today/20230107.html" target="_blank" rel="noopener">《从npm版本依赖到Monorepo大仓项目》</a>已经介绍过npm是什么，定义如下：</p>
<blockquote>
<p>npm，Node Package Manager的缩写，也就是“Node的包管理器”。<br>npm（“Node 包管理器”）是 JavaScript 运行时 Node.js 的默认程序包管理器。</p>
</blockquote>
<p>也了解它的版本是如何管理的，但是我们还缺乏对它的核心功能需要了解，具体了解以下几个方面：</p>
<ul>
<li><code>npm install xxx</code>， npm如何将远程的npm包下载到我们的本地<code>node_modules</code></li>
<li><code>npm ls</code>， npm如何如何维护npm包在本地的关系的</li>
<li><code>npm run xxx</code>，npm如何执行我们的脚本命令</li>
</ul>
<p>首先，我们需要知道npm由三部分组成：</p>
<ul>
<li>npm包管理网站</li>
<li>npm-cli，命令行工具</li>
<li>npm包注册中心，npm registry</li>
</ul>
<p>接下来就是注册账号，以及包的发布，其中版本管理这块，是遵循APR版本规范(<code>major.minor.patch</code>版本模型规范)，具体可看这里<a href="https://qborfy.com/today/20230107.html#npm版本" target="_blank" rel="noopener">npm版本管理</a>。</p>
<h2 id="npm包管理"><a href="#npm包管理" class="headerlink" title="npm包管理"></a>npm包管理</h2><p>目前npm包下载方式分为两种，一种是全局，一种是当前项目，其都会放在<code>node_modules</code>目录下。下面通过以下几方面去讲述npm是如何管理npm包的：</p>
<ul>
<li>循环依赖</li>
<li>版本冲突</li>
<li>同个版本包收敛</li>
</ul>
<p>我们以这个下面这个包管理树为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo</span><br><span class="line">+-- blerg@1.2.5</span><br><span class="line">+-- bar@1.2.3</span><br><span class="line">|   +-- blerg@1.x (latest=1.3.7)</span><br><span class="line">|   +-- baz@2.x</span><br><span class="line">|   |   `-- quux@3.x</span><br><span class="line">|   |       `-- bar@1.2.3 (cycle)</span><br><span class="line">|   `-- asdf@*</span><br><span class="line">`-- baz@1.2.3</span><br><span class="line">    `-- quux@3.x</span><br><span class="line">        `-- bar</span><br></pre></td></tr></table></figure>

<p>我们从上面可以看出:</p>
<ul>
<li><code>blerg</code> 有两个版本分别是 <code>1.2.5</code> 和 <code>1.x</code>，这是同个次版本的包放在不同地方</li>
<li><code>bar</code> 版本是<code>1.2.3</code>，但是依赖 <code>blerg</code> 和 <code>baz</code>，但是依赖<code>baz</code>包的版本是<code>2.x</code>，这是版本冲突</li>
<li><code>baz</code> 版本是<code>1.2.3</code>，，但是所依赖的包中有个依赖<code>bar</code> 这就是循环依赖</li>
</ul>
<p>那么npm是如何解决这类问题的呢？npm会将上述包管理树优化成如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo</span><br><span class="line">+-- node_modules</span><br><span class="line">    +-- blerg (1.2.5) &lt;---[A]</span><br><span class="line">    +-- bar (1.2.3) &lt;---[B]</span><br><span class="line">    |   +-- node_modules</span><br><span class="line">    |       +-- baz (2.0.2) &lt;---[C]</span><br><span class="line">    +-- asdf (2.3.4)</span><br><span class="line">    +-- baz (1.2.3) &lt;---[D]</span><br><span class="line">    +-- quux (3.2.0) &lt;---[E]</span><br></pre></td></tr></table></figure>

<p>那么npm的遵循策略是什么呢？其实还是APR版本规范(<code>major.minor.patch</code>版本模型规范)。</p>
<ul>
<li>第一，会将依赖树打平，从树结构变成一级结构，解决了循环依赖问题</li>
<li>第二，会将主项目依赖的npm包提到一级，然后对于相同次版本<code>minor</code>中的包统一版本，这就是同个版本包收敛，节省空间</li>
<li>第三，接着将同一个包，但是不同版本的包一次放到对应依赖包内，形成二级依赖(node_modules)，这就解决了版本冲突</li>
</ul>
<p><strong>require加载顺序</strong></p>
<ul>
<li>加载核心模块，如：fs、path等</li>
<li>加上对应文件后缀，优先级为：test.js &gt; test.json &gt; test.node</li>
<li>搜索路径，如果有指定路径则按照路径去找，如：require(‘./test’) 则在当前目录寻找</li>
<li>如果没有指定路径，则从当前目录下往上去找 node_modules文件夹，然后从文件夹里去遍历寻找对应模块名，如果找不到则到上一层node_modules去找，直到最顶层目录</li>
<li>首次会加载比较慢，后面node.js 会将缓存相关信息到内存避免二次查询</li>
</ul>
<h2 id="npm-install执行过程"><a href="#npm-install执行过程" class="headerlink" title="npm install执行过程"></a>npm install执行过程</h2>
<div class="mxgraph-container">
    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/npm-install.drawio&quot;}"></div>
</div>


<h2 id="npm-run执行过程"><a href="#npm-run执行过程" class="headerlink" title="npm run执行过程"></a>npm run执行过程</h2><p>以<code>npm run serve</code>为例，执行过程如下：</p>

<div class="mxgraph-container">
    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/npm-run.drawio&quot;}"></div>
</div>


<h2 id="痛点问题"><a href="#痛点问题" class="headerlink" title="痛点问题"></a>痛点问题</h2><p>npm的管理包已经能解决大部分开发问题了，那么为什么还会有出现<code>yarn</code>和<code>pnpm</code>等新型管理工具，主要npm包存在目前难以解决的痛点问题：</p>
<ul>
<li>yarn新增yarn.lock，可以解决npm包版本变动问题，目前已被npm引入特性，生成package-lock.json</li>
<li>npm包多个项目依赖包一致，但每个项目都需要重新安装，不仅耗时，且占用磁盘空间，这是pnpm解决了的问题</li>
<li>包经常创建太深的依赖树，这导致 Windows 上的目录路径过长，这是pnpm解决的问题</li>
<li><a href="https://pnpm.io/zh/blog/2020/05/27/flat-node-modules-is-not-the-only-way" target="_blank" rel="noopener">平铺的结构不是 node_modules 的唯一实现方式</a>，pnpm作者描述：目前node_modules大部分为了解决重复依赖包的问题，把npm依赖树进行打平，这样子会产生一些问题：<ul>
<li>项目可以访问一些不依赖的npm包</li>
<li>打平依赖树的算法非常复杂，导致安装时更加慢</li>
<li>node_modules目录结构十分复杂</li>
</ul>
</li>
</ul>
<p>这些痛点问题都不是npm和yarn能解决的，因此才会pnpm的出现，接下来我们再了解一下pnpm。</p>
<h1 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h1><p>官网是这么定义的：</p>
<blockquote>
<p>快速的，节省磁盘空间的npm包管理工具</p>
</blockquote>
<p>同时还支持以下这些特性：</p>
<ul>
<li>快速： 比其他包管理器快 2 倍</li>
<li>高效：<code>node_modules</code> 中的文件为复制或链接自特定的内容寻址存储库</li>
<li>支持 <code>monorepos</code>：  内置支持单仓多包</li>
<li>严格：默认创建了一个非平铺的 node_modules，因此代码无法访问任意包</li>
</ul>
<p>这里安装教程就忽略了，推荐的用法是直接使用npm安装全局命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g pnpm</span><br></pre></td></tr></table></figure>

<p>其他安装方式可以参考官网教程:<a href="https://pnpm.io/zh/installation" target="_blank" rel="noopener">pnpm 安装</a></p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>从作者博客或者github源码，我们可以尝试去推测实现pnpm几个特性所需要关键原理。</p>
<h3 id="更快速的install"><a href="#更快速的install" class="headerlink" title="更快速的install"></a>更快速的install</h3><p>pnpm为了加快<code>npm install</code>，从以下两个方面进行优化：</p>
<ul>
<li>创建一个<code>.pnpm store</code>，除了第一次安装需要按照npm包，后续再次安装，将会创建一个符号链接到npm包</li>
<li>不打平<code>npm 依赖树</code>，节省复杂依赖树打平时间</li>
</ul>
<p>可以参考官网的架构图，去更好了解pnpm针对node_moduels的管理，如下：</p>
<p><img src="/assets/img/pnmp-node-modules-structure.jpg" alt></p>
<p>这里有几个设计点需要弄清楚：</p>
<ol>
<li>pnpm将所有依赖树的目录，软链接到<code>.pnpm store</code>中对应的npm包</li>
<li><code>node_moduels</code>将不会有<code>package.json</code>依赖(<code>devDependencies</code>和<code>dependencies</code>)外的npm包</li>
<li><code>node_moduels</code>的目录结构，和npm依赖树保持一致</li>
</ol>
<p>通过上述几个点，pnpm将拥有比<code>yarn</code>和<code>npm</code>更快的install速度。</p>
<p><strong>额外知识点</strong>：</p>
<ol>
<li>Linux文件链接分为软链接和硬链接，两者有什么区别？</li>
</ol>
<ul>
<li>Linux中的符号链接，就是我们平时说的软连接，可以针对文件、目录创建，但是源文件删除后链接不可用，命令:<code>ln -s xxx xxx</code></li>
<li>Linux中的硬链接，只能针对文件，但是文件删除仍可使用，命令:<code>ln xxx xxx</code></li>
</ul>
<ol start="2">
<li>Windows如何解决符号链接问题？</li>
</ol>
<p>pnpm采用<a href="https://learn.microsoft.com/en-us/windows/win32/fileio/hard-links-and-junctions" target="_blank" rel="noopener">junctions</a>，具体如下：</p>
<ul>
<li>Windows的文件系统是基于NTFS架构，本身就支持hard link 、junctions和symbolic links</li>
<li>Hard Link和Linux中硬链接没什么区别，同样只支持文件类型创建链接，采用函数:<code>CreateHardLinkA</code> <code>DeleteFileA</code></li>
<li>Junctions是符号链接，也叫软链接，支持文件、目录创建链接，实现：<code>junction 命令行</code></li>
</ul>
<h3 id="更安全的install"><a href="#更安全的install" class="headerlink" title="更安全的install"></a>更安全的install</h3><p>我们从上文可以得在Node.js中，<code>require()</code>是如何查询对应npm包，是从<code>node_modules</code>一层层向上查找获取的。</p>
<p>由于pnpm使用非扁平化的<code>node_modules</code>管理依赖树，因此对于非package.json依赖的npm包，是不会放在项目的<code>node_modules</code>中，从而使得开发者无法获取无依赖的npm包。具体可以参考下图：</p>

<div class="mxgraph-container">
    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/pnpm-safe-npm.drawio&quot;}"></div>
</div>



<h2 id="使用可能会遇到的问题"><a href="#使用可能会遇到的问题" class="headerlink" title="使用可能会遇到的问题"></a>使用可能会遇到的问题</h2><p>pnpm官网罗列了一些在使用过程可能会遇到的问题，具体有以下几个方面：</p>
<h3 id="peer-dependencies-如何解决"><a href="#peer-dependencies-如何解决" class="headerlink" title="peer dependencies 如何解决"></a>peer dependencies 如何解决</h3><h4 id="npm-workplace"><a href="#npm-workplace" class="headerlink" title="npm workplace"></a>npm workplace</h4><p>首先我们需要先了解一下<code>npm workplace</code> 或者 <code>yarn workplace</code>，工作空间的概念。</p>
<blockquote>
<p><code>Workspaces</code> 是一个通用术语，指的是 npm cli 中的一组功能，这些功能支持从单个顶级根包中管理本地文件系统中的多个包。<br>这组功能弥补了从本地文件系统处理链接包的更加简化的工作流程。自动链接过程作为 npm install 的一部分，避免手动使用 npm link 来添加对应该符号链接到当前 node_modules 文件夹中的包的引用。</p>
</blockquote>
<p>简单的说，<code>npm workplace</code>主要用来解决以下几个问题：</p>
<ul>
<li>在同一个git仓库中管理多个npm包</li>
<li>同时npm包之间可以存在互相依赖</li>
<li>多个子项目会依赖一些公共的npm包</li>
<li>减少之前因为<code>npm link</code>管理的混乱</li>
</ul>
<h3 id="peerDependencies"><a href="#peerDependencies" class="headerlink" title="peerDependencies"></a>peerDependencies</h3><p>通过上面<code>npm workplace</code>概念了解，当工作区里有多个子项目需要依赖一些公共的npm包，但是这些公共npm包版本可能大家所需要的都不一样，这个时候就需要<code>peerDependencies</code>去描述依赖和版本。它是这么定义的：</p>
<blockquote>
<p>在开发插件时，你的插件需要某些依赖的支持，但是你又没必要去安装，因为插件的宿主回去安装这些依赖。此时就可以用 <code>peerDependencies</code> 去声明一下需要依赖的插件和版本。如果出问题的话，npm 会有警告来提示使用者去解决版本中的冲突。</p>
</blockquote>
<p>因此，<code>peerDependencies</code>的目的很清晰，就为了解决workplace下不同子项目中公共依赖包版本问题。</p>
<p>所以回到<code>pnpm</code>中，由于<code>pnpm</code>是认定项目中只有一组<code>npm</code>依赖树，那么针对workplace中的 <code>peerDependencies</code>，它是如何解决的呢？</p>
<p><code>pnpm</code>的解决方案是：<strong>为不同的<code>peerDependencies</code> 依赖项创建不同的解析</strong>。</p>
<p>如何理解这句话呢？参考官网的解释：</p>
<p>当有两个子项目，他们的依赖分别如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- foo-parent-1</span><br><span class="line">  - bar@1.0.0</span><br><span class="line">  - baz@1.0.0</span><br><span class="line">  - foo@1.0.0</span><br><span class="line">- foo-parent-2</span><br><span class="line">  - bar@1.0.0</span><br><span class="line">  - baz@1.1.0</span><br><span class="line">  - foo@1.0.0</span><br></pre></td></tr></table></figure>

<p><code>foo-parent-2</code>或<code>foo-parent-1</code>公共依赖了<code>baz</code>，但是要求版本不一样，如果这个时候项目中没有声明<code>peerDependencies</code>，<code>.pnpm store</code>中保存的依赖树如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node_modules</span><br><span class="line">└── .pnpm</span><br><span class="line">    ├── foo@1.0.0</span><br><span class="line">    ├── bar@1.0.0</span><br><span class="line">    ├── baz@1.0.0</span><br><span class="line">    ├── baz@1.1.0</span><br></pre></td></tr></table></figure>

<p>如果有声明<code>peerDependencies</code>，<code>pnpm</code>会根据不同的<code>peerDependencies</code>创建对应的链接，<code>.pnpm store</code>中保存的依赖树如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node_modules</span><br><span class="line">└── .pnpm</span><br><span class="line">    ├── foo@1.0.0_bar@1.0.0+baz@1.0.0 #不同声明peerDependencies所创建的链接目录</span><br><span class="line">    │   └── node_modules</span><br><span class="line">    │       ├── foo</span><br><span class="line">    │       ├── bar   -&gt; ../../bar@1.0.0/node_modules/bar</span><br><span class="line">    │       ├── baz   -&gt; ../../baz@1.0.0/node_modules/baz</span><br><span class="line">    ├── foo@1.0.0_bar@1.0.0+baz@1.1.0   #不同声明peerDependencies所创建的链接目录</span><br><span class="line">    │   └── node_modules</span><br><span class="line">    │       ├── foo</span><br><span class="line">    │       ├── bar   -&gt; ../../bar@1.0.0/node_modules/bar</span><br><span class="line">    │       ├── baz   -&gt; ../../baz@1.1.0/node_modules/baz</span><br><span class="line">    ├── baz@1.0.0</span><br><span class="line">    ├── baz@1.1.0</span><br></pre></td></tr></table></figure>

<p>通过创建不同的<code>peerDependencies</code>的链接，去解决不同子项目中的依赖包版本问题。</p>
<h3 id="hosited配置"><a href="#hosited配置" class="headerlink" title="hosited配置"></a>hosited配置</h3><p>pnpm从2022年初支持<code>hoisted</code>配置，可以在 <code>.npmrc</code> 文件中使用 <code>node-linker=hoisted</code> 设置。</p>
<p>新增该设定，是为了基本上使 pnpm 可以兼容所有与 npm CLI 兼容的 Node.js 技术栈。</p>
<h3 id="删除npm包"><a href="#删除npm包" class="headerlink" title="删除npm包"></a>删除npm包</h3><p>这个是个人的疑问，既然将所有的依赖包统一归置到<code>.pnpm store</code>管理，那么针对一些过期或者无用的npm包什么时候进行删除呢？</p>
<p>pnpm的给出的方案如下：</p>
<ul>
<li>设置npm包的有效期，可以在<code>.npmrc</code>配置中设置<a href="https://pnpm.io/zh/npmrc#modules-cache-max-age" target="_blank" rel="noopener">modules-cache-max-age</a>配置项，单位为：分钟，默认值：10080，7天</li>
<li><code>pnpm prune</code>， 从存储中删除未引用的包</li>
</ul>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><p>官网同时也提出未解决的问题：</p>
<ul>
<li>针对<code>package-lock.json</code>等锁文件更新，npm允许每次安装同样版本的npm包可能会更新lock文件，从而更新<code>node_modules</code>文件内容，但是pnpm由于创建隔离布局，无法实时按照<code>package-lock.json</code>的更新而更新，因此pnpm推荐将使用<code>pnpm import</code>命令将<code>package-lock.json</code>等文件转为<code>pnpm-lock.yaml</code></li>
</ul>
<p>这个问题就是pnpm没法按照项目现有的<code>package-lock.json</code>去做自动更新，只能通过<code>pnpm import</code>去做转换。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>pnpm</code>确实给前端开发带来一些提醒，让我们关注到平时可能已经习惯的问题，比如<code>npm</code>包管理混乱导致的问题，虽然存在但是我们已经忽略或者已经习惯了。</p>
<p>总结一下学习<code>pnpm</code>后，在实际项目中引用会给我们带来什么：</p>
<ul>
<li>提高我们本地开发效率，毕竟多个前端项目同时在电脑，每次安装或更新都需要等待一段时间</li>
<li>提高项目的编译速度，利用<code>.pnpm store</code>在编译机上，不用每次都重新安装</li>
<li>提高项目npm依赖的安全性，清晰明白项目中npm依赖结构，不用担心非法npm包在项目中被开发使用</li>
</ul>
<p>这里联想扩展几个问题点：</p>
<ul>
<li><p>什么时候node.js才能支持es6的import和export</p>
</li>
<li><p>node.js或者浏览器，什么时候才能直接加载远程js包，而不是需要安装到本地才能使用</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1></li>
<li><p><a href="https://docs.npmjs.com/about-npm" target="_blank" rel="noopener">npm官网</a></p>
</li>
<li><p><a href="https://pnpm.io/" target="_blank" rel="noopener">pnpm官网</a></p>
</li>
<li><p><a href="https://www.kochan.io/nodejs/why-should-we-use-pnpm.html" target="_blank" rel="noopener">我们为什么要使用 pnpm？</a></p>
</li>
<li><p><a href="https://www.imaegoo.com/2021/node-modules-speed-up/" target="_blank" rel="noopener">浅析各家包管理工具是如何解决 npm 安装慢的痛点的</a></p>
</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>实现一个JS引擎竟如此简单</title>
    <url>/today/20230218.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>这是很久之前的一个念想，当时为了加深自己对js的理解，明白js引擎是如何工作的。<br>于是从上网找了一个<a href="https://github.com/webfansplz/giao-js" target="_blank" rel="noopener">giao-js</a>，感觉还不错，因此想学习一下。</p>
<h1 id="JS引擎"><a href="#JS引擎" class="headerlink" title="JS引擎"></a>JS引擎</h1><p>之前有篇文章<a href="https://qborfy.com/today/20230117.html" target="_blank" rel="noopener">理解React中Fiber架构(一)</a>中有讲到浏览器进程如何渲染网页和执行js代码的，我们再复习一遍。</p>
<p>一个完整的web网页在浏览器显示和交互的进程（chrome为主），需要涉及到线程主要以下几个部分：</p>
<ul>
<li><code>GUI 渲染线程</code>，负责渲染浏览器界面HTML元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行。</li>
<li><code>JavaScript引擎线程</code>，JS内核，负责处理Javascript脚本程序。 一直等待着任务队列中任务的到来，然后解析Javascript脚本，运行代码。</li>
<li><code>定时触发器线程</code>，定时器setInterval与setTimeout所在线程，为什么要单独弄个线程处理定时器？是因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确</li>
<li><code>事件触发线程</code>，用来控制事件轮询，JS引擎自己忙不过来，需要浏览器另开线程协助</li>
<li><code>异步http请求线程</code>，在<code>XMLHttpRequest</code>或<code>fetch</code>在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等待处理。这里需要注意<code>XMLHttpRequest</code>和<code>fetch</code>的区别，<code>fetch</code>是w3c标准化后一个专门提供给开发调用发起http的API接口，XMLHttpRequest是一个非标准化的Http请求对象，主要是可以发起http请求获取XML数据。</li>
</ul>
<p>针对JS引擎，官方的定义是：</p>
<a id="more"></a>

<blockquote>
<p>JavaScript引擎是一个专门处理JavaScript脚本的虚拟机，一般会附带在网页浏览器之中。 —— <a href="https://zh.wikipedia.org/zh-hans/JavaScript%E5%BC%95%E6%93%8E" target="_blank" rel="noopener">JS引擎 维基百科</a></p>
</blockquote>
<p>因此，我们了解JS引擎在浏览器中的主要作用就，解析JS代码，并运行代码，那么它是怎么做到的呢？</p>
<p>如同我们人一样去认识一门语言，电脑也一样，当我们写了一行代码，JS引擎要识别出来，它同样去分析代码，然后确定执行，主要有以下几个步骤：</p>
<ul>
<li>词法分析，主要是<code>分词（tokenize）</code>，将JS代码比较关键词（如：function、const、let等），拆出来放到解析器里</li>
<li>语法分析，主要解析（parse），主要用了<code>预解析器</code>和<code>解析器</code>:<ul>
<li><code>预解析器</code>会判断哪些代码需要立即执行，哪些代码不需要立即执行，需要立即执行的代码才会放到解析器里去解析</li>
<li><code>解析器</code>，从词法分析获取关键词做标记，将代码生成一个抽象语法树，也叫AST语法树</li>
</ul>
</li>
<li>生成AST语法树，AST语法树由<code>解析器</code>生成后，将会传递给到<code>解释器</code></li>
<li>生成字节码，主要由<code>解释器</code>将AST语法树编译成字节码</li>
<li>执行代码，将字节码转成机器代码，以更快的速度在电脑中执行</li>
</ul>

<div class="mxgraph-container">
    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/jsengine.drawio&quot;}"></div>
</div>


<p>所以我们要模拟JS引擎要实现功能主要以下几块：</p>
<ul>
<li><code>分词器</code>，将JS关键词进行标记</li>
<li><code>解析器</code>，生成AST语法树</li>
<li><code>解释器</code>，执行AST语法树</li>
</ul>
<h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><blockquote>
<p>将源代码分解并组织成一组有意义的单词,这一过程即为词法分析(Token)。</p>
</blockquote>
<p>词法分析的工作就是 将一个长长的字符串识别出一个个的单词，这一个个单词就是 Token，具体实现效果如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  经过词法分析会将上面拆分如下对象</span></span><br><span class="line">[</span><br><span class="line">  (<span class="string">"var"</span>: <span class="string">"keyword"</span>),</span><br><span class="line">  (<span class="string">"a"</span>: <span class="string">"identifier"</span>),</span><br><span class="line">  (<span class="string">"="</span>: <span class="string">"assignment"</span>),</span><br><span class="line">  (<span class="string">"1"</span>: <span class="string">"literal"</span>),</span><br><span class="line">  (<span class="string">";"</span>: <span class="string">"separator"</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>如果用图来显示的话，它应该是这样子的：</p>

<div class="mxgraph-container">
    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/jsengine-token.drawio&quot;}"></div>
</div>



<p>根据上面的结果，那么词法分析的实践步骤应该如下：</p>
<ul>
<li>先分词，分词的逻辑使用正则表达式<ul>
<li>先判断是否为关键词，如：运算符(+-*/=)、声明符(var、const、function)等</li>
<li>如果是则执行拆词</li>
<li>接着遇到空格也拆词</li>
<li>遇到换行符或;也拆词</li>
<li>…还有符合条件判断也拆词</li>
<li>最终会获取到一个数组，[“var”, “a”, “=”, “1”, “;”]</li>
</ul>
</li>
<li>再判断该词属于哪个类型，如： var属于keyword关键字。</li>
</ul>
<p>利用<code>Acron</code>做词法分析， 代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> acron = <span class="built_in">require</span>(<span class="string">'acorn'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用acorn库进行词法分析</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; code 代码</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; ecmaVersion ECMAScript的标准版本 </span></span><br><span class="line"><span class="comment"> * @returns </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> getToken = <span class="function">(<span class="params">code, ecmaVersion = <span class="string">'11'</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tokenObj = acron.tokenizer(code, &#123;</span><br><span class="line">        ecmaVersion,</span><br><span class="line">        locations: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> tokens = [];</span><br><span class="line">    <span class="keyword">let</span> token = tokenObj.getToken();</span><br><span class="line">    <span class="built_in">console</span>.log(token)</span><br><span class="line">    <span class="keyword">while</span> (token.end !== token.start) &#123;</span><br><span class="line">        tokens.push(token);</span><br><span class="line">        token = tokenObj.getToken();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tokens;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getToken(<span class="string">`const a= 1+1;`</span>); <span class="comment">// 最终输出Token数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出如下对象</span></span><br><span class="line">[ &#123;</span><br><span class="line">  <span class="string">"type"</span>: &#123; <span class="comment">// 关键词Token所属类型</span></span><br><span class="line">    <span class="string">"label"</span>: <span class="string">"const"</span>,  <span class="comment">// 解析到的关键词所属的类型 为const</span></span><br><span class="line">    <span class="string">"keyword"</span>: <span class="string">"const"</span>, <span class="comment">//  关键字</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"value"</span>: <span class="string">"const"</span>, <span class="comment">// 解析到的 关键词Token</span></span><br><span class="line">  <span class="string">"start"</span>: <span class="number">0</span>, <span class="comment">// 关键词的开始位置</span></span><br><span class="line">  <span class="string">"end"</span>: <span class="number">5</span> <span class="comment">// 关键词的结束位置 下一个位置是空白符</span></span><br><span class="line">&#125;, ...]</span><br></pre></td></tr></table></figure>

<h1 id="语法解析"><a href="#语法解析" class="headerlink" title="语法解析"></a>语法解析</h1><blockquote>
<p>将词法分析阶段生成的 Token 转换为抽象语法树(Abstract Syntax Tree),这一过程称之为语法解析(Parsing)。</p>
</blockquote>
<p>简单的说，就是利用Token标识符去生成AST语法树。</p>
<h2 id="AST语法树"><a href="#AST语法树" class="headerlink" title="AST语法树"></a>AST语法树</h2><p>在语法解析前，我们需要对AST语法树有一个认知，即是：什么是AST语法树？</p>
<blockquote>
<p>抽象语法树 (Abstract Syntax Tree)，简称 AST，它是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。</p>
</blockquote>
<p>用比较容易理解的话，用一个树形数据结构去描述我们源代码，从而能让机器能更好识别我们所想要实现的功能。</p>
<p>目前市面上Javascript语言的AST语法树的结构基本上都遵循<a href="https://github.com/estree/estree" target="_blank" rel="noopener">ESTree语法树规范</a>。</p>
<p>这里说明一下<a href="https://github.com/estree/estree" target="_blank" rel="noopener">ESTree语法树规范</a>的起源，能让我们更容易理解语法解析的过程：</p>
<blockquote>
<p>使用不同工具构建的抽象语法树可能会有不同的结构，如果大家都遵从同样的规范，那么相关联的生态链工具的开发会更为轻松、明晰。很早之前，FireFox 浏览器所使用的 JavaScript 引擎 SpiderMonkey 曾经提供了一个 JavaScript API，使得开发者可以直接调用 SpiderMonkey 的 JavaScript 分析器。这个 API 所描述的 JavaScript 抽象语法树格式渐渐流行起来，如今成为 JavaScript AST 的通用描述。<a href="https://github.com/estree/estree" target="_blank" rel="noopener">ESTree语法树规范</a> 正是在此基础上建立起来的，它现在是社区对 JavaScript 抽象语法树构建时采用最广泛的规则，可以认为是社区推动的事实标准。众多基础设施开发者一起维护着这个规范，包括 Dave Herman（Mozilla 研究中心的首席研究员和策略总监）、 Nicholas C. Zakas（ESLint 的作者）、Ingvar Stepanyan（Acorn 的作者）、Mike Sherov 与 Ariya Hidayat（Esprima 的作者）以及 Babel.js 团队等。</p>
<p><a href="https://github.com/estree/estree" target="_blank" rel="noopener">ESTree语法树规范</a> 的初始版本是基于 ES5 的[2]，后续的 ES6/ES7/ES8 等版本的规范，都只针对新增语言特性提出。</p>
</blockquote>
<p><a href="https://github.com/estree/estree" target="_blank" rel="noopener">ESTree语法树规范</a>基于ECMAScript标准去描述不同标准的AST树结构，具体如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 节点对象  下面这个版本属于ES2015的规范</span></span><br><span class="line">interface Node &#123;</span><br><span class="line">    type: string;</span><br><span class="line">    loc: SourceLocation | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extend interface Program &#123;</span><br><span class="line">    sourceType: <span class="string">"script"</span> | <span class="string">"module"</span>;</span><br><span class="line">    body: [ Statement | ImportOrExportDeclaration ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IfStatement &lt;: Statement &#123; <span class="comment">// &lt;: 标识前者是后者的子集 即是继承的关系</span></span><br><span class="line">    type: <span class="string">"IfStatement"</span>;</span><br><span class="line">    test: Expression;</span><br><span class="line">    consequent: Statement;</span><br><span class="line">    alternate: Statement | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此了解JS的AST语法树结构，需要对ESTree规范有了解，它分别定义不同类型节点的数据结构，拿几种常见的做一下介绍，具体如下所示：</p>
<ul>
<li><code>Program</code>，一个完整的程序源码树，就是树的跟节点，因此也属于<code>Node</code>类型</li>
<li><code>Node</code>，语法树的基础节点<ul>
<li><code>Function</code>，函数声明或表达式，继承节点<code>Node</code></li>
<li><code>Statement</code>，代码内容，标识任何声明，继承节点<code>Node</code><ul>
<li><code>Declaration</code> 声明节点</li>
</ul>
</li>
<li><code>Expression</code>， 表达式，标识任何声明，继承节点<code>Node</code></li>
<li><code>Pattern</code>，解构绑定和赋值节点，继承节点<code>Node</code></li>
</ul>
</li>
<li><code>Identifier</code>，标识符，如：变量名、函数名</li>
<li><code>Literal</code>， 字面量，对应 JavaScript，就是基本值，例如布尔值 true、数字 200、字符串 “this is a string”</li>
</ul>
<p>一个AST语法的组成结构大概如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Program</span><br><span class="line">|-- body: Node[] // 代码主体</span><br><span class="line">|     |-- Function // 函数声明</span><br><span class="line">|     |-- Statement // 代码内容</span><br><span class="line">|     |-- Declaration // 变量声明</span><br><span class="line">|     |-- Expression // 表达式</span><br><span class="line">|          |-- Literal</span><br><span class="line">|          |-- Identifier</span><br></pre></td></tr></table></figure>

<p>还需要解答一个问题，就是在AST语法树中，如何判断一个节点的完整性呢? </p>
<p>按照ESTree的规范：遇到一个空节点（比如：换行/分号/结构体结束符<code>}]</code>等），则拆成一个完整的节点。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>弄明白AST语法树的数据结构，接下来就是如何将之前<code>词法分析</code>的Token数组解析成语法树结构，解析流程图(Acron.js实现)如下：</p>

<div class="mxgraph-container">
    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/jsengine-parse.drawio&quot;}"></div>
</div>


<p>利用<code>Acron</code>做语法解析， 代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> code = <span class="string">`function sum(a, b)&#123;return a+b;&#125;; const a = sum(1, 2);`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> acron = <span class="built_in">require</span>(<span class="string">'acorn'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(acron.parse(code))</span><br></pre></td></tr></table></figure>

<p>最终得到结构如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Node &#123;</span><br><span class="line">  type: <span class="string">'Program'</span>,</span><br><span class="line">  start: <span class="number">0</span>,</span><br><span class="line">  end: <span class="number">53</span>,</span><br><span class="line">  body:</span><br><span class="line">   [ Node &#123;</span><br><span class="line">       type: <span class="string">'FunctionDeclaration'</span>,</span><br><span class="line">       start: <span class="number">0</span>,</span><br><span class="line">       end: <span class="number">31</span>,</span><br><span class="line">       id: [Node],</span><br><span class="line">       expression: <span class="literal">false</span>,</span><br><span class="line">       generator: <span class="literal">false</span>,</span><br><span class="line">       <span class="keyword">async</span>: <span class="literal">false</span>,</span><br><span class="line">       params: [<span class="built_in">Array</span>],</span><br><span class="line">       body: [Node] &#125;,</span><br><span class="line">     Node &#123; <span class="attr">type</span>: <span class="string">'EmptyStatement'</span>, <span class="attr">start</span>: <span class="number">31</span>, <span class="attr">end</span>: <span class="number">32</span> &#125;,</span><br><span class="line">     Node &#123;</span><br><span class="line">       type: <span class="string">'VariableDeclaration'</span>,</span><br><span class="line">       start: <span class="number">33</span>,</span><br><span class="line">       end: <span class="number">53</span>,</span><br><span class="line">       declarations: [<span class="built_in">Array</span>],</span><br><span class="line">       kind: <span class="string">'const'</span> &#125; ],</span><br><span class="line">  sourceType: <span class="string">'script'</span> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h1><blockquote>
<p>解释器，就是遍历AST语法树，然后根据Node节点类型，去执行或计算每个节点。</p>
</blockquote>
<p>这里实现一个JS解释器，需要对AST语法树Node节点每个类型做区分判断，主要有以下几种：</p>
<ul>
<li>变量</li>
<li>作用域以及作用域链</li>
<li>上下文This指向</li>
<li>条件判断</li>
<li>For循环，其中的 break和continue</li>
<li>函数部分 Function</li>
<li>生成器 Generator</li>
<li>异步 Async</li>
</ul>
<p>因此我们需要几个类去保存相关的值：</p>
<ul>
<li>Scope，作用域类，保存作用域内的值以及作用域链（当前作用域可以找到父级作用域链）</li>
<li>Visitor，AST树Node节点处理类，里面有函数<code>visitNode(node, scope)</code>，用来处理对应node类型，其中VISITOR是所有类型函数的Map对象，用来快速查询</li>
<li>Variable，变量存储类，用来存储变量类型和值</li>
</ul>
<p>参考代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历AST语法树，并执行对应的处理函数</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; node </span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; scope </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">visitNode(node, scope) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; type &#125; = node;</span><br><span class="line">    <span class="keyword">if</span> (VISITOR[type]) &#123;</span><br><span class="line">        <span class="keyword">return</span> VISITOR[type](&#123; node, scope, <span class="attr">context</span>: <span class="keyword">this</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变量和作用域"><a href="#变量和作用域" class="headerlink" title="变量和作用域"></a>变量和作用域</h2><p>在JavaScript中，对变量的声明通常是绑定在作用域中的，而作用域分为以下几种：</p>
<ul>
<li>全局作用域，全局作用域中仅存在一处，即为最上级的环境。</li>
<li>函数作用域，函数存在并执行时，内部存储函数作用域</li>
<li>块级作用域，每隔block块{}都可产生作用域，如if for while等</li>
</ul>
<p>我们举个例子，以<code>var a = 1;</code>为例，我们需要需要哪些代码，才能实现从AST树解析，将变量<code>a</code>被声明在全局变量作用域中，具体步骤如下图：</p>

<div class="mxgraph-container">
    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/jsengine-interpreter.drawio&quot;}"></div>
</div>


<p>这里实现一个作用域Scope类，参考代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scope</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; type </span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; parent </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">constructor</span>(type, parent) &#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent || <span class="literal">null</span>; <span class="comment">// 父级作用域</span></span><br><span class="line">        <span class="keyword">this</span>.type = type; <span class="comment">// 作用域类型 Global, Function, Block</span></span><br><span class="line">        <span class="keyword">this</span>.targetScope = <span class="keyword">new</span> <span class="built_in">Map</span>();  <span class="comment">// 当前作用域</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 变量声明方法,变量已定义则抛出语法错误异常</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; kind 变量类型</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; rawName  变量名</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; value 变量值</span></span><br><span class="line"><span class="comment">     * @returns </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    declare(kind, rawName, value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.targetScope.set(rawName, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="上下文This"><a href="#上下文This" class="headerlink" title="上下文This"></a>上下文This</h3><p>上下文的this对象其实指的就是当前作用域，然而我们了解过JS中的this是可以改变的，如：</p>
<ul>
<li><code>call()</code> <code>bind()</code> <code>apply()</code>等函数，当执行到相关函数的时候，需要将传递进来scope的替换成当前的scope</li>
<li>ES6中的箭头函数等，this指向上一级</li>
</ul>
<p>这些都需要在解析代码的时候注意的逻辑问题。</p>
<h2 id="其他类型解释"><a href="#其他类型解释" class="headerlink" title="其他类型解释"></a>其他类型解释</h2><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p><code>IfStatement</code>，里面有属性: <code>test</code>为判断条件，<code>consequent</code>为条件成立时执行的语句，<code>alternate</code>为条件不成立时执行的语句，参考代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// visitNode会执行AST语法树节点函数</span></span><br><span class="line"><span class="keyword">const</span> &#123; test, consequent, alternate &#125; = node;</span><br><span class="line"><span class="keyword">const</span> testValue = visitNode(test, scope);</span><br><span class="line"><span class="keyword">if</span> (testValue) &#123;</span><br><span class="line">    <span class="keyword">if</span>(consequent)&#123;</span><br><span class="line">       visitNode(consequent, scope);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(alternate)&#123;</span><br><span class="line">       visitNode(alternate, scope);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他部分逻辑就不会在这里一一描述，具体Node类型都有自己的判断逻辑，因此想要了解完整逻辑，可以到完整源码里查看，注解都十分清晰。</p>
<p>完整源码地址在：<a href="https://github.com/qiubohong/qiubohong.github.io/tree/master/code/jsengine/src/interpreter/index.js" target="_blank" rel="noopener">https://github.com/qiubohong/qiubohong.github.io/tree/master/code/jsengine</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文涉及的东西有点多，花了好几天时间才弄明白，因此有些知识点在这里做一下小总结：</p>
<ul>
<li>JS引擎是有三部分组成的，分别是：<code>词法分析</code>,<code>语法解析</code>和<code>解释器</code></li>
<li>词法解析和语法解析，最终的目标是生成符合ESTree规范的<code>AST语法树</code></li>
<li>解释器的作用就是依据<code>AST语法树</code>去执行相关逻辑，输出所需要的最终结果<ul>
<li>比较重要的部分在于变量、作用域和作用域链的实现</li>
<li>其他部分则是依据对应<code>ECMAScript 规范</code>实现对应逻辑皆可</li>
</ul>
</li>
</ul>
<h2 id="ECMAScript-规范"><a href="#ECMAScript-规范" class="headerlink" title="ECMAScript 规范"></a>ECMAScript 规范</h2><p>其实，JS解释器实现起来不难，就是需要对JS执行逻辑有完整的认识，不仅仅只是上面几个部分，但是基本上AST语法树都已经包括在里面了，所以这个时候需要你对ECMAScript 规范有一定了解才能完整实现解释器。</p>
<p>所以这里贴一个ECMAScript 规范链接，作为后续完整解释器的扩展。</p>
<blockquote>
<p>使用 ECMAScript 指代由 Ecma International Technical Committee 39 负责编撰的 ECMAScript Language Specification，而使用 JavaScript 来指代我们日常使用的那个常见编程语言。</p>
<p>我们可以在 <a href="https://tc39.es/ecma262" target="_blank" rel="noopener">https://tc39.es/ecma262</a> 获取到最新的 ECMAScript 规范</p>
</blockquote>
<p>如何阅读规范呢？</p>
<ul>
<li>惯例与基础：如在 ECMAScript 中 Number 的定义是什么，亦或者 throw a TypeError exception 语句代表什么含义；</li>
<li>语言语法产生式：如如何写一个符合规范的 for-in 循环；</li>
<li>语言静态语义：如一个 VariableDeclaration 如何确定一个变量声明；</li>
<li>语言运行时语义：如一个 for-in 循环的执行例程的定义；</li>
<li>APIs：如 String.prototype.substring 等内置对象的方法例程定义。</li>
</ul>
<h2 id="能做什么"><a href="#能做什么" class="headerlink" title="能做什么"></a>能做什么</h2><p>有了我们自己的JS引擎后我们能做些什么，其实目前市面上已经有很多应用场景，比如:</p>
<ul>
<li><a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a>，最常见JavaScript编译器，能够将js代码编译成我们想要的任一版本的ECMAscript标准，基于 acorn.js优化</li>
<li><a href="https://eslint.org/" target="_blank" rel="noopener">ESlint</a>，最常用的代码质量扫描工具，能找到代码不符合规范的地方，基于Espree.js进行分析</li>
<li><a href="https://prettier.io/" target="_blank" rel="noopener">pretiier</a>,最常用的代码格式工具，能帮忙把代码格式优化</li>
<li>js沙箱安全机制，之前写过一篇文件<a href="https://qborfy.com/lowcode/sandbox.html" target="_blank" rel="noopener">低代码系列——js沙箱设计</a>里提到过，想要完整动态执行js代码，最好的方式是拥有自己的js解释器</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://juejin.cn/post/6943550570515038245" target="_blank" rel="noopener">编译原理实战一：如何用JS实现一个词法分析器？</a></li>
<li><a href="https://github.com/webfansplz/giao-js/blob/main/Article.md" target="_blank" rel="noopener">giao-js github源码</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1886888" target="_blank" rel="noopener">分享一篇可视化的JS引擎执行流程</a></li>
<li><a href="https://github.com/acornjs/acorn" target="_blank" rel="noopener">Acron 一个小巧又快速的js解析器</a></li>
<li><a href="https://github.com/estree/estree" target="_blank" rel="noopener">The ESTree Spec(ES语法树规范)</a></li>
<li><a href="https://astexplorer.net/" target="_blank" rel="noopener">astexplorer 在线语法解析器</a></li>
<li><a href="https://fed.taobao.org/blog/taofed/do71ct/mlgtox/" target="_blank" rel="noopener">ECMAScript 规范阅读导引 Part 1</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>前端架构成长之路——微前端架构理论篇</title>
    <url>/framework/frontend-microapp-1.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近项目开发中使用了<code>qiankun</code>框架去做微前端，我是属于半懂不懂的状态，大概了解过微前端是什么，可以解决什么问题，但是没有并系统的认识和从0实战过。</p>
<p>所以希望通过几篇文章去重新认识<code>微前端</code>这一架构，主要会从几个方面：</p>
<ul>
<li>是什么，以及为什么会出现</li>
<li>实现原理，以及主流框架</li>
<li>项目实战</li>
</ul>
<a id="more"></a>

<h1 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h1><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>在说微前端之前，我们需要先了解一下后端的微服务，因为微前端本身就是吸取微服务理念而产生的，所以我们先对微服务做一个简单的认识：</p>
<blockquote>
<p>2014年，Martin Fowler 与 James Lewis 共同提出了微服务的概念，定义了微服务是由以单一应用程序构成的小服务，自己拥有自己的进程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用HTTP API通信。同时服务会使用最小的规模的集中管理 (例如 Docker) 能力，服务可以用不同的编程语言与数据库等组件实现 —— <a href="https://zh.wikipedia.org/zh-sg/%E5%BE%AE%E6%9C%8D%E5%8B%99" target="_blank" rel="noopener">维基百科 微服务</a>。</p>
</blockquote>
<p><code>微服务</code>架构，通常拿来对比的架构是<code>单体软件</code>架构，<code>单体软件</code>存在以下几个问题：</p>
<ul>
<li>所有功能耦合在一起，互相影响，最终难以管理</li>
<li>哪怕只修改一行代码，整个软件就要重新构建和部署，成本非常高</li>
<li>不可能每个功能单独开发和测试，只能整体开发和测试，导致必须采用瀑布式开发模型</li>
</ul>
<p>因此开始出现将单体软件拆成一个个<code>功能单元服务</code>+<code>通讯协议</code>组成，这种叫<code>面向服务</code>(service-oriented architecture，简称 SOA)架构，也是微服务的雏形。</p>
<p>因此<code>微服务</code>架构的等于<code>面向服务</code>架构，它有多种实现方案，其中最佳实践是基于Docker容器实现的。</p>
<p>微服务的几大特性：</p>
<ul>
<li>敏捷性， 可快速迭代自己的微服务</li>
<li>弹性部署，快速持续集成与部署，服务独立性增加了应用程序应对故障的弹性</li>
<li>技术自由，可以自由选择最佳工具来解决他们的具体问题</li>
<li>可重复使用的代码，可以将专为某项功能编写的服务可以用作另一项功能的构建块</li>
</ul>
<p>Ok，微服务了解到这里基本上就有大概的认知，微服务当然不只是这些，还有一些其他技术点，如：服务发现、事件传播等。</p>
<h2 id="微前端"><a href="#微前端" class="headerlink" title="微前端"></a>微前端</h2><p>了解完微服务，那么微前端概念是什么开始提出的呢？</p>
<blockquote>
<p>微前端 这个名词，第一次被提出还是在2016年底，那是在 ThoughtWorks Technology Radar。这个概念将微服务这个被广泛应用于服务端的技术范式扩展到前端领域。<br>微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。 —— <a href="https://micro-frontends.org/" target="_blank" rel="noopener">微前端的完整介绍</a></p>
</blockquote>
<p>简单的说，微前端架构是从微服务理念扩展而来的，一个适用于前端的微服务架构。</p>
<h1 id="微前端-1"><a href="#微前端-1" class="headerlink" title="微前端"></a>微前端</h1><h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>从上面发展历程我们对<code>微前端</code>架构有个简单认知和它的定义，接下来我们通过不同类型的做比较去对微前端做更深的认知。</p>
<h2 id="单体巨石-VS-微前端"><a href="#单体巨石-VS-微前端" class="headerlink" title="单体巨石 VS 微前端"></a>单体巨石 VS 微前端</h2><p>用单体巨石架构和微前端架构做一个比较，能更好的理解微前端架构，具体如下图所示：</p>

<div class="mxgraph-container">
    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/micro.drawio&quot;}"></div>
</div>


<p>简单的讲，就是将原本耦合在一起的单体巨石应用按照一定原则拆分成各种微前端小应用，最简单的拆分方案就是和微服务做一一映射。</p>
<h2 id="组件-VS-微前端"><a href="#组件-VS-微前端" class="headerlink" title="组件 VS 微前端"></a>组件 VS 微前端</h2><p>我们再从另外一个角度的去看待微前端，假设将微前端看做组件，是不是就好理解多了，只不过这个组件有点大，功能比较齐全，没有对外提供参数配置。</p>
<p>但是从两者的实际应用场景来说，还是有很多不同的地方，具体如下：</p>
<ul>
<li>从应用场景来看，组件是不可运行，被调用的，是应用中一部分，而微前端是完整可运行的一个应用</li>
<li>从技术上来看，组件是基于某个框架实现的，而微前端应用不依赖任何框架，但是微前端架构会依赖某个框架实现</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>微前端</code>架构，就是把复杂问题简单化，每个<code>微前端</code>项目都只需要关心自己的事情。因此<code>微前端</code>架构的核心思维如下：</p>
<ul>
<li><code>技术不可知</code>，每个<code>微前端</code>都应该选择自己的技术栈和技术进化路线，而不是和其他团队保持一致，同时架构师应该考虑的是<strong>如何高效的提供可复用的WebComponent会成为核心问题</strong></li>
<li><code>环境隔离</code>，<code>微前端</code>架构中每个子项目不共享运行时环境，即是：不依赖共享状态或全局变量，同时也可以通过命名规范（如：前缀）或命名空间，去隔离每个微前端应用</li>
<li><code>原生API优先</code>，使用 用于通信的原生浏览器事件机制 ，而不是自己构建一个PubSub系统</li>
<li><code>独立性</code>，<code>微前端</code>架构中每个子项目是完整的，可以独立运行、独立开发、独立部署</li>
<li><code>高可用</code>，<code>微前端</code>架构是高可用的，即使某个子应用异常也不会影响其他子应用的访问</li>
</ul>
<p>以上就是要实现<code>微前端</code>架构所需要考虑的点，同时也是架构中的核心思维。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>微前端架构在上面描述了很多优势，但是如果没做好架构设计，它也可能会带来一些问题，因此我们需要提前了解<code>微前端架构</code>可能会带来的缺陷：</p>
<ul>
<li>增加运维成本，因为由原本只需要发布一个应用，变成需要发布N个应用</li>
<li>拆分粒度越小，架构越复杂，开发维护成本越高</li>
<li>微前端支持不同技术栈，那么也带来了不同技术栈带来技术栈混乱的风险，同时也提高了开发维护成本</li>
<li>微前端架构本身就是将项目完全独立，可能导致部分公共代码无法通用</li>
<li>还有一些其他问题，如：当采用某类微前端框架增加开发成本等</li>
</ul>
<p>上面这些问题，在项目是否要用微前端架构都需要考虑的事情，但是也有一句话可以提供给大家参考。</p>
<blockquote>
<p>工程就是权衡的艺术，而微服务（microframeworks）架构给你提供了一个可以权衡的维度。</p>
</blockquote>
<p>了解完是什么，接下来就当项目中要实施<code>微前端</code>架构的时候要怎么做了。</p>
<h1 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h1><p>在项目要实施<code>微前端</code>架构，主要有几个工作项：</p>
<ul>
<li>首先，就是需要搞清楚如何将项目拆分一个个微前端子项目</li>
<li>其次，选型，采用哪种微前端框架去实施</li>
<li>最后，使用渐进式方案去实施，而不是一口气全切换，如果是新项目直接采用微前端架构，那么这里推荐采用<strong>Monorepo大仓+微前端</strong>，这里会让极大降低项目的管理成本。</li>
</ul>
<h2 id="如何拆分"><a href="#如何拆分" class="headerlink" title="如何拆分"></a>如何拆分</h2><p>微前端架构主要工作就是拆分，那么问题来了，我们应该依据什么样的标准去拆分呢？我们大体可以从下几点去考虑：</p>
<ul>
<li>第一，拆分条件，项目是否适合微前端架构</li>
<li>第二，拆分原则，项目拆分时候需要遵循的设计原则</li>
<li>第三，拆分方法，项目拆分可以依据哪些因素进行拆分</li>
</ul>
<h3 id="拆分条件"><a href="#拆分条件" class="headerlink" title="拆分条件"></a>拆分条件</h3><p>我们要对项目进行微前端架构设计的时候，我们应该从下面几方面去考虑是否适合：</p>
<ul>
<li>是否有快速迭代的需求，如果有快速迭代需求，则表示业务需要快速响应，那么采用微前端架构去拆分，不仅支持快速迭代，还支持业务快速试错</li>
<li>是否有代码提交出现大量冲突，如果有，则表示代码管理成本较高，微前端架构可以降低项目的管理成本</li>
<li>是否小功能需要等待大版本的场景，如果有，则表示小功能会影响到大版本的功能，这个时候微前端架构的<code>独立发布</code>特性，可随时回滚，风险变小，时间变短，影响面小，从而降低大版本发布延期风险</li>
</ul>
<p>从上面几个方面，我们可以很清晰的判断当前项目是否需要做微前端架构调整，只有这个时候，微前端的拆分才是有确定收益的，增加的运维成本才是值得的。</p>
<h3 id="拆分原则"><a href="#拆分原则" class="headerlink" title="拆分原则"></a>拆分原则</h3><p>当我们面对需要拆分微前端的时候，以下几个原则可以作为参考：</p>
<ul>
<li>单一职责原则，每个微前端只需关心自己的业务规则，确保职责单一，避免职责交叉</li>
<li>服务自治原则，每个微前端的开发，必须拥有开发、测试、运维、部署等整个过程，表示该应用可以独立运行而不需要依赖其他应用</li>
<li>持续演进原则，单体架构向微服务架构拆分过程中，无法做到一蹴而就，应逐步拆分细化，持续演进，避免微服务数量的瞬间爆炸性增长</li>
<li>服务粒度适中，先粗后细的原则，再按照拆分条件判断粗粒度的微前端是否需要拆分</li>
<li>避免循环依赖，循环依赖的情况会导致微前端在迭代发布的时候不知道优先发布哪个，在拆分的时候需要考虑，针对依赖部分进行下沉，拆分成公共模块</li>
<li>横向拆分原则，拆分微前端应该按照依赖层次的横向去拆，而不是纵向拆分，因为拆分越深，维护成本越高</li>
</ul>
<h3 id="拆分方法"><a href="#拆分方法" class="headerlink" title="拆分方法"></a>拆分方法</h3><p>以上两个主要针对拆分的假设条件，当真正去拆分操作的时候，我们应当从这些方面去入手：</p>
<ul>
<li>按照业务领域，参考<a href="https://zh.wikipedia.org/zh-hans/%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">领域模型</a>，将同类业务归为同一个微前端，按照单一职责原则、功能完整性进行拆分</li>
<li>按照组织架构，应尽量避免对组织架构和团队的调整，避免由于功能的重新划分，而增加大量且不必要的团队之间的沟通成本</li>
<li>按照技术栈，简单点说React的技术栈放一个微前端，Vue的技术栈放另外一个微前端</li>
<li>按需求迭代频率，将迭代频率高的放在一个微前端，频率低放在另外一个微前端</li>
</ul>
<p>学会了拆分方法，里面的优先级应该有大概排序，业务领域 &gt; 组织架构 &gt; 技术栈 &gt; 需求迭代频率，我推荐的做法如下：</p>
<ul>
<li>先按照业务领域去拆分</li>
<li>拆分的粒度不够，还要再拆分就按照组织结构再拆分</li>
<li>再往下，就是按照技术栈拆分</li>
<li>再往下，就是需求迭代频率</li>
</ul>
<h2 id="微前端框架"><a href="#微前端框架" class="headerlink" title="微前端框架"></a>微前端框架</h2><p>了解完如何拆分，那么接下来就是对微前端架构实现的框架进行选型，下面是我从网上收集目前市场主流的几大微前端框架：</p>
<ul>
<li><a href="https://github.com/single-spa/single-spa" target="_blank" rel="noopener">single-spa</a>，将多个单页面应用聚合为一个整体应用的 JavaScript 微前端框架</li>
<li><a href="https://qiankun.umijs.org/zh/guide" target="_blank" rel="noopener">qiankun</a>，基于single-spa，能更简单、无痛构建可用微前端架构的框架</li>
<li><a href="https://wujie-micro.github.io/doc/guide/" target="_blank" rel="noopener">无界</a>，基于iframe，实现路由同步机制的微前端架构框架</li>
<li><a href="https://zeroing.jd.com/docs.html#/" target="_blank" rel="noopener">micro-app</a>，借鉴WebComponent思想，结合自定义的ShadowDom，将微前端封装成一个类WebComponent组件的微前端框架</li>
<li><a href="https://webpack.docschina.org/concepts/module-federation/" target="_blank" rel="noopener">webpack 模块联邦</a>，在webpack构建时候加载远程应用而实现的微前端架构方案</li>
</ul>
<p>以上，就是目前实现微前端架构的主流框架，当然每个框架都自己的优缺点，我们在选型的时候主要还是通过以下几点去判断是否适合：</p>
<ul>
<li>对现有项目是否需要改造，改造成本多少</li>
<li>是否有学习成本，学习成本有多复杂</li>
<li>未来是否足够的扩展性</li>
<li>团队内是否有熟悉、精通该选型的人，否则遇到问题，容易入坑</li>
<li>项目维护的情况，issue 是否有响应，迭代是否在正常进行</li>
</ul>
<p>到了这里，本篇介绍微前端架构基本上就结束了，虽然很多理论知识，但是我们可以再次回顾一下，总结一下要点：</p>
<ul>
<li>微前端架构源自微服务架构，两者主要都是为了解决巨石应用的痛点，迭代慢、开发复杂</li>
<li>微前端架构拆分需要注意几个点：拆分条件、拆分原则和拆分方法</li>
<li>微前端架构主流框架：<a href="https://github.com/single-spa/single-spa" target="_blank" rel="noopener">single-spa</a>、<a href="https://qiankun.umijs.org/zh/guide" target="_blank" rel="noopener">qiankun</a>、<a href="https://wujie-micro.github.io/doc/guide/" target="_blank" rel="noopener">无界</a>、<a href="https://zeroing.jd.com/docs.html#/" target="_blank" rel="noopener">micro-app</a>、<a href="https://webpack.docschina.org/concepts/module-federation/" target="_blank" rel="noopener">webpack 模块联邦</a>等</li>
</ul>
<p>当然，我不会只写理论知识点，后面我会针对每个框架的写一篇深入实战文章，从背后原理，适用场景去一一描述，前端架构之路不好走，希望大家一起努力加油。</p>
<h1 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h1><h2 id="领域驱动设计"><a href="#领域驱动设计" class="headerlink" title="领域驱动设计"></a>领域驱动设计</h2><p>要了解一个新的东西，首先弄明白它解决了什么问题？领域驱动设计主要是为了解决：</p>
<ul>
<li>帮助团队更好理解业务世界</li>
<li>能协助开发构建良好的设计</li>
<li>降低业务逻辑与开发逻辑的耦合，降低复杂性</li>
</ul>
<p>那么现在，我们就明白领域驱动设计是什么了？它是强调业务概念、专业术语的开发设计理念。以下是一些官方解释，后面在前端架构系列文里，会写专门文章做深入介绍：</p>
<blockquote>
<p>领域驱动设计（Domain-Driven Design，简称DDD）是一种强调业务概念、专业术语以及原则的开发范式，旨在帮助用户，团队和软件开发者来解决复杂的信息系统和软件。它使用图形模型作为核心，其目标是使开发者能够理解、分析和把握业务概念，并将这些概念转化为可操作的软件。—— 【ChatGPT回答】</p>
</blockquote>
<h3 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h3><blockquote>
<p><code>领域模型</code>，来自领域驱动架构(DDD)中的一个概念，与<code>开发模型</code>(解决实际问题所抽象出来的概念模型) <code>设计模型</code>(描述了所要构建的系统)不同的是， <code>领域模型</code>是表达与业务相关的事实，它更加关注业务知识，能否显性化、清晰的表达业务语义。</p>
</blockquote>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://mp.weixin.qq.com/s/8vfTp-FZbYNk2k8gCIGc8w" target="_blank" rel="noopener">模块联邦在微前端架构中的实践</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2022/04/microservice.html" target="_blank" rel="noopener">微服务是什么？ —— 阮一峰</a></li>
<li><a href="https://micro-frontends.org/" target="_blank" rel="noopener">微前端的完整介绍</a></li>
<li><a href="https://www.zhihu.com/question/25089273" target="_blank" rel="noopener">领域驱动架构（DDD）建模中的模型到底是什么？</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
        <tag>架构系列</tag>
      </tags>
  </entry>
  <entry>
    <title>前端架构成长之路——Nest.js微服务架构实战</title>
    <url>/framework/frontend-microapp-3.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
        <tag>架构系列</tag>
      </tags>
  </entry>
  <entry>
    <title>好玩有趣收集系列（二）</title>
    <url>/ideas/20230218.html</url>
    <content><![CDATA[<p>今日收集一些好玩有趣的开源api或框架或开源项目 </p>
<h1 id="自动生成1000个性化视频"><a href="#自动生成1000个性化视频" class="headerlink" title="自动生成1000个性化视频"></a>自动生成1000个性化视频</h1><p>通过<a href="https://shotstack.io/docs/guide/getting-started/core-concepts/" target="_blank" rel="noopener">Shotstack</a>提供的API服务制作不同视频。</p>
<blockquote>
<p>ShotStack是一个基于云的视频编辑API。与Adobe Premiere或After Effects等传统桌面视频编辑应用程序不同，ShotStack纯粹是基于代码的–您可以使用代码创建编辑。该API使用使用JSON的REST架构样式来描述应该如何编辑视频。有许多不同语言的SDK可用于与API交互并创建JSON请求。</p>
</blockquote>
<p>是否可以利用该api和小程序结合在一起做一些 生日祝福小视频定制服务。  </p>
<a id="more"></a>

<h1 id="ssh2-js-zx-js-快速实现运维"><a href="#ssh2-js-zx-js-快速实现运维" class="headerlink" title="ssh2.js + zx.js 快速实现运维"></a>ssh2.js + zx.js 快速实现运维</h1><ul>
<li><a href="https://github.com/mscdex/ssh2" target="_blank" rel="noopener">ssh2.js</a> 它是用纯JavaScript为Node.js编写的SSH2客户端和服务器模块</li>
<li><a href="https://www.npmjs.com/package/zx" target="_blank" rel="noopener">zx.js</a> 更加方便执行shell命令的API接口</li>
<li><a href="https://www.npmjs.com/package/inquirer" target="_blank" rel="noopener">inquirer.js</a> 提供终端交互的工具包</li>
</ul>
<blockquote>
<p>原文：<a href="https://github.com/CatsAndMice/blog/issues/42" target="_blank" rel="noopener">【Node.js】ssh2.js+Shell一套组合拳下来，一年要花2080分钟做的工作竟然节省到52分钟</a><br>其他好玩的文章：</p>
<ul>
<li><a href="https://juejin.cn/post/7068969844607189029" target="_blank" rel="noopener">自动生成npm版本号和发布npm包</a></li>
<li><a href="https://juejin.cn/post/7072972877628178440" target="_blank" rel="noopener">发属于自己的快速创建开发文件脚手架</a></li>
</ul>
</blockquote>
<h1 id="密码学工具"><a href="#密码学工具" class="headerlink" title="密码学工具"></a>密码学工具</h1><p><a href="https://crypto-online.cn/" target="_blank" rel="noopener">cryptography 加密密码相关工具网站</a></p>
<h1 id="自动生成证件照"><a href="#自动生成证件照" class="headerlink" title="自动生成证件照"></a>自动生成证件照</h1><p><a href="https://github.com/liuxiaojun666/certificate-photo" target="_blank" rel="noopener">certificate-photo  生成证件照的小程序源码</a></p>
<h1 id="常用小工具"><a href="#常用小工具" class="headerlink" title="常用小工具"></a>常用小工具</h1><p>回头可以自己搞一套，提高网站访问量</p>
<p><a href="https://tool.browser.qq.com/category/develop" target="_blank" rel="noopener">腾讯浏览器 帮小忙工具集合</a></p>
<h1 id="P2P私域聊天工具"><a href="#P2P私域聊天工具" class="headerlink" title="P2P私域聊天工具"></a>P2P私域聊天工具</h1><blockquote>
<p>webrtc file transfer tool，p2p网页在线文件传输，跨终端，不限平台，内网不限速，支持私有部署，支持多文件拖拽发送，支持本地屏幕录制，远程屏幕共享，远程音视频通话，密码房间，中继服务设置，webrtc检测，文字传输，公共聊天，丰富的后台管理，实时执行日志展示，机器人告警通知等功能</p>
</blockquote>
<p><a href="https://github.com/iamtsm/tl-rtc-file" target="_blank" rel="noopener">webrtc file transfer tool github 地址</a></p>
<h1 id="个人Linux服务器管理面板"><a href="#个人Linux服务器管理面板" class="headerlink" title="个人Linux服务器管理面板"></a>个人Linux服务器管理面板</h1><p>能够让你快速观看个人服务器的一些状态和信息。</p>
<p><a href="https://github.com/chaos-zhu/easynode" target="_blank" rel="noopener">github地址</a></p>
<h1 id="有趣的言论"><a href="#有趣的言论" class="headerlink" title="有趣的言论"></a>有趣的言论</h1><p>创业箴言：</p>
<p>领导者的作用不是行使权力，而是分配权力。</p>
<p>有效的领导者通过设定方向、确定人员（找到具有正确技能和背景的人）、授权他人、确保决策执行，来节省自己的时间，并扩大自己的影响。</p>
<p>– <a href="https://hackernoon.com/optimize-for-alignment-not-control-great-leaders-serve-and-more-startup-mantras" target="_blank" rel="noopener">《我的创业箴言》</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>奇思妙想</tag>
      </tags>
  </entry>
  <entry>
    <title>创业idea —— 一个小程序利用一句话画一幅画</title>
    <url>/ideas/20230217.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近从开源库看到一个很火的项目，就是用一句话画一幅画。</p>
<p>这里虽然他们开源只识别英文，我们可以调用第三方的翻译API转成英文，然后再返回到开源库。</p>
<p>小程序思路：</p>
<ul>
<li>一个人一天体验3次，转发可以获得次数</li>
<li>允许转发下载，以及个人签名等</li>
<li>提高用户量</li>
<li>如果访问量爆发的话，可以继续尝试</li>
<li>名字叫随意画</li>
</ul>
<h1 id="AI生成图片开源项目"><a href="#AI生成图片开源项目" class="headerlink" title="AI生成图片开源项目"></a>AI生成图片开源项目</h1><p><a href="https://github.com/cmdr2/stable-diffusion-ui?utm_source=gold_browser_extension" target="_blank" rel="noopener">stable-diffusion-ui 一句话生成一幅画</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>奇思妙想</tag>
      </tags>
  </entry>
  <entry>
    <title>可以从ChatGPT学到什么(一)</title>
    <url>/today/20230216.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近<code>chatgpt</code>智能对答火的一塌涂地，就是你找<code>chatgpt</code>咨询，它不仅能理解你的意思，还能给出准确的答案，而且能够从上下文理解你的意思。</p>
<p>简单的说，就不再是之前的智能对答，如果遇到不理解的问题回复【我好像不太理解你的问题】。</p>
<p>更有甚者，利用chatgpt完成论文编写，同时还有帮小孩子写作业、程序员利用它整理某个业务的实现思路，作者利用其帮忙写小说细节等等。</p>
<p>我尝试问了一些常规问题，如下图所示，可以更好的理解<code>chatgpt</code>的能力。</p>
<ol>
<li><p>如何以<code>Nest.js</code>框架实现用户登录功能</p>
<a id="more"></a>
<p><img src="/assets/img/20230216-1.jpeg" alt></p>
</li>
<li><p>直接将高考作文题要求放入，如下：</p>
<blockquote>
<p>请以“像一道闪电”为题目，写一段抒情文字或一首小诗。要求：感情真挚，语言生动，有感染力。要求800字。 —— 2022年北京卷</p>
</blockquote>
</li>
</ol>
<p><img src="/assets/img/20230216-2.png" alt></p>
<p>因此，作为程序员，没有理由不去深入且完整的了解它，故而有这篇小白科普文。</p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>为了更好的了解后面的内容，我们需要提前对一些知识概念了解一下。</p>
<h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h2><blockquote>
<p>人工智能 (AI) 是计算机模拟人类智能行为的功能。 通过 AI，计算机可以分析图像、理解语音、以自然方式交互，以及使用数据进行预测。</p>
</blockquote>
<p>目前AI开发流程分为：</p>
<ol>
<li>确定目的模型，AI最终是用来做什么，如：图像识别、语言识别等</li>
<li>准备训练数据，收集和预处理数据，如：要识别一只猫，可能需要几十万张不同猫的图片</li>
<li>训练模型，也叫建模，通过各种算法、方法和技巧去创建，最终输出模型，如：从不同图片中去识别猫的，需要写算法、然后标注结果是否准确，这里的模型你可以理解成“只会识别猫的眼睛”</li>
<li>评估模型，反复的调整算法参数、数据，不断评估训练生成的模型，最终得到满意的模型，如：告诉【眼睛模型】哪些图片是猫，哪些图片不是猫，猫的特征有什么，直到【眼睛模型】可以识别出所有的猫的图片和不是猫的图片</li>
<li>部署模型，将模型应用到正式的实际数据或新产生数据中，进行预测、评价，如：把【眼睛模型】去接触真实世界，看到一些真实猫图片或视频</li>
</ol>
<p>总结来说，AI就是可以模拟人的部分行为，如上文举例所说的【眼睛模型】，就是实现人类眼睛可以识别猫的功能，扩展开来就是可以充当人的眼睛去识别万物。</p>
<p>当然有些更加智能的模型可以重复2/3/4三个步骤让自己变得更加完善（这也叫【无监督模型或自监督模型】）。</p>
<h2 id="语言模型"><a href="#语言模型" class="headerlink" title="语言模型"></a>语言模型</h2><p>从前面了解到【模型】的概念，从通俗的理解模型是一个模仿人类某个功能，从技术上讲模型是一段算法代码。</p>
<p>因此语言模型从这两个方面来说：</p>
<ul>
<li>许多自然语言处理方面的应用，如：语音识别[1]，机器翻译[2]，词性标注，句法分析[3]，手写体识别[4]和资讯检索</li>
<li>从技术上来讲，是一个概率分布的算法</li>
</ul>
<p>我们对语言模型可以理解成，一个能够识别自然语言（包括语音，语义识别等）的算法模型即可。</p>
<p>常用的语言模型算法有以下几种：</p>
<ul>
<li>ELMo 华盛顿大学提出的算法 </li>
<li>GPT OpenAI提出的算法</li>
<li>BERT Google提出的算法</li>
</ul>
<h2 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h2><blockquote>
<p>Generative Pre-trained Transformer (GPT)，是一种基于互联网可用数据训练的文本生成深度学习模型。</p>
</blockquote>
<p>GPT的整个发展过程分为：</p>
<ul>
<li>GPT-1，有一定的泛化能力，能够用于和监督任务无关的 NLP 任务，如：自然语言推理：判断两个句子的关系；问答与常识推理：输入文章及若干答案，输出答案的准确率等</li>
<li>GPT-2，使用无监督预训练模型做有监督任务，比GTP-1拥有更加强大能力，能阅读摘要、聊天、续写、编故事，甚至生成假新闻等，甚至可以假扮网络角色进行会话聊天，如：微软的小冰。</li>
<li>GPT-3，作为一个无监督模型，几乎可以完成自然语言处理的绝大部分任务，如面向问题的搜索、阅读理解、语义推断、机器翻译、文章生成和自动问答等等。</li>
<li>GPT3.5，是一系列模型，使用<code>人类反馈强化学习(RLHF)</code>，与<code>GPT-3</code>最大的区别在使用互联网的资料直接训练。</li>
<li>GPT-4，针对GPT-3不分青红皂白和质量好坏地对网络上的所有文本进行学习，进而生产出错误的、恶意冒犯的、甚至是攻击性的语言输出的缺陷，而准备提出新的升级模型。</li>
</ul>
<p><strong>一个无监督模型功能多效果好，似乎让人们看到了通用人工智能的希望，可能这就是 GPT-3 影响如此之大的主要原因。</strong></p>
<p>有了这些概念性的知识后，我们就可以开始认识<code>ChatGPT</code>。</p>
<h1 id="ChatGPT"><a href="#ChatGPT" class="headerlink" title="ChatGPT"></a>ChatGPT</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>在官网上定义如下：</p>
<blockquote>
<p>ChatGPT: 专门针对对话而优化的语言模型。同时已经训练了一个名为ChatGPT的模型，它以对话的方式进行交互。对话形式使ChatGPT能够回答后续问题，承认错误，挑战不正确的前提，拒绝不适当的请求。ChatGPT是InstructGPT的兄弟模型，InstructGPT被训练为遵循提示中的说明并提供详细的响应。 —— <a href="https://openai.com/blog/chatgpt/" target="_blank" rel="noopener">ChatGPT官网</a></p>
</blockquote>
<p>按照我所理解来说，ChatGPT是：</p>
<ul>
<li>一个基于<code>GPT-3.5系列模型</code> + <code>人类反馈强化学习(RLHF)</code>实现的语言模型</li>
<li>一个可以正常对话聊天、自动纠正错误的智能对话机器人(快速，而不需要等待太长时间)</li>
<li>一个链接互联网所有公开信息，能检索到所有信息和总结的智能搜索引擎</li>
<li>一个可以辅助你实现相关工作（如：作业，代码，论文等）的智能工具</li>
</ul>
<p><strong><a href="https://openai.com/blog/instruction-following/" target="_blank" rel="noopener">InstructGPT</a> VS ChatGPT</strong></p>
<ul>
<li>两者都是基于<code>GPT-3.5系列模型</code>做调整的语言模型</li>
<li><code>InstructGPT</code>是一个问题就一个回答，如果回答不正确就调整， <code>ChatGPT</code>则是一个问题就多个回答，然后学习将这些回答进行排序</li>
</ul>
<p>如何使用：</p>
<p>其实如果可以直接访问<a href="https://chat.openai.com/" target="_blank" rel="noopener">ChatGPT官网</a>就可以直接用，国内也有很多插件可以使用。</p>
<h2 id="影响什么"><a href="#影响什么" class="headerlink" title="影响什么"></a>影响什么</h2><p>ChatGPT的火爆是AI多年沉淀的一次技术爆发，距离上一次AI技术的热点新闻还是在谷歌的阿尔法狗战胜世界围棋冠军李世石（2016年）。</p>
<p>我们可以先收集一下目前使用AI技术的一些场景：</p>
<ul>
<li>各种识别，人脸、指纹等</li>
<li>智能辅助驾驶</li>
<li>各种转义，如：语音转文字，文字转语音， 翻译等</li>
<li>各种语音助手，如：Siri，小爱同学等</li>
</ul>
<p>其实，AI在我们生活中已经随处可见，只是有时候我们觉得这些功能还是比较属于机器范围内的，如有时候小爱同学会说“我没听清楚你的问题”这种明显非智能回答，给我们造成一种认知觉得AI很傻。</p>
<p>因此，ChatGPT的火爆之处在于：它真的可以像一个人类给予你想要的回答，更加准确的说，它是一个负责任的智能AI，能竭尽所能的给你想要的答案。</p>
<p>接下来，我从网上搜索了一些资料，从几个行业讲一下它可能会带来的影响。</p>
<h3 id="教育行业"><a href="#教育行业" class="headerlink" title="教育行业"></a>教育行业</h3><p>其实最大的担心就是，大家利用chatgpt去写作业或论文，尤其是学龄前儿童和中小学阶段，正是属于知识探索期，chatgpt是否会影响学生的学习吗？</p>
<p>这里引用一段话，针对国内的，吴永和教授的一个观点：</p>
<blockquote>
<p>面向未来，作为承担2021年度国家社会科学基金重大项目“面向未成年人的人工智能技术规范研究”的首席专家，吴永和从五个方面给出了教育人工智能发展的建议：</p>
<ul>
<li>一、是进行理论的奠基，确定价值观、战略方向，做好顶层设计；</li>
<li>二、是提升人类的人工智能核心素养，从而使师生能正确驾驭智能工具；</li>
<li>三、是完善技术应用的监管，保持人工智能的向善性，使技术能够更好地为人服务；</li>
<li>四、是考虑技术和教育深度融合的伦理问题，更好地做到人机共融；</li>
<li>五、是落实相关标准，比如教育人工智能的算法描述信息、安全描述框架、伦理审查规范。</li>
</ul>
</blockquote>
<h3 id="IT行业"><a href="#IT行业" class="headerlink" title="IT行业"></a>IT行业</h3><p>网络已经有很多人利用chatgpt去生成代码甚至正式上线，那么是否会代替程序员，或者以后程序员已经如何学习发展？</p>
<p>这里引用知乎上的一个问答<a href="https://www.zhihu.com/question/570403406" target="_blank" rel="noopener">OpenAI 的超级对话模型 ChatGPT 会导致程序员大规模失业吗？</a>，总结一下精彩回答：</p>
<blockquote>
<ul>
<li>chatgpt作为一个管家型查找，把喂到你嘴里这个功能发挥到了极致。</li>
<li>chatgpt给出的代码实现和”背题家”也出奇的相似</li>
<li>chatGPT最多能看作一个助手, 对于广大程序员来说是一个不错的辅助工具</li>
<li>AI的发展已经明确告诉你了，不要卷细节上的东西，提升核心竞争力，就是你的解决问题的思路</li>
<li>没有思想的人才是最快被取代的</li>
<li>ChatGPT 又来了，这次我是什么感觉呢？感觉真的 Google 和 StackOverflow 已经不好用了</li>
<li>借助 Copilot 和 ChatGPT，程序员的自我感觉更棒了！可以更加肆无忌惮地在未知领域里自由探索了！</li>
</ul>
</blockquote>
<h3 id="其他行业"><a href="#其他行业" class="headerlink" title="其他行业"></a>其他行业</h3><p>引用知乎上的问答<a href="https://www.zhihu.com/question/582809884/answer/2883146417" target="_blank" rel="noopener">ChatGPT 会取代人的哪些工作？哪些人群的职业规划需要转变？</a>，总结一下精彩回答：</p>
<blockquote>
<ul>
<li>内容行业：文字+图像处理效率的提升，更加庞大的内容生态也有了存在的基础，推动芯片和硬件的提升，从而实现更宏大的数字世界</li>
<li>游戏行业：npc会和你流畅的对话，黄油里面可以根据你的xp来叫主人或者变态，新的需求会生成，也催生新的经济形态</li>
<li>这将是人工智能诞生以来，人类的工作第一次真正接近被大规模替代的时点——不是部分工作被替代，而是大规模被替代的开始。</li>
<li>ChatGPT的商业模式，可能不会像搜索那样依赖广告，难以出现大规模的2C级应用，而更可能是2B，主要运用于工作场景</li>
<li>会提问题的人将是最后的赢家，可以让你的工作不但不会被AI取代，反而创造了全新的工作方式</li>
</ul>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>第一篇关于ChatGPT的了解就先写到这里，作为AI小白，我们可以学习到：</p>
<ul>
<li>AI模型是的训练过程：确定模型&gt;准备数据&gt;训练模型&gt;调整模型&gt;部署模型</li>
<li>ChatGPT的实质定义，利用互联网的资料训练<code>GPT-3.5模型</code>而成的一个对话式的语言模型</li>
<li>ChatGPT的出现可能带来的改变，可以将某些行业岗位的价值重新定义，但是却能提高更多岗位的工作效率和价值，从而提升整个社会运转速度</li>
</ul>
<p>最后，问ChatGPT我能从你这里学到什么？如下图：</p>
<p><img src="/assets/img/20230216-3.png" alt></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://support.huaweicloud.com/productdesc-modelarts/modelarts_01_0010.html" target="_blank" rel="noopener">华为 AI开发基本流程介绍</a></li>
<li><a href="https://learn.microsoft.com/zh-cn/azure/architecture/data-guide/big-data/ai-overview" target="_blank" rel="noopener">谷歌 人工智能 (AI) 体系结构设计</a></li>
<li><a href="https://www.8btc.com/article/6791988" target="_blank" rel="noopener">ChatGPT的崛起：从GPT-1到GPT-3，AIGC时代即将到来</a></li>
<li><a href="https://github.com/BlinkDL/ChatRWKV" target="_blank" rel="noopener">自己搭建chatpt</a></li>
<li><a href="https://gpt3demo.com/" target="_blank" rel="noopener">GPT-3 demo应用收集</a></li>
<li><a href="http://edu.china.com.cn/2023-02/15/content_85106877.htm" target="_blank" rel="noopener">用ChatGPT写作业会毁了孩子的学业吗？</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>前端自动化UI测试的完整方案</title>
    <url>/today/20230215.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>开发公共平台项目，测试资源相对比较少，因此对开发者自身而言，为了维护项目的稳定性，需要对平台做各类测试，即使有测试环境，但是也很容易缺乏测试场景导致带着bug上线的情况。</p>
<p>因此我们需要做完整自动化测试方案，来避免这类常规错误，提高平台的可用性和稳定性。</p>
<p>这里先简单描述自动化测试的分类：</p>
<ul>
<li>单元测试，验证独立的单元模块代码或函数是否正常工作</li>
<li>集成测试，验证多个单元模块间的协同工作</li>
<li>UI 测试，只针对前端UI部分测试，后端数据采用mock方式</li>
<li>端到端测试，从用户的角度，通过机器来模仿用户在真实浏览器中验证应用交互</li>
<li>快照测试，验证程序的UI变化</li>
</ul>
<p>接下来我们将根据这些测试类如何在项目中落地完整方案。</p>
<a id="more"></a>

<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>前端项目主要用的单元测试框架为<code>Jest</code>和<code>Mocha</code>，下面就<code>Jest</code>框架如何实现一个单元测试。</p>
<h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ol>
<li><p>安装依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i jest --save-dev</span><br><span class="line"><span class="meta">#</span> 如果是typescript还需要安装 ts</span><br><span class="line">npm i ts-jest babel-jest --save-dev</span><br><span class="line"><span class="meta">#</span> 安装类型</span><br><span class="line">npm i @types/jest --save-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>新增测试命令，在<code>package.json</code>中<code>scripts</code>新增代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">"scripts"</span>: &#123;</span><br><span class="line">        <span class="string">"test"</span>: <span class="string">"node --experimental-vm-modules node_modules/jest/bin/jest.js"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新增配置文件<code>jest.config.js</code>，参考配置如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="string">"testEnvironment"</span>: <span class="string">"node"</span>,</span><br><span class="line">    testMatch: [ <span class="comment">//匹配测试用例的文件</span></span><br><span class="line">        <span class="string">'&lt;rootDir&gt;/test/**/*.test.ts'</span></span><br><span class="line">    ],</span><br><span class="line">    transform: &#123;</span><br><span class="line">        <span class="string">'^.+\\.js$'</span>: <span class="string">'&lt;rootDir&gt;/node_modules/babel-jest'</span>, <span class="comment">// babel编译</span></span><br><span class="line">        <span class="string">'^.+\\.ts$'</span>: <span class="string">'&lt;rootDir&gt;/node_modules/ts-jest'</span>, <span class="comment">// typescript编译</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"collectCoverage"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写单元测试代码，在根目录下新建测试文件<code>test/sum.test.js</code>，标识对<code>a.ts</code>文件做测试，代码如下：</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sum.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sum.test.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">'../src/sum'</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">"test two num sum"</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> res = sum(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    expect(<span class="keyword">typeof</span> res).toBe(<span class="string">"number"</span>)</span><br><span class="line">    expect(res).toBe(<span class="number">11</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>开始自动化测试<code>yarn test</code>或者<code>npm run test</code>，然后会出现如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PASS  ./sum.test.ts</span><br><span class="line">----------|---------|----------|---------|---------|-------------------</span><br><span class="line">File      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s </span><br><span class="line">----------|---------|----------|---------|---------|-------------------</span><br><span class="line">All files |     100 |      100 |     100 |     100 |                   </span><br><span class="line"> sum.ts   |     100 |      100 |     100 |     100 |                   </span><br><span class="line">----------|---------|----------|---------|---------|-------------------</span><br><span class="line">Test Suites: 1 passed, 1 total</span><br><span class="line">Tests:       1 passed, 1 total</span><br><span class="line">Snapshots:   0 total</span><br><span class="line">Time:        1.394 s, estimated 3 s</span><br></pre></td></tr></table></figure>

<p>简单说明一下上面的表格几个字段作用：</p>
<ul>
<li>File，标识当前测试的文件</li>
<li>Stmts，语句覆盖率（statement coverage）：是不是每个语句都执行了</li>
<li>Branch，分支覆盖率（branch coverage）：是不是每个if代码块都执行了</li>
<li>Funcs，函数覆盖率（function coverage）：是不是每个函数都调用了</li>
<li>Lines，行覆盖率（line coverage）：是不是每一行都执行了</li>
</ul>
<h2 id="怎么提高单元测试覆盖率"><a href="#怎么提高单元测试覆盖率" class="headerlink" title="怎么提高单元测试覆盖率"></a>怎么提高单元测试覆盖率</h2><p>分为两个部分：</p>
<ul>
<li>提高代码质量，减少代码块的大小，减少各类复杂逻辑判断，不去测试有依赖性函数，如：需接口、数据库等</li>
<li>提高开发意愿，一自动化生成单元测试，二采用设置覆盖率指标，三是确定单元测试规范（哪些模块需要写，哪些不需要写）</li>
</ul>
<h1 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h1><p>集成测试主要是测试当单元模块组合到一起之后是否功能正常。</p>
<p>相比较单元测试只是针对某个函数或方案做单一功能测试，集成测试是针对某个功能模块做完整的测试，因此在测试粒度上的选择，需要开发自己去衡量，但是一般的选择如下几种：</p>
<ul>
<li>如果有UI展示的，一般通过router分割页面粒度去进行测试，尽可能的少mock依赖，尽量的渲染全子组件</li>
<li>如果是库不含JS的，则以功能模块为粒度进行测试，测试数据尽量丰富且贴近真实数据</li>
</ul>
<p>具体实现步骤其实和单元测试一样，只是所写的测试功能比单元测试范围要大且完整。</p>
<h1 id="UI-测试"><a href="#UI-测试" class="headerlink" title="UI 测试"></a>UI 测试</h1><blockquote>
<p>相比较后面<code>端到端测试</code>，UI测试只是对于前端的测试，是脱离真实后端环境的，仅仅只是将前端放在真实环境中运行，而后端和数据都应该使用 Mock 的。</p>
</blockquote>
<p>UI 测试在前端上，也可以叫组件测试<br>那么如何实现UI测试，其实依旧可以使用<code>Jest</code>、<code>Enzyme</code> <code>selenium</code> <code>Vitest</code>等框架，目前都支持将<code>Vue</code>、<code>React</code>等组件进行模拟渲染完成。</p>
<p>利用<code>Jest</code>实现对React UI组件测试，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// React Home.jsx</span></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;Home&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// home.test.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createRoot &#125; <span class="keyword">from</span> <span class="string">"react-dom/client"</span>; <span class="comment">// createRoot 是React18 新出的特性</span></span><br><span class="line"><span class="keyword">import</span> &#123; act &#125; <span class="keyword">from</span> <span class="string">"react-dom/test-utils"</span>; <span class="comment">// react支持测试动作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">"../src/pages/home"</span>;</span><br><span class="line"></span><br><span class="line">global.IS_REACT_ACT_ENVIRONMENT = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> root = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> container = <span class="literal">null</span>;</span><br><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 DOM 元素作为渲染目标</span></span><br><span class="line">    container = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(container);</span><br><span class="line">    root = createRoot(container)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 退出时进行清理</span></span><br><span class="line">    <span class="comment">// root.unmount(container);</span></span><br><span class="line">    container.remove();</span><br><span class="line">    container = <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">it(<span class="string">"渲染有或无名称"</span>, () =&gt; &#123;</span><br><span class="line">    act(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        root.render(&lt;Home /&gt;);</span><br><span class="line">    &#125;);</span><br><span class="line">    expect(container.textContent).toBe("Home");</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当然你依然可以使用<code>Jest</code>去做Vue UI 测试，但是<code>Vitest</code>实现在vite项目中更加好用，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Home.vue</span></span><br><span class="line">&lt;script setup lang=<span class="string">"ts"</span>&gt;</span><br><span class="line">defineProps&lt;&#123; <span class="attr">msg</span>: string &#125;&gt;()</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;template&gt;</span></span><br><span class="line"><span class="regexp">  &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/</span>h1&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/home.test.js</span></span><br><span class="line"><span class="regexp">import &#123; mount &#125; from '@vue/</span>test-utils<span class="string">'</span></span><br><span class="line"><span class="string">import Home from '</span>../src/components/Home.vue<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">test('</span>mount component<span class="string">', async () =&gt; &#123;</span></span><br><span class="line"><span class="string">    expect(Home).toBeTruthy()</span></span><br><span class="line"><span class="string">    const wrapper = mount(Home, &#123;</span></span><br><span class="line"><span class="string">        props: &#123;</span></span><br><span class="line"><span class="string">            msg: '</span>Home<span class="string">',</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">      &#125;)</span></span><br><span class="line"><span class="string">    expect(wrapper.html()).toContain('</span>Home<span class="string">')</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure>

<h2 id="快照测试"><a href="#快照测试" class="headerlink" title="快照测试"></a>快照测试</h2><p>快照测试是属于UI测试的一种分类，主要用于区分同样的数据下，页面UI展示是否发生变化，如果不一样则比较测试结果失败，有异常或者功能迭代。针对快照测试详细说明如下：</p>
<blockquote>
<p>快照测试类似于“找不同”游戏。快照测试会给运行中的应用程序拍一张图片，并将其与以前保存的图片进行比较。如果图像不同，则测试失败。这种测试方法对确保应用程序代码变更后是否仍然可以正确渲染很有帮助。</p>
<p>当然，在前端中，其实并不是比较图片，而是比较前后生成的html结构，本质上是一个字符串的比较。</p>
</blockquote>
<p>同理，如果一个功能模块，针对同样的输入，得出的结果是不一样，那么也是一种快照测试。</p>
<p>利用<code>Jest</code>实现快照测试代码如下（基本和UI测试一样）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// home.test.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createRoot &#125; <span class="keyword">from</span> <span class="string">"react-dom/client"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; act &#125; <span class="keyword">from</span> <span class="string">"react-dom/test-utils"</span>;</span><br><span class="line"><span class="keyword">import</span> pretty <span class="keyword">from</span> <span class="string">"pretty"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">"../src/pages/home"</span>;</span><br><span class="line"></span><br><span class="line">global.IS_REACT_ACT_ENVIRONMENT = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> root = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> container = <span class="literal">null</span>;</span><br><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 DOM 元素作为渲染目标</span></span><br><span class="line">    container = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(container);</span><br><span class="line">    root = createRoot(container)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 退出时进行清理</span></span><br><span class="line">    <span class="comment">// root.unmount(container);</span></span><br><span class="line">    container.remove();</span><br><span class="line">    container = <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">it(<span class="string">"渲染有或无名称"</span>, () =&gt; &#123;</span><br><span class="line">    act(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        root.render(&lt;Home /&gt;);</span><br><span class="line">    &#125;);</span><br><span class="line">    expect(container.textContent).toBe("Home");</span><br><span class="line"></span><br><span class="line">    // 快照对比 这里你可以先把html结构存储一份，然后再拿出来对比</span><br><span class="line">    expect(</span><br><span class="line">        pretty(container.innerHTML)).</span><br><span class="line">        toMatchInlineSnapshot(`</span><br><span class="line">"&lt;div&gt;</span><br><span class="line">  &lt;h1&gt;Home1&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;"</span><br><span class="line">`);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="E2E测试"><a href="#E2E测试" class="headerlink" title="E2E测试"></a>E2E测试</h1><p>E2E测试，也叫端到端测试，就是模拟真实环境下，用户不同操作行为的测试。</p>
<p>目前主要进行E2E测试框架有如下几种：</p>
<ul>
<li>puppeteer 一个 Node 库，它提供了一个高级 API 来通过 DevTools 协议控制 Chromium 或 Chrome</li>
<li>cypress  现代网络构建的下一代前端测试工具， 编写更快、更容易和更可靠的测试</li>
<li>Selenium  是开源的自动化测试工具，它主要是用于Web 应用程序的自动化测试，不只局限于此，同时支持所有基于web 的管理任务自动化</li>
<li>NightWatch 是一个用于web应用和网站上执行自动化端到端（end-to-end）测试的集成框架，用于主流浏览器中，简化编写和执行多种类型地测试程序</li>
</ul>
<p>这几者的区别后面会有专门文章去描述，现在我们先利用<code>cypress</code>实现E2E测试代码， 以Vue项目为主，如下：<br>步骤一，安装依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add cypress -D</span><br></pre></td></tr></table></figure>

<p>步骤二，新增脚本，package.json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">        <span class="attr">"cypress"</span>: <span class="string">"cypress open"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤三，后面按照其提示去添加测试文件，比如：<code>index.cy.ts</code>，然后修改代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'template spec'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'has home text'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 访问首页</span></span><br><span class="line">    cy.visit(<span class="string">'http://localhost:5173/'</span>)</span><br><span class="line">    <span class="comment">// 断言是否有 Home 文字</span></span><br><span class="line">    cy.contains(<span class="string">'Home'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>具体效果如下图：</p>
<p><img src="/assets/img/20230215.png" alt></p>
<p>当然E2E没有这么简单，还有一些点击、输入等事件，甚至可以模拟登录等，这些详细操作放在后面cypress实战篇去讲解。</p>
<h1 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h1><p>了解自动化测试后，我们还需要对测试覆盖率进行一个完整的了解。</p>
<blockquote>
<p>测试覆盖率(test coverage)是衡量软件测试完整性的一个重要指标。掌握测试覆盖率数据，有利于客观认识软件质量，正确了解测试状态，有效改进测试工作。</p>
</blockquote>
<p>其实上面提到单元测试的时候已经有讲过一些，这里再做一个完整都介绍。</p>
<p>覆盖率主要分为以下几种：</p>
<ul>
<li>代码覆盖率， 如上述所说分为几种，如：行覆盖率、函数覆盖率等</li>
<li>需求覆盖率，测试所覆盖的需求数量与总需求数量的比值</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>自动化测试在前端开发是必不可少的一个环节，因为前端是直接面向用户的，即使有测试团队支持，也难免会出现测试遗漏的场景，或者加大测试人力成本。</p>
<p>当然不同项目的自动化测试所需要的环节是不一样的，根据个人经验，建议不同场景采用自动化测试如下：</p>
<ul>
<li>开发纯函数库，建议写更多的单元测试 + 少量的集成测试</li>
<li>开发组件库，建议写更多的单元测试、为每个组件编写快照测试、写少量的集成测试 + 端到端测试</li>
<li>开发业务系统，建议写更多的集成测试、为工具类库、算法写单元测试、写少量的端到端测试</li>
<li>开发公共平台项目，建议写更多的集成测试和完整的端到端测试</li>
</ul>
<h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><ul>
<li><a href="https://github.com/qiubohong/qiubohong.github.io/tree/master/code/react/my-app" target="_blank" rel="noopener">React测试demo代码</a></li>
<li><a href="https://github.com/qiubohong/qiubohong.github.io/tree/master/code/vue/vite-project" target="_blank" rel="noopener">Vue测试demo代码</a></li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247493866&idx=1&sn=c4a3d5ddf6e3148360f3de9ea32e018f&chksm=cf0327d1f874aec72d630aa81d7b1b0b0961943287fbab023e6d39d466f33b642e12ca7f1ac0&token=953834215&lang=zh_CN#rd" target="_blank" rel="noopener">把 puppeteer 融入调试流程，调试体验爽翻了！</a></li>
<li><a href="https://github.com/goldbergyoni/javascript-testing-best-practices/blob/master/readme-zh-CN.md" target="_blank" rel="noopener">JS最佳测试实践</a></li>
<li><a href="https://blog.checklyhq.com/how-to-bypass-totp-based-2fa-login-flows-with-playwright/" target="_blank" rel="noopener">如何使用Playwright绕过验证登录做端到端测试</a></li>
<li><a href="https://juejin.cn/post/6844904194600599560" target="_blank" rel="noopener">前端自动化测试入门</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>数据可视化收集</title>
    <url>/ideas/20230215.html</url>
    <content><![CDATA[<h1 id="数据可视化收集"><a href="#数据可视化收集" class="headerlink" title="数据可视化收集"></a>数据可视化收集</h1><p>收集数据可视化或报表开源系统，为了能够根据不同数据源展示可视化界面。</p>
<h2 id="DataEase"><a href="#DataEase" class="headerlink" title="DataEase"></a>DataEase</h2><p>人人可用的开源数据可视化分析工具</p>
<ul>
<li>官网地址：<a href="https://dataease.io/" target="_blank" rel="noopener">https://dataease.io/</a><br>Github： <a href="https://github.com/dataease/dataease/" target="_blank" rel="noopener">https://github.com/dataease/dataease/</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>奇思妙想</tag>
      </tags>
  </entry>
  <entry>
    <title>创业idea——AI种植与花店</title>
    <url>/ideas/20230214.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>此想法源于一个抖音视频，里面有个商业模式，通过摄像头+气味嗅觉捕捉器+液体分析器，可以识别当前植物的状态，且占地面积不大，可以直接树立到家里墙上。大概如下图所示：</p>
<p><img src="/assets/img/idea-20230214-3.png" alt></p>
<a id="more"></a>
<p><img src="/assets/img/idea-20230214-1.png" alt><br><img src="/assets/img/idea-20230214-2.png" alt></p>
<h1 id="创业想法"><a href="#创业想法" class="headerlink" title="创业想法"></a>创业想法</h1><p>因此萌生出一种想法，目前还没有关注这一块，家里大部分的时候也有盆栽或者绿植，都是从花店里直接购买的，那么如果利用这种技术去实现互利网AI种植，是不是一种创新的创业思维呢？</p>
<p>目前花店主要有以下几种痛点：</p>
<ul>
<li>购买盆栽后，没有完整的种植经验，很快就死了</li>
<li>无法知道自己需要什么的盆栽</li>
</ul>
<p>商业模式：</p>
<ul>
<li>分尺寸，如：小盆栽适合办公位，中大型的适合放在家庭做墙壁或者隔墙板，超大型就是AI农业大棚型</li>
<li>商场里租一个大店铺，除了宣传，还可以将一些位置租给某些用户，给他们去做亲子活动</li>
</ul>
<p>后续可以尝试继续研究，留此文做一个念想。</p>
<h1 id="已经实施的项目"><a href="#已经实施的项目" class="headerlink" title="已经实施的项目"></a>已经实施的项目</h1><ul>
<li><a href="https://www.squarerootsgrow.com/about" target="_blank" rel="noopener">马斯克弟弟 火星种菜项目 SquareRoot</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>奇思妙想</tag>
      </tags>
  </entry>
  <entry>
    <title>有了GPT-3，再也不用手写commit message(翻译)</title>
    <url>/translate/use-gpt3-auto-git-commit.html</url>
    <content><![CDATA[<blockquote>
<p>本文翻译的目的，主要想了解GPT3是什么，以及目前大家使用GPT3用来做什么，以及如何开发GPT3。</p>
</blockquote>
<h1 id="GPT-3"><a href="#GPT-3" class="headerlink" title="GPT-3"></a>GPT-3</h1><p>GPT-3是一个很多人或公司正在使用的协助开发的工具，比如：编写脚本、命令行等操作。</p>
<blockquote>
<p>GPT-3指的是生成型预训练变换模型3（英语：Generative Pre-trained Transformer 3，简称GPT-3）是一个自回归语言模型，目的是为了使用深度学习生成人类可以理解的自然语言[1]。GPT-3是由在旧金山的人工智能公司OpenAI训练与开发，模型设计基于谷歌开发的变换语言模型。GPT-3的神经网路包含1750亿个参数，为有史以来参数最多的神经网路模型[2]。OpenAI于2020年5月发表GPT-3的论文，在次月为少量公司与开发人团释出应用程式介面的测试版。微软在2020年9月22日宣布取得了GPT-3的独家授权。 —— <a href="https://zh.wikipedia.org/zh/GPT-3" target="_blank" rel="noopener">维基百科 GPT-3</a></p>
</blockquote>
<p>使用<code>gitcommit</code>,你将不需要花费时间去写git commit。 下面就让学习如何安装 <code>gptcommit</code>，以及享受一下GPT-3帮你写git commit。</p>
<a id="more"></a>

<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>首先，我们先了解一下 git commit， git commit提交信息，是程序员与程序员之间交流他们开发代码的重要信息，特别在code review中。<br>尤其当代码发生重大变化或者写的代码极为复杂，我们需要一一详细描述代码块功能，非常的耗时而且无聊。<br>平时开发代码后，由于一不小心容易写<code>fix: bug</code>之类的提交记录，很想修改后，但是又没有什么好的办法。<br>同时复杂的这些随意的话术对code review也很难理解这段代码的真正含义是什么。<br>更糟糕的是，如果提交记录是<code>fix: 修复文案错误</code>等，会让code review更加毫无意义，甚至忽略掉需要code review的地方。<br>所以问题是写 git commit很费时，而且描述不准确又容易造成不必要误会，那么使用<code>gptcommit</code>会让你摆脱这些烦恼。</p>
<h1 id="安装教程-几分钟"><a href="#安装教程-几分钟" class="headerlink" title="安装教程(几分钟)"></a>安装教程(几分钟)</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>在安装<code>gptcommit</code>之前，你需要先准备以下几个环境：</p>
<ul>
<li><a href="https://rustup.rs/" target="_blank" rel="noopener">Cargo</a>, <code>Rust</code>语言的包管理器</li>
<li><a href="https://platform.openai.com/account/api-keys" target="_blank" rel="noopener">OpenAI API Keys</a>, OpenAI的密钥</li>
</ul>
<p><strong>安装Rust</strong></p>
<p>Linux或Mac安装命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh</span><br></pre></td></tr></table></figure>

<p><strong>OpenAI API Keys获取方式</strong></p>
<p>国内没法正常访问，以下两种方式：</p>
<ul>
<li>这里去淘宝买一个API key</li>
<li>或者翻墙出去购买一个</li>
</ul>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol>
<li><p>使用<code>cargo</code>安装<code>gptcommit</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo install --locked gptcommit</span><br></pre></td></tr></table></figure>
</li>
<li><p>在本地某个仓库里安装执行一下命令，主要是初始化<code>gptcommit</code> git hook。这里需要你对这些仓库有git push的权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gptcommit install</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置全局变量<code>OPENAI_API_KEY</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export OPENAI_API_KEY="sk-..."</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>也可以直接将变量设置到全局文件中，如<code>~/.bashrc</code>, <code>~/.zshrc</code></p>
<h2 id="demo实战"><a href="#demo实战" class="headerlink" title="demo实战"></a>demo实战</h2><p>如果使用了后，会生成如下git commit:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Demo #1: the full installation and commit workflow, editing multiple rust files</span><br><span class="line">Demo #2: a one-line change to a string inside a rust file.</span><br><span class="line">Demo #3: Modifying non-code files, in this case a README.</span><br></pre></td></tr></table></figure>

<h2 id="参考对象"><a href="#参考对象" class="headerlink" title="参考对象"></a>参考对象</h2><p><code>gptcommit</code>参考之前的很受欢迎的commit 工具：</p>
<ul>
<li><a href="https://github.com/RomanHotsiy/commitgpt" target="_blank" rel="noopener">https://github.com/RomanHotsiy/commitgpt</a></li>
</ul>
<p><code>commitgpt</code>目前已无法使用，因为它使用第三方的OpenAI API Key，由于官方OpenAI访问次数受限，必须要求每个用户都用自己的API key。</p>
<p><code>gptcommit</code>集成了 git hook，可以直接用来git flow工作流的最后一步，同时，由于使用Rust，它执行速度会更快。</p>
<p>同时还参考<a href="https://github.com/KanHarI/gpt-commit-summarizer" target="_blank" rel="noopener">gpt-commit-summarizer</a>工具，它是直接作用在github Action持续集成中，而不是git 工作流。<br>总结commit记录是发生在PR阶段，而不是每次 commit。<br>该操作会直接将PR操作的commit进行汇总，然后直接提交，不需要再code review。</p>
<p><code>gptcommit</code>参考<code>gpt-commit-summarizer</code>的设计点，但是主要针对是git commit的提交信息进行总结。</p>
<h2 id="背后原理"><a href="#背后原理" class="headerlink" title="背后原理"></a>背后原理</h2><p>git commit提交劫持主要分为两个部分：</p>
<p>首先，会将每个文件单独汇总，然后到OpenAI去生成commit 信息记录。</p>
<p>其次，汇总所有文件修改内容，也有两个要点，分别是：</p>
<ul>
<li>告诉AI生成一个修改的标题</li>
<li>同时要生成修改的一些要点内容</li>
</ul>
<p>最终输出的提交记录如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[title]</span><br><span class="line"></span><br><span class="line">- [summary point 1]</span><br><span class="line">- [summary point 2...]</span><br><span class="line"></span><br><span class="line">[/changed/file A]</span><br><span class="line">- [file summary point 1]</span><br><span class="line">- [file summary point 2...]</span><br><span class="line">[/changed/file B...]</span><br><span class="line">- [file summary point 1...]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h2><p>接下来就在项目中实战吧。<br>执行命令<code>cargo install --locked gptcommit</code>安装或到<a href="https://github.com/zurawiki/gptcommit" target="_blank" rel="noopener">github 仓库</a>中去查看更多信息。<br>当然，你需要先在OpenAI里注册一个账号，同时拥有一个API key才能正在使用起来。</p>
<p>Github地址： <a href="https://github.com/zurawiki/gptcommit" target="_blank" rel="noopener">https://github.com/zurawiki/gptcommit</a></p>
<h1 id="下一步计划"><a href="#下一步计划" class="headerlink" title="下一步计划"></a>下一步计划</h1><p>后面也打算做一下更加有趣的功能：</p>
<ul>
<li>如何利用GPT-3去实现更加自动化 git flow工作流？</li>
<li>如何跳过哪些大的总结?</li>
<li>如何收集用户反馈，将commit信息更加有效？</li>
</ul>
<p>最后，如果在使用过程有任何问题或者建议，请到Github开源地址写一个issue给我，我会很快处理。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>原文地址：<a href="https://zura.wiki/post/never-write-a-commit-message-again-with-the-help-of-gpt-3/" target="_blank" rel="noopener">Never write a commit message again (with the help of GPT-3)</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>翻译文章</tag>
      </tags>
  </entry>
  <entry>
    <title>Next、Nuxt、Nest的区别(翻译)</title>
    <url>/translate/nuxt-next-nest-diff.html</url>
    <content><![CDATA[<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>翻译文章</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux如何快速删除大量文件</title>
    <url>/today/20230213.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近服务器经常遇到磁盘占用空间满的告警，因此跟进定位问题后，发现原来是airflow的有好几个任务每分钟都在产生日志文件，导致磁盘空间占用率暴涨，因此想了几个策略：</p>
<ul>
<li>airflow降低日志文件输出大小，将原来<code>info</code>级别日志跳高到<code>warning</code></li>
<li>定时清理日志文件</li>
</ul>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>问题就出现在清理日志文件，打算先清除一遍，主要清除一个月以前的日志文件，命令为<code>find /data/airflow/ -name &#39;*.log&#39; -and -mtime +30 -type f |xargs rm</code>。</p>
<p>但是等了半天发现日志文件一直无法清除掉，不知道为什么？</p>
<a id="more"></a>

<p>后面直接上机器删除文件，采用<code>rm -rf ./*.log</code>，发现报错如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin/rm: argument list too long</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因：  删除文件中包含的小文件数量过多，通常是由于受到 shell 参数个数限制所致</p>
</blockquote>
<p>虽然网上有其他方案可以快速解决，比如：<code>find</code>减少文件数量。</p>
<p>这下子就搞的很郁闷了，后面上网找了方案，发现可以通过<code>rsync</code>去快速删除大量文件，因此想记录总结一下。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="Linux文件存储原理"><a href="#Linux文件存储原理" class="headerlink" title="Linux文件存储原理"></a>Linux文件存储原理</h2><p>我们需要对Linux文件存储原理做一个基本的了解，Linux文件存储数据是放在一张<code>inode 表</code>，里面每一个文件的节点，每个节点包括以下内容：</p>
<ul>
<li>文件类型</li>
<li>权限</li>
<li>UID，GID</li>
<li><code>i_nlink</code> 链接数（指向这个文件名路径名称个数）</li>
<li><code>i_count</code> 使用数（指使用这个文件的进程数）</li>
<li>该文件的大小和不同的时间戳</li>
<li>指向磁盘上文件的数据块指针</li>
<li>有关文件的其他数据</li>
</ul>
<p>Linux文件真正删除的过程：</p>
<ul>
<li><code>i_nlink=0</code> 没有人进行链接使用，包括任何硬链接</li>
<li><code>i_count=0</code> 没有任何进程使用</li>
</ul>
<h2 id="rm原理"><a href="#rm原理" class="headerlink" title="rm原理"></a>rm原理</h2><p>rm的原理：减少磁盘引用计数<code>i_nlink</code>，就是减少其他文件对这个文件链接，实际并没有删除文件内容。</p>
<p>因此，如果日志文件正在其他进程使用，<code>rm</code>并不是真正删除，<code>i_count</code>并不会减少，因此也不会释放磁盘空间。</p>
<p>如果想要真正删除一个文件，还需要同时将<code>i_count</code>降至0。</p>
<p>了解完rm的原理，也就真正明白为什么<code>find /opt/airflow/logs -name &#39;*.*&#39; -and -mtime +30 -type f | xargs rm -rvf</code>命令会这么慢，因为它要去找日志文件的所有link链接，然后一一删除掉。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>最终在网上找了最佳解决方案，就是使用<code>rsync</code>。</p>
<p><code>rsync</code>本身的就是将两个文件夹作同步使用，如何使用<code>rsync</code>删除文件，步骤是这样子:</p>
<ul>
<li>如果将一个空文件夹，同步到要删除的文件夹里，是不是等于将文件夹清空了呢？</li>
</ul>
<p>很取巧的方式，但是也很有效果，具体命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>制造一个空文件夹</span><br><span class="line">mkdir -p /opt/airflow/empty;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>执行rsync同步空文件夹</span><br><span class="line">rsync --delete-before -aO  /opt/airflow/empty/ /opt/airflow/logs/;</span><br></pre></td></tr></table></figure>

<p>命令详解：</p>
<ul>
<li><code>--delete-before</code> 接收者在传输之前进行删除操作</li>
<li><code>-a</code> 归档模式，表示以递归方式传输文件，并保持所有文件属性</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://cloud.tencent.com/developer/article/1647290" target="_blank" rel="noopener">Linux 下删除大量文件效率对比，看谁删的快！</a></li>
<li><a href="https://www.cnblogs.com/cherishry/p/5886069.html" target="_blank" rel="noopener">Linux下文件删除的原理</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>低代码系列——组件描述DSL</title>
    <url>/lowcode/component.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前写了一篇<a href="/lowcode/sandbox.html">《低代码系列——js沙箱设计》</a>，于是萌生了干脆将完整的低代码平台设计的整个过程都整理一遍，然后输出文章，同时准备搞个人开源项目用来实现低代码平台。</p>
<p>低代码平台核心部分是编辑器，编辑器里最重要一块如何将组件抽象化，存储到一个可描述的对象中。</p>
<p>下面我们就针对这种组件抽象描述做一次深入的设计。</p>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://json-schema.apifox.cn/" target="_blank" rel="noopener">JSON Schema 规范</a><br><a href="https://jsoncrack.com/" target="_blank" rel="noopener">JSON 可视化</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>低代码</tag>
      </tags>
  </entry>
  <entry>
    <title>低代码系列——插件系统设计</title>
    <url>/lowcode/plugin.html</url>
    <content><![CDATA[<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>低代码</tag>
      </tags>
  </entry>
  <entry>
    <title>性能优化我们到底能做些什么东西</title>
    <url>/today/20230304.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://mp.weixin.qq.com/s/ZfIWKRbF3Yq7sNFG2TsQFw" target="_blank" rel="noopener">性能优化经验分享</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>如何实现HTTP2.0</title>
    <url>/today/20230319.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://lowin.li/2022/06/27/pan-dian-kai-yuan-copilot/" target="_blank" rel="noopener">盘点开源“Copilot”，do it yourself</a><br><a href="https://blog.csdn.net/gel1234/article/details/127050405" target="_blank" rel="noopener">如何搭建免费的GitHub Copilot？</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>前端安全-JS原型链污染是怎么回事</title>
    <url>/today/20230209.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>面试题经常会提到一个问题，就是前端安全问题哪些，我们基本上都回答上来以下几个：</p>
<ul>
<li>XSS脚本攻击，利用网站漏洞，注入非法脚本</li>
<li>CSRF跨站请求伪造，攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求</li>
<li>运营商劫持，一般是经过某些运营商DNS网关后，在外层套入iframe，然后实现页面劫持</li>
</ul>
<p>但是在前端安全中，还有一个问题就是 ：<code>JS原型链污染</code>， 那么是原型链污染怎么回事，请看下面详细介绍。</p>
<blockquote>
<p>这里插入一条新闻，新出一个很邪恶的js库叫<a href="https://github.com/wll8/lodash-utils" target="_blank" rel="noopener">Evil.js</a>，名字还取得很lodash，其中主要就是利用原型prototype进行重写项目中常用的方法，如：</p>
<ul>
<li>Array.map 有5%概率会丢失最后一个元素，</li>
<li>当数组长度可以被7整除时，Array.includes 永远返回false。</li>
</ul>
</blockquote>
<p>所以学会如何防御项目内被攻击，了解更多JS原型安全知识很重要，起码周末不用调试半天问题，才发现项目中代码被恶意写入。</p>
<a id="more"></a>

<p>在看这篇文章，请确保自己对JS原型和原型链有一定了解，如果忘记或缺乏了解的话，可以看我之前的文案<a href="today/20220129.html#原型">从null、undefined、NaN的区别了解JS的原型链</a>再次复习和学习一下。</p>
<h1 id="原型链污染"><a href="#原型链污染" class="headerlink" title="原型链污染"></a>原型链污染</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>下面通过一段代码，我们能够快速了解原型链是如何污染的？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">    bar: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果这里将foo.__proto__改掉</span></span><br><span class="line"></span><br><span class="line">foo.__proto__.bar = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.bar); <span class="comment">// 这里正常输出 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新声明一个</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> zoo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(zoo.bar); <span class="comment">// 这里错误输出 2</span></span><br></pre></td></tr></table></figure>

<p>从上述代码可以概括一下，原型链攻击是：</p>
<blockquote>
<p>在一个应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是原型链污染。</p>
</blockquote>
<h2 id="攻击场景"><a href="#攻击场景" class="headerlink" title="攻击场景"></a>攻击场景</h2><p>其实我们主要看哪些场景会允许代码设置<code>__proto__</code>？主要有以下两种：</p>
<ul>
<li>对象merge</li>
<li>对象clone</li>
<li>Node.js的construtor</li>
</ul>
<h3 id="merge-demo案例"><a href="#merge-demo案例" class="headerlink" title="merge demo案例"></a>merge demo案例</h3><p>一般实现对象的merge代码实现如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key <span class="keyword">in</span> source &amp;&amp; key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            merge(target[key], source[key])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target[key] = source[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行代码</span></span><br><span class="line"><span class="keyword">let</span> o1 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> o2 = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="string">"__proto__"</span>: &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;&#125;</span><br><span class="line">merge(o1, o2)</span><br><span class="line"><span class="built_in">console</span>.log(o1.a, o1.b)</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(o3.b) <span class="comment">// 发现原型链没有被污染</span></span><br></pre></td></tr></table></figure>

<p>这是为什么呢？因为声明变量的时候，”<strong>_proto</strong>“并不是一个key，即使修改也不会改变Object的原型。</p>
<p>那么如何做到”<strong>_proto</strong>“成为一个key，可以将demo代码调整一下，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> o2 = <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"a": 1, "__proto__": &#123;"b": 2&#125;&#125;'</span>)</span><br><span class="line">merge(o1, o2)</span><br><span class="line"><span class="built_in">console</span>.log(o1.a, o1.b)</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(o3.b) <span class="comment">// 输出2</span></span><br></pre></td></tr></table></figure>

<p>merge操作是最常见可能控制键名的操作，也最能被原型链攻击，很多常见的库都存在这个问题。如： <code>lodash.merge</code>。</p>
<h2 id="实际应用问题"><a href="#实际应用问题" class="headerlink" title="实际应用问题"></a>实际应用问题</h2><blockquote>
<p>Code-Breaking 2018 Thejs 分析</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> lodash = <span class="built_in">require</span>(<span class="string">'lodash'</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">app.engine(<span class="string">'ejs'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">filePath, options, callback</span>) </span>&#123; </span><br><span class="line"><span class="comment">// define the template engine</span></span><br><span class="line">    fs.readFile(filePath, (err, content) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(err))</span><br><span class="line">        <span class="keyword">let</span> compiled = lodash.template(content)</span><br><span class="line">        <span class="keyword">let</span> rendered = compiled(&#123;...options&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> callback(<span class="literal">null</span>, rendered)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">app.all(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> data = req.session.data || &#123;<span class="attr">language</span>: [], <span class="attr">category</span>: []&#125;</span><br><span class="line">    <span class="keyword">if</span> (req.method == <span class="string">'POST'</span>) &#123;</span><br><span class="line">        data = lodash.merge(data, req.body)</span><br><span class="line">        req.session.data = data</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res.render(<span class="string">'index'</span>, &#123;</span><br><span class="line">        language: data.language, </span><br><span class="line">        category: data.category</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>题目是利用<code>lodash.template</code> + <code>lodash.merge</code>两个方法实现部分功能：</p>
<ul>
<li>用户提交的信息，用merge方法合并到session里，session里最终保存你提交的所有信息</li>
<li>然后利用merge方法注入原型污染</li>
<li>最后利用template中的方法，完成整个网站污染</li>
</ul>
<p>整个案例其实比较重要的一点就是，提交参数的时候序列化提交参数是否有做防御，如何没有的话那么很容易就中招了。</p>
<h2 id="如何防御"><a href="#如何防御" class="headerlink" title="如何防御"></a>如何防御</h2><p>分不同情况做防御：</p>
<h3 id="引入npm包导致的"><a href="#引入npm包导致的" class="headerlink" title="引入npm包导致的"></a>引入npm包导致的</h3><ul>
<li>项目代码扫描，主要是针对构建好的代码进行扫描，是否<code>Evil.js</code>修改内置原型的情况进行告警提示</li>
<li>禁止修改原型，如：使用<code>Object.freeze</code></li>
</ul>
<h3 id="针对node-js"><a href="#针对node-js" class="headerlink" title="针对node.js"></a>针对node.js</h3><ul>
<li>针对node服务端接口参数进行序列化的时候，禁止非法<code>key</code>值传入</li>
<li>禁止修改原型，如：使用<code>Object.freeze</code></li>
<li>采用<code>Object.create(null)</code>创建对象，避免直接使用<code>{}</code></li>
<li>使用<code>map</code>数据类型创建</li>
<li>不对参数做<code>JSON.parse</code>转换，采用封装后的反序列化方法</li>
<li>尽量采用安全的<code>merge</code>或<code>clone</code>库方法</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html" target="_blank" rel="noopener">深入理解 JavaScript Prototype 污染攻击</a></li>
<li><a href="https://xz.aliyun.com/t/7025" target="_blank" rel="noopener">再探 JavaScript 原型链污染到 RCE</a></li>
<li><a href="https://www.freebuf.com/articles/web/216373.html" target="_blank" rel="noopener">Javascript原型链攻击与防御</a></li>
</ul>
]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>css变量了解到项目落地</title>
    <url>/today/20230208.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在打开一些网站的，查看其CSS样式的时候，发现如下图：</p>
<p><img src="/assets/img/20230208-1.png" alt></p>
<p>所以就很好奇，原来现在CSS样式变量已经可以正式投入生产使用了，所以希望能够做个简单了解。</p>
<p>浏览器的兼容性：<br><img src="/assets/img/20230208-2.png" alt></p>
<a id="more"></a>

<h1 id="CSS变量var"><a href="#CSS变量var" class="headerlink" title="CSS变量var()"></a>CSS变量var()</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><blockquote>
<p>自定义属性（有时候也被称作CSS 变量或者级联变量）是由 CSS 作者定义的，它包含的值可以在整个文档中重复使用。由自定义属性标记设定值（比如： –main-color: black;），由 var() 函数来获取值（比如： color: var(–main-color);）</p>
</blockquote>
<p>通俗的说，就是CSS以后不需要用<code>less</code>或<code>css</code>也能正常使用变量去定义一些常用值。</p>
<h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><ol>
<li><p>声明以及对应作用域</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 可以HTML 文档的任何地方访问到它 */</span></span><br><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attribute">--main-bg-color</span>: brown;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">:where(html)</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 只能在element元素下面所对应使用 */</span></span><br><span class="line"><span class="selector-tag">element</span> &#123;</span><br><span class="line">  <span class="attribute">--main-bg-color</span>: brown;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>引用变量</p>
</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">element</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">var</span>(--main-bg-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>自带继承</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.one</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="comment">/** 无法使用 var(--test) */</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.two</span> &#123;</span></span><br><span class="line">  --test: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-class">.three</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="comment">/** 重写 var(--test) = 2em */</span></span></span><br><span class="line">  --test: 2em;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="css"><span class="selector-class">.four</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="comment">/** 继承.two的变量 var(--test) = 10px */</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"one"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"two"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"three"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"four"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>自定义属性备用值</li>
</ol>
<p><code>var(--my-var, xxx)</code>，当一个变量未定义或非法值的时候，可以<code>red</code>用来做正常显示值，备用值并不是用于实现浏览器兼容性的。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.two</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--my-var, red); <span class="comment">/* 入股my-var 没有定义，则用red显示 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>JS获取变量值</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/设置变量</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'p'</span>).style.setProperty(<span class="string">'--weight'</span>,<span class="string">'bold'</span>);</span><br><span class="line"><span class="comment">//读取变量</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'p'</span>).style.getPropertyValue(<span class="string">'--weight'</span>);</span><br><span class="line"><span class="comment">//删除变量</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'p'</span>).style.removeProperty(<span class="string">'--weight'</span>);</span><br></pre></td></tr></table></figure>

<h1 id="CSS变量实战"><a href="#CSS变量实战" class="headerlink" title="CSS变量实战"></a>CSS变量实战</h1><p>在前端项目中如何使用CSS变量，一般是通过构建工具生成的兼容性代码。</p>
<h2 id="浏览器是否支持"><a href="#浏览器是否支持" class="headerlink" title="浏览器是否支持"></a>浏览器是否支持</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isSupported = <span class="built_in">window</span>.CSS &amp;&amp; <span class="built_in">window</span>.CSS.supports &amp;&amp; <span class="built_in">window</span>.CSS.supports(<span class="string">'--a'</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(isSupported) &#123;</span><br><span class="line">    <span class="comment">/* 这里面是支持css变量的操作 */</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 这里面是不支持css变量的操作 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以通过CSS中<code>@supports</code>做判断：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">supports</span> ( (--a: <span class="number">0</span>)) &#123;</span><br><span class="line">  <span class="comment">/* supported */</span></span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">supports</span> ( not (--a: <span class="number">0</span>)) &#123;</span><br><span class="line">  <span class="comment">/* not supported */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>最常用的是网站换主题，在开发过程直接按照CSS变量去编写，而不需要去了解SASS或LESS的语法</li>
<li>原本一些动画效果，需要多个css样式区分，现在可以通过css变量实现，从而减少代码</li>
<li>结合JS操作事件+更改CSS变量，实现更多CSS效果</li>
</ul>
<h2 id="变量库"><a href="#变量库" class="headerlink" title="变量库"></a>变量库</h2><p><a href="https://open-props.style/" target="_blank" rel="noopener">open-props CSS常用变量收集库</a></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">"https://unpkg.com/open-props"</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="built_in">var</span>(--radius-2);</span><br><span class="line">  <span class="attribute">padding</span>: <span class="built_in">var</span>(--size-fluid-3);</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="built_in">var</span>(--shadow-2);</span><br><span class="line"></span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    <span class="selector-tag">box-shadow</span>: <span class="selector-tag">var</span>(<span class="selector-tag">--shadow-3</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @<span class="keyword">media</span> (--motionOK) &#123;</span><br><span class="line">    <span class="selector-tag">animation</span>: <span class="selector-tag">var</span>(<span class="selector-tag">--animation-fade-in</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_custom_properties" target="_blank" rel="noopener">CSS自定义变量 MDN</a></p>
]]></content>
      <tags>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>低代码系列——js沙箱设计</title>
    <url>/lowcode/sandbox.html</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>由于自己参与过低代码平台开发，所以希望能把我自己开发低代码中遇到的问题或者一些设计思路进行总结汇总，这是开始写的第一篇，也是比较基础的一篇，关于低代码平台的介绍会放在介绍篇章，这篇就不做过多介绍。</p>
<p>这里为什么会一开始介绍js沙箱设计呢？</p>
<p>因为低代码平台，会运行用户本身自己编写的业务逻辑代码，这里就需要平台去运行用户写的js代码，但是js代码保存到数据库是一个字符串，那么平台应该怎么运行呢？</p>
<p>答案是js沙箱，那么如何设计一个沙箱呢？按照低代码平台的需要特性，主要以下几方面：</p>
<ul>
<li>隔离，隔离是为了保证当前执行代码不影响整个平台的代码</li>
<li>插入，沙箱允许插入平台的内置对象</li>
<li>容错，沙箱内代码即使有错误，也不影响整个平台执行</li>
</ul>
<a id="more"></a>
<h1 id="沙箱"><a href="#沙箱" class="headerlink" title="沙箱"></a>沙箱</h1><p>在设计沙箱之前，我们先对沙箱有个了解：</p>
<blockquote>
<p>在计算机安全中，沙箱（Sandbox）是一种用于隔离正在运行程序的安全机制，通常用于执行未经测试或不受信任的程序或代码，它会为待执行的程序创建一个独立的执行环境，内部程序的执行不会影响到外部程序的运行。</p>
</blockquote>
<p>通俗的讲，就是由我们主程序自己设定一个区域，用来执行代码，且这段代码如何执行都不会影响到外部的主程序。</p>
<p>举几个我们开发中经常会用的沙箱：</p>
<ul>
<li>Vue template里的表达式，如: <code>&lt;div&gt;2&lt;/div&gt;</code>，执行<code>1+1</code>就是Vue设计的一个沙箱机制</li>
<li>开发Chrome插件，插件里的代码有很多限制条件，循序Chrome插件规则，那么插件的运行环境和规则也是一个沙箱</li>
<li>在线代码编辑器， CodeSanbox在执行脚本也会单独成立一个沙箱去隔离执行代码，防止代码访问或影响主页面</li>
<li>微前端<code>qiangun</code>或<code>single-spa</code>框架里主应用和子应用之间的完全隔离，也是一种沙箱机制，如: 应用之间CSS样式不能互相影响</li>
</ul>
<p>在了解完沙箱是什么后，那么在JavaScript语言里如何实现沙箱呢？主要有以下几种方式：</p>
<ul>
<li>使用 with 声明</li>
<li>使用 new Function 声明</li>
<li>基于 Proxy实现</li>
<li>基于属性 diff实现</li>
<li>基于 iframe实现</li>
<li>基于 ES 提案 ShadowRealm API</li>
</ul>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="with关键字"><a href="#with关键字" class="headerlink" title="with关键字"></a>with关键字</h2><blockquote>
<p>with 扩展一个语句的作用域链。 —— <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/with" target="_blank" rel="noopener">MDN with</a><br>JavaScript 查找某个未使用命名空间的变量时，会通过作用域链来查找，作用域链是跟执行代码的 context 或者包含这个变量的函数有关。’with’语句将某个对象添加到作用域链的顶部，如果在 statement 中有某个未使用命名空间的变量，跟作用域链中的某个属性同名，则这个变量将指向这个属性值。如果沒有同名的属性，则将拋出ReferenceError异常。</p>
</blockquote>
<p>按照个人比较容易理解的意思，就是给一段代码加上指定对象为该作用的全局变量。示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="number">1.1</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用with</span></span><br><span class="line"><span class="keyword">with</span>(<span class="built_in">Math</span>)&#123;</span><br><span class="line">    floor(<span class="number">1.1</span>) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="new-Function"><a href="#new-Function" class="headerlink" title="new Function"></a>new Function</h2><p><code>new Function(argStr, codeStr)</code>是能将字符串代码转换为可执行的函数。具体示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'test'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'arg'</span>, <span class="string">'console.log(arg)'</span>);</span><br><span class="line"><span class="comment">// 这里等于 test = (arg)=&gt; &#123;console.log(arg)&#125;;</span></span><br><span class="line"></span><br><span class="line">test(name); <span class="comment">// test</span></span><br></pre></td></tr></table></figure>

<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><blockquote>
<p>Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">Proxy MDN</a></p>
</blockquote>
<p>Proxy只能代理<code>object</code>类型的变量，针对基础类型的代理只能将其封装到对象里再进行代理监听。</p>
<p>Proxy代理方法如下：</p>
<ul>
<li><code>getPrototypeOf(target)</code> 代理获取原型的方法</li>
<li><code>setPrototypeOf(target, newProto)</code> 设置原型，如果不想设置原型，可以<code>return false</code></li>
<li><code>isExtensible(target)</code>  拦截对对象的 <code>Object.isExtensible()</code>，必须返回一个 Boolean 值，判断一个对象是否是可扩展的</li>
<li><code>preventExtensions(target)</code> 拦截<code>Object.preventExtensions()</code>，让一个对象变的不可扩展，也就是永远不能再添加新的属性</li>
<li><code>getOwnPropertyDescriptor(target, prop)</code> 拦截<code>Object.getOwnPropertyDescriptor()</code>，拦截获取对象属性的描述符</li>
<li><code>defineProperty(target, property, descriptor)</code> 拦截<code>Object.defineProperty()</code></li>
<li><code>has(target, key)</code>，针对 in 操作符的代理方法</li>
<li><code>get(target, property, receiver)</code>，用于拦截对象的读取属性操作</li>
<li><code>set()</code>，设置属性值操作的捕获器。</li>
<li><code>construct()</code>，用于拦截 new 操作符</li>
</ul>
<p>与<code>Object.defineProperty</code>主要区别(可拦截方法比<code>Object.defineProperty</code>多)：</p>
<ul>
<li>Proxy代理的是整个对象，Object.defineProperty只代理对象上的某个属性,如果是多层嵌套的数据需要循环递归绑定;</li>
<li>对象上定义新属性时，Proxy可以监听到，Object.defineProperty监听不到，需要借助$set方法;</li>
<li>数组的某些方法(push、unshift和splice)Object.defineProperty监听不到，Proxy可以监听到;</li>
</ul>
<h2 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a>Symbol.unscopables</h2><blockquote>
<p>指用于指定对象值，其对象自身和继承的从关联对象的 with 环境绑定中排除的属性名称。</p>
</blockquote>
<p>可以这么理解，就是为了防止<code>with</code>添加作用域的时候，将某个属性从作用域中排除掉，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = &#123;</span><br><span class="line">    p: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 禁止将a.p放到with作用域中</span></span><br><span class="line">a[<span class="built_in">Symbol</span>.unscopables] = &#123;<span class="attr">p</span>: <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span>(a)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p) <span class="comment">// 报错 p not defined</span></span><br><span class="line">    <span class="built_in">console</span>.log(b) <span class="comment">// 正常输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此很多内置对象都设置该值为true，从而降低with的侵入，具体如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.unscopables];</span><br><span class="line"><span class="comment">/*&#123;</span></span><br><span class="line"><span class="comment">  copyWithin: true,</span></span><br><span class="line"><span class="comment">  entries: true,</span></span><br><span class="line"><span class="comment">  fill: true,</span></span><br><span class="line"><span class="comment">  find: true,</span></span><br><span class="line"><span class="comment">  findIndex: true,</span></span><br><span class="line"><span class="comment">  flat: true,</span></span><br><span class="line"><span class="comment">  flatMap: true,</span></span><br><span class="line"><span class="comment">  includes: true,</span></span><br><span class="line"><span class="comment">  keys: true,</span></span><br><span class="line"><span class="comment">  values: true,</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure>

<h1 id="沙箱实现"><a href="#沙箱实现" class="headerlink" title="沙箱实现"></a>沙箱实现</h1><p>沙箱实现步骤一般如下：</p>
<ul>
<li>解析代码，动态执行</li>
<li>修改代码的作用域，避免进行向上全局查询</li>
<li>创建全局对象的替代对象，避免污染全局对象</li>
<li>执行代码</li>
</ul>
<h2 id="基于Proxy实现"><a href="#基于Proxy实现" class="headerlink" title="基于Proxy实现"></a>基于Proxy实现</h2><p>前面基础知识将到Proxy是一个可以代理对象的方法，那么其实可以按照将一些全局对象做代理后放入到沙箱里。主要有两个步骤：</p>
<ul>
<li>使用<code>new Function</code>将代码字符串转为可执行函数</li>
<li>加<code>with</code>生成局部作用域</li>
<li>使用<code>createFake</code>方法生成替代对象<code>fakeWindow</code></li>
<li>使用<code>Proxy</code>代理拦截<code>set</code> <code>get</code>操作，更新到<code>fakeWindow</code>中</li>
<li>当沙箱不用时，将<code>window</code>重置回</li>
</ul>
<p>简易沙箱示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; complieCode2Fn, createFakeWindow &#125; = <span class="built_in">require</span>(<span class="string">'./complieCode.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxySandbox</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(global) &#123;</span><br><span class="line">        <span class="keyword">const</span> rawGlobal = global;</span><br><span class="line">        <span class="keyword">const</span> fakeWindow = createFakeWindow(global);</span><br><span class="line">        <span class="keyword">this</span>.proxyBox = <span class="keyword">new</span> <span class="built_in">Proxy</span>(fakeWindow, &#123;</span><br><span class="line">            <span class="comment">// 拦截所有属性，防止到 Proxy 对象以外的作用域链查找。</span></span><br><span class="line">            has(target, key) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">get</span>(target, key, receiver) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'get'</span>, key, target[key])</span><br><span class="line">                <span class="comment">// 加固，防止逃逸</span></span><br><span class="line">                <span class="keyword">if</span> (key === <span class="built_in">Symbol</span>.unscopables) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 通过Reflect获取</span></span><br><span class="line">                <span class="keyword">let</span> temp = <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">                <span class="keyword">if</span>(!target.hasOwnProperty(key))&#123;</span><br><span class="line">                    temp = rawGlobal[key];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">set</span>(target, key, newValue) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!target.hasOwnProperty(key) &amp;&amp; fakeWindow.hasOwnProperty(key)) &#123;</span><br><span class="line">                    <span class="keyword">const</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(sandbox, key);</span><br><span class="line">                    <span class="keyword">const</span> &#123; writable, configurable, enumerable &#125; = descriptor;</span><br><span class="line">                    <span class="keyword">if</span> (writable) &#123;</span><br><span class="line">                        <span class="comment">// 中独有的属性如果可以写，同样需要复制到fakeWindow中</span></span><br><span class="line">                        <span class="built_in">Object</span>.defineProperty(target, p, &#123;</span><br><span class="line">                            configurable,</span><br><span class="line">                            enumerable,</span><br><span class="line">                            writable,</span><br><span class="line">                            newValue,</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    target[key] = newValue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    excute(code)&#123;</span><br><span class="line">        <span class="keyword">const</span> fn = complieCode2Fn(code);</span><br><span class="line">        <span class="keyword">return</span> fn(<span class="keyword">this</span>.proxyBox);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fakeBox = <span class="keyword">new</span> ProxySandbox(global);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`a = 1;console.log('a:', a);return a;`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fakeBox.excute(code));  <span class="comment">// 输出a:1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'在沙箱外获取沙箱内设置的全局值a:'</span>, a); <span class="comment">// a is not defined</span></span><br></pre></td></tr></table></figure>

<p>问题1： 如何防止<code>Array.isArray</code>重写后不影响顶部window？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">const code = `</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Array</span>.isArray = <span class="function"><span class="params">()</span>=&gt;</span> <span class="literal">true</span>;</span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="string">console.log(Array.isArray('a')); // 输出true 正常应该是false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>生成<code>fakeWindow</code>对象时候，遍历内置<code>Array</code>，通过<code>Object.freeze</code>冻结其修改的可能性</li>
</ul>
<p>问题2： 提前关闭 sandbox 的 with 语境，如 ‘} alert(this); {‘  或者使用 eval 和 new Function 直接逃逸，如何解决？</p>
<ul>
<li>解析code字符串，利用堆栈深度检测算法，将非法字符串 <code>{}</code>做简单计算 或者 <code>eval</code> 等关键字，然后报错处理</li>
</ul>
<p>问题3： 如何解决修改原型链方法实现逃逸，既可以获取沙箱外的对象？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> code = <span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    (&#123;&#125;).constructor.prototype.toString = () =&gt; &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        console.log('Escape')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="built_in">console</span>.log((&#123;&#125;).toString()) <span class="comment">// 输出Escape 正常应该输出[object Object]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这种只能在原型链上下功夫，将所有的原型链做一次封装，从而</li>
</ul>
<h2 id="基于iframe实现"><a href="#基于iframe实现" class="headerlink" title="基于iframe实现"></a>基于iframe实现</h2><p>利用<code>iframe</code>天然隔离机制，加上<code>postMessage</code>通讯机制，可以快速实现一个简易沙箱，具体步骤如下：</p>
<ul>
<li>创建一个iframe，获取其window作为替代对象</li>
<li>将function执行放到iframe里，不会影响其沙箱外程序使用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IframeSandbox</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// 创建一个 iframe 对象，取出其中的原生浏览器全局对象作为沙箱的全局对象</span></span><br><span class="line">        <span class="keyword">const</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>, &#123;<span class="attr">url</span>: <span class="string">'about:blank'</span>&#125;)</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(iframe)</span><br><span class="line">        <span class="keyword">this</span>.sandboxGlobal = iframe.contentWindow <span class="comment">// 沙箱运行时的全局对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    excute(code)&#123;</span><br><span class="line">        <span class="keyword">const</span> fn = <span class="keyword">new</span> <span class="keyword">this</span>.sandboxGlobal.Function(<span class="string">'sandbox'</span>, <span class="string">`with(sandbox)&#123;<span class="subst">$&#123;code&#125;</span>&#125;`</span>)</span><br><span class="line">        <span class="keyword">return</span> fn(<span class="keyword">this</span>.sandboxGlobal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fakeBox = <span class="keyword">new</span> IframeSandbox();</span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`a = 1;console.log(a)`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fakeBox.excute(code));  <span class="comment">// 输出a:1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'在沙箱外获取沙箱内设置的全局值a:'</span>, a); <span class="comment">// a is not defined</span></span><br></pre></td></tr></table></figure>

<p>问题1： 需要解决其调用<code>parent</code>进行逃逸获取？</p>
<ul>
<li>最佳方案是通过<code>Proxy</code>对iframe的window对象进行拦截代理即可</li>
</ul>
<h2 id="基于ShadowRealm-提案的实现"><a href="#基于ShadowRealm-提案的实现" class="headerlink" title="基于ShadowRealm 提案的实现"></a>基于ShadowRealm 提案的实现</h2><blockquote>
<p>ShadowRealm API 是一个新的 JavaScript 提案，它允许一个 JS 运行时创建多个高度隔离的 JS 运行环境（realm），每个 realm 具有独立的全局对象和内建对象。</p>
</blockquote>
<p>通俗的说，这是JavaScript自带的沙箱API，你可以利用它快速实现上面需要通过proxy或iframe才能实现的隔离机制。</p>
<p>ShadowRealm声明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">declare <span class="class"><span class="keyword">class</span> <span class="title">ShadowRealm</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>();</span><br><span class="line">  evaluate(sourceText: string): PrimitiveValueOrCallable;</span><br><span class="line">  importValue(specifier: string, bindingName: string): Promise&lt;PrimitiveValueOrCallable&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>evaluate(sourceText: string)</code> 同步执行代码字符串，类似 eval()</li>
<li><code>importValue(specifier: string, bindingName: string)</code> 异步执行代码字符串</li>
</ul>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sr = <span class="keyword">new</span> ShadowRealm();</span><br><span class="line">globalThis.test = <span class="string">'test'</span>;</span><br><span class="line">sr.evaluate(<span class="string">`globalThis.test = 'test ShadowRealm'; console.log(globalThis.test)`</span>) <span class="comment">// 输出 test ShadowRealm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个文件  my-module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> values.reduce(<span class="function">(<span class="params">prev, value</span>) =&gt;</span> prev + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">const</span> sr = <span class="keyword">new</span> ShadowRealm();</span><br><span class="line"><span class="keyword">const</span> wrappedSum = <span class="keyword">await</span> sr.importValue(<span class="string">'./my-module.js'</span>, <span class="string">'sum'</span>); <span class="comment">// 加载js模块，然后获取里面函数</span></span><br><span class="line"><span class="built_in">console</span>.log(wrappedSum(<span class="string">'hi'</span>, <span class="string">' '</span>, <span class="string">'folks'</span>, <span class="string">'!'</span>)); <span class="comment">// 输出 hi folks !</span></span><br></pre></td></tr></table></figure>

<p>其实再来实现一个沙箱就很简单了，因为ShadownRealm本身就是一个沙箱。</p>
<h2 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h2><h3 id="Web-Workers"><a href="#Web-Workers" class="headerlink" title="Web Workers"></a>Web Workers</h3><p><code>Web Workers</code>代码运行在独立的进程中，通信是异步的，无法获取当前程序一些属性或共享状态，且有一点无法不支持 DOM 操作，必须通过 postMessage 通知 UI 主线程来实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workerSandbox</span>(<span class="params">appCode</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([appCode]);</span><br><span class="line"> <span class="keyword">var</span> appWorker = <span class="keyword">new</span> Worker(<span class="built_in">window</span>.URL.createObjectURL(blob));</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">workerSandbox(<span class="string">'const a = 1;console.log(a);'</span>) <span class="comment">// 输出1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// a not defined</span></span><br></pre></td></tr></table></figure>

<h3 id="vm-模块"><a href="#vm-模块" class="headerlink" title="vm 模块"></a>vm 模块</h3><p>Node.js 上的 vm 模块，与 ShadowRealm API 类似，但具有更多功能：缓存 JavaScript 引擎、拦截 import() 等等。但它唯一的缺点就是不能跨平台，只能在 Node.js 环境下使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="built_in">require</span>(<span class="string">'vm'</span>);</span><br><span class="line"><span class="keyword">const</span> sandbox = &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line">vm.createContext(sandbox)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> whatIsThis = vm.runInContext(<span class="string">`</span></span><br><span class="line"><span class="string">    a = 2 ;</span></span><br><span class="line"><span class="string">`</span>, sandbox);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sandbox) <span class="comment">// 输出2</span></span><br></pre></td></tr></table></figure>

<h1 id="沙箱错误捕获"><a href="#沙箱错误捕获" class="headerlink" title="沙箱错误捕获"></a>沙箱错误捕获</h1><p>在完成沙箱主体后，还需要对沙箱内部错误进行捕获再次处理，从而不影响主体程序的执行。</p>
<p>这一块其实就在执行动态代码那里，做一层<code>try/catch</code>基本上可以完成的错误捕获。</p>
<h1 id="沙箱逃逸"><a href="#沙箱逃逸" class="headerlink" title="沙箱逃逸"></a>沙箱逃逸</h1><p>沙箱逃逸（Sandbox Escape），沙箱于作者而言是一种安全策略，但于使用者而言可能是一种束缚。脑洞大开的开发者们尝试用各种方式摆脱这种束缚，也称之为沙箱逃逸。</p>
<p>沙箱逃逸的几种方式：</p>
<ul>
<li>访问沙箱执行上下文中某个对象内部属性时，如：通过window.parent</li>
<li>通过访问原型链实现逃逸</li>
</ul>
<p>如何解决沙箱逃逸：</p>
<blockquote>
<p>自定义解释器，分析源程序结构从而手动控制每一条语句的执行逻辑，如：<code>Babel</code>等</p>
</blockquote>
<p>简单的说，就是用JS去实现JS解释器，将每行代码进行解析，然后增加一些安全机制，从而避免非法代码入侵。</p>
<p>后续会专门写个文章去实现一个简单的JS解释器，这里就不做多阐述。更新后会放在这里链接。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">MDN Proxy</a></li>
<li><a href="https://github.com/careyke/frontend_knowledge_structure/blob/master/microFrontend/question02_03_js_sandbox.md" target="_blank" rel="noopener">qiankun中JS沙箱的实现</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1482264" target="_blank" rel="noopener">CodeSandbox 如何工作</a></li>
<li><a href="https://juejin.cn/post/7089822133559230501" target="_blank" rel="noopener">Javascript 新特性前瞻 —— ShadowRealms</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
        <tag>低代码</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo网站提高SEO优化方法</title>
    <url>/today/20230131.html</url>
    <content><![CDATA[<h1 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h1><ul>
<li>添加站点地图 <code>sitemap.xml</code>文件和搜索机器人文件<code>robots.txt</code></li>
<li>提交站点到搜索引擎(百度和谷歌)</li>
<li>hexo针对搜索的优化</li>
</ul>
<h2 id="添加站点地图"><a href="#添加站点地图" class="headerlink" title="添加站点地图"></a>添加站点地图</h2><h3 id="添加站点地图-sitemap-xml"><a href="#添加站点地图-sitemap-xml" class="headerlink" title="添加站点地图 sitemap.xml"></a>添加站点地图 <code>sitemap.xml</code></h3><ol>
<li><p>添加hexo插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改<code>_config.yml</code>配置</p>
</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sitemap:</span> </span><br><span class="line"><span class="attr">  path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">baidusitemap.xml</span></span><br></pre></td></tr></table></figure>

<h3 id="搜索机器人文件robots-txt"><a href="#搜索机器人文件robots-txt" class="headerlink" title="搜索机器人文件robots.txt"></a>搜索机器人文件<code>robots.txt</code></h3><p>在source目录下新建<code>robots.txt</code>文件，文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /archives/</span><br><span class="line">Allow: /categories/</span><br><span class="line">Allow: /tags/ </span><br><span class="line">Allow: /resources/ </span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /fancybox/</span><br><span class="line"></span><br><span class="line">Sitemap: https://hoxis.github.io/sitemap.xml</span><br><span class="line">Sitemap: https://hoxis.github.io/baidusitemap.xml</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="提交站点"><a href="#提交站点" class="headerlink" title="提交站点"></a>提交站点</h2><ul>
<li><a href="https://search.google.com/search-console?utm_source=about-page&resource_id=https://qborfy.com/" target="_blank" rel="noopener">谷歌Search Console</a>  直接按照引导添加即可<code>sitemap.xml</code>文件</li>
<li><a href="https://ziyuan.baidu.com/linksubmit/url" target="_blank" rel="noopener">百度站长平台</a>  按照其引导提交站点即可，主要是<code>sitemap.xml</code>文件</li>
</ul>
<h2 id="hexo优化建议"><a href="#hexo优化建议" class="headerlink" title="hexo优化建议"></a>hexo优化建议</h2><ul>
<li>出站链接添加<code>nofollow</code>标签</li>
<li>添加关键字，主要在文章首部地方添加<code>keywords</code>和<code>description</code></li>
<li>修改博文链接，将hexo默认<code>domain/year/month/day/postname</code>改为<code>title</code></li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://hoxis.github.io/Hexo+Next%20SEO%E4%BC%98%E5%8C%96.html" target="_blank" rel="noopener">Hexo博客Next主题SEO优化方法</a></p>
]]></content>
      <tags>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题目收集(持续更新)</title>
    <url>/study/face-test.html</url>
    <content><![CDATA[<p>主要以下几方面去收集？</p>
<ul>
<li>八股文，主要针对理论基础知识</li>
<li>框架类，主要针对React/Vue等</li>
<li>编程题，主要针对各种常用方法进行手动编写</li>
<li>算法题，主要是各类算法题进行汇总</li>
</ul>
<a id="more"></a>

<h1 id="八股文"><a href="#八股文" class="headerlink" title="八股文"></a>八股文</h1><ul>
<li>dom树是怎么生成的</li>
<li>浏览器缓存</li>
<li>一个页面在浏览器加载经历哪些阶段</li>
<li>TCP三次握手 四次挥手为什么？</li>
<li>为什么跨域？跨域实现方案</li>
<li>浏览器渲染机制、重绘、重排</li>
<li>script标签defer和async的区别</li>
</ul>
<h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><ul>
<li>v8垃圾回收</li>
<li>JS上下文执行栈和闭包</li>
<li>JS的模块化</li>
<li>JS的类型检查，如何判断Array数组类型</li>
<li>JS原型、原型链</li>
<li>JS Event Loop</li>
<li>JS new 实现一个对象过程</li>
<li>JS forEach和map的区别，如何跳出循环</li>
<li>JS 数组有哪些方法会影响自身，哪些方法不会影响自身</li>
</ul>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><ul>
<li>CSS 样式优先级(#,.等选择器)</li>
<li>CSS BFC</li>
<li>CSS 垂直居中</li>
<li>CSS 层叠上下文和层叠顺序</li>
<li>flex布局</li>
<li>CSS 响应式布局</li>
</ul>
<h1 id="框架类"><a href="#框架类" class="headerlink" title="框架类"></a>框架类</h1><h1 id="通用问题"><a href="#通用问题" class="headerlink" title="通用问题"></a>通用问题</h1><ul>
<li>如何看React和Vue</li>
<li>生命周期</li>
<li>路由实现机制</li>
<li>diff算法和key的作用</li>
<li>数据绑定原理</li>
<li>虚拟 DOM 实现原理</li>
<li>组件通信</li>
<li>Hook的实现原理</li>
<li>session与cookie的区别</li>
<li>性能优化完整方案</li>
<li>10个1m的文件 和 1个10m的文件 在浏览器哪个传输比较快</li>
</ul>
<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><ul>
<li>Fiber架构是什么</li>
<li>Hook函数的作用是什么</li>
<li>setState是异步还是同步，如果要获取更新后的state应该怎么做</li>
</ul>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><ul>
<li>Vue2和Vue3的区别</li>
<li>Vue3的组合式 API是什么？有什么好处？</li>
<li>Vue3中如何开发函数式组件？</li>
<li>nextTick 的原理是什么？</li>
<li>Vue通讯机制</li>
<li>computed与watch</li>
</ul>
<h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><ul>
<li>TypeScript是什么？有什么特性或者好处？</li>
<li>TypeScript 的缺点是什么？</li>
<li>Typescript 中的装饰器是什么？</li>
<li>TypeScript 如何设计 Class 的声明？</li>
<li>TypeScript 中 type 和 interface 的区别?</li>
<li>TypeScript 枚举是什么？</li>
<li>简单介绍一下 TypeScript 模块的加载机制？</li>
<li>TypeScript 的 tsconfig.json 中有哪些配置项信息？</li>
<li>如何初始化一个Typescript项目？</li>
</ul>
<h1 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h1><ul>
<li>目前市面上主流的构建工具有哪些？ webpack和 vite对比?</li>
</ul>
<h1 id="编码题"><a href="#编码题" class="headerlink" title="编码题"></a>编码题</h1><ul>
<li>深浅拷贝</li>
<li>Promise和Promise.all实现 </li>
<li>throttle节流 和 debounce防抖</li>
<li>如何通过原型实现继承</li>
</ul>
<h1 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h1><ul>
<li>排序题</li>
<li>去重题</li>
<li>反转题</li>
</ul>
<p>具体可以参考这些:</p>
<ul>
<li><a href="https://juejin.cn/post/6987320619394138148" target="_blank" rel="noopener">算法面试】leetcode最常见的150道前端面试题 — 简单题上</a></li>
</ul>
]]></content>
      <tags>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title>从null、undefined、NaN的区别了解JS的原型链</title>
    <url>/today/20230129.html</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>由于在面试经常会遇到问题null，undefined，NaN之间的区别，因此想要深入且系统了解一下这些代表空之间的区别，以及它们底层的原理——原型链，同时还要搞明白<code>__proto__</code>和<code>prototype</code>分别是什么。</p>
<p>为了更好系统的理解null，undefined，NaN之间的区别和关系，我们需要从Javascript语言设计底层去理解，为什么一个空值需要设计这么多个。为什么不能像Java，一个null就可以满足？</p>
<p>我们先简单认识三者：</p>
<ul>
<li><code>undefined</code> 表示原始值undefined。它是一个 JavaScript 的 原始数据类型 </li>
<li><code>null</code> 特指对象的值未设置。它是 JavaScript 基本类型 之一。</li>
<li><code>NaN</code> 是一个表示非数字的值</li>
</ul>
<p>接下来主要从以下两个点去认识null，undefined，NaN之间的区别和关系：</p>
<ul>
<li>数据类型 <code>typeof</code></li>
<li><code>===</code> 判断</li>
<li>原型 <code>prototype</code></li>
</ul>
<a id="more"></a>

<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>在Javascript中，<code>typeof</code>可以判断出当前变量的数据类型，主要以下几种数据类型：</p>
<ul>
<li><code>typeof undefined</code>，输出 <code>undefined</code></li>
<li><code>typeof NaN</code>，输出 <code>number</code></li>
<li><code>typeof null</code> 输出 <code>object</code></li>
</ul>
<p>从上面的结果可以得知 <code>undefined</code>在JavaScript中是一种数据类型，而<code>NaN</code>和<code>null</code>则是某种数据类型的值。</p>
<p>但是在JS在定义基础数据类型有以下集中种：</p>
<ul>
<li><code>number</code> 数字类型，包括数字 和 NaN</li>
<li><code>string</code> 字符串类型</li>
<li><code>boolean</code> 布尔类型 包括: true 和 false</li>
<li><code>undefined</code> undefined未定义类型</li>
<li><code>null</code>  null空数据类型</li>
<li><code>bigint</code> ES2020新定义 BigInt大整数类型，主要用来解决大于 2^53 - 1 的整数，如：<code>const theBiggestInt = 9007199254740991n; const alsoHuge = BigInt(9007199254740991);</code></li>
<li><code>symbol</code> ES6定义 Symbol类型，应用场景：解决属性命名唯一性的问题，比如一个object里有两个属性名都一样，但是分别对不同的意思，可以通过Symbol类型去解决，如：<code>a = Symbol(&#39;test&#39;); b = Symbol(&#39;test&#39;);obj = {[a]: &#39;test&#39;, [b]: &#39;test&#39;}</code></li>
</ul>
<p>同时typeof运算符还可以返回以下两种类型：</p>
<ul>
<li><code>function</code> 函数类型，新的<code>class</code>也是返回<code>function</code></li>
<li><code>object</code> 除了以上类型，其他对象统一返回<code>object</code></li>
</ul>
<p>因此 <code>null</code>被单独归类成一种基础数据类型，但是为什么<code>typeof null</code> 得到的却是 <code>object</code>？</p>
<h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p>先了解一下typeof是什么？</p>
<blockquote>
<p>typeof是一个操作符而不是函数，用来检测给定变量的数据类型。</p>
</blockquote>
<p>typeof是一个操作符，和 <code>+</code> <code>-</code> <code>=</code> 符号一样，只是用了<code>typeof</code>字母进行标识而已，类似还有：<code>delete</code> <code>void</code> <code>in</code> <code>instanceof</code>等。</p>
<p>使用typeof需要注意以下几点：</p>
<ul>
<li>typeof 操作符的优先级高于加法（+）等二进制操作符。因此，需要用括号来计算加法结果的类型。 如：<code>typeof someData + &quot; Wisen&quot;; // &quot;number Wisen&quot;</code> <code>typeof (someData + &quot; Wisen&quot;); // &quot;string&quot;</code></li>
<li>typeof 通常总是保证为它提供的任何操作数返回一个字符串。即使使用未声明的标识符，typeof 也会返回 “undefined”，而不是抛出错误。 但是在<code>let</code> <code>const</code>声明的变量，使用 typeof 会抛出一个 ReferenceError。因为<code>let</code> <code>const</code>声明的变量块作用域变量在块的头部处于“暂存死区”。</li>
<li><code>typeof document.all === &#39;undefined&#39;; // true</code> 因为所有浏览器都公开了一个类型为 undefined 的非标准宿主对象 <code>document.all</code>，但是 <code>document.all</code> 不等于 <code>undefined</code>，这种情况出现是在 Web 标准中，document.all 具有 “undefined” 类型的情况被归类为“故意违反”原始 ECMAScript Web 兼容性标准。</li>
<li>typeof 并不能检查出所有的类型，只能检查出上述所说的8种，针对其他类型可以通过原型链去判断获取，如： <code>Object.prototype.toString.call(x)</code> <code>x.constructor.name</code></li>
</ul>
<h3 id="typeof-工作原理"><a href="#typeof-工作原理" class="headerlink" title="typeof 工作原理"></a>typeof 工作原理</h3><p>那么typeof真正是如何工作的呢？</p>
<ul>
<li>首先，会将所运算的变量数据在底层转换成二进制，而在Javascript设计中，是利用二进制前（低）三位存储其类型信息，如：000: 对象，1：整数， 100：字符串等</li>
<li>其次，null存储起来转成二进制为<code>0000000000000000</code>，那么按照JS的设计原则， 低三位为<code>000</code>则代表对象</li>
<li>因此，null在typeof计算后，会直接返回<code>object</code></li>
</ul>
<p>PS： 注意细节， <code>undefined</code>：用 - （−2^30）表示。</p>
<p>这里引用一下<a href="https://github.com/justjavac" target="_blank" rel="noopener">迷渡 justjavac</a>老师的几个解释：</p>
<p><a href="https://segmentfault.com/q/1010000011846328" target="_blank" rel="noopener">JavaScript中typeof原理探究？</a><br><a href="https://www.zhihu.com/question/62732293/answer/201723301" target="_blank" rel="noopener">v8引擎是如何知道js数据类型的？</a></p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="===运算符"></a>===运算符</h1><p>要讲三者的区别，还有一种方式就是通过 <code>===</code> 全等运算符，它们的表现如下：</p>
<ul>
<li><code>null === null // true</code> </li>
<li><code>undefined === undefined // true</code></li>
<li><code>NaN === NaN // false</code></li>
</ul>
<p>前两者比较好理解，毕竟都是等于自身，但是<code>NaN</code>不等于<code>NaN</code>就很容易给人带来误解。</p>
<p>这里就需要先解释<code>===</code>和<code>==</code>的区别：</p>
<ul>
<li>==， 两边值类型不同的时候，要先进行类型转换，再比较两者的值。</li>
<li>===，不做类型转换，类型不同的一定不等，然后对比两者的值。</li>
</ul>
<p>因此我们可以得到<code>===</code>的实现过程：</p>
<ul>
<li>先判断两者的数据类型是否一致</li>
<li>再判断两者是否为基础数据类型，如果是数字类型还需要判断两者是否有为NaN，如果没有返回true，其他基础类型直接对比值</li>
<li>如果是引用数据类型，如：object或function，则判断它们的引用对象是否为同一个，如：<code>a = function(){}; b= a; c=a; b===c;</code></li>
</ul>
<h2 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h2><blockquote>
<p>NaN 即 Not a Number ，代表该值不是一个数字number类型</p>
</blockquote>
<p>那么如何判断<code>NaN</code>值呢？答案是通过<code>isNaN(x)</code>或者<code>Number.isNaN(x)</code>函数去判断，这里也有坑就是<code>Number.isNaN(x)</code> 不会强制转换<code>x</code>为<code>number</code>,只是会判断x是否为<code>NaN</code></p>
<p>为什么JS要设计一直<code>NaN</code>值？ 个人猜测是因为JS是一门弱类型语言，它支持类型之间互相转换，其他基础数据类型都可以直接转换或者报类型错误，但是在<code>number</code>为了更好兼容加减乘除运算符，设计一个值为NaN(非数字)，当值无法转换<code>number</code>类型，将返回NaN。</p>
<p><strong>同时，我们也需要了解<code>NaN</code>与<code>Infinity</code>的区别：</strong></p>
<ul>
<li>NaN，是Not a Number的缩写，不是一个数字的意思。</li>
<li>Infinity，是指无穷大的数字，后面可以用BigInt数据类型代替。</li>
</ul>
<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><p>如果要了解到三者的本质，从三者的原型去区分：</p>
<ul>
<li><code>Object.prototype.toString.call(undefined) // [object Undefined]</code>，原型为自己本身或者没有原型，因为它是一个基础数据类型，且是全局对象(window)的一个属性，并不是一个实例化的对象</li>
<li><code>Object.prototype.toString.call(null) // [object Null]</code>， 原型为自己本身，因为它是原型链上的最后一个</li>
<li><code>Object.prototype.toString.call(null) // [object Number]</code>，原型为<code>Number</code>，因为它是属于<code>Number类型</code></li>
</ul>
<p>那么什么是原型呢？</p>
<p>我们需要明白原型是怎么出现的，是为了解决什么问题？</p>
<blockquote>
<p>原型机制，是JS语言实现面向对象编程中继承特性是设计的一种机制，这种继承机制与经典的面向对象编程语言的继承机制不同。<br>传统的面向对象编程，实现对象继承，通过是定义一个父类，如果有个子类继承父类，那么在子类在实例化，会将父类的属性和方法都复制一份到子类的实例中<br>而原型机制是每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推，最终形成<code>原型链 (prototype chain)</code>。<br>这些属性和方法定义在 Object 的构造器函数 (constructor functions) 之上的prototype属性上，而非对象实例本身</p>
</blockquote>
<p>如何理解呢？下面通过一下几个点：</p>
<ul>
<li>new一个对象的全过程</li>
<li>如何实现继承？以及继承中的原型链？</li>
</ul>
<p>但是在搞清楚这个之前，我们还需要了解JS原型中经常会混淆两个属性，<code>prototype</code>和<code>__proto__</code>，所以我们先弄明白这两个属性分别是做什么的。</p>
<h2 id="prototype和proto"><a href="#prototype和proto" class="headerlink" title="prototype和proto"></a>prototype和<strong>proto</strong></h2><blockquote>
<p>在JS里，万物皆对象。方法（Function）是对象，方法的原型(Function.prototype)是对象。因此，它们都会具有对象共有的特点。<br>那么只要是对象就会有属性<code>__proto__</code>，称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型对象<code>prototype</code>。</p>
</blockquote>
<p>为了更好的理解，我们通过一段代码和对应原型关系图去对比了解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">a = <span class="keyword">new</span> A();</span><br></pre></td></tr></table></figure>

<p>上述代码<code>prototype</code>和<code>__proto__</code>的关系如下图：</p>
<p><img src="/assets/img/20230130-1.png" alt></p>
<p>通过上图我们可以很清晰的知道两者的区别：</p>
<ul>
<li><code>prototype</code>是一个对象，只有函数才有，实例化后的变量是没有的，且<code>prototype</code>原型允许扩展函数的方法或者属性，从而让实例化后的对象进行使用，再者就是<code>prototype</code>既然是对象那么它自己也会有<code>__proto__</code>属性</li>
<li><code>__proto__</code>是实例化对象后拥有的属性，它的值主要指向该对象构造函数的原型<code>prototype</code>，从而形成<code>原型链</code></li>
<li>当一个实例化对象在调用某方法或某属性时，会先判断<code>__proto__</code>的<code>prototype</code>对象上是否有，如果没有则会往下一层<code>__proto__</code>去寻找</li>
</ul>
<h2 id="new的实现过程"><a href="#new的实现过程" class="headerlink" title="new的实现过程"></a>new的实现过程</h2><p>demo代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">a = <span class="keyword">new</span> A();</span><br></pre></td></tr></table></figure>

<p>那么在这一个过程中，js在底层中，做了哪些事情呢？ 通过上图我们可以很清楚的知道：</p>
<ul>
<li>创建全新的函数A实例化一个对象</li>
<li>然后将对象的<strong>proto</strong>指向构造函数的prototype</li>
<li>将对象的this指向到调用方的this</li>
<li>如果函数无返回对象类型Object，则返回该函数对象</li>
</ul>
<h2 id="继承与原型链"><a href="#继承与原型链" class="headerlink" title="继承与原型链"></a>继承与原型链</h2><p>继承其实在ES6后来说已经很简单了，因为定义了<code>class</code>和<code>extends</code>等语法糖，所以不需要再像之前通过原型去解决，但是为了更好的了解原型链，我们接下来尝试一下几种ES5时代实现继承的方式。</p>
<h3 id="原型指向实现"><a href="#原型指向实现" class="headerlink" title="原型指向实现"></a>原型指向实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="string">'test'</span>;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 需要将A的属性继承</span></span><br><span class="line">    A.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">B.prototype.__proto__ = A.prototype;</span><br><span class="line"><span class="comment">// 思考一下，为什么要将隐性原型指向A？</span></span><br><span class="line">B.__proto__ = A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line">b.a; <span class="comment">// test</span></span><br><span class="line">b.say(); <span class="comment">// test</span></span><br><span class="line"></span><br><span class="line">b <span class="keyword">instanceof</span> B; <span class="comment">// true</span></span><br><span class="line">b <span class="keyword">instanceof</span> A; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这里需要注意几个点：</p>
<ol>
<li>在B构造函数里实现<code>A.call(this)</code>，是因为需要将A函数实现一遍，且A中this指向的属性绑定B函数中</li>
<li><code>B.prototype.__proto__ = A.prototype</code>这行是继承A的方法，后续如果要重写相同方法需要放在这行代码后面</li>
<li><code>B.__proto__ = A</code> 如果没有这行代码，貌似上面的结果并不会有太多异常，那么为什么要这行代码呢？(等待后续解释)</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里再总结一下，在数据类型上，三者的区别主要是：</p>
<ul>
<li><code>undefined</code> 是一种基础数据类型，可以通过<code>typeof</code>直接识别</li>
<li><code>null</code> 虽然也是一种基础数据类型，但是由于<code>typeof</code>从一开始实现机制问题，<code>typeof null</code>一直遗留下来返回的<code>object</code></li>
<li><code>NaN</code> 是<code>number</code>数据类型的一个值，代表无法识别为数字类型的值，如：<code>Number(&#39;abc&#39;) // NaN</code></li>
</ul>
<p>在 <code>===</code> 运算符号上，区别主要是：</p>
<ul>
<li><code>undefined</code>，可以等于任何值为<code>undefined</code>的变量</li>
<li><code>null</code>，可以等于任何值为<code>null</code>的变量</li>
<li><code>NaN</code>，不等于任何值的变量，只能通过<code>isNaN</code>函数判断</li>
</ul>
<p>从原型上去了解三者，他们本质就完全不同：</p>
<ul>
<li><code>undefined</code>，原型为自己本身或者没有原型</li>
<li><code>null</code>，原型为自己</li>
<li><code>NaN</code>，原型为Number</li>
</ul>
<p>同时我们也清楚的认识到JS中原型和原型链，原型是JS设计实现面向对象的一种机制，主要通过两个东西实现原型对象<code>prototype</code>和隐性原型<code>__proto__</code>实现，这两者主要关系在于：</p>
<ul>
<li>隐性原型<code>__proto__</code>是一个实例化对象后的属性，会指向声明该对象的构造函数的原型对象<code>prototype</code></li>
<li>原型对象<code>prototype</code>是一个对象，一般只有函数才会有，它通常包括<code>constructor</code>构造函数指向函数本身，以及其他扩展方法和属性，同时它本身也拥有<code>__proto__</code>隐性原型属性</li>
</ul>
<p>当然JS的原型和原型链并没有那么简单，不仅仅只是实现继承这么简单，后续我们还需要关注原型链安全问题，后续请看<a href="/2023/01/06/today/20220203/">《JS原型链污染是怎么回事》</a>。</p>
]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>:has伪类的到来延伸到其他伪元素和伪类的区别</title>
    <url>/today/20230128.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近从网上看到一个有趣的CSS应用，就是纯用CSS也能是父子树展示，具体效果如下：</p>
<ul class="tree">
  <li>
    <details open>
      <summary style="display: list-item;">目录节点1</summary>
      <ul>
        <li>
          <details>
            <summary style="display: list-item;">节点1</summary>
            <ul>
              <li>子节点1-1</li>
              <li>子节点1-2</li>
            </ul>
          </details>
        </li>
        <li>
          <details>
            <summary style="display: list-item;">节点2</summary>
            <ul>
              <li>子节点2-1</li>
              <li>子节点2-2</li>
            </ul>
          </details>
        </li>
      </ul>
    </details>
  </li>
</ul>

<p>然后里面关联到一篇新闻，就是<code>:has</code>伪元素的出现会给CSS带来极大的变动，这是为什么，不就是一个CSS伪元素吗？因此去了解一下，才发现这个伪元素确实不一样，主要有以下几点：</p>
<ul>
<li>可以选择父级元素， <code>a:has(&gt; img)</code>，包含<code>img元素</code>的<code>a元素</code></li>
<li>可以选择兄弟元素， <code>h1:has(+ p)</code>，后面为<code>p元素</code>的<code>h1元素</code></li>
</ul>
<p>为什么有了它之后，CSS会有大变动，因为以往我们的样式都是直接选择 元素 或者 子元素 或者 后面的元素，如果要选择父元素或前面的元素只能通过命名规范去确定，比如上述两个例子：</p>
<ul>
<li><code>a:has(&gt; img)</code>，我们只能通过<code>a.has-img</code>类似样式去命名</li>
<li><code>h1:has(+ p)</code>，只能通过<code>h1.next-p</code>类似样式去命名</li>
</ul>
<p>大概清楚它能带来的变化，接下来我们来详细了解一下它。</p>
<a id="more"></a>

<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>在<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:has" target="_blank" rel="noopener">MDN</a>里是这么定义<code>:has()</code>的:</p>
<blockquote>
<p>CSS 函数式伪类 <code>:has()</code> 表示一个元素，如果作为参数传递的任何相对选择器在锚定到该元素时，至少匹配一个元素。这个伪类通过把可容错相对选择器列表作为参数，提供了一种针对引用元素选择父元素或者先前的兄弟元素的方法。</p>
</blockquote>
<p>你可以这么理解<code>h1:has(+ p)</code>伪元素:</p>
<ul>
<li>第一步，会先筛选<code>h1</code>元素列表，如果列表长度大于1才会执行has()</li>
<li>第二步，执行<code>+ p</code>，就是判断<code>h1</code>元素列表中哪些元素的下个元素为<code>p</code></li>
<li>第三步，将筛选后的元素列表返回</li>
</ul>
<p>再简单点说就是一个过滤器，过滤条件可以是任意CSS表达式。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>除了上述的场景外，<code>:has()</code> 还可以做以下几个场景：</p>
<ul>
<li>与<code>:is()</code> <code>:not()</code> 结合使用，如：<code>is:(h1, h2, h3):has(+ :not(h2,h3, h4))</code> </li>
<li>表单必填项, 给每个必填项增加”*””文字，代码如下：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-tag">label</span><span class="selector-pseudo">:has(+input</span><span class="selector-pseudo">:required)</span><span class="selector-pseudo">::before</span>&#123;</span></span><br><span class="line">  content: '*';</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>备注<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<div style="border:1px solid #ccc;margin:20px;padding:20px;">
<style>
label:has(+input:required)::before{
  content: '*';
  color: red;
  width:1em;
  display:inline-block;
}
</style>
<form>
  <div style="margin:10px">
    <label style="display:inline-block;width:4em; text-align:right;">用户名</label>
    <input required>
  </div>
  <div style="margin:10px">
    <label style="display:inline-block;width:4em; text-align:right;">备注</label>
    <input>
  </div>
</form>
</div>


<h1 id="伪类与伪元素"><a href="#伪类与伪元素" class="headerlink" title="伪类与伪元素"></a>伪类与伪元素</h1><p>了解完<code>:has()</code>伪类，那么来复习一下CSS中的其他伪类与伪元素。</p>
<h2 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h2><p>伪元素，又称为伪类，是添加到CSS选择器上的关键字，给指定DOM元素添加特殊状态。MDN是这么定义的：</p>
<blockquote>
<p>CSS 伪类是添加到选择器的关键字，用于指定所选元素的特殊状态。例如，伪类 :hover 可以用于选择一个按钮，当用户的指针悬停在按钮上时，设置此按钮的样式。 ——<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes" target="_blank" rel="noopener">MDN 伪类</a></p>
</blockquote>
<p>伪类一般组成为两部分： <code>:</code> + <code>伪类名</code>，按照伪类的功能进行划分，主要分为以下几类：</p>
<ul>
<li>元素显示状态伪类，如：<code>:fullscreen</code> <code>:hover</code></li>
<li>输入状态伪类，如：<code>:focus</code> <code>:actived</code></li>
<li>语言的伪类，如：<code>:lang()</code></li>
<li>位置伪类，如：<code>:left</code></li>
<li>资源状态伪类，如：<code>:playing</code> <code>:paused</code></li>
<li>时间方面的伪类</li>
<li>树结构的伪类，如： <code>:nth-child()</code></li>
<li>用户行为伪类，如：<code>:actived</code></li>
<li>函数式伪类，如：<code>:where</code> <code>:is</code> <code>:not</code></li>
</ul>
<p>其实我们真正在使用的没有几个，但是我们仍然要重点关注一下，能加快我们的开发效率，比如：元素显示状态伪类，用户行为伪类, 函数式伪类等</p>
<h2 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h2><blockquote>
<p>伪元素是一个附加至选择器末的关键词，允许你对被选择元素的特定部分修改样式。——<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-elements" target="_blank" rel="noopener">伪元素 MDN</a></p>
</blockquote>
<p>从命名上你就可以看出来，伪元素其实是一个类似的元素东西，虽然有部分写法可以改变样式，但是大部分还是给CSS选择器对应元素增加元素，比较常见的伪元素有：</p>
<p>而且从书写规范来讲，伪元素为<code>::</code>+<code>伪元素名</code>，比较常见的伪元素有以下几种：</p>
<ul>
<li><code>::before</code> 给元素添加最前面添加一个子伪元素</li>
<li><code>::after</code> 给元素添加最后面添加一个子伪元素</li>
<li><code>::first-line</code> 选择元素第一个</li>
<li><code>::placeholder</code> 修改有<code>placehodler</code>的样式</li>
</ul>
<p>部分demo代码测试案例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.article-inner</span>  <span class="selector-tag">p</span><span class="selector-class">.demo-20230108</span><span class="selector-pseudo">::first-line</span> &#123; <span class="attribute">color</span>:<span class="number">#f00</span> &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.article-inner</span>  <span class="selector-tag">p</span><span class="selector-class">.demo-20230108</span><span class="selector-pseudo">::first-letter</span> &#123; <span class="attribute">text-transform</span>: uppercase &#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width:400px; padding:20px; border:1px solid;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">'demo-20230108'</span> <span class="attr">style</span>=<span class="string">"word-break:break-all"</span>&gt;</span>abcdefg,首字母要大写，然后第一行是要红色的字体，换行后就变成正常的，这里是一段很长的测试文字。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<style>
    .article-inner  p.demo-20230108::first-line { color:#f00 }
    .article-inner  p.demo-20230108::first-letter { text-transform: uppercase }
</style>
<div style="width:400px; padding:20px; border:1px solid;">
    <p class="demo-20230108" style="word-break:break-all">abcdefg,首字母要大写，然后第一行是要红色的字体，换行后就变成正常的，这里是一段很长的测试文字。</p>
</div>

<h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2><p>只有一句话： <code>与伪元素比较，伪类能够根据状态改变元素样式。</code></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.zhangxinxu.com/wordpress/2022/08/css-has-pseudo-class/" target="_blank" rel="noopener">CSS :has()伪类她来了</a></p>
]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>从0开始学习FlexBox布局</title>
    <url>/today/20230124.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前研究过一篇<a href="https://qborfy.com/today/20230111.html" target="_blank" rel="noopener">《移动端适配总结》</a>，里面主要通过布局不变，改变布局组件元素的大小去适应移动端。但是这种方式对于PC端或者Pad等大屏幕并不适合，所以从想找找看是否有新的方案能否满足跨端自适应布局方式。</p>
<p>目前同时解决PC端和移动端的响应式布局的解决方案以下几种：</p>
<ul>
<li>通过<code>@media</code>媒体查询去设置不同尺寸的样式</li>
<li>通过<code>Flexbox</code> <code>Grid</code>等现代化布局去做响应式布局</li>
</ul>
<a id="more"></a>

<h1 id="CSS排版布局"><a href="#CSS排版布局" class="headerlink" title="CSS排版布局"></a>CSS排版布局</h1><p>先简单再复习一下css是什么：</p>
<blockquote>
<p>CSS（层叠样式表）用于设置和布置网页——例如，更改内容的字体、颜色、大小和间距，将其拆分为多个列的布局，或添加动画和其他装饰功能。</p>
</blockquote>
<p>除了基础样式和动画外，CSS最大的一个功能就是告诉浏览器应该怎么对HTML元素进行排版布局。</p>
<blockquote>
<p>CSS 页面布局技术允许我们拾取网页中的元素，并且控制它们相对正常布局流、周边元素、父容器或者主视口/窗口的位置。</p>
</blockquote>
<p>目前，CSS布局分为以下几个：</p>
<ul>
<li>正常布局流，Flow layout，流式布局，是由块级盒子(block)和内联盒子(inline-block)，块级盒子从上至下排列，每个块级盒子会独自占一行，内联盒子则会被父级块级元素的宽度内，它们与其他内联元素、相邻的文本内容（或者被包裹的）被安排在同一行。如果空间不够，溢出的文本或元素将移到新的一行。</li>
<li>弹性盒子，Flexbox，与Flow layout最大的不同点在于，弹性盒子默认支持内部子元素（不管是块级还是内联）水平对齐，还支持等高，从而使得很多布局任务变得更加容易。后面我们详细讲解。</li>
<li>网格，Grid，有点类似表格table布局，相比较Flexbox，Grid更加强大，能适用更加复杂的排版，它包含了列(Columns)、行(Row)等布局。</li>
<li>浮动，Float，最初只用于在成块的文本内浮动图像，但是后来发现它能实现复杂的布局。一个浮动元素会被移出正常文档流，附到其父容器的左或右边，在正常布局中位于该浮动元素之下的内容，此时会围绕着浮动元素，填满其左或右侧的空间。</li>
<li>定位，Position，正常的文档流布局中取出元素，并使它们具有不同的行为，例如放在另一个元素的上面，或者始终保持在浏览器视窗内的同一位置。</li>
<li>多列布局，Column，有点类似Grid，比Grid简单，只是简单将容器分割成几列(<code>column-count</code>)，且可以设置（<code>column-width</code>）每一列的宽度</li>
</ul>
<h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p><code>BFC</code>(block formatting context)，块级格式化上下文，CSS中基于box的一个布局对象和单位，它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p>
<p>满足以下条件之一即为BFC:</p>
<ol>
<li>float的值不为none</li>
<li>position的值不为static或者relative</li>
<li>display的值为 table-cell, table-caption, inline-block,flex, 或者 inline-flex中的其中一个，现代化css用 <code>display:flow-root</code></li>
<li>overflow的值不为visible</li>
<li>根元素</li>
</ol>
<p>BFC有几个特点：</p>
<ul>
<li>不影响外部元素，外部元素也影响不到其内部</li>
<li>计算BFC高度的时候，浮动元素的高度也计算在内</li>
</ul>
<h3 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h3><blockquote>
<p>随着人们使用的屏幕尺寸的种类越来越多，出现了<code>响应式网页设计的概念（responsive web design，RWD）</code>，RWD 指的是允许 Web 页面适应不同屏幕宽度因素等，进行布局和外观的调整的一系列实践。</p>
</blockquote>
<p>响应式设计不是一种技术，而是一种设计方式或者理念，它指的是网页的布局应该随着屏幕的变化而自适应改变。</p>
<h1 id="Flexbox"><a href="#Flexbox" class="headerlink" title="Flexbox"></a>Flexbox</h1><p>Flexbox，Flexible Box， 俗称弹性盒子，是从网页默认流式布局(Flow layout)脱离出来的一种布局模式，其父元素容器还是遵循Flow layout，但是Flexbox中的元素都会遵循Flexbox新的布局方式。</p>
<blockquote>
<p>MDN介绍，弹性盒子是一种用于按行或按列布局元素的一维布局方法。元素可以膨胀以填充额外的空间，收缩以适应更小的空间。</p>
</blockquote>
<p>Flexbox的出现主要是为了解决Flow layout布局的一些无法很好解决的问题，如下：</p>
<ul>
<li>一个子元素需要垂直居中显示在容器中</li>
<li>多个子元素需要水平平均对齐在容器中，以及一旦子元素超过父容器的宽度，需要自动换行</li>
<li>所有子元素需要显示同样的高度或者宽度</li>
</ul>
<p>所以弹性盒子其实是由两部分组成：</p>
<ul>
<li>容器，需要设置为<code>display:flex</code>，用来控制子元素内的布局</li>
<li>子元素，遵循Flex布局方式所控制，但是也可以按照Flex布局做一些调整</li>
</ul>
<p><strong>同时需要注意一点，Flexbox弹性盒子内，元素的宽度不再是自身所设定的宽度，而是会根据容器设置的规则而发生变化。</strong></p>
<p>实现一个弹性盒子，其实很简单，只需要设置容器的<code>display:flex</code>，即可实现，代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.container&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.item&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item1"</span>&gt;</span>item1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item2"</span>&gt;</span>item1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item3"</span>&gt;</span>item1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Flexbox的两条轴"><a href="#Flexbox的两条轴" class="headerlink" title="Flexbox的两条轴"></a>Flexbox的两条轴</h2><p>要了解Flexbox，首先得知道盒子内部是按照两条轴去进行布局，分别为：</p>
<ul>
<li>主轴，Primary axis，子元素将按照该轴的方向进行排版布局</li>
<li>横轴，Cross axis，子元素默认会按照该轴的宽高度去拉伸自己本身的宽度高</li>
</ul>
<p>如下图所示：</p>
<p><img src="/assets/img/20230124-1.png" alt></p>
<p>那么Flexbox的属性设置，主要就是围绕这两个轴，分别调整容器内部子元素的对齐方向，子元素的在轴的位置，轴之间的间隔等。</p>
<h2 id="Flexbox的属性"><a href="#Flexbox的属性" class="headerlink" title="Flexbox的属性"></a>Flexbox的属性</h2><p>当然Flex布局的容器还支持其他设置属性：</p>
<ul>
<li>flex-direction 设置子元素的对齐方向，如：垂直(column)、水平(row)</li>
<li>justify-content 控制子元素主轴对齐方向</li>
<li>align-items 控制子元素横轴对齐方向</li>
<li>gap 设置子元素的间隔距离</li>
<li>order 设置子元素展示顺序，忽略html的顺序</li>
<li>flex-wrap 子元素超过容器大小后是否换行</li>
</ul>
<p>子元素也可以设置自身属性：</p>
<ul>
<li>flex-grow 设置子元素是否占用剩余空间，如果子元素都设置了，则会按照设置数字大小去做占用比例</li>
<li>flex-basis 子元素弹性宽度或者高度设置，当容器空间足够，则会按照此属性设置，如果空间不够，则会占据剩余的空间</li>
<li>flex-shrink 当子元素占用空间比容器大，默认会按照子元素占据比例进行缩放，该属性可以改变被压缩比例大小</li>
<li>align-self 子元素控制自己横轴对齐方向</li>
<li>margin 子元素设置auto后，可以达到类似<code>justify-content</code> 或 <code>align-items</code>的效果</li>
</ul>
<p>所有属性设置demo可以查看<a href="/code/flex/demo.html">Flexbox布局属性设置demo</a>。</p>
<h2 id="Flexbox的响应式布局"><a href="#Flexbox的响应式布局" class="headerlink" title="Flexbox的响应式布局"></a>Flexbox的响应式布局</h2><p>其实了解Flexbox布局，其实再去实现响应式布局，其实已经没有那么难了，不需要<code>@media</code>媒体查询那么麻烦一个个设置对应屏幕尺寸，只需要按照以下几个属性去设置对应的即可完成响应式布局：</p>
<ul>
<li>设置一个Flex容器，预先设置好当子元素在不同屏幕的展示排版</li>
<li>利用<code>flex-wrap: wrap;</code> 允许子元素自动换行</li>
<li>在设置不同子元素<code>flex-basis</code> <code>flex-grow</code> 占据容器占比</li>
<li>设置子元素<code>flex-shrink</code>是否缩放，从而避免元素被压缩的导致布局展示不对</li>
<li>设置子元素的最小宽度<code>min-width</code>，从而避免元素被压缩太小</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.joshwcomeau.com/css/interactive-guide-to-flexbox/" target="_blank" rel="noopener">Flexbox 交互式指南</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo Yilia主题支持搜索功能</title>
    <url>/share/hexo-search.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>当hexo的文章越来越多，依靠标题和tag去搜索有点不够用，因此需要支持搜索功能，hexo查询主要依赖本地索引文件生成，具体步骤如下：</p>
<ul>
<li>安装插件: <code>npm install --save hexo-generator-search</code></li>
<li>根目录下的_config.yml中添加如下配置即可</li>
</ul>
<a id="more"></a>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">search.xml</span></span><br><span class="line"><span class="attr">  field:</span> <span class="string">all</span></span><br></pre></td></tr></table></figure>

<ul>
<li>添加搜索框，在主题目录<code>themes/yilia/layout/layout.ejs</code>下的<code>&lt;div id=&quot;wrapper&quot; class=&quot;body-wrap&quot;&gt;</code>后面添加如下代码：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span>(<span class="attr">theme.search</span>) &#123; %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page-header"</span> <span class="attr">style</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">%#</span> 《集成本地搜索 %&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/search.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"local-search"</span> <span class="attr">class</span>=<span class="string">"local-search local-search-plugin"</span> <span class="attr">style</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"search"</span> <span class="attr">placeholder</span>=<span class="string">"站内搜索"</span> <span class="attr">id</span>=<span class="string">"local-search-input"</span> <span class="attr">class</span>=<span class="string">"local-search-input-cls"</span> <span class="attr">style</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">id</span>=<span class="string">"local-search-icon-search"</span> <span class="attr">class</span>=<span class="string">"icon"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span> <span class="attr">title</span>=<span class="string">"站内搜索"</span>&gt;</span>🔍<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"local-search-result"</span> <span class="attr">class</span>=<span class="string">"local-search-result-cls"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">if</span> ($(<span class="string">'.local-search'</span>).size()) &#123;</span></span><br><span class="line"><span class="javascript">            $.getScript(<span class="string">'/search/search.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">              searchFunc(<span class="string">"/search.xml"</span>, <span class="string">'local-search-input'</span>, <span class="string">'local-search-result'</span>);</span></span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">%#</span> 集成本地搜索》 %&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"wrapper"</span> <span class="attr">class</span>=<span class="string">"body-wrap"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>新建<code>themes/yilia/source/search</code>目录，同时新增<code>search.js</code>和<code>search.css</code>文件</li>
</ul>
<p>代码如下：</p>
<p><strong>search.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A local search script with the help of hexo-generator-search</span></span><br><span class="line"><span class="comment">// Copyright (C) 2015 </span></span><br><span class="line"><span class="comment">// Joseph Pan &lt;http://github.com/wzpan&gt;</span></span><br><span class="line"><span class="comment">// Shuhao Mao &lt;http://github.com/maoshuhao&gt;</span></span><br><span class="line"><span class="comment">// This library is free software; you can redistribute it and/or modify</span></span><br><span class="line"><span class="comment">// it under the terms of the GNU Lesser General Public License as</span></span><br><span class="line"><span class="comment">// published by the Free Software Foundation; either version 2.1 of the</span></span><br><span class="line"><span class="comment">// License, or (at your option) any later version.</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// This library is distributed in the hope that it will be useful, but</span></span><br><span class="line"><span class="comment">// WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span></span><br><span class="line"><span class="comment">// Lesser General Public License for more details.</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// You should have received a copy of the GNU Lesser General Public</span></span><br><span class="line"><span class="comment">// License along with this library; if not, write to the Free Software</span></span><br><span class="line"><span class="comment">// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</span></span><br><span class="line"><span class="comment">// 02110-1301 USA</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> searchFunc = <span class="function"><span class="keyword">function</span> (<span class="params">path, search_id, content_id</span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">    <span class="keyword">var</span> BTN = <span class="string">"&lt;i id='local-search-close'&gt;x&lt;/i&gt;"</span>;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: path,</span><br><span class="line">        dataType: <span class="string">"xml"</span>,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params">xmlResponse</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// get the contents from search data</span></span><br><span class="line">            <span class="keyword">var</span> datas = $(<span class="string">"entry"</span>, xmlResponse).map(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    title: $(<span class="string">"title"</span>, <span class="keyword">this</span>).text(),</span><br><span class="line">                    content: $(<span class="string">"content"</span>, <span class="keyword">this</span>).text(),</span><br><span class="line">                    url: $(<span class="string">"url"</span>, <span class="keyword">this</span>).text()</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;).get();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> $input = <span class="built_in">document</span>.getElementById(search_id);</span><br><span class="line">            <span class="keyword">var</span> $resultContent = <span class="built_in">document</span>.getElementById(content_id);</span><br><span class="line"></span><br><span class="line">            $input.addEventListener(<span class="string">'input'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> str = <span class="string">'&lt;ul class=\"search-result-list\"&gt;'</span>;</span><br><span class="line">                <span class="keyword">var</span> keywords = <span class="keyword">this</span>.value.trim().toLowerCase().split(<span class="regexp">/[\s\-]+/</span>);</span><br><span class="line">                $resultContent.innerHTML = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.value.trim().length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// perform local searching</span></span><br><span class="line">                datas.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">var</span> isMatch = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">var</span> content_index = [];</span><br><span class="line">                    <span class="keyword">if</span> (!data.title || data.title.trim() === <span class="string">''</span>) &#123;</span><br><span class="line">                        data.title = <span class="string">"Untitled"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">var</span> data_title = data.title.trim().toLowerCase();</span><br><span class="line">                    <span class="keyword">var</span> data_content = data.content.trim().replace(<span class="regexp">/&lt;[^&gt;]+&gt;/g</span>, <span class="string">""</span>).toLowerCase();</span><br><span class="line">                    <span class="keyword">var</span> data_url = data.url;</span><br><span class="line">                    <span class="keyword">var</span> index_title = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">var</span> index_content = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">var</span> first_occur = <span class="number">-1</span>;</span><br><span class="line">                    <span class="comment">// only match artiles with not empty contents</span></span><br><span class="line">                    <span class="keyword">if</span> (data_content !== <span class="string">''</span>) &#123;</span><br><span class="line">                        keywords.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">keyword, i</span>) </span>&#123;</span><br><span class="line">                            index_title = data_title.indexOf(keyword);</span><br><span class="line">                            index_content = data_content.indexOf(keyword);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (index_title &lt; <span class="number">0</span> &amp;&amp; index_content &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                                isMatch = <span class="literal">false</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (index_content &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                                    index_content = <span class="number">0</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                                    first_occur = index_content;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// content_index.push(&#123;index_content:index_content, keyword_len:keyword_len&#125;);</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        isMatch = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// show search results</span></span><br><span class="line">                    <span class="keyword">if</span> (isMatch) &#123;</span><br><span class="line">                        str += <span class="string">"&lt;li&gt;&lt;a href='"</span> + data_url +</span><br><span class="line">                            <span class="string">"' class='search-result-title'&gt;"</span> + data_title + <span class="string">"&lt;/a&gt;"</span>;</span><br><span class="line">                        <span class="keyword">var</span> content = data.content.trim().replace(<span class="regexp">/&lt;[^&gt;]+&gt;/g</span>, <span class="string">""</span>);</span><br><span class="line">                        <span class="keyword">if</span> (first_occur &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// cut out 100 characters</span></span><br><span class="line">                            <span class="keyword">var</span> start = first_occur - <span class="number">20</span>;</span><br><span class="line">                            <span class="keyword">var</span> end = first_occur + <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (start &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                                start = <span class="number">0</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (start == <span class="number">0</span>) &#123;</span><br><span class="line">                                end = <span class="number">100</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (end &gt; content.length) &#123;</span><br><span class="line">                                end = content.length;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">var</span> match_content = content.substr(start, end);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// highlight all keywords</span></span><br><span class="line">                            keywords.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">keyword</span>) </span>&#123;</span><br><span class="line">                                <span class="keyword">var</span> regS = <span class="keyword">new</span> <span class="built_in">RegExp</span>(keyword, <span class="string">"gi"</span>);</span><br><span class="line">                                match_content = match_content.replace(regS,</span><br><span class="line">                                    <span class="string">"&lt;em class=\"search-keyword\"&gt;"</span> +</span><br><span class="line">                                    keyword + <span class="string">"&lt;/em&gt;"</span>);</span><br><span class="line">                            &#125;);</span><br><span class="line"></span><br><span class="line">                            str += <span class="string">"&lt;p class=\"search-result\"&gt;"</span> + match_content +</span><br><span class="line">                                <span class="string">"...&lt;/p&gt;"</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        str += <span class="string">"&lt;/li&gt;"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                str += <span class="string">"&lt;/ul&gt;"</span>;</span><br><span class="line">                <span class="keyword">if</span> (str.indexOf(<span class="string">'&lt;li&gt;'</span>) === <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> $resultContent.innerHTML = BTN +</span><br><span class="line">                        <span class="string">"&lt;ul&gt;&lt;span class='local-search-empty'&gt;没有找到内容，更换下搜索词试试吧~&lt;span&gt;&lt;/ul&gt;"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                $resultContent.innerHTML = BTN + str;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    $(<span class="built_in">document</span>).on(<span class="string">'click'</span>, <span class="string">'#local-search-close'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="string">'#local-search-input'</span>).val(<span class="string">''</span>);</span><br><span class="line">        $(<span class="string">'#local-search-result'</span>).html(<span class="string">''</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    $(<span class="built_in">document</span>).on(<span class="string">'focus'</span>, <span class="string">'#local-search'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="string">'#local-search-icon-search'</span>).html(<span class="string">'❌'</span>);</span><br><span class="line">        $(<span class="string">'#local-search-icon-search'</span>).attr(<span class="string">'id'</span>, <span class="string">'local-search-icon-close'</span>);</span><br><span class="line">        <span class="comment">//console.log("66666");</span></span><br><span class="line">    &#125;);</span><br><span class="line">    $(<span class="built_in">document</span>).on(<span class="string">'click'</span>, <span class="string">'#local-search-icon-close'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="string">'#local-search-input'</span>).val(<span class="string">''</span>);</span><br><span class="line">        $(<span class="string">'#local-search-result'</span>).html(<span class="string">''</span>);</span><br><span class="line">        $(<span class="string">'#local-search-icon-close'</span>).html(<span class="string">'🔍'</span>);</span><br><span class="line">        $(<span class="string">'#local-search-icon-close'</span>).attr(<span class="string">'id'</span>, <span class="string">'local-search-icon-search'</span>);</span><br><span class="line">        <span class="comment">//console.log("1111");</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>search.css</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.local-search</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">16px</span> <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-input-cls</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">80%</span>;</span><br><span class="line">    <span class="comment">/* margin: 10px 0; */</span></span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">8px</span> <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#4d4d4d</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#666</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-input-cls</span><span class="selector-pseudo">::-webkit-input-placeholder</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#2d2626</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-input-cls</span><span class="selector-pseudo">::-moz-input-placeholder</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#2d2626</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-input-cls</span><span class="selector-pseudo">::-ms-input-placeholder</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#2d2626</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#local-search-close</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">'x'</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#888</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: consolas;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">    <span class="attribute">font-style</span>: normal;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">400</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(0);</span><br><span class="line">    <span class="attribute">transition</span>: all .<span class="number">3s</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#local-search-close</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="number">#666</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#222</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(180deg);</span><br><span class="line">    <span class="attribute">transition</span>: all .<span class="number">3s</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-result-cls</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">99</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="comment">/* top: 50px; */</span></span><br><span class="line">    <span class="attribute">right</span>: -<span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-result-cls</span> <span class="selector-class">.local-search-empty</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#888</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">44px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">400</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-result-cls</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">360px</span>;</span><br><span class="line">    <span class="attribute">max-height</span>: <span class="number">450px</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: auto;</span><br><span class="line">    <span class="attribute">overflow-y</span>: auto;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(255, 255, 255, 0.9);</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">3px</span> <span class="number">4px</span> <span class="number">10px</span> <span class="number">#7dc3d8</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-result-cls</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: left;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#bdb7b7</span>;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">400</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-result-cls</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">    <span class="attribute">border-bottom</span>: none;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-result-cls</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>:none;</span><br><span class="line">    <span class="attribute">transition</span>: all .<span class="number">3s</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-result-cls</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>:underline;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-result-cls</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">max-height</span>: <span class="number">124px</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-result-cls</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">em</span><span class="selector-class">.search-keyword</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#e58c7c</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>:bold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-plugin</span> <span class="selector-class">.local-search-input-cls</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: .<span class="number">6</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">80%</span>;</span><br><span class="line">    <span class="attribute">transition</span>: all .<span class="number">3s</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-plugin</span> <span class="selector-class">.local-search-input-cls</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">80%</span>;</span><br><span class="line">    <span class="attribute">transition</span>: all .<span class="number">3s</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-plugin</span> <span class="selector-class">.icon</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#999</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://gaomf.cn/2016/10/10/%E4%B8%BAHexo%E5%8D%9A%E5%AE%A2Yilia%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener">为Hexo博客Yilia主题添加本地站内搜索功能</a></p>
]]></content>
      <tags>
        <tag>技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>从nest.js中了解IoC和DI的实现</title>
    <url>/today/20230122.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>从上一篇<a href="/2023/01/10/today/20220110/">《从egg.js转到nest.js》</a>，想对其再深入了解一下，尤其比较好奇Typescript是如何实现<code>IoC</code>和<code>DI</code>，因为在Java的是通过的反射(Spring IoC实现原理)去创建对应的类。因此下文将详细讲解Nest.js中IoC和DI的实现原理。</p>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>在了解实现原理之前有几个知识概念，需要了解一下：</p>
<ul>
<li>IoC和DI</li>
<li>JavaScript的Reflect</li>
<li>TypeScript的装饰器</li>
</ul>
<a id="more"></a>

<h2 id="IoC和DI"><a href="#IoC和DI" class="headerlink" title="IoC和DI"></a>IoC和DI</h2><p>IoC和DI其实同属于一个技术理念，下面维基百科的介绍：</p>
<blockquote>
<p>IoC，控制反转（英语：Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。</p>
</blockquote>
<p>简单的说IoC是一个开发代码的设计原则，DI则是实现这个设计原则的方案。</p>
<h3 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h3><p>从代码层上来讲解IoC，简单的说就是：</p>
<ul>
<li>Class A中用到了Class B的对象b，一般情况下，需要在A的代码中显式地用 new 创建 B 的对象。</li>
<li>使用IoC设计原则后，A 的代码只需要定义一个 private 的B对象，不需要直接 new 来获得这个对象，而是通过相关的容器控制程序来将B对象在外部new出来并注入到A类里的引用中。</li>
<li>IoC将采用依赖注入或依赖查找两种方案去实现</li>
</ul>
<p>再通俗一点，就是有一个IoC容器管家，负责你开发的代码类的归置，你只管使用代码类，不用管它放在哪里，只需要调用即可。</p>
<h3 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h3><p>DI，Dependency Injection，依赖注入</p>
<blockquote>
<p>依赖注入是被动的接收对象，在类A的实例创建过程中即创建了依赖的B对象，通过类型或名称来判断将不同的对象注入到不同的属性中<br>依赖查找是主动索取相应类型的对象，获得依赖对象的时间也可以在代码中自由控制</p>
</blockquote>
<p>简单的说，就是依赖注入是将需要注入的对象完全交给框架去实现，而依赖查找则是开发者通过框架提供的方法，由自己控制需要注入的时间点。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>采用IoC和DI，需要注意的问题是：</p>
<ul>
<li>循环依赖，就是A依赖B，B依赖A，如何避免这种情况发生，或者框架提供什么样的方案去避免？</li>
<li>如果依赖的类越来越多，会不会导致项目启动速度变慢，因为需要初始化类很多，尤其当遇到一些类初始化可能会错误，但其实是可以忽略的？</li>
<li>初始化类的顺序如何控制，如：A依赖B，需要B实例化后才能实例？</li>
</ul>
<h2 id="JavaScript的Reflect"><a href="#JavaScript的Reflect" class="headerlink" title="JavaScript的Reflect"></a>JavaScript的Reflect</h2><p>Reflect在MDN网站是这么解释的：</p>
<blockquote>
<p>Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与proxy handlers (en-US)的方法相同。Reflect不是一个函数对象，因此它是不可构造的。<br>其中的一些方法与 Object 相同，尽管二者之间存在某些细微上的差别。</p>
</blockquote>
<p>按照前端开发者理解来说，Reflect能解决开发中遇到很多this的代理问题，虽然大部分方案都可以通过其他方式解决，但是Reflect的定义能帮助我们快速实现这些功能。</p>
<p>Reflect符合ES6标准的提供的API有如下几个：</p>
<ul>
<li><code>Reflect.apply(target, thisArgument, argumentsList)</code>,和 <code>Function.prototype.apply(thisArgument, argumentsList)</code> 功能类似，也是调用函数，且允许将函数的this指向<code>thisArgument</code></li>
<li><code>Reflect.construct(target, argumentsList[, newTarget])</code>，new一个target，且可以将target的this的指向新的newTarget对象</li>
<li><code>Reflect.defineProperty(target, propertyKey, attributes)</code>，拦截target对象的操作，和 <code>Object.defineProperty()</code> 类似</li>
<li><code>Reflect.deleteProperty(target, propertyKey)</code>，作为函数的delete操作符，相当于执行 delete target[name]。</li>
<li><code>Reflect.get(target, propertyKey[, receiver])</code>，获取target的属性值，和<code>target[name]</code>的区别在于可以<code>receiver</code>，可以指定调用属性值的时候<code>this</code></li>
<li><code>Reflect.getOwnPropertyDescriptor(target, propertyKey)</code>，类似于 Object.getOwnPropertyDescriptor()。如果对象中存在该属性，则返回对应的属性描述符，否则返回 undefined。</li>
<li><code>Reflect.getPrototypeOf(target)</code>，返回指定对象的原型（即内部的 [[Prototype]] 属性的值）</li>
<li><code>Reflect.has(target, propertyKey)</code>，判断一个对象是否存在某个属性，和 <code>in 运算符</code> 的功能完全相同</li>
<li><code>Reflect.ownKeys(target)</code>，返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 Object.keys(), 但不会受enumerable 影响).</li>
<li><code>Reflect.isExtensible(target)</code>， 判断一个对象是否可扩展（即是否能够添加新的属性）</li>
<li><code>Reflect.preventExtensions(target)</code>，阻止新属性添加到对象</li>
<li><code>Reflect.set(target, propertyKey, value[, receiver])</code>，将值分配给属性的函数。返回一个Boolean，如果更新成功，则返回true。</li>
<li><code>Reflect.setPrototypeOf(target, prototype)</code>，可设置对象的原型，即内部的 [[Prototype]] 属性）为另一个对象或 null，利用原型链用来强制给某个对象增加额外方法</li>
</ul>
<p>当然还有一些没有进入标准，但是在ES7提案的方法<code>Reflect Metadata</code>（Typescript已实现），后面Nest.js已采用的方法，主要有以下几个：</p>
<ul>
<li><code>Reflect.getMetadata(metadataKey, target, propertyKey)</code>, 用于获取某个类的元数据</li>
<li><code>Reflect.defineMetadata(metadataKey, metadataValue, target, propertyKey);</code>, 用于设置某个类的元数据</li>
</ul>
<p>简单理解这个api方法，你可以通过<code>Reflect.defineMetadata</code>获取到类或者函数的参数类型，也可以给类或者函数设置元数据再获取，具体代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Prop</span>(<span class="params"></span>): <span class="title">PropertyDecorator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">target, key: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">type</span> = Reflect.getMetadata(<span class="string">'design:type'</span>, target, key);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> type: <span class="subst">$&#123;<span class="keyword">type</span>.name&#125;</span>`</span>);</span><br><span class="line">    <span class="comment">// other...</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> SomeClass &#123;</span><br><span class="line">  <span class="meta">@Prop</span>()</span><br><span class="line">  <span class="keyword">public</span> Aprop!: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TypeScript 的优势了，TypeScript 支持编译时自动添加一些 metadata 数据，如下所示：</p>
<ul>
<li><code>Reflect.getMetadata(&quot;design:type&quot;, target, key)</code>， 获取target函数类型</li>
<li><code>Reflect.getMetadata(&quot;design:paramtypes&quot;, target, key)</code>， 获取target函数参数类型</li>
<li><code>Reflect.getMetadata(&quot;design:returntype&quot;, target, key)</code>， 获取target函数返回值类型</li>
</ul>
<p>这个<code>Reflect.getMetadata(&quot;design:paramtypes&quot;, target, key)</code>基本上就是Nest.js实现Ioc和DI的核心代码。</p>
<h2 id="TypeScript的装饰器"><a href="#TypeScript的装饰器" class="headerlink" title="TypeScript的装饰器"></a>TypeScript的装饰器</h2><blockquote>
<p>装饰器（Decorators）为我们在类的声明及成员上通过元编程语法添加标注提供了一种方式。<br>装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。</p>
</blockquote>
<p>如何实现一个装饰器呢？</p>
<p>如果我们要定制一个修饰器如何应用到一个声明上，我们得写一个装饰器工厂函数。 装饰器工厂就是一个简单的函数，它返回一个表达式，以供装饰器在运行时调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">color</span>(<span class="params">value: string</span>) </span>&#123; <span class="comment">// 这是一个装饰器工厂</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123; <span class="comment">//  这是装饰器</span></span><br><span class="line">        <span class="comment">// do something with "target" and "value"...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@color(<span class="string">'blue'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="IoC和DI实现原理"><a href="#IoC和DI实现原理" class="headerlink" title="IoC和DI实现原理"></a>IoC和DI实现原理</h1><p>其实在了解完<code>Reflect.getMetadata</code>，我们就大概知道IoC和DI的实现原理，我们以一个<code>@Controller</code>为例, 具体步骤如下：</p>
<ul>
<li>实现<code>@Controller</code>装饰器工厂，标识待注入的类</li>
<li>实现IoC容器，注册要被依赖注入的类</li>
<li>获取待注入的类其构造函数所需要的参数类型，并实例化，返回待注入的类</li>
</ul>
<p>具体代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现Controller装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Controller</span>(<span class="params">path: <span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>)</span>&#123;</span><br><span class="line">        Reflect.defineMetadata(<span class="string">'Controller'</span>, path, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要依赖注入的类</span></span><br><span class="line"><span class="keyword">class</span> A()&#123;</span><br><span class="line">    say()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'aaaaaa'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用</span></span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">"/api"</span>)</span><br><span class="line"><span class="keyword">class</span> Demo()&#123;</span><br><span class="line">    construtor(a: A )&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = A;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    say()&#123;</span><br><span class="line">        <span class="keyword">this</span>.a.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Ioc容器和DI依赖注入</span></span><br><span class="line"><span class="keyword">class</span> Container &#123;</span><br><span class="line">  provides = <span class="keyword">new</span> Map()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 注册要被依赖注入类，形成IoC容器 后续可以做</span></span><br><span class="line">  addProvide(provider) &#123;</span><br><span class="line">    <span class="keyword">this</span>.provides.set(provider.name, provider)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注入依赖类</span></span><br><span class="line">  inject(target) &#123;</span><br><span class="line">      <span class="comment">// 获取参数类型</span></span><br><span class="line">      <span class="keyword">const</span> paramTypes = Reflect.getMetadata(<span class="string">'design:paramtypes'</span>, target) || []</span><br><span class="line">      <span class="keyword">const</span> args = paramTypes.map(<span class="function">(<span class="params"><span class="keyword">type</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">type</span>() <span class="comment">// 简单做一下实例化</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">return</span> Reflect.construct(target, args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> container = <span class="keyword">new</span> Container()</span><br><span class="line"><span class="keyword">const</span> project = container.inject(Project)</span><br><span class="line"></span><br><span class="line"><span class="comment">// project就是最终生成返回使用的类</span></span><br><span class="line"></span><br><span class="line">project.say(); <span class="comment">// 输出 aaaaaa</span></span><br></pre></td></tr></table></figure>

<p>所以Nest.js实现IoC和DI的核心实现原理：</p>
<ul>
<li>通过装饰器给 class 或者对象添加 metadata</li>
<li>运行的时候通过这些元数据来实现依赖的扫描，对象的创建等等功能</li>
</ul>
<p>当然，还有很多问题没解决，目前只是简单实现了依赖注入，上述IoC的问题还没有解决，由于篇幅较长，所以拆成几篇，放到后续继续研究。</p>
]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>有趣的工具收集</title>
    <url>/ideas/20230120.html</url>
    <content><![CDATA[<h1 id="Deprank-js重要性排名"><a href="#Deprank-js重要性排名" class="headerlink" title="Deprank js重要性排名"></a>Deprank js重要性排名</h1><p>一个 JS 工具，按照重要性对本项目的所有脚本进行排序。原理是计算依赖关系，被依赖最多的脚本最重要。</p>
<p>官网：<a href="https://github.com/codemix/deprank" target="_blank" rel="noopener">Deprank</a></p>
<p>例子如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| Filename               | Lines | Dependents | PageRank |</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">| fixtures/core.js       | 3     | 1          | 0.284098 |</span><br><span class="line">| fixtures/utils.js      | 4     | 3          | 0.268437 |</span><br><span class="line">| fixtures/user/user.js  | 4     | 1          | 0.132253 |</span><br><span class="line">| fixtures/todo.js       | 6     | 1          | 0.089796 |</span><br><span class="line">| fixtures/user/index.js | 1     | 1          | 0.089796 |</span><br><span class="line">| fixtures/concepts.js   | 4     | 1          | 0.079694 |</span><br><span class="line">| fixtures/index.js      | 4     | 0          | 0.055926 |</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="FFmpeg-guide流程图生成FFmpeg命令"><a href="#FFmpeg-guide流程图生成FFmpeg命令" class="headerlink" title="FFmpeg.guide流程图生成FFmpeg命令"></a>FFmpeg.guide流程图生成FFmpeg命令</h1><p>一个图形界面，用户拖曳生成线框，表示视频处理的各种命令节点。这个软件会根据节点线框，生成对应的 FFmpeg 命令。</p>
<p>官网：<a href="https://ffmpeg.guide/" target="_blank" rel="noopener">FFmpeg.guide</a></p>
<p><img src="https://camo.githubusercontent.com/88f4911c4947e769f79adb3f3d8133015be0ae4b1c46be98f0faa9f93454b60c/68747470733a2f2f63646e2e6265656b6b612e636f6d2f626c6f67696d672f61737365742f3230323231312f6267323032323131303331342e77656270" alt></p>
<h1 id="blurhash-生成模糊缩略图的工具"><a href="#blurhash-生成模糊缩略图的工具" class="headerlink" title="blurhash 生成模糊缩略图的工具"></a>blurhash 生成模糊缩略图的工具</h1><p>这个工具可以提取图片的颜色分布，生成一个哈希字符串。网页就可以用这个哈希，生成图片的模糊缩略图。</p>
<p>官网：<a href="https://github.com/woltapp/blurhash" target="_blank" rel="noopener">blurhash</a></p>
<p>js应用:<a href="https://github.com/Dens49/blurhash-js" target="_blank" rel="noopener">https://github.com/Dens49/blurhash-js</a></p>
<p>例子如下：</p>
<img src="https://blurha.sh/12c2aca29ea896a628be.jpg" width="269" height="173">
<img src="/assets/img/20230120-idea.png" width="269" height="173">


<h1 id="iconbolt-免费svg-icon网站"><a href="#iconbolt-免费svg-icon网站" class="headerlink" title="iconbolt 免费svg icon网站"></a>iconbolt 免费svg icon网站</h1><p>有点类似阿里的iconfont，但是这个免费的，不需要登录直接使用。</p>
<p><a href="https://www.iconbolt.com/" target="_blank" rel="noopener">iconbolt</a></p>
]]></content>
      <tags>
        <tag>奇思妙想</tag>
      </tags>
  </entry>
  <entry>
    <title>从lerna到初步了解和使用Nx(一)</title>
    <url>/today/20230119.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>自从组内开发架构采用Monorepo大仓项目后，了解一些Monorepo的常用技术，主要采用了<code>lerna</code>框架去做多个子项目统一package.json命令脚本，因此想要了解一下lerna框架，同时也查到lerna的公司同步开发<code>Nx</code>项目，尝试一下它的应用。</p>
<p>想了解Monorepo大仓项目如何设计的可以翻到前往阅读 <a href="https://qborfy.com/today/20230107.html" target="_blank" rel="noopener">《从npm版本依赖到Monorepo大仓项目》</a>。</p>
<a id="more"></a>
<h1 id="lerna"><a href="#lerna" class="headerlink" title="lerna"></a>lerna</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><blockquote>
<p>Lerna是用于TypeScrip/JavaScript的原始monorepo工具。它已经存在多年，被数以万计的项目使用，包括Reaction和Jest。</p>
</blockquote>
<p>了解Lerna，必须想要了解一下<code>monorepo</code>架构， 简单点说，<code>monorepo</code>架构就是将许多不同业务项目的归纳一个仓库中，抽取公共部分，降低版本依赖的复杂度，达到所有项目统一化的架构。</p>
<p>Lerna解决了<code>monorepo</code>架构以下问题：</p>
<ul>
<li>将不同子项目链接在一起，不用发布npm就可以互相引用</li>
<li>可以将命令顺序执行，从而实现将不同项目分发到不同机器</li>
<li>参与CI/CD工作流中，拥有自由的定制脚本功能，从而满足不同的工作流</li>
</ul>
<h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><p>主要有以下几个步骤：</p>
<ul>
<li>初始化项目： <code>npx lerna init</code></li>
<li>修改<code>package.json</code>，去添加一个npm/yarn/pnpm workspace</li>
<li>运行命令<code>lerna run xxx</code>： 统一执行所有子项目的scripts命令，如：lerna run build</li>
</ul>
<p>更加具体的操作，可以到官方文档去查看<a href="https://lerna.js.org/docs/features/run-tasks" target="_blank" rel="noopener">https://lerna.js.org/docs/features/run-tasks</a></p>
<h1 id="Nx"><a href="#Nx" class="headerlink" title="Nx"></a>Nx</h1><p>先说明一下Nx与Lerna的关系：</p>
<blockquote>
<p>Nrwl(开源构建系统NX背后的公司)已经接管了Lerna。NX是一个由前谷歌员工开发的构建系统，它利用了谷歌内部工具使用的许多技术。Lerna v5是这种新管理方式下的第一个版本，它更新了过时的包，并开始对存储库本身进行一些清理。从V5.1+开始，Lerna提供了集成NX的新可能性，并将许多任务调度工作推迟到NX。</p>
</blockquote>
<h2 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h2><p>官方介绍：</p>
<blockquote>
<p>Nx是一个智能、快速和可扩展的构建系统，具有一流的Monorepo支持和强大的集成。</p>
</blockquote>
<p>Nx的目标是：</p>
<ul>
<li>加快你的前端项目工程化</li>
<li>提供一流的开发体验</li>
</ul>
<h2 id="实践-第一个nx项目"><a href="#实践-第一个nx项目" class="headerlink" title="实践-第一个nx项目"></a>实践-第一个nx项目</h2><ul>
<li><p>初始化项目， <code>npx create-nx-workspace@latest package-based --preset=npm</code></p>
</li>
<li><p>添加子项目， 目录下新建标准npm项目<code>packages/is-even</code></p>
</li>
<li><p>安装依赖，在根目录下执行<code>npm i typescript -D -W</code></p>
</li>
<li><p>第一次编译，根目录下执行<code>npx nx build is-even</code></p>
</li>
<li><p>新建第二个子项目，<code>packages/is-odd</code>，在项目中引用<code>is-even</code></p>
</li>
<li><p>关联依赖，在根目录下执行<code>npm install</code>，即可自动实现关联依赖</p>
</li>
<li><p>项目编译依赖，在根目录<code>nx.json</code>新增build依赖，如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "targetDefaults": &#123;</span><br><span class="line">    "build": &#123;</span><br><span class="line">      "dependsOn": ["^build"]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译打包，单独打包子项目<code>is-odd</code>，命令<code>npx nx build is-even</code>，同时会编译打包<code>is-even</code>，因为引用了</p>
</li>
<li><p>再次打包，nx会自动引入上一次build的cache缓存，从而加快编译速度</p>
</li>
<li><p>将所有的子项目统一打包编译，命令:<code>npx nx run-many --target=build</code></p>
</li>
<li><p>如果不需要使用cache缓存，可以使用命令:<code>npx nx run-many --target=build --skip-nx-cache</code></p>
</li>
<li><p>如果需要查看当前子项目依赖的项目是否被修改，可以使用命令：<code>npx nx affected --target=build</code></p>
</li>
</ul>
<p>到此，一个Nx的Monrepo项目就完成了。</p>
<p>当然实际应用中，没有那么简单，后续我们将通过Vue(vite) 、 React去完成一个Nx项目，已经如何和现有的CI工作流结合运行。</p>
<p>同时我们还需要解决这些问题：</p>
<ol>
<li>如何解决非Monrepo项目依赖Monrepo项目的公共代码</li>
<li>如何解决子项目需要发布，但是所依赖的其他子项目不发布问题</li>
<li>如何解决不同项目将采用不同的框架，如Vue、React，项目之间依赖问题？</li>
<li>如何解决不同子项目中依赖同一个npm包，但是版本不一致的问题？是通过前置检查？还是各自完全安装好？</li>
<li>实际应用中，如果遇到子项目需要单独剥离开成立单独项目，应该如何操作？</li>
<li>后续如果子项目越来越多，导致本地开发中项目运行开销过大，无法运行，如何解决？</li>
<li>子项目越来越多，是否有规范可以定义是否需要单独成立子项目？</li>
<li>如何定制公共代码剥离规则？如何检查规则应用？</li>
<li>前后端分离项目和SSR项目能否一起囊括？</li>
<li>项目权限问题如何解决？如：外包人员无法查看其它子项目代码？</li>
<li>……</li>
</ol>
<p>我们有很多问题，但是基本上都是引入Monrepo大仓项目导致的问题，我们希望Nx能有相关的解决方案提供参考或者应用，减少我们实际开发的阻塞。</p>
<p>所以，Nx项目还是持续跟进研究学习，找个实际项目去落地实践，或者将现有一些项目去整合试试看。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>理解React中Fiber架构(一)</title>
    <url>/today/20230117.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>自从React16版本更新了Hook用法，同时引入了新的Fiber架构去重构整个渲染和事件处理过程，React团队引入Hook是为了更好剥离业务代码，让开发能更加友好的抽象代码，达到低耦合的函数组件目的，那么重构Diff算法，引入Fiber架构是为了什么呢？ 其实只是为了能够一个目标<code>快速响应</code>，原先Diff算法时间复杂度为<span>$$ O(n^3)$$</span> ，最后经过Fiber重构达到了$$ O(n) $$，这里面具体有什么门道，值得我们去深入研究一下。</p>
<a id="more"></a>

<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在了解Fiber架构之前，我们需要对原有React16之前版本是有什么问题，才需要引入Fiber架构去解决该问题？</p>
<p>React15及以前的版本采用的是Stack Reconciler（栈协调器）架构，使用同步递归方式去创建虚拟DOM，一旦进入创建过程，就无法中断，如果创建过程超过16ms，用户就会出现页面卡顿感觉。具体可以参考下图：</p>
<p><img src="/assets/img/20230117-1.png" alt></p>
<p>因此，从网上搜索了一下React15及以前的版本反馈，的主要问题有如下几个：</p>
<ul>
<li>React的动画效果表现不佳</li>
<li>React在有大量DOM节点渲染卡顿</li>
</ul>
<h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>为什么会出现卡顿的情况，主要原因如下：</p>
<ol>
<li>JavaScript是单线程，与渲染线程互斥，当其中一个线程执行时，另一个线程只能挂起等待。</li>
<li>Stack Reconciler 栈协调器某个任务是长期占用JavaScript主线程</li>
</ol>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>为了更好了解Fiber架构设计，需要提前了解一些前置知识，每个知识点其实都需要深入了解，这里只是简单描述，主要有以下几点：</p>
<ul>
<li>单线程的 JavaScript 与多线程的浏览器</li>
<li>React生命周期</li>
<li>React虚拟DOM<h2 id="单线程的-JavaScript-与多线程的浏览器"><a href="#单线程的-JavaScript-与多线程的浏览器" class="headerlink" title="单线程的 JavaScript 与多线程的浏览器"></a>单线程的 JavaScript 与多线程的浏览器</h2></li>
</ul>
<p>在我们学习前端知识的时候，有个结论是： <code>单线程的 JavaScript 与多线程的浏览器</code>。</p>
<p>一个完整的web网页在浏览器显示和交互的进程（chrome为主），需要涉及到线程主要以下几个部分：</p>
<ul>
<li><code>GUI 渲染线程</code>，负责渲染浏览器界面HTML元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行。</li>
<li><code>JavaScript引擎线程</code>，JS内核，负责处理Javascript脚本程序。 一直等待着任务队列中任务的到来，然后解析Javascript脚本，运行代码。</li>
<li><code>定时触发器线程</code>，定时器setInterval与setTimeout所在线程，为什么要单独弄个线程处理定时器？是因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确</li>
<li><code>事件触发线程</code>，用来控制事件轮询，JS引擎自己忙不过来，需要浏览器另开线程协助</li>
<li><code>异步http请求线程</code>，在<code>XMLHttpRequest</code>或<code>fetch</code>在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等待处理。这里需要注意<code>XMLHttpRequest</code>和<code>fetch</code>的区别，<code>fetch</code>是w3c标准化后一个专门提供给开发调用发起http的API接口，XMLHttpRequest是一个非标准化的Http请求对象，主要是可以发起http请求获取XML数据。</li>
</ul>
<p>上述就是浏览器的多线程，然后单线程的JavaScript通常指的是<code>JavaScript引擎线程</code>，为什么需要单线程？因为多线程可能会出现各种UI交互冲突问题。因此了解单线程JS需要注意几点：</p>
<ul>
<li>GUI线程和JS引擎是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。</li>
<li>JS 引擎只是任意的 JS 代码按需执行的环境，是其他线程调用触发JS引擎执行JS代码，比如：一个按钮点击触发事件，接着调用js引擎执行等</li>
</ul>
<p>JS 引擎工作流程图如下：</p>
<p><img src="/assets/img/20230117-3.png" alt></p>
<h2 id="React-生命周期"><a href="#React-生命周期" class="headerlink" title="React 生命周期"></a>React 生命周期</h2><p>为了更好了解React Fiber架构，我们需要对比React15和React16的生命周期，具体如下：</p>
<h3 id="React15的生命周期"><a href="#React15的生命周期" class="headerlink" title="React15的生命周期"></a>React15的生命周期</h3><p>在15版本的时候，一个完整的组件生命周期如下（按照执行顺序）：</p>
<ul>
<li>constructor()，组件的构造函数，用来初始化state</li>
<li>componentWillMount()，初始化渲染前时调用</li>
<li>componentDidMount()，初始化渲染后调用</li>
<li>componentWillReceiveProps()，父组件修改组件的props时会调用</li>
<li>render()，每次渲染时候会调用</li>
<li>componentWillUpdate()，组件更新前调用</li>
<li>shouldComponentUpdate()，组件更新时调用，主要判断组件要不要更新</li>
<li>componentDidUpdate()，组件更新后调用</li>
<li>componentWillUnmount()，组件卸载时调用</li>
</ul>
<p><img src="/assets/img/20230117-4.png" alt></p>
<p>按照不同时期，执行过程是不一样，具体可以见React的生命周期更改相关文章。</p>
<h3 id="React16生命周期"><a href="#React16生命周期" class="headerlink" title="React16生命周期"></a>React16生命周期</h3><p>相比较React15，16版本基于Fiber架构主要对更新周期的函数做了调整，整个生命周期如下：</p>
<ul>
<li>constructor()，组件的构造函数，用来初始化state</li>
<li>getDerivedStateFromProps()，初始化/更新时调用，使用 props 来派生/更新 state。</li>
<li>componentDidMount()，初始化渲染后调用</li>
<li>shouldComponentUpdate()，</li>
<li>render()，每次渲染时候会调用</li>
<li>shouldComponentUpdate()，组件更新时调用，主要判断组件要不要更新</li>
<li>getSnapshotBeforeUpdate()，返回值会作为第三个参数给到 componentDidUpdate。它的执行时机是在 render 方法之后，真实 DOM 更新之前。可以同时获取到更新前的真实 DOM 和更新前后的 state&amp;props 信息。</li>
<li>componentDidUpdate()，组件更新后调用，从 getSnapshotBeforeUpdate 获取到的值</li>
<li>componentWillUnmount()，组件卸载时调用</li>
</ul>
<p>对比一下，React 16 废弃的是哪些生命周期：</p>
<ul>
<li>componentWillMount；</li>
<li>componentWillUpdate；</li>
<li>componentWillReceiveProps</li>
</ul>
<p>这些生命周期的共性，就是它们都处于 render 阶段，都可能重复被执行，而且由于这些 API 常年被滥用，它们在重复执行的过程中都存在着不可小觑的风险。</p>
<p>为什么废弃这些生命周期，因为引用了Fiber架构，render 阶段是允许暂停、终止和重启的。这就导致 render 阶段的生命周期都是有可能被重复执行的。</p>
<p>React16生命周期图如下：</p>
<p><img src="/assets/img/20230117-5.png" alt></p>
<h2 id="React-虚拟DOM"><a href="#React-虚拟DOM" class="headerlink" title="React 虚拟DOM"></a>React 虚拟DOM</h2><blockquote>
<p>虚拟 DOM（Virtual DOM）本质上是JS 和 DOM 之间的一个映射缓存，它在形态上表现为一个能够描述 DOM 结构及其属性信息的 JS 对象。</p>
</blockquote>
<p>记住两个点：</p>
<ul>
<li>虚拟 DOM 是 JS 对象</li>
<li>虚拟 DOM 是对真实 DOM 的描述</li>
</ul>
<p>虚拟DOM出现react生命周期的两个节点：</p>
<ol>
<li>挂载阶段，React 将结合 JSX 的描述，构建出虚拟 DOM 树，然后通过 ReactDOM.render 实现虚拟 DOM 到真实 DOM 的映射</li>
<li>更新阶段，页面的变化在作用于真实 DOM 之前，会先作用于虚拟 DOM，虚拟 DOM 将在 JS 层借助算法先对比出具体有哪些真实 DOM 需要被改变，然后再将这些改变作用于真实 DOM，这里就需要DOM Diff算法。</li>
</ol>
<p>为什么需要虚拟DOM？并不是因为虚拟DOM有更高的性能，而是因为虚拟 DOM 的优越之处在于，它能够在提供更爽、更高效的研发模式（也就是函数式的 UI 编程方式）的同时，仍然保持一个还不错的性能。解决了以下问题：</p>
<ol>
<li>研发体验/研发效率的问题，解决以往模板和数据，需要重复调整的问题</li>
<li>跨平台的问题，从web、小程序、app等，一套虚拟DOM，结合不同渲染逻辑，满足各类跨端场景</li>
</ol>
<p>而在虚拟DOM这一块，Fiber架构的引入，最大的调整就是虚拟DOM更新中的diff算法，由于分片渲染，不需要一次将diff执行，可以分批计算从而减少diff算法的复杂度。</p>
<h2 id="Stack-Reconciler-栈协调器"><a href="#Stack-Reconciler-栈协调器" class="headerlink" title="Stack Reconciler(栈协调器)"></a>Stack Reconciler(栈协调器)</h2><p>在了解Fiber架构之前，需要对React15的Stack Reconciler(栈协调器)做一次完整了解。先了解一下什么Reconciler协调器，在React中是这么定义的：</p>
<blockquote>
<p>Virtual DOM 是一种编程概念。在这个概念里，UI 以一种理想化的，或者说“虚拟的”表现形式被保存于内存中，并通过如 ReactDOM 等类库使之与“真实的” DOM 同步。这一过程叫作Reconciler 协调（调和）。</p>
</blockquote>
<p>所以实现Reconciler，其实就是实现虚拟DOM到真实DOM渲染的整个逻辑过程，因此调和 !== Diff，但是Diff 确实是调和过程中最具代表性的一环。</p>
<p>那么要了解React15是如何实现Stack Reconciler，最重要的两块：</p>
<ul>
<li>Diff算法策略</li>
<li>找到diff节点并<code>同步</code>更新渲染</li>
</ul>
<p>Diff算法策略要点：(主要是树递归)</p>
<ol>
<li>Diff 算法性能突破的关键点在于“分层对比”；</li>
<li>类型一致的节点才有继续 Diff 的必要性；</li>
<li>key 属性的设置，可以帮我们尽可能重用同一层级内的节点。</li>
</ol>
<h1 id="Fiber架构"><a href="#Fiber架构" class="headerlink" title="Fiber架构"></a>Fiber架构</h1><p>我们先来看看 React  团队在“React 哲学”中对 React 的定位：</p>
<blockquote>
<p>我们认为，React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式。它在 Facebook 和 Instagram 上表现优秀。</p>
</blockquote>
<p><code>快速响应</code>是React哲学理念，因此Fiber架构的出现是为了让React框架能更加快速响应用户的操作。</p>
<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>什么是 Fiber？从字面上来理解，Fiber 这个单词翻译过来是“丝、纤维”的意思，是比线还要细的东西。在计算机科学里，我们有进程、线程之分，而 Fiber 就是比线程还要纤细的一个过程，也就是所谓的“纤程”。纤程的出现，意在对渲染过程实现更加精细的控制。</p>
<p>Fiber的概念理解：</p>
<ul>
<li>从架构角度来看，Fiber 是对 React 核心算法（即调和过程）的重写</li>
<li>从编码角度来看，Fiber 是 React 内部所定义的一种数据结构，它是 Fiber 树结构的节点单位，也就是 React 16 新架构下的“虚拟 DOM”；</li>
<li>从工作流的角度来看，Fiber 节点保存了组件需要更新的状态和副作用，一个 Fiber 同时也对应着一个工作单元。</li>
</ul>
<p>从架构角度理解Fiber:</p>
<ul>
<li>架构核心：“可中断”“可恢复”与“优先级”</li>
<li>可中断，指的是在Fiber架构下，任何工作任务都可以被更高优先级的任务中断</li>
<li>可恢复，指的是被中断的任务可以被恢复继续执行</li>
<li>优先级，指的是每个任务都有自己的优先级定义</li>
<li>因此需要增加“Scheduler（调度器）”，作用是调度更新的优先级的任务</li>
</ul>
<h2 id="怎么解决问题"><a href="#怎么解决问题" class="headerlink" title="怎么解决问题"></a>怎么解决问题</h2><p>有了Fiber架构，怎么解决React15所面临的问题，虚拟DOM同步渲染真实DOM导致页面卡顿？</p>
<ul>
<li>将虚拟DOM，从原有的树结构，改为链表结构，拆分成一个个Fiber树节点</li>
<li>利用Fiber架构，将渲染过程拆分成一个个工作单元任务，设置优先级，支持可中断、可恢复</li>
<li>这样子当需要渲染复杂DOM时候，同时不影响其他优先级较高工作任务执行</li>
</ul>
<p>可以参考下图，了解一下Fiber架构工作图：</p>
<p><img src="/assets/img/20230117-2.png" alt></p>
<p>当然这样子讲只是简单的原理，还需要弄明白异步后可能产生更多问题？比如如何定制优先级，当两个同样优先级的任务相遇的时候如何解决，这些放在第二章讲解。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过第一篇Fiber文章学习，大概了解到Fiber架构出现的背景和原因，以及它是什么，是如何工作的解决之前所遇到问题。简单总结一下：</p>
<ul>
<li>React中定义Reconciler协调，指的是将虚拟DOM渲染到真实DOM的过程，React15之前采用是stack Reconciler栈协调，同步渲染机制导致页面卡顿</li>
<li>React16之后采用Fiber Reconciler，实现异步渲染DOM</li>
<li>采用新的Fiber架构，同时影响到React的整个生命周期，主要是在更新阶段的生命周期</li>
</ul>
<p>后续深入了解请看第二篇章《从React中学习Fiber架构(二)》。</p>
<h1 id="额外话题（Vue-js对比）"><a href="#额外话题（Vue-js对比）" class="headerlink" title="额外话题（Vue.js对比）"></a>额外话题（Vue.js对比）</h1><p>相比较React做Fiber架构优化，主要是针对事件做了时间分片，那么为什么Vue3(Vue@next)版本并不需要做呢？Vue.js作者尤雨溪是这样子回答的：</p>
<blockquote>
<p>尤雨溪：在 Web 应用中，「可中断式更新」主要是由大量 CPU 计算加上复杂 DOM 操作引起的。时间分片旨在让应用在 CPU 进行大量计算时也能与用户交互，但时间分片只能对大量 CPU 计算进行优化，无法优化复杂 DOM 操作，因为要确保用户正在操作的界面是最新的状态才行。因此，我们可以考虑两种不同的可中断式更新的场景：</p>
<ol>
<li>CPU 计算量不大，但 DOM 操作非常复杂（比如说你向页面中插入了十万个节点）。这种场景下不管你做不做时间分片，页面都会很卡。</li>
<li>CPU 计算量非常大。理论上时间分片在这种场景里会有较大收益，但是人机交互研究表明，除了动画之外，大部分用户不会觉得 10 毫秒和 100 毫秒有很大区别。<br>也就是说，时间分片只在 CPU 需要连续计算 100 毫秒以上的情况下才有较大收益。有意思的地方就出现了，在 React 经常会出现 100 毫秒以上的计算量，因为</li>
<li>Fiber 架构的复杂性导致 React 的虚拟 DOM 协调效率较低，这是系统性的问题。</li>
<li>React 使用 JSX 导致它的渲染效率比 template 低，因为 template 很容易做静态分析和优化。</li>
<li>React Hooks 将大部分组件树的优化 API 暴露给开发者，开发者很多时候需要手动调用 useMemo 来优化渲染效率。这意味着 React 应用默认就有 render 过多的问题。更严重的是，这些优化在 React 里很难自动化。</li>
<li>这些优化要求开发者正确设置依赖数组</li>
<li>盲目添加 useMemo 会导致应该 render 的没 render。<br>很不幸，大部分开发者都很懒，不会在每个地方都加上优化，因此大部分 React 应用都会有大量的没必要的 CPU 计算工作。<br>对比较而言，Vue 解决了上述问题：</li>
<li>Vue 的架构里没有时间分片，也就没有 Fiber，因此简单了很多，这使得渲染可以更快。</li>
<li>Vue 通过分析 template、简化协调过程，做了大量的 AOT 优化，性能测试结果表明大部分的 DOM 内容有 80% 属于静态内容，因此 Vue 3 的协调速度比 Svelte 快，花费的时间比 React 的 1/10 还少。</li>
<li>通过数据响应式追踪，Vue 可以做到组件树级别的优化，比如把插槽编译为函数以避免 children 的变化引发 re-render，比如自动缓存内联事件处理函数以避免 re-render。Vue 3 可以做到在不借助开发者的任何手动优化的情况下，防止子组件在非必要的情况下 re-render。这意味着同样一次更新，React 应用可能要 re-render 多个组件，而 Vue 应用很可能只 re-render 一个组件。<br>因此，在默认情况下，Vue 3 应用会比 React 应用少花费很多 CPU 时间，因而遇到 CPU 连续计算时间超过 100 毫秒的机会相当少，除非是极端情况。但大部分极端情况是 DOM 操作过于复杂，而不是 CPU 计算量太大。</li>
</ol>
</blockquote>
<p>进行汇总一下描述，Vue3之所以没有使用Fiber架构，主要有以下几个原因：</p>
<ol>
<li>Vue.js针对template渲染机制做了多重优化，包括AOT优化(在构建的时候提前进行编译，提前将template转义成render函数)等，使得DOM元素渲染更快</li>
<li>复杂DOM渲染出现超过100ms以上的计算，是因为React本身机制导致，并不是所有复杂的DOM渲染都会需要100ms</li>
<li>React Hook的暴露增加渲染效率的复杂度，从而导致React渲染更慢，从而需要Fiber架构去协调</li>
<li>Vue数据响应式追踪机制，避免了多次重复render组件树，提高渲染效率</li>
<li>Vue使用Fiber架构去实现，确实可以有好处，但是会增加整体代码体积和复杂度，投入产出比太低</li>
</ol>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="AOT-vs-JIT"><a href="#AOT-vs-JIT" class="headerlink" title="AOT vs JIT"></a>AOT vs JIT</h3><ul>
<li>AOT，Ahead Of Time，提前编译或预编译，宿主环境获得的是编译后的代码，在浏览器中我们可以直接下载并运行编译后的代码，比如：Vue的template是通过Vue-loader编译后才能使用。</li>
<li>JIT，Just In Time，即时编译 ，代码在宿主环境编译并执行，每个文件都是单独编译的，当我们更改代码时不需要再次构建整个项目，比如：React中JSX只有在浏览器运行的时候才知道具体代码。</li>
</ul>
]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>从Z-Library到了解IPFS去中心化技术</title>
    <url>/today/20230116.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近想下载一些免费的电子书，然后找到一个推荐的网站，说是去中心化图书馆，利用去中心化，可以永久有效的，就是<code>Z-Library</code>，因此觉得挺有趣，所以适合简单研究一下。</p>
<h1 id="Z-Library"><a href="#Z-Library" class="headerlink" title="Z-Library"></a>Z-Library</h1><blockquote>
<p>Z-Library（简称Z-Lib，前身为BookFinder）是一个影子图书馆和开放获取文件分享计划，用户可在此一网站上下载期刊文章以及各种类型的书籍。根据Z-Library的说法，截至2022年6月12日，其共收录了10,456,034本书和84,837,646篇文章[1]。Z-Library在其电子书搜索页面上宣称自己是“全球最大的数字图书馆”[2]，并在文章搜索页面上称自身是“全球最大的科学文章存储库”[3]。它原是创世纪图书馆的镜像网站，并从该图书馆获得大部分馆藏。但它的一些馆藏由用户自行上载，并且不为创世纪图书馆所收藏[4]。该平台公开网域已于2022年11月3日遭到美国政府屏蔽。</p>
</blockquote>
<p>ZLibrary虽然是一个俄国网站，但它拥有16种语言版本可供选择，下滑至网页末尾，即可切换语言。</p>
<p>访问地址：<a href="https://zlib.cydiar.com/" target="_blank" rel="noopener">https://zlib.cydiar.com/</a><br>访问地址：<a href="https://bk.hallowlib.org/" target="_blank" rel="noopener">https://bk.hallowlib.org/</a> 国内备用网址</p>
<a id="more"></a>
<h2 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h2><p>除了上述提供的网址后，可以在里面访问直接跳转下载，但是同时也提供了IPFS节点下载地址。具体如下图：</p>
<p><img src="/assets/img/20230116.png" alt></p>
<h2 id="IPFS下载"><a href="#IPFS下载" class="headerlink" title="IPFS下载"></a>IPFS下载</h2><p>需要在本地搭建IPFS节点，才可以正常文件，但是国内经常会访问不了，所以不建议搭建，因此只是简单了解一下背后技术即可。</p>
<p>接下来具体讲解一下什么是IPFS。</p>
<h1 id="IPFS"><a href="#IPFS" class="headerlink" title="IPFS"></a>IPFS</h1><blockquote>
<p>星际文件系统(InterPlanetary File System). IPFS 是一个分布式的web, 点到点超媒体协议. 可以让我们的互联网速度更快, 更加安全, 并且更加开放. IPFS协议的目标是取代传统的互联网协议HTTP。</p>
</blockquote>
<p>HTTP协议的缺陷：</p>
<ul>
<li>使用HTTP协议每次需要从中心化的服务器下载完整的文件</li>
<li>Web文件经常被删除</li>
<li>经常受各种限制，导致文件无法正常下载</li>
</ul>
<p>IPFS是一个协议，类似http协议，主要定义了：</p>
<ul>
<li>定义了基于内容的寻址文件系统</li>
<li>内容分发</li>
<li>使用的技术分布式哈希、p2p传输、版本管理系统</li>
<li>可以像http那样查看互联网页面</li>
<li>IPFS是一个文件系统，有文件夹和文件，可挂载文件系统</li>
<li>未来浏览器可以直接支持 ipfs:/ 或者 fs:/ 协议</li>
</ul>
<p>底层架构介绍：</p>
<ul>
<li>IPFS是模块化的协议， 分为连接层、路由层、数据块交换</li>
<li>连接层：通过其他任何网络协议连接</li>
<li>路由层：寻找定位文件所在位置</li>
<li>数据块交换：采用BitTorrent技术</li>
<li>p2p系统：世界范围内的p2p文件传输网络</li>
<li>是一个CDN，文件添加到IPFS网络，将会在全世界进行CDN加速</li>
<li>IPNS：基于SFS（自认证系统）命名体系，可以和现有域名系统绑定</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>IPFS主要是使用go语言实现的，目前主流的IPFS实现有几个框架，具体如下：</p>
<ul>
<li><a href="https://github.com/ipfs/kubo" target="_blank" rel="noopener">go-ipfs</a></li>
<li><a href="https://github.com/ipfs/js-ipfs" target="_blank" rel="noopener">js-ipfs</a></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Z-Library是一个去中心化的图书馆，大家都有各自的节点维护自己的个人图书，也可以从其他节点去下载，降低现有web文件存储的缺陷。</p>
<p>而IPFS的出现刚好可以满足这个理想目标，IPFS是一个协议，同时已经有现有框架go-ipfs去快速搭建个人的IPFS节点，所以能够很快体验一下去中心化体验，但是很多时候由于网络问题，并不能很快完成书籍的下载。</p>
<p>虽然IPFS同时实现HTTP协议，但是访问其他节点的时候是有网络访问速度问题，因此体验不是特别好，但是新的技术概念还是需要时间去沉淀和学习，留此文章做个mark，继续保留学习的态度。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/ipfs/ipfs-desktop/releases" target="_blank" rel="noopener">IPFS下载桌面端</a><br><a href="https://cloud.tencent.com/developer/article/1815072" target="_blank" rel="noopener">IPFS搭建HTTPS去中心化网站，真实可用</a></p>
]]></content>
      <tags>
        <tag>每日更新</tag>
        <tag>技术探鲜</tag>
      </tags>
  </entry>
  <entry>
    <title>自己尝试运行大语言模型</title>
    <url>/today/20230311.html</url>
    <content><![CDATA[<p>自己尝试运行大语言模型</p>
<p><a href="https://hub.baai.ac.cn/view/25299" target="_blank" rel="noopener"></a><br><a href="https://github.com/THUDM/ChatGLM-6B" target="_blank" rel="noopener">https://github.com/THUDM/ChatGLM-6B</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>学习总结</tag>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端适配方案总结</title>
    <url>/today/20230111.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>由于自己太久没开发移动端的页面，个人觉得移动端开发相比较PC端开发最大的不同，在于需要去适配各种尺寸的手机屏幕，尤其还有1px的问题。</p>
<p>因此需要再次收集一下，除了自己认知(rem适配)以外，是否还有移动端适配的方案吗？</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>移动端存在几类问题，如下所列：</p>
<ul>
<li>1px显示过粗问题</li>
<li>手机屏幕出现刘海屏、滴水屏等，如何适配</li>
<li>如何在不同屏幕，显示正确高清图片</li>
<li>meta 的 viewport 值 能否用来适配</li>
<li>rem，vw，vh计算单位的区别</li>
<li>…</li>
</ul>
<a id="more"></a>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h2><blockquote>
<p>像素是计算机屏幕上所能显示的最小单位。用来表示图像的单位。</p>
</blockquote>
<p>按照我个人理解，把屏幕比做一张白纸，然后像素就是一个点，接着同一水平线上的点形成一条线，水平线和垂直线同时就形成一个画面。</p>
<p>然后对于我们前端开发而言，像素又需要分成几类：</p>
<ul>
<li><code>设备独立像素</code>, 俗称<code>DIP</code>，你可以理解成我们平时用css像素 又等于 逻辑像素，简单说就是同一个尺寸的屏幕，设备独立像素是一样的，从而减少误解</li>
<li><code>物理像素</code>，其实就是我们真实肉眼可见的像素，物理像素 = 分辨率</li>
<li><code>设备像素比</code>， <code>DPR</code> <code>devicePixelRatio</code> = 设备像素 / 设备独立像素，当物理像素和设备独立像素不一样的时候，这个时候就需要一个标准来做适配，利用<code>DPR</code>我们能将同样的画面适应不同的屏幕</li>
<li><code>每英寸像素</code> <code>ppi</code> （pixel per inch），表示每英寸所包含的像素点数目，更确切的说法应该是像素密度。数值越高，说明屏幕能以更高密度显示图像</li>
</ul>
<h2 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h2><blockquote>
<p>分辨率指屏幕上像素的数目，一般用水平<em>垂直，比如：屏幕分辨率为 800</em> 600， 水平有800个像素点，垂直有600个像素</p>
</blockquote>
<p>所以平时我们将2k、4k屏幕，通常指的是水平方向的存放像素超过2000或4000个。</p>
<h2 id="视口（viewport）"><a href="#视口（viewport）" class="headerlink" title="视口（viewport）"></a>视口（viewport）</h2><blockquote>
<p>视口代表当前可见的计算机图形区域。在 Web 浏览器术语中，通常与浏览器窗口相同，但不包括浏览器的 UI，菜单栏等——即指你正在浏览的文档的那一部分。<br>视口一般是指用户访问页面时，当前的可视区域范围。通过滚动条滑动，视口可以显示页面的其他部分。<br>通过 document.documentElement.clientWidth 或 window.innerWidth 可以获取视口宽度。</p>
</blockquote>
<p>简单的说，视口就是浏览器肉眼可见的区域，是随时可变化，视口是一个概念，它又可以根据不同情况分为以下几种：</p>
<ul>
<li>布局视口，对于开发来说的一种视口概念，在移动端可以通过 <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=980, initial-scale=1.0&quot;&gt;&lt;/meta&gt;</code>调整从而将打屏显示的内容完整缩小适配到移动端小屏</li>
<li>视觉视口，是一种针对移动端屏幕提出来的概念，具体是指的屏幕的可见区域，当键盘弹起、浏览器工具栏隐藏等，视觉视口都会随之变化，而布局视口不会</li>
</ul>
<h2 id="布局视口（layout-viewport）"><a href="#布局视口（layout-viewport）" class="headerlink" title="布局视口（layout viewport）"></a>布局视口（layout viewport）</h2><blockquote>
<p>innerHeight 和 innerWidth 所组成的区域通常被认为是布局视口（layout viewport）。浏览器的框架不被认为是视口的一部分。</p>
</blockquote>
<p>在PC端的时候， 视口=布局视口=视觉视口。</p>
<p>在移动端的时候，布局视口 = 内容宽度，可以通过<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=980, initial-scale=1.0&quot;&gt;&lt;/meta&gt;</code>调整，下面举几个例子(移动端为375*667)：</p>
<ul>
<li><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=980, initial-scale=1.0&quot;&gt;&lt;/meta&gt;</code>， 布局视口=window.innerWidth=980</li>
<li><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;/meta&gt;</code>, 布局视口=window.innerWidth=375</li>
</ul>
<h2 id="视觉视口（visual-viewport）"><a href="#视觉视口（visual-viewport）" class="headerlink" title="视觉视口（visual viewport）"></a>视觉视口（visual viewport）</h2><blockquote>
<p>视觉视口指当前浏览器中可见的部分，并且可以变化。当使用双指缩放，或键盘在手机上弹出的时候，或者之前隐藏的地址栏变得可见的时候，视觉视口缩小了，但是布局视口却保持不变。</p>
</blockquote>
<p>相比较<code>布局视口</code>概念，视觉视口是由苹果 乔布斯提出，为了更好的在移动端展示web网页，视觉视口=屏幕的可见区域，下面通过几个例子去认知(移动端为375*667)：</p>
<ul>
<li><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=980, initial-scale=1.0&quot;&gt;&lt;/meta&gt;</code>，视觉视口=window.screen.width=375</li>
<li><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;/meta&gt;</code>，视觉视口=window.screen.width=375</li>
</ul>
<h2 id="viewport设置项"><a href="#viewport设置项" class="headerlink" title="viewport设置项"></a>viewport设置项</h2><p><code>viewport</code>的设置主要是在移动端配置视口大小，从width宽度，initial-scale缩放等设置属性，具体如下：</p>
<ul>
<li>width：控制 viewport 的大小，可以给它指定一个值(正整数)，或者是一个特殊的值(如：device-width 设备独立像素宽度，单位缩放为 1 时)；</li>
<li>initial-scale：初始缩放比例，即当页面第一次加载时的缩放比例，为一个数字(可以带小数)；</li>
<li>maximum-scale：允许用户缩放到的最大比例，为一个数字(可以带小数)；</li>
<li>minimum-scale：允许用户缩放到的最小比例，为一个数字(可以带小数)；</li>
<li>user-scalable：是否允许用户手动缩放，值为 “no”(不允许) 或 “yes”(允许)；</li>
<li>height：与 width 相对应(很少使用)。</li>
</ul>
<h2 id="注意项"><a href="#注意项" class="headerlink" title="注意项"></a>注意项</h2><ul>
<li>iframe的视口等于是其内部高度和宽度的大小。</li>
<li>SVG的视口即 SVG 图片的可视区域。</li>
</ul>
<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p>这些兼容方案都是基于视口不缩放配置才能生效：<br><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;/meta&gt;</code></p>
<p>目前市面主流的几种适配方案如下：</p>
<ul>
<li><code>rem</code> ，通过一个宽度尺寸作为统一的单位值，然后通过js计算出不同尺寸对比值，得到适配效果</li>
<li><code>vw</code> ，一个浏览器支持的单位，利用 CSS 视窗的特性，总宽度为 100vw，每一份为一个单位 1vw，设置 1rem 单位为 10vw</li>
<li><code>px + calc + clamp</code>，大漠在2021年提出，根据 CSS 的新特性：css变量、calc()函数、clamp()、@container函数实现</li>
</ul>
<h2 id="rem方案"><a href="#rem方案" class="headerlink" title="rem方案"></a>rem方案</h2><p><code>rem</code>是指的html元素的<code>font-size</code>的大小，如：<code>html{font-size:50px}; 1rem=50px</code>。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>通过一个具体的例子，更好理解它的原理。比如你拿到一张设计稿为750px宽度的，里面有个长方形为100*200，这个时候需要在不同屏幕去做适配。</p>
<p>rem的解决方案思路为：</p>
<ul>
<li>将标准尺寸宽度 750/10= 75px，设置:<code>html{font-size:75px} 1rem=75px</code></li>
<li>将长方形的 100*200，100/75 * 200/75，设置为：<code>.rectangle{width: 1.33rem;height:2.66rem}</code></li>
<li>那么当屏幕的尺寸发生变话的时候， 变成从750减少为375，那么这个时候，设置: <code>html{font-size:37.5px} 1rem=37.5px</code></li>
<li>长方形的css设置无需变化，从而达到适配的效果</li>
<li></li>
</ul>
<p>所以rem的解决方案就是在web应用在加载的时候，提前计算好rem单位，所以就可以完成适配。</p>
<p>目前主流的方案有：</p>
<ul>
<li><a href="https://github.com/amfe/lib-flexible" target="_blank" rel="noopener">flexible</a></li>
<li><a href="https://github.com/songsiqi/px2rem" target="_blank" rel="noopener">px2rem</a></li>
</ul>
<p>源码实现：</p>
<p><a href="/code/h5-shipei/flexible.js">h5-shipei.js</a></p>
<p>PS: 里面涉及到<code>pageshow</code>事件，基本上是因为移动端缓存了web页面，当浏览器历史记录前进或后退的是会触发，可以通过<code>e.persisted</code>判断是否从缓存获取</p>
<p>缺点：</p>
<ul>
<li>需要前置js才能实现，根据设备的视窗宽度进行计算，影响性能</li>
<li>在 PC 端浏览破相，一般设置一个最大宽度</li>
</ul>
<h2 id="vw方案"><a href="#vw方案" class="headerlink" title="vw方案"></a>vw方案</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>vw是css的一种计算单位，定义： </p>
<blockquote>
<p>1vw 等于1/100的视口宽度 （Viewport Width）</p>
</blockquote>
<p>同理vh也是:</p>
<blockquote>
<p>1vh 等于1/100的视口高度 （Viewport Height）</p>
</blockquote>
<p>那么vmax，vmin，我在网上找到比较好解释如下：</p>
<blockquote>
<p>vmin — vmin的值是当前vw和vh中较小的值。<br>vmax — vw和vh中较大的值。<br>在横竖屏的切换中，十分有用。</p>
</blockquote>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>了解到vw的概念，那么如何利用vw去解决移动端的适配呢？其实和rem方案是一样，具体代码可以如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* rem 方案 */</span></span><br><span class="line"><span class="selector-tag">html</span> &#123; <span class="attribute">font-size</span>: width / <span class="number">100</span>&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123; <span class="attribute">width</span>: <span class="number">26.67rem</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* vw 方案 */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123; <span class="attribute">width</span>: <span class="number">26.67vw</span> &#125;</span><br></pre></td></tr></table></figure>

<p>已实现的框架方案如下：</p>
<p><a href="https://github.com/evrone/postcss-px-to-viewport/blob/master/README_CN.md" target="_blank" rel="noopener">postcss-px-to-viewport</a></p>
<p>利用打包编译过程，将设置好的px单位转换为vw或vh，具体使用可以看使用文档。</p>
<p>缺点：</p>
<ul>
<li>和rem一样，容易在pc端适配错误，可以用@media媒体查询去做样式兼容</li>
</ul>
<p><strong>后续添加</strong></p>
<p>如果利用flex/grid布局，加上vw、vh单位，是否可以做到自适应布局呢？</p>
<p>答案是肯定，而且相对而言会比其他方案，会更加容易开发些，实现步骤如下：</p>
<ul>
<li>利用flex弹性布局，加上vw设置flex弹性盒子的宽度，从而做到不同宽度屏幕，是否换行或者垂直布局</li>
</ul>
<p>后续可以专门写个文章用来描述flex布局的原理。</p>
<h2 id="px-calc-clamp"><a href="#px-calc-clamp" class="headerlink" title="px + calc + clamp"></a>px + calc + clamp</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p><code>calc()</code> 此 CSS 函数允许在声明 CSS 属性值时执行一些计算。 支持  + ， - ， / ,* 等运算。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* property: calc(expression) */</span></span><br><span class="line"><span class="selector-tag">width</span>: <span class="selector-tag">calc</span>(100% <span class="selector-tag">-</span> 80<span class="selector-tag">px</span>);</span><br></pre></td></tr></table></figure>

<p><code>clamp()</code> 函数的作用是把一个值限制在一个上限和下限之间，当这个值超过最小值和最大值的范围时，在最小值和最大值之间选择一个值使用。它接收三个参数：最小值、首选值、最大值。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">font-size</span>: <span class="selector-tag">clamp</span>(1<span class="selector-tag">rem</span>, 2<span class="selector-class">.5vw</span>, 2<span class="selector-tag">rem</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>当<code>2.5vw</code>大于<code>2rem</code>，使用2rem</li>
<li>当<code>2.5vw</code>小于<code>1rem</code>，使用1rem</li>
<li>其他使用<code>2.5vw</code>单位</li>
</ul>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>了解到上面css两个函数，如果通过只用px单位去做适配呢？原理步骤如下：</p>
<ul>
<li>假设我们拿到的设计稿750px宽度，那么这个时候有个长方体是200*100</li>
<li>利用css变量，设置一个首先值，然后计算出去其他尺寸所需的最大值、最小值，设置clamp()</li>
<li>同时利用calc()去计算偏差值</li>
</ul>
<p>缺点：</p>
<ul>
<li>calc 和clamp 函数在浏览器支持度还不够</li>
<li>需要了解这套方案还需要较深的技术方案</li>
</ul>
<h1 id="1px高清显示问题"><a href="#1px高清显示问题" class="headerlink" title="1px高清显示问题"></a>1px高清显示问题</h1><p>1像素问题： 1像素指在 Retina 屏显示 1单位物理像素</p>
<ul>
<li>DPR = 1，此时 1 物理像素 等于 1 CSS 像素</li>
<li>DPR = 2，此时 1 物理像素等于 0.5 CSS 像素</li>
<li>border-width: 1px，这里的 1px 其实是 1 CSS 像素宽度，等于 2 物理像素，设计师其实想要的是 border-width: 0.5px<br>DPR = 3，此时 1 物理像素等于 0.33 CSS 像素。设计师想要的是 border-width: 0.33px</li>
</ul>
<p>解决方案：</p>
<ul>
<li>渐变实现 ： background-image: linear-gradient(to top, ,,,)</li>
<li>使用缩放实现：transform: scaleY(0.333)</li>
<li>使用图片实现：base64</li>
<li>使用 SVG 实现：嵌入 background url</li>
<li>border-image，低端机下支持度不好</li>
</ul>
<p>以上方案都是基于媒体查询解决的</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">media</span> only screen and (-webkit-min-device-pixel-ratio: <span class="number">2</span>),</span><br><span class="line">    only screen and (min-device-pixel-ratio: <span class="number">2</span>) &#123;&#125;</span><br><span class="line">@<span class="keyword">media</span> only screen and (-webkit-min-device-pixel-ratio: <span class="number">3</span>),</span><br><span class="line">    only screen and (min-device-pixel-ratio: <span class="number">3</span>) &#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h1><blockquote>
<p>媒体查询（Media queries）非常实用，尤其是当你想要根据设备的大致类型（如打印设备与带屏幕的设备）或者特定的特征和设备参数（例如屏幕分辨率和浏览器视窗宽度）来修改网站或应用程序时。</p>
</blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>一般有几种用法，如下所示：</p>
<ul>
<li>通过 <code>@media</code> 和 <code>@import at-rules</code> 用CSS 装饰样式</li>
<li>用 <code>media=</code> 属性为<code>&lt;style&gt;, &lt;link&gt;, &lt;source&gt;</code>和其他HTML元素指定特定的媒体类型</li>
<li>使用<code>Window.matchMedia()</code>和 <code>MediaQueryList.addListener()</code> 方法来测试和监控媒体状态</li>
</ul>
<p>CSS装饰样式用法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen, print &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>HTML元素引入</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">src</span>=<span class="string">"styles.css"</span> <span class="attr">media</span>=<span class="string">"screen"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">src</span>=<span class="string">"styles.css"</span> <span class="attr">media</span>=<span class="string">"print"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>js用法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mql = <span class="built_in">window</span>.matchMedia(<span class="string">'(max-width: 600px)'</span>);</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">".mq-value"</span>).innerText = mql.matches;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mql = <span class="built_in">window</span>.matchMedia(<span class="string">'(max-width: 600px)'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">screenTest</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.matches) &#123;</span><br><span class="line">    <span class="comment">/* the viewport is 600 pixels wide or less */</span></span><br><span class="line">    para.textContent = <span class="string">'This is a narrow screen — less than 600px wide.'</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.style.backgroundColor = <span class="string">'red'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* the viewport is more than than 600 pixels wide */</span></span><br><span class="line">    para.textContent = <span class="string">'This is a wide screen — more than 600px wide.'</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.style.backgroundColor = <span class="string">'blue'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mql.addListener(screenTest);</span><br></pre></td></tr></table></figure>

<h1 id="图片高清问题"><a href="#图片高清问题" class="headerlink" title="图片高清问题"></a>图片高清问题</h1><p>图片高清问题，一般是指的：不同 DPR 下图片的高清解决方案。</p>
<p>这种问题解决方案，通常是利用媒体查询+提供不同尺寸的图片去显示。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>移动端适配方案，结合开发中，大家都是直接写px，然后利用编译过程的进行转换，比如: <code>px2rem</code> ，<code>px2vw</code>。</p>
<p>再就是排版问题，不同屏幕问题需要做自动排版优化方案，这个需要后面去研究一下<a href="https://news.sangniao.com/p/1729687518" target="_blank" rel="noopener">《如何正确的使用 CSS Clamp 进行响应式排版》</a>。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>从egg.js转到nest.js</title>
    <url>/today/20230110.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>进入部门工作后，接触到的node.js服务端框架，是egg.js，后面基于扩展增加了很多插件，比如：@Controller @Service等注解，还有针对egg-framework 定制化部门使用的底层framework。</p>
<p>但是，随着时间的迁移，egg已经不太能满足我们的开发效率和开发模式，主要有以下几点：</p>
<ul>
<li>对typescript支持度不够，这是由于egg.js本身就不是typescript开发</li>
<li>egg.js封装web架构，约定大于编码，如：强制将web应用分级为： controller、service、middleware、extend等，自由度相对比较弱，当你需要定制化开发内容，你需要深入了解egg.js的整个运行原理才能实现</li>
<li>虽然部门内部定制化开发 @Controller @Service等注解，减少路由配置，但是这一块插件还存在一些隐藏规则，需要开发注意</li>
</ul>
<p>当然egg.js运行的web应用还是比较稳定，而且相关插件生态也比较丰富，只是当egg.js迭代更新速度在2020年后就逐步放缓，更不上变化，我们就需要迎接一些新的框架来满足要求。</p>
<h1 id="框架对比"><a href="#框架对比" class="headerlink" title="框架对比"></a>框架对比</h1><p>我从近两年听到或者网上收集的，基于Node.js的框架主要有以下几个：</p>
<ul>
<li>基础框架，基本上还是以express、koa、Fastify.js等为主</li>
<li>egg.js，以MVC为架构的web框架</li>
<li>nest.js，以Ioc 控制反转作为核心概念的web框架，对typescript支持友好</li>
<li>nuxt.js，以Vue.js作为SSR服务端渲染核心的web框架，最新是Nuxt3（以Vue3为核心）</li>
<li>next.js，以React.js作为SSR服务端渲染核心的</li>
<li>Meteor.js，full-stack javascript平台，最大的特点是当数据发生改变的时候，所有依赖该数据的地方自动发生相应的改变。</li>
<li>Fastify.js，号称最快的node.js web框架，特点是内置了基于 JSON schema 的 validation 和 serialization，比JSON.stringify还快的json序列化算法，虽然是借助借助第三方库 ajv。</li>
<li>strapi.js，快速生成API接口的web框架，同时实现各种后端所需要的鉴权、权限、文件上传等轮子</li>
</ul>
<a id="more"></a>

<p>对比一下，我们主要用来开发后端api接口，不需要SSR，不需要过于重或过于轻量的框架，因此最后挑选了nest.js。</p>
<h1 id="nest-js"><a href="#nest-js" class="headerlink" title="nest.js"></a>nest.js</h1><blockquote>
<p>Nest (NestJS) 是一个用于构建高效、可扩展的Node.js服务器端应用程序的框架。它使用渐进式 JavaScript，构建并完全支持TypeScript（但仍然允许开发人员使用纯 JavaScript 进行编码）并结合了 OOP（面向对象编程）、FP（函数式编程）和 FRP（函数式响应式编程）的元素。</p>
</blockquote>
<p>术语介绍：</p>
<ul>
<li>什么是渐进式？简单说，就一开始你不需要了解它的全部功能，能快速上手，有些功能特性不用也可以正常使用。</li>
<li>OOP 面向对象编程，万物皆可用对象来描述，如： <code>class Dog{ say(return &#39;one one!&#39;)}</code></li>
<li>FP 函数式编程，以函数作为入口，而不是去声明一个对象类，如： <code>say(&#39;one one!&#39;)</code></li>
<li>RP 响应式编程，一种面向数据流和变化传播的编程范式，如：<code>a = 5; b=6; c=a+b;</code> 当<code>a</code>或<code>b</code>变化的时候，<code>c</code>会随之变化</li>
<li>FRP 函数式响应式编程，依赖数据流的函数式编程，如：<code>str=&#39;one one~&#39;; say(str)</code>， 当<code>str</code>变化，会自动触发<code>say</code></li>
</ul>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>Nest.js的核心是基于IoC控制反转 + DI 依赖注入 去实现类的声明和实例化的。如果你了解过Spring Boot其实很容易上手nest.js。</p>
<h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>Module 其实是nest.js用来将一个web应用拆分成各个子模块的分类规定，web应用根模块一般叫<code>app.module.ts</code>，官方设计图如下：</p>
<p><img src="https://docs.nestjs.com/assets/Modules_1.png" alt></p>
<p>Module应该由以下几个部分组成：</p>
<ul>
<li>providers： 允许交给模块实例化的类，包括不限于Service等</li>
<li>controllers：必须实例的controller类</li>
<li>imports： 模块依赖其他模块</li>
<li>exports：模块对外提供的方法类</li>
</ul>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>Controller就一个作用，分割路由，调用处理方法，返回http请求结果。</p>
<p><img src="https://docs.nestjs.com/assets/Controllers_1.png" alt></p>
<p>支持写法：</p>
<ul>
<li><code>@Controller(&#39;test&#39;)</code></li>
<li><code>@Get()</code> <code>@Post()</code> <code>@Put()</code> <code>@Del()</code>代表各种请求方法(http Method)</li>
<li>还支持一些特殊写法： <code>@Session()</code>  <code>@Body(key?: string)</code> <code>@Param(key?: string)</code></li>
</ul>
<h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><p>Provider其实就是不仅仅是Service层，还包括：Sql的Dao层、工具方法等提供。它和其他层关系如下图：</p>
<p><img src="https://docs.nestjs.com/assets/Components_1.png" alt></p>
<p>写法：</p>
<ul>
<li><code>@Injectable()</code> 声明该类是一个Provider，允许其他类实现依赖注入</li>
<li><code>@Optional()</code> 允许构造不传</li>
<li><code>@Inject()</code> 自动依赖注入</li>
</ul>
<h2 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a>Middleware</h2><p>Middleware中间件，其实和egg.js的中间件概念一样，就是当http请求来了之后，被中间件处理一遍之后才会到对应的Controller层。</p>
<p><img src="https://docs.nestjs.com/assets/Middlewares_1.png" alt></p>
<p>写法：</p>
<ul>
<li><code>implements NestMiddleware</code>，必须实现<code>NestMiddleware</code>接口，以及内部方法<code>use(req: Request, res: Response, next: NextFunction)</code>，同时内部方法必须调用<code>next</code></li>
<li>在<code>Module</code>层注册中间件，这里需要可以设置</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module, NestModule, MiddlewareConsumer &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; LoggerMiddleware &#125; <span class="keyword">from</span> <span class="string">'./common/middleware/logger.middleware'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsModule &#125; <span class="keyword">from</span> <span class="string">'./cats/cats.module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  imports: [CatsModule],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule <span class="keyword">implements</span> NestModule &#123;</span><br><span class="line">  configure(consumer: MiddlewareConsumer) &#123;</span><br><span class="line">    consumer</span><br><span class="line">      .apply(LoggerMiddleware)</span><br><span class="line">      .forRoutes(<span class="string">'cats'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>了解 <code>MiddlewareConsumer</code>，中间件消费者工具类，主要把中间件加上一些配置项功能，如：<code>forRoutes</code>支持路由匹配，<code>exclude</code>不包含路由</li>
<li>函数式声明中间件，因为Middleware是基于expres，所以写法与express基本上一致</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Request, Response, NextFunction &#125; <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">logger</span>(<span class="params">req: Request, res: Response, next: NextFunction</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Request...`</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="ExceptionFilter"><a href="#ExceptionFilter" class="headerlink" title="ExceptionFilter"></a>ExceptionFilter</h2><p>Filter过滤器，这个应该是所有web框架都具备的功能，拦截用户请求和web返回数据。在Nest.js中，只实现ExeptionFilter，你也可以基于这个去自定义自己的异常过滤器，具体如下图：</p>
<p><img src="https://docs.nestjs.com/assets/Filter_1.png" alt></p>
<p>写法：</p>
<ul>
<li><code>@Catch(HttpException) class HttpExceptionFilter implements ExceptionFilter</code> 实现自定义异常过滤器</li>
<li><code>@UseFilters(new HttpExceptionFilter())</code> 能给具体接口包裹上一层自定义的异常过滤器</li>
</ul>
<h2 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h2><p>Pipe 管道流，是指的Http请求里的内容数据流，它支持数据验证、数据转换等功能，有点类似Filter的功能。</p>
<p>写法：</p>
<ul>
<li><code>@Param(&#39;id&#39;, ParseIntPipe) id: number</code>，将参数id转换为number类型</li>
<li><code>class ValidationPipe implements PipeTransform</code>自定义 Pipe，同时必须实现方法<code>transform(value: any, metadata: ArgumentMetadata)</code></li>
<li><code>@UsePipes(new Pipe())</code>，支持在controller配置自定义的Pipe</li>
</ul>
<h2 id="Guard"><a href="#Guard" class="headerlink" title="Guard"></a>Guard</h2><p>Guard 守卫，也是处Http请求中的一层特殊中间件，但是与中间件不同的时候，中间件不知道next()是去哪个执行代码，而Guard则可以获取<code>ExecutionContext</code>实例，可以获知整个请求的生命周期和内置内容，通常用来接口登录和权限控制。</p>
<p><img src="https://docs.nestjs.com/assets/Guards_1.png" alt></p>
<p>写法：</p>
<ul>
<li><code>class AuthGuard implements CanActivate</code></li>
<li>必须实现方法<code>canActivate(context: ExecutionContext): boolean | Promise&lt;boolean&gt; | Observable&lt;boolean&gt;</code></li>
<li>注册使用：<code>@UseGuards</code> Controller层使用， <code>app.useGlobalGuards(new RolesGuard());</code> 全局注册</li>
</ul>
<h2 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h2><p>Interceptor是面向切面编程理念影响的概念，它允许你在方法执行前后扩展原有函数功能，如：改变返回结果，扩展基本功能等，常用的场景：添加常规日志。</p>
<p><img src="https://docs.nestjs.com/assets/Interceptors_1.png" alt></p>
<p>写法：</p>
<ul>
<li><code>class LoggingInterceptor implements NestInterceptor</code>,自定义实现</li>
<li><code>intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt;</code>方法实现，同时需要返回对应结果<code>next()</code></li>
<li>注册使用：<code>@UseInterceptors(LoggingInterceptor)</code>可以在类或方法前进行注册， <code>app.useGlobalInterceptors(new LoggingInterceptor());</code>全局注册</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>自定义参数装饰器<code>createParamDecorator</code>，可以从request对象中抽取固定的参数。</li>
<li><code>applyDecorators</code> 可以将多个装饰器 方法合在一起验证，然后形成一个新的注装饰器</li>
</ul>
<p>PS: 装饰器是什么？</p>
<ul>
<li>装饰器在JavaScript中暂时是没有，只有TypeScript才可以实现一种语法糖</li>
<li>装饰器使用 @expression 的形式，其中 expression 必须能够演算为在运行时调用的函数，其中包括装饰声明信息。</li>
<li>自定义装饰器代码如下：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个装饰器工厂——有助于将用户参数传给装饰器声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"f(): evaluated"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"f(): called"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"g(): evaluated"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"g(): called"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> C &#123;</span><br><span class="line">  <span class="meta">@f</span>()</span><br><span class="line">  <span class="meta">@g</span>()</span><br><span class="line">  method() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f(): evaluated</span></span><br><span class="line"><span class="comment">// g(): evaluated</span></span><br><span class="line"><span class="comment">// g(): called</span></span><br><span class="line"><span class="comment">// f(): called</span></span><br></pre></td></tr></table></figure>

<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>Nest.js的生命周期分为三个阶段：初始化、运行和终止，下图详细生命周期的各个子阶段：</p>
<p><img src="https://docs.nestjs.com/assets/lifecycle-events.png" alt></p>
<p>允许监听的生命周期函数：</p>
<ul>
<li><code>onModuleInit()</code>, 模块初始化时候调用</li>
<li><code>onApplicationBootstrap()</code>，所有模块都准备好了，但是在web应用正式启用前会被调用</li>
<li><code>onModuleDestroy()</code>，模块准备被停止</li>
<li><code>beforeApplicationShutdown()</code>, web应用准备被停止之前</li>
<li><code>onApplicationShutdown()</code>，web应用被停止之后，在进程退出之前</li>
</ul>
<h2 id="上手实战"><a href="#上手实战" class="headerlink" title="上手实战"></a>上手实战</h2><h3 id="第一步安装："><a href="#第一步安装：" class="headerlink" title="第一步安装："></a>第一步安装：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm i -g @nestjs/cli</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nest new project-name --strict</span></span><br></pre></td></tr></table></figure>

<h3 id="生成项目结构"><a href="#生成项目结构" class="headerlink" title="生成项目结构"></a>生成项目结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">|-- app.controller.spec.ts // controller层的单元测试</span><br><span class="line">|-- app.controller.ts // controller层 控制路由接口层</span><br><span class="line">|-- app.module.ts // 应用根模块</span><br><span class="line">|-- app.service.ts // service层 给controller提供各种业务处理方法</span><br><span class="line">|-- main.ts // 入口文件</span><br></pre></td></tr></table></figure>

<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yarn</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yarn start:dev</span></span><br></pre></td></tr></table></figure>

<p>打开 <a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a> 就可以访问了。</p>
<p>后面有篇文章叫<a href="/2023/01/22/today/20220122/">《从nest.js中了解Ioc和DI》</a>，大家想了解可以去看看。</p>
]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>对CMDB进行一个系统完整认知</title>
    <url>/today/20230109.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近半年，都在开发部门内部的CMDB平台和申请流程，因此对CMDB有了一定了解，但是又不够系统，所以希望写一篇文章能够系统完整的认知一下CMDB，包括以下几点：</p>
<ul>
<li>是什么</li>
<li>能做什么和怎么做</li>
<li>优秀方案</li>
<li>未来方向</li>
</ul>
<a id="more"></a>
<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><blockquote>
<p>CMDB(Configuration Management Database)，配置管理数据库，主要包含了配置项全生命周期的信息以及配置项之间的关系(包括物理关系、实时通信关系、非实时通信关系和依赖关系)。<br>CMDB存储与管理企业IT架构中设备的各种配置信息，它与所有服务支持和服务交付流程都紧密相联，支持这些流程的运转、发挥配置信息的价值，同时依赖于相关流程保证数据的准确性。<br>CMDB存储目标定义为：配置管理致力于通过维护IT基础设施和IT服务的逻辑模式来协助管理IT服务的经济价值(客户需求、质量和成本的结合)，并将与此相关的信息提供给其他业务流程。它通过识别、监测、控制和提供有关配置项及其版本方面的信息来实现目标。<br>以上描述来自百度百科<a href="https://baike.baidu.com/item/CMDB/5403317" target="_blank" rel="noopener">CMDB</a>。</p>
</blockquote>
<p>按照个人理解，CMDB按照比较容易理解的说法，CMDB主要存储公司内部IT基础架构数据存储和配置，能够数字化IT资产与业务的关联关系。</p>
<p>更加明确的说，CMDB是运维的基础核心系统，包括运维所需要的元数据，同时共享数据管理源。 CMDB存储的数据包括但不限于：</p>
<ul>
<li>逻辑资源，指的是底层物理资源对应的逻辑资源，包括：xxx系统、xxx服务、xxxApp等</li>
<li>物理资源，指的是可供运维人员实际操作的物理资源，包括：服务器(cvm、物理机、容器)，机房、机柜、网络设备、链路资源、配件等</li>
</ul>
<h1 id="能做什么"><a href="#能做什么" class="headerlink" title="能做什么"></a>能做什么</h1><p>上面描述CMDB是什么，CMDB到底能做什么呢？或者它对运维有什么作用呢？</p>
<p>这里需要简单介绍几个概念：</p>
<ul>
<li>ITSM(IT service management), IT服务管理，主要是给用户提供标准流程完成IT资产交付，和管理这些IT流程的系统</li>
<li>ITIL(Information Technology Infrastructure Library)，IT服务管理标准库， 是ITSM最常用的实现方案，侧重于使 IT服务与业务需求保持紧密关联</li>
<li>DevOps由英文 Development（开发）和 Operations（运维）组合而成，是开发和运维紧密结合的思想理念，是开发和运维团队之间的流程能够自动化和持续集成、交付，从开发到交付部署形成一个循环的过程。后面我们会单独抽出一个文章做详细了解。</li>
</ul>
<p>上面的几个概念，只要是IT从业者或多或少都有接触到，那么CMDB在这些系统或者流程中，起到一个数据基石的作用，我们举几个例子：</p>
<ol>
<li>如果没有CMDB的配置数据，ITSM流程对用户(开发)就很难入手，比如要申请一台机器，流程里会有很多IT专用描述，开发无法快速申请流程</li>
<li>如果没有CMDB，那么DevOps中要实现自动化持续集成和交付，开发要将服务部署到哪台机器，运维无法得知</li>
</ol>
<p>那么总结一下，CMDB能做的事情，主要有以下几点：</p>
<ol>
<li>能数字化IT资产，并且提供到IT资产管理一个可靠的参考数据</li>
<li>能帮忙快速完成ISM流程，以及更加有效管理ITSM流程</li>
<li>能将业务与IT资产做关联，实现业务与IT资产的有效管理</li>
</ol>
<h1 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h1><p>明白CMDB能做什么，那么我们应该如何设计一个合理CMDB呢？</p>
<p>首先，市场上已经存在各色各样的CMDB平台，主要有以下几个：</p>
<ul>
<li><a href="https://bk.tencent.com/docs/document/6.0/142/8600" target="_blank" rel="noopener">腾讯蓝鲸平台CMDB配置系统</a>，基于腾讯蓝鲸平台的CMDB配置系统</li>
<li><a href="https://github.com/Combodo/iTop" target="_blank" rel="noopener">ITOP</a>，一个完整的开源，ITIL，基于Web的服务管理工具，包括完全可定制的CMDB，帮助台系统和文档管理工具。</li>
<li>怎么开发CMDB平台这里就不做描述，无非几点：</li>
</ul>
<ol>
<li>可自由配置的CMDB模型的 管理web界面</li>
<li>开发标准API接口（主要模型的CRUD），对第三方工具提供服务</li>
</ol>
<h2 id="模型设计"><a href="#模型设计" class="headerlink" title="模型设计"></a>模型设计</h2><p>一个可维护的CMDB平台，肯定脱离不了前期模型设计，所以一个良好且能够向前兼容的模型设计至关重要，因此我这边简单罗列了一下模型几大类，以及它们之间的关系：</p>
<ul>
<li>业务模型，这里业务模型可以拆分多级，最多三级，因为三级业务树基本上能够满足大部分业务等级拆分</li>
<li>模块模型，模块即是从开发角度去理解的项目粒度，通俗的说，就是一个单独且完整的项目，</li>
<li>设备模型，就是服务器，包括：虚拟机、物理机、容器等</li>
<li>持续集成相关模型，主要包括：CI(持续集成)、CD(持续交付)等模型</li>
<li>网络架构相关模型，主要包括：网络策略、域名、证书等</li>
</ul>
<p>再就是需要设计模型与模型之间的关系，这里会很绕，但是为了让大家更加清晰了解CMDB的设计，这里简单绘画了一下：</p>
<p><img src="/assets/img/cmdb1.svg" alt></p>
<h3 id="模型生命周期"><a href="#模型生命周期" class="headerlink" title="模型生命周期"></a>模型生命周期</h3><p>每个CMDB中模型，都有其生命周期流程，结合ITSM就可以完成实现模型的生命周期状态扭转。</p>
<h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><p>** 在CMDB实现阶段：一定要变成运维和运维研发的共同项目，并且具体的配置项管理人要全程参与，比如说需求讨论、测试、上线验收等等（运维研发项目都可以遵循该模式） **</p>
<h3 id="导致CMDB失败的因素"><a href="#导致CMDB失败的因素" class="headerlink" title="导致CMDB失败的因素"></a>导致CMDB失败的因素</h3><ol>
<li>在复杂流程上消耗太多的时间—我们是创建一个CMDB库，不是一个流程系统。</li>
<li>没有指定配置项负责人—-确保配置项有人专职维护。</li>
<li>目标过大，涵盖太多的功能—-比如说IT采购和预算管理等等。</li>
<li>颗粒度不合适—-配置合理的CMDB的配置项层次和粒度非常重要。</li>
<li>存在组织隔阂—-CMDB是一个集成体系，靠流程中的每一个人通力协作，而不是某个人。</li>
</ol>
<h3 id="导致CMDB成功的因素"><a href="#导致CMDB成功的因素" class="headerlink" title="导致CMDB成功的因素"></a>导致CMDB成功的因素</h3><ol>
<li>业务导向。比如说我们在CMDB的新的系统中实时加入QR码技术，为了降低资产盘点的工作量。</li>
<li>能自动发现就自动发现，降低配置管理的成本，但自动发现的信息不能用来做告警。</li>
<li>配置项的管理员必须全程参与，需求定型、测试及验收等等。</li>
<li>CMDB系统建设完成之后，其他系统必须和他联动。比如说监控、质量、容量等等，用场景驱动配置项的管理。</li>
<li>流程一定要平台化，不要让流程脱离CMDB存在，比如说搞一个OA流程，这个是很致命的。</li>
<li>CMDB要持续演进，特别是云端资源的管理。</li>
<li>配置项和流程必须要文档化，后期要进行CMDB培训。</li>
</ol>
<h1 id="未来规划——自动化-智能化-更安全的运维"><a href="#未来规划——自动化-智能化-更安全的运维" class="headerlink" title="未来规划——自动化/智能化/更安全的运维"></a>未来规划——自动化/智能化/更安全的运维</h1><p>目前绝大部分的CMDB数据都是走运维人工手动录入，是否能够做到自动化，甚至智能化。</p>
<p>让数据自动化主要靠以下几点：</p>
<ol>
<li>建立数据生命周期管理，自动化流程驱动数据更新</li>
<li>与多个运维工具对接，促进数据消费，提高数据流动性</li>
<li>通过规则校验以及人工审计确保及时发现和修复异常数据</li>
</ol>
<p>依托CMDB的数据基石，能让运维走向智能化，运维的价值在于交付能力，主要：</p>
<ol>
<li>开发能够随时交付，无需运维过多参与，自动化运维</li>
<li>实时监控，智能化告警，提前告知开发进行预警</li>
<li>服务异常自愈，依托CMDB数据，能够自动重启服务完成服务异常自愈</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>CMDB其实就是一个数据管理平台，开发技术上难度不大，最大难度在于数据，以下几点：</p>
<ul>
<li>第一要保证数据的准确性</li>
<li>第二要能快速自动化获取数据</li>
<li>第三数据模型以及其关联设计，主要完成这三点</li>
</ul>
<p>但是完成CMDB数据后，只是迈开自动化/智能化运维的第一步，后面还需要基于CMDB去完成整个DevOps流程自动化/智能化。</p>
]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在页面展示数学公式之Latex语法</title>
    <url>/today/20230108.html</url>
    <content><![CDATA[<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>最近在做markdown 算法文章分享，算法肯定会涉及到数学复杂度，比如: $$ O(log_nX) $$ 等数学公式的展示，但是如果写成这样子<code>lognX</code>，估计很难准确表达，因此上网搜索了一下数学表达式在前端页面如何展示的相关技术。</p>
<h1 id="web-数学表达式展示解决方案"><a href="#web-数学表达式展示解决方案" class="headerlink" title="web 数学表达式展示解决方案"></a>web 数学表达式展示解决方案</h1><p>一般需要在web页面展示数学表达式相关技术，基本上都是在线编辑器，但是markdown也算是一种编辑器语法，所以上网收集了主要以下几种</p>
<ul>
<li>TeX，前期计算机无法生成数学公式排版或者排版很丑，因此<code>Donald E. Knuth</code>设计了一套排版技术，拥有很多计算机的命令或者技术语言</li>
<li>LaTeX，是一种基于TeX的实现排版系统，准确的基于TeX的应用系统，已经封装很多公式模板，直接套用即可</li>
<li>MathJaX，基于LaTeX实现的JavaScript渲染器， 渲染稍慢，支持更多复杂的表示</li>
<li>KaTeX，也基于LaTeX实现的是一个JavaScript库，对比MathJaX，渲染更快，支持若干简写字符，但是本身支持的范围较小</li>
</ul>
<a id="more"></a>

<h1 id="对比说明"><a href="#对比说明" class="headerlink" title="对比说明"></a>对比说明</h1><h2 id="MathJaX"><a href="#MathJaX" class="headerlink" title="MathJaX"></a>MathJaX</h2><blockquote>
<p>MathJaX 是一个适用所有浏览器的展示数学表达式的js引擎。</p>
</blockquote>
<p>官网地址：<a href="https://www.mathjax.org/" target="_blank" rel="noopener">https://www.mathjax.org/</a></p>
<h2 id="KaTex"><a href="#KaTex" class="headerlink" title="KaTex"></a>KaTex</h2><blockquote>
<p>KaTeX 是一个支持在网页上显示 TeX 公式的 JavaScript 库</p>
</blockquote>
<p>通俗的说，Tex就是一种数学公式的排版语言规范，KaTeX是以Tex作为基础语言规范的实现版本。</p>
<p>官网地址：<a href="https://katex.org/" target="_blank" rel="noopener">https://katex.org/</a></p>
<h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><p>快速使用，这里尝试<a href="/code/latex/index.html">demo</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>LaTex公式 demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">integrity</span>=<span class="string">"sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- The loading of KaTeX is deferred to speed up page rendering --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">integrity</span>=<span class="string">"sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- To automatically render math in text elements, include the auto-render extension: --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">integrity</span>=<span class="string">"sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">onload</span>=<span class="string">"renderMathInElement(document.body);"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span> 对数： <span class="tag">&lt;<span class="name">span</span>&gt;</span>$$ log_nX $$<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span> 统计表达式： <span class="tag">&lt;<span class="name">span</span>&gt;</span>$$  \sum_&#123;i=1&#125;^&#123;n&#125;&#123;X_i&#125; $$<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在gitbook中，你只需要添加相关插件即可：</p>
<ul>
<li><code>npm install gitbook-plugin-katex</code>，安装插件</li>
<li>在<code>book.json</code>中的<code>plugins</code>，新增:<code>katex</code></li>
<li>然后就可以在页面中使用语法<code>$$ log_nX $$</code>展示为$$ log_nX $$</li>
</ul>
<p>在hexo等博客，需要以下步骤：</p>
<ul>
<li>找到主题配置文件：<code>themes\landscape\layout\_partial\after-footer.ejs</code>，添加js文件 <code>&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.js&quot;&gt;&lt;/script&gt;</code></li>
<li>找到主题配置文件：<code>themes\landscape\layout\_partial\after-footer.ejs</code>，添加css文件 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css&quot;&gt;</code></li>
<li>后续再安装hexo的katex插件即可 <code>npm install hexo-katex --save</code></li>
</ul>
<h2 id="LaTeX数学公式编写"><a href="#LaTeX数学公式编写" class="headerlink" title="LaTeX数学公式编写"></a>LaTeX数学公式编写</h2><p>简单语法如下：</p>
<ul>
<li><code>$$ log_nX $$</code> 对数表达式 $$ O(log_nX) $$ </li>
<li><code>$$  \sum_{i=1}^{n}{X_i} $$</code> 统计表达式 $$  \sum_{i=1}^{n}{X_i} $$</li>
</ul>
<p>有个在线编辑网站能帮你快速生成公式，请访问<a href="https://www.latexlive.com/##" target="_blank" rel="noopener">Latex公式编辑器</a></p>
<p>如果要想学习更多公式，这里分享一些教程：</p>
<p><a href="https://zhuanlan.zhihu.com/p/110756681" target="_blank" rel="noopener">LaTeX 公式篇</a></p>
<p><a href="https://qyxf.github.io/2020/01/03/latex-formula-beginner" target="_blank" rel="noopener">LaTeX 公式语法速成</a></p>
]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>从npm版本依赖到Monorepo大仓项目</title>
    <url>/today/20230107.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前端的发展很快，自从node.js的出现，打开前端新的大门，npm让js有了自己的包管理能力，能够让前端项目工程化，从而能够处理更加复杂的前端项目。</p>
<p>但是随之而来的是，同一个项目的npm依赖越来越多，有些是开源的，有些是自研的，尤其在同一个团队，当你开发一个新的npm包的时候，只是为了服务特定几个项目，但是这几个项目不在你管理范围内，当你需要更新的时候需要通知到他们，有时候会出现版本依赖问题，然后反复沟通和测试，最终达到协调。但是下次更新的时候又再次遇到这个问题，重复一次。</p>
<h1 id="npm依赖"><a href="#npm依赖" class="headerlink" title="npm依赖"></a>npm依赖</h1><h2 id="npm是什么"><a href="#npm是什么" class="headerlink" title="npm是什么"></a>npm是什么</h2><blockquote>
<p>npm，Node Package Manager的缩写，也就是“Node的包管理器”。<br>npm（“Node 包管理器”）是 JavaScript 运行时 Node.js 的默认程序包管理器。</p>
</blockquote>
<a id="more"></a>

<p>通俗的说，npm是管理js包的工具，它包括以下几个部分：</p>
<ol>
<li>npm源，存放各类npm包的网站，可以注册，上传npm包</li>
<li>npm-cli 命令工具，允许你自由下载任何npm包</li>
</ol>
<h2 id="npm如何管理包"><a href="#npm如何管理包" class="headerlink" title="npm如何管理包"></a>npm如何管理包</h2><p>那么npm是如何管理包的呢？主要项目下<code>package.json</code>对npm进行描述，主要有以下几个属性：</p>
<ul>
<li>name：JavaScript 项目或库的名称。</li>
<li>version：项目的版本。</li>
<li>scripts： 当作在项目本地运行的命令行工具</li>
<li>dependencies：当项目被人依赖的时候，需要安装的npm包，描述：<code>npm包名： npm包版本</code></li>
<li>devDependencies：本地开发的时候，需要安装的npm包，描述：<code>npm包名： npm包版本</code></li>
</ul>
<p>同时<code>package-lock.json</code>文件描述了 npm JavaScript 项目中使用的依赖项的确切版本，确保下次安装项目依赖的npm包升级版本后导致项目无法运行（这个是很多新手安装npm包的时候会遇到的一个错误）。</p>
<h2 id="npm版本"><a href="#npm版本" class="headerlink" title="npm版本"></a>npm版本</h2><p>npm包版本遵循<code>major.minor.patch</code>版本模型规范，什么是<code>major.minor.patch</code>版本模型规范，下面引用一下说明：</p>
<blockquote>
<p>APR版本规范，major是当前的主版本号，minor则是次版本号，patch对应的则是APR的补丁号，同时还有版本所处阶段<code>base</code>, <code>alpha</code>, <code>beta</code>, <code>RC</code>, <code>release</code>。</p>
</blockquote>
<p>因此在package.json描述的依赖npm包的版本号，如:<code>~1.0.0</code>，<code>^1.0.0</code>，几个符号代表的意思如下：</p>
<ul>
<li><code>^</code>：表示最新的次版本，例如， <code>^1.0.4</code>  可能会安装主版本系列  <code>1</code> 的最新次版本 <code>1.3.0</code>。</li>
<li><code>〜</code>：表示最新的补丁程序版本，与  <code>^</code>  类似， <code>〜1.0.4</code>  可能会安装次版本系列 <code>1.0</code>  的最新次版本<code>1.0.7</code>。</li>
</ul>
<h2 id="npm包版本依赖问题"><a href="#npm包版本依赖问题" class="headerlink" title="npm包版本依赖问题"></a>npm包版本依赖问题</h2><p>即使有<code>package-lock.json</code>或者<code>yarn.lock</code>等约束文件解决项目依赖包的版本的问题，但是当项目越来越庞大，拆分的公共npm包越来越多，这些npm管理难度和数量成正比提升，团队需要面临npm包版本问题也越来越多，尤其当<code>微前端</code>概念提出，当大项目被拆分成N个子项目的时候，团队成员需要面临以下几个问题：</p>
<ul>
<li>公共包npm更新了，如何通知到其他子项目依赖的npm包更新版本</li>
<li>子项目有些公共的代码需要抽象到公共一起维护，是抽离成npm包，但是又需要新起一个项目</li>
<li>公共npm越来越多，子项目也越拆越多，如何管理这些项目的开发、测试和持续发布</li>
<li>其他各种开发细节问题…</li>
</ul>
<p>因此，大家迫切需要去一个标准去统一维护管理这些项目，因此<code>Monorepo</code>统一项目管理规范，就是我们的最佳选择。</p>
<h1 id="Monorepo"><a href="#Monorepo" class="headerlink" title="Monorepo"></a>Monorepo</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><blockquote>
<p>Monorepo是包含多个不同项目的单一存储库，具有明确定义的关系。</p>
</blockquote>
<p>通俗的讲，<code>Monorepo</code>就是将几个不同项目放到一个git仓库里，通过制定一个大家遵循的管理规范和子项目之间依赖关系。</p>
<p><code>Monorepo</code>大仓项目与<code>monolithic</code>单体巨石项目还是有很大的区别，下面简单说明：</p>
<ul>
<li>Monorepo !== 单体巨石项目，monorepos 简化了代码共享和跨项目重构，它们显着降低了创建库、微服务和微前端的成本，不需要做到一起发布</li>
<li>能够有效解决子项目与子项目的之间版本依赖关系，而不是单纯将几个项目放在一起形成一堆代码山</li>
</ul>
<p>为了更好的了解<code>Monorepo</code>大仓，可以和对立面<code>Polyrepo</code>多个标准式项目 作对比：</p>
<p><img src="/assets/img/monorepo-polyrepo.svg" alt="大仓与多个对比"></p>
<h2 id="monorepo-工具"><a href="#monorepo-工具" class="headerlink" title="monorepo 工具"></a>monorepo 工具</h2><p>Monorepos 有很多优势，但要使它们发挥作用，您需要拥有合适的工具。随着工作空间的扩大，工具必须帮助您保持快速、易于理解和管理。</p>
<p>市面上主流的<code>Monorepo</code>管理工具有：</p>
<ul>
<li>Bazel（谷歌）</li>
<li>Gradle Build Tool（Gradle, Inc）</li>
<li>Lage（微软）</li>
<li>Lerna  </li>
<li>Nx（Nrwl）</li>
<li>Pants（Pants Build 社区）</li>
<li>Rush（由 Microsoft)</li>
<li>Turborepo（由 Vercel）</li>
</ul>
<p>工具应该具备以下几点能力：</p>
<ul>
<li>本地计算缓存，能够提供本地构建缓存、单元测试缓存等能力</li>
<li>本地任务编排，能够以正确的顺序并行运行任务</li>
<li>分布式计算缓存，跨不同环境共享缓存工件的能力。这意味着你的整个组织，包括 CI 代理，永远不会构建或测试相同的东西两次。</li>
<li>分布式任务执行，在多台机器上分发命令的能力，同时在很大程度上保留在单台机器上运行它的开发人体工程学。</li>
<li>透明远程执行，在本地开发时在多台机器上执行任何命令的能力。</li>
<li>检测受影响的项目/包，确定更改可能会影响什么，以仅运行构建/测试受影响的项目。</li>
<li>工作区分析，无需额外配置即可理解工作区项目图的能力。</li>
<li>依赖图可视化，可视化项目和/或任务之间的依赖关系。可视化是交互式的，这意味着您可以搜索、过滤、隐藏、聚焦/突出显示和查询图中的节点。</li>
<li>源码分享，促进分散的源代码片段的共享。</li>
<li>一致的工具，无论您使用什么来开发项目，如JavaScript 框架、Go、Rust、Java 等，工具都可以帮助您获得一致的体验</li>
<li>代码生成，本机支持生成代码</li>
<li>项目限制和可见性，支持定义规则以限制 repo 中的依赖关系。例如，开发人员可以将某些项目标记为他们团队的私有项目，这样其他人就无法依赖它们。开发人员还可以根据使用的技术（例如 React 或 Nest.js）标记项目，并确保后端项目不会导入前端项目。</li>
</ul>
<h2 id="monorepo单一原则"><a href="#monorepo单一原则" class="headerlink" title="monorepo单一原则"></a>monorepo单一原则</h2><p>单一原则指的是单一版本(One Version)原则，具体定义如下：</p>
<blockquote>
<p>单一版本(One Version)原则，是指在任意时间，代码库内的每一份组件、每一个依赖只有一个版本。</p>
</blockquote>
<p>对内部库而言，这意味着使用主干开发（见下），并且必须在主干 HEAD 上依赖。这是一个非常强的约束——这意味着除了终端制品，任何一个内部被依赖的库都不能通过分支发布，而必须保持自己在单仓的主干上一直是发布状态。</p>
<p>对外部依赖而言，同一个第三方库在单仓中永远只会引入一个版本。</p>
<p>为什么？</p>
<p>因为原来的git flow开发流，从feature-&gt;dev-&gt;master，每个分支里面的依赖版本都可能会不一样，从而导致依赖版本难以维护。</p>
<h2 id="monorepo挑战"><a href="#monorepo挑战" class="headerlink" title="monorepo挑战"></a>monorepo挑战</h2><ul>
<li>并非所有服务都适用于 monorepos</li>
<li>需要更复杂的 CI 设置</li>
<li>需要考虑代码架构大规模的改变</li>
</ul>
<h1 id="monorepo实战"><a href="#monorepo实战" class="headerlink" title="monorepo实战"></a>monorepo实战</h1><p>作为前端开发者，<a href="https://lerna.js.org" target="_blank" rel="noopener">Lerna</a>框架是肯定要尝试一番，同时功能比较齐全的<a href>Nx</a>框架要去体验一番。</p>
<p>但是其实两者的关系非常紧密，都是同一个公司<code>Nrwl</code>开发的，所以有很多类似点。</p>
<h2 id="Lerna"><a href="#Lerna" class="headerlink" title="Lerna"></a>Lerna</h2><p>快速开始安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx lerna init</span><br></pre></td></tr></table></figure>

<p>PS: npx是什么？</p>
<ul>
<li>npx：Node Package Execute 即node包执行器</li>
<li>npx 是npm v5.2.0版本之后随npm 一起打包安装的一个包执行器。</li>
<li>它会自动去寻找二进制命令文件且不必全局安装依赖包。</li>
<li>npx 可以在不指定项目中的确切位置或使用别名的情况下运行正确版本的工具，比如<code>npx lerna init</code>命令会执行去npm源安装<code>lerna-cli</code>命令工具到本地，然后执行<code>lerna init</code>命令</li>
</ul>
<p>安装完以后，项目的初始化架构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">packages/</span><br><span class="line">    header/</span><br><span class="line">        src/</span><br><span class="line">            ...</span><br><span class="line">        package.json</span><br><span class="line">        rollup.config.json</span><br><span class="line">        jest.config.js</span><br><span class="line"></span><br><span class="line">    footer/</span><br><span class="line">        src/</span><br><span class="line">            ...</span><br><span class="line">        package.json</span><br><span class="line">        rollup.config.json</span><br><span class="line">        jest.config.js</span><br><span class="line"></span><br><span class="line">    remixapp/</span><br><span class="line">        app/</span><br><span class="line">            ...</span><br><span class="line">        public/</span><br><span class="line">        package.json</span><br><span class="line">        remix.config.js</span><br><span class="line"></span><br><span class="line">package.json</span><br><span class="line">lerna.json # 需要自己手动新建， 用来描述</span><br></pre></td></tr></table></figure>

<p>修改<code>package.json</code>，去添加一个npm/yarn/pnpm workspace</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;root&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;workspaces&quot;: [&quot;packages/*&quot;],</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;lerna&quot;: &quot;6.0.1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h2><ul>
<li><code>lerna run xxx</code>： 统一执行所有子项目的scripts命令，如：lerna run build</li>
<li><code>npx nx graph</code>：查看项目依赖图</li>
<li><code>npx lerna add-caching</code>：设置子项目的一些缓存设置，会在根目录下生成<code>nx.json</code></li>
<li><code>npx lerna publish --no-private</code>: 统一发布npm包</li>
<li><code>npx lerna run xxx --scope=header</code>：允许只针对某个子项目header执行命令</li>
</ul>
<p>其他命令可以到官网查看， <a href="https://lerna.js.org/docs/api-reference/commands" target="_blank" rel="noopener">Lerna命令</a></p>
<h2 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h2><p>官网里定义是：</p>
<blockquote>
<p><a href="https://nx.dev/" target="_blank" rel="noopener">NX</a>是一个智能、快速和可扩展的构建系统，具有一流的Monorepo支持和强大的集成。</p>
</blockquote>
<p>实战步骤如下：</p>
<p>创建一个新工作区：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx create-nx-workspace@latest package-based --preset=npm</span><br></pre></td></tr></table></figure>

<p>然后在<code>packages</code>创建自己的子项目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package-based/</span><br><span class="line">├── packages/</span><br><span class="line">│   └── is-even/</span><br><span class="line">│       ├── index.ts</span><br><span class="line">│       └── package.json</span><br><span class="line">│   └── is-odd/</span><br><span class="line">│       ├── index.ts</span><br><span class="line">│       └── package.json</span><br><span class="line">├── nx.json</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure>

<p>接下来就是配置 <code>nx.json</code>，子项目之间的依赖，和任务执行顺序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// nx.json</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;targetDefaults&quot;: &#123;</span><br><span class="line">    &quot;build&quot;: &#123;</span><br><span class="line">      &quot;dependsOn&quot;: [&quot;^build&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行构建命令<code>npx nx build is-odd</code> 可以看到要先构建<code>is-event</code>项目</p>
<p>最后是构建全部项目<code>npx nx run-many --target=build</code></p>
<h2 id="CI-CD构建流程改造"><a href="#CI-CD构建流程改造" class="headerlink" title="CI/CD构建流程改造"></a>CI/CD构建流程改造</h2><p>这个按照各自团队的CI/CD构建流程去改造，但是主要有以下几点：</p>
<ul>
<li>CI/CD流水线职责分离</li>
<li>统一镜像NPM凭证管理</li>
<li>手动触发CD流水线发布，使用统一版本进行管理发布</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://monorepo.tools/#what-is-a-monorepo" target="_blank" rel="noopener">Monorepo Explain</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>Meteor.js尝鲜实战</title>
    <url>/today/20230305.html</url>
    <content><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247493866&idx=1&sn=c4a3d5ddf6e3148360f3de9ea32e018f&chksm=cf0327d1f874aec72d630aa81d7b1b0b0961943287fbab023e6d39d466f33b642e12ca7f1ac0&token=953834215&lang=zh_CN#rd" target="_blank" rel="noopener">把 puppeteer 融入调试流程，调试体验爽翻了！</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>从审批流到bpmn-js入门</title>
    <url>/today/20230106.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>公司内部由于需要很多审批地方，一开始采用邮件或者企业微信进行口头审批，一般会抄送相关人员，以达到初步审批的效果，但是随着审批越来越复杂，比如有时候需要驳回或者转接，甚至需要调用其他系统接口继续流程的时候，就很麻烦，因此迫切需要一个工作流去解决审批相关事情。</p>
<h1 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h1><p>在选型前，我们需要知道工作流是什么？</p>
<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>工作流就是通过计算机技术对业务流程进行自动化管理。实现多个参与者按照预定的流程去自动执行业务流程。</p>
<blockquote>
<p>工作流定义: 通过计算机对业务流程自动化执行管理</p>
</blockquote>
<p>再通俗一点，工作流就是通过程序去自动实现平时需要人工操作的流程节点，所以工作流能解决的问题一定是可以被流程化的问题。</p>
<p>然而这一过程被大家统称为业务流程建模，通常对已经存在复杂问题进行模型化的抽象，通过模型来推导解决问题的方案。</p>
<a id="more"></a>

<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="BPM"><a href="#BPM" class="headerlink" title="BPM"></a>BPM</h3><p><code>BPM(Business Process Management)</code>， 业务流程管理，是指的在工作流的基础上，基于业务流程建模，支持业务流程的分析、建模、模拟、优化、协同与监控等功能的新一代企业应用系统核心。</p>
<p>简单点说，<code>BPM</code>其实一个业务流程管理系统的统称，不单单可以实现审批流，还可以实现各种更为复杂的业务流程，如：数据同步等。</p>
<h3 id="BPMN"><a href="#BPMN" class="headerlink" title="BPMN"></a>BPMN</h3><p><code>BPMN（Business Process Model And Notation）</code>， 业务流程模型和符号，由<code>BPMI（Business Process Management Initiative）</code>开发的一套标准的业务流程建模符号，使用BPMN 提供的符号可以创建业务流程。</p>
<p>更加容易理解的说，<code>BPMN</code>是实现<code>BPM</code>的一套标准，制定很多建模符号标准。</p>
<p>这里简单比喻一下，<code>BPMN</code>是一门语言，你可以用它去开发<code>BPM</code>系统。</p>
<p>后面会更加详细讲解 <code>BPMN</code> 的基础知识。</p>
<p>建模符号了解，可以放到下一章节分享。</p>
<h3 id="工作流引擎选型"><a href="#工作流引擎选型" class="headerlink" title="工作流引擎选型"></a>工作流引擎选型</h3><p>由于<code>BPMN</code>是市面主流的工作流标准， 那么市面绝大部分工作流引擎都是基于该标准去实现。下面罗列一下目前市面上主流的各种引擎：</p>
<ul>
<li><code>Osworkflow</code>,一个轻量化的流程引擎，基于状态机机制，但不支持会签、跳转、退回、加签等这些操作，需要自己扩展开发，有一定难度，如果流程比较简单，osworkflow是很好的选择但该开源组件已过时，长时间没有版本升级了。</li>
<li><code>JBPM</code>, 以<code>JBPM4</code>版本作为分割点，JBPM5以后版本基于<code>Drools Flow</code>， JBPM4已停止维护，也不建议选择。</li>
<li><code>Activiti</code>, activiti5和activiti6是基于<code>JBPM4</code>开源，<code>activiti7</code>是基于6升级的，内核基本不变，但是由于<code>Tijs Rademakers</code>离开，谨慎选择。</li>
<li><a href="https://flowable.com/open-source" target="_blank" rel="noopener"><code>flowable</code></a>, 基于activiti6衍生出来的版本，以flowable6.4.1版本为分水岭，大力发展其商业版产品，开源版本维护不及时，部分功能已经不再开源版发布，可以考虑选择。</li>
<li><a href="https://docs.camunda.org/manual/7.18/" target="_blank" rel="noopener"><code>Camunda</code></a>, Camunda基于activiti5，所以其保留了PVM，商业版本和开源版本功能相差不大，建议选择。</li>
</ul>
<h3 id="流程设计器选型"><a href="#流程设计器选型" class="headerlink" title="流程设计器选型"></a>流程设计器选型</h3><p>对于低代码平台中的流程可视化，流程设计器是重要的支撑工具，目前市场上比较主流的流程:</p>
<ul>
<li><a href="https://bpmn.io/" target="_blank" rel="noopener">bpmn-js</a>,是 BPMN 2.0 渲染工具包和 Web 模型，使用 Web 建模工具可以很方便的构建 BPMN 图表，可以把 BPMN 图表嵌入到你的项目中，容易扩展。</li>
<li><a href="http://jgraph.github.io/mxgraph/" target="_blank" rel="noopener">mxGraph</a>是一个强大的JavaScript流程图前端库，由于mxGraph是一个开放的js绘图开发框架，我们可以开发出很炫的样式，或者完全按照项目需求定制。</li>
<li>[Activiti-Modeler] Activiti 开源版本中带了web版流程设计器,界面不美观，用户体验差</li>
<li>[flowable-modeler]flowable开源版本中带了web版流程设计器,界面不美观，用户体验差</li>
</ul>
<h3 id="建议选型"><a href="#建议选型" class="headerlink" title="建议选型"></a>建议选型</h3><p>推荐大家使用<a href="https://docs.camunda.org/manual/7.18/" target="_blank" rel="noopener"><code>Camunda</code></a>（流程引擎）+<a href="https://bpmn.io/" target="_blank" rel="noopener">bpmn-js</a>（流程设计器）组合。</p>
<h1 id="快速部署"><a href="#快速部署" class="headerlink" title="快速部署"></a>快速部署</h1><p>选型后就是实战，推荐的选型都有很完整的安装部署文档，下面简单说一下部署步骤。</p>
<p>再次说明一下两者的区别：</p>
<ul>
<li><code>Camunda</code>是工作流引擎，用来执行工作流模型文件任务，同时管理各种流程执行。</li>
<li><code>bpmn-js</code>是前端的流程设计器，基于<code>bnpm</code>标准实现，用来生成工作流模型文件。</li>
</ul>
<h2 id="Camunda部署"><a href="#Camunda部署" class="headerlink" title="Camunda部署"></a>Camunda部署</h2><ol>
<li>docker快速安装后端：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull camunda/camunda-bpm-platform:run-latest</span><br><span class="line">docker run -d --name camunda -p 8080:8080 camunda/camunda-bpm-platform:run-latest</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>通过<code>spring boot</code>快速创建项目：<br>更新pom.xml文件内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.tencent<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>camunda_spring_boot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>camunda_spring_boot<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>camunda_spring_boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>17<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">camunda.spring-boot.version</span>&gt;</span>7.15.0<span class="tag">&lt;/<span class="name">camunda.spring-boot.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.camunda.bpm.springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>camunda-bpm-spring-boot-starter-webapp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;camunda.spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改登录用户配置， application.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">camunda.bpm</span>:<span class="string"></span></span><br><span class="line">  <span class="meta">admin-user</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">id</span>: <span class="string">demo</span></span><br><span class="line">    <span class="attr">password</span>: <span class="string">demo</span></span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">Demo</span></span><br><span class="line">  <span class="attr">filter</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">create</span>: <span class="string">All tasks</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将<code>bpmn-js</code>操作好的xml文件保存到<code>src/main/resources/loan-approval.bpmn</code></p>
</li>
</ol>
<p>运行程序，访问<a href="http://localhost:8080/camunda/app/cockpit/default/#/dashboard" target="_blank" rel="noopener">http://localhost:8080/camunda/app/cockpit/default/#/dashboard</a>，就可以看到相关任务。</p>
<p>后面是运行任务等，就不属于入门教程，可以放到后面教程慢慢学习。</p>
<h2 id="bpmn-js部署"><a href="#bpmn-js部署" class="headerlink" title="bpmn-js部署"></a>bpmn-js部署</h2><p><a href="/fedlearn/code/bpmn-js/index.html">demo访问</a>， 快速使用，代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, user-scalable=no"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>BPMNJS测试案例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">&lt;!-- 引入BPMN-JS的CSS文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://unpkg.com/bpmn-js@11.1.0/dist/assets/diagram-js.css"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://unpkg.com/bpmn-js@11.1.0/dist/assets/bpmn-font/css/bpmn.css"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"canvas"</span> <span class="attr">style</span>=<span class="string">"height:80vh;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入BPMN-JS的JS文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/bpmn-js@11.1.0/dist/bpmn-modeler.development.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- xml文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./bpmn.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> bpmnModeler = <span class="keyword">new</span> BpmnJS(&#123;</span></span><br><span class="line"><span class="actionscript">      container: <span class="string">'#canvas'</span></span></span><br><span class="line">    &#125;);</span><br><span class="line">		</span><br><span class="line"><span class="actionscript">    bpmnModeler.importXML(xml, <span class="function"><span class="keyword">function</span><span class="params">(err)</span> </span>&#123;</span></span><br><span class="line"><span class="vbscript">	  <span class="keyword">if</span> (<span class="built_in">err</span>) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">console</span>.error(<span class="string">'failed to load diagram'</span>, err);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>BPNM</code>是大家统一认知的业务流建模标准，实现它的工作流引擎有很多，经过选型最终确定使用<a href="https://docs.camunda.org/manual/7.18/" target="_blank" rel="noopener">camunda</a> + <a href="https://bpmn.io/" target="_blank" rel="noopener">bpmn-js</a>。</p>
<p>简单尝试一下，还是很简单实现了一个简单工作流管理系统，从设计工作流到工作流执行。</p>
<p>如果要真正用起来，还是需要发心思去了解<code>BPNM</code>的整体标准，以及<a href="https://docs.camunda.org/manual/7.18/" target="_blank" rel="noopener">camunda</a>是如何运作执行的，同时需要将<a href="https://bpmn.io/" target="_blank" rel="noopener">bpmn-js</a>流程设计器。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://shaochenfeng.com/camunda/10.%E5%88%9B%E5%BB%BA_camunda_spring_boot_%E9%A1%B9%E7%9B%AE/" target="_blank" rel="noopener">camunda Spring Boot项目</a></p>
<p><a href="https://juejin.cn/post/6844904017592614919" target="_blank" rel="noopener">全网最详bpmn.js教材-http请求篇</a></p>
]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>前端快速入门搭建Prometheus监控系统</title>
    <url>/today/20230220.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在尝试做性能优化相关事项，其中有个点就是需要对前端页面性能做监控，有了性能数据才能验证自己的性能优化方案是否ok。</p>
<p>目前市面上主流的监控开源方案选择：</p>
<ul>
<li>Promethues ，基于Google的 SoundCloud，2012年开源的被广为适用的监控系统</li>
<li>Zabbix，基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案</li>
<li>LightHouse，专用于前端页面性能监控，并可以生成对应报告的</li>
<li>Sentry，提供了检测和解决影响用户体验的错误和其他问题的工具</li>
</ul>
<p>其中 Promethues 对比其他方案来说功能更加全面，因为它的生态更加完整，支持各类数据进行上报，对后续整个监控平台有更好的可扩展性。</p>
<a id="more"></a>

<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><blockquote>
<p><a href="https://prometheus.io/" target="_blank" rel="noopener">Prometheus</a> 是由 <a href="https://soundcloud.com/" target="_blank" rel="noopener">SoundCloud</a>(一家公司) 开源监控告警解决方案，从 2012 年开始编写代码，再到 2015 年 github 上开源以来，已经吸引了 9k+ 关注，以及很多大公司的使用；2016 年 Prometheus 成为继 k8s 后，第二名 CNCF(Cloud Native Computing Foundation) 成员。</p>
</blockquote>
<blockquote>
<p>作为新一代监控开源解决方案，很多理念与 Google SRE 运维之道不谋而合。—— <a href="https://prometheus.io/" target="_blank" rel="noopener">Prometheus官网</a></p>
</blockquote>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://yunlzheng.gitbook.io/prometheus-book/" target="_blank" rel="noopener">Prometheus中文教程</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>appium 自动化测试框架</title>
    <url>/today/20230317.html</url>
    <content><![CDATA[<p>appium 自动化测试框架，尤其是移动端</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>Svelte尝鲜体验</title>
    <url>/today/20230307.html</url>
    <content><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>Jamstack尝鲜体验</title>
    <url>/today/20230318.html</url>
    <content><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>利用现有语言模型去做智能搜索问答机器人</title>
    <url>/today/20230310.html</url>
    <content><![CDATA[<h1 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>用 ChatGPT 开发一个能听懂人话的命令行工具<br><a href="https://mp.weixin.qq.com/s/rQc0iM7WIrNQDP9aCs7Hpw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/rQc0iM7WIrNQDP9aCs7Hpw</a></p>
<p><a href="https://flowiseai.com/" target="_blank" rel="noopener">https://flowiseai.com/</a> 流程化开发AI机器人</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>Svelte尝鲜体验</title>
    <url>/today/20230308.html</url>
    <content><![CDATA[<h1 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>低代码的另一种实现思路，不再是页面开发，而是应用开发。<br><a href="https://mp.weixin.qq.com/s/dwi40gJjGBHW9MVpag5Oxg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/dwi40gJjGBHW9MVpag5Oxg</a></p>
<p>可视化搭建 - keepAlive 模式<br><a href="https://mp.weixin.qq.com/s/1fYO__dfUy2MIjHi3IJrmg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/1fYO__dfUy2MIjHi3IJrmg</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>如何基于chatgpt去开发工具</title>
    <url>/today/20230309.html</url>
    <content><![CDATA[<h1 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>用 ChatGPT 开发一个能听懂人话的命令行工具<br><a href="https://mp.weixin.qq.com/s/rQc0iM7WIrNQDP9aCs7Hpw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/rQc0iM7WIrNQDP9aCs7Hpw</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>微前端系列——结合Monorepo大仓架构实战</title>
    <url>/today/20230306.html</url>
    <content><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 ChatGPT 等大语言模型重新搭建智能开发体系</title>
    <url>/today/20230316.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p> 今年 ChatGPT的火爆，引发国内外一大众公司扑入人工智能领域去开发属于自己的大语言模型，那么在这次 AI 浪潮中，作为个人开发者而言，是无法独立去开发一个大语言模型，因为机器很贵，而且所需要数据资源很缺乏，因此我曾经写过一篇文章<a href></a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建一套自己的Copilot</title>
    <url>/today/20230303.html</url>
    <content><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://lowin.li/2022/06/27/pan-dian-kai-yuan-copilot/" target="_blank" rel="noopener">盘点开源“Copilot”，do it yourself</a><br><a href="https://blog.csdn.net/gel1234/article/details/127050405" target="_blank" rel="noopener">如何搭建免费的GitHub Copilot？</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue冷知识系列之Suspense和defineAsyncComponent</title>
    <url>/today/20230302.html</url>
    <content><![CDATA[<blockquote>
<p>做一个有温度和有干货的技术分享作者 —— <a href="https://qborfy.com" target="_blank" rel="noopener">Qborfy</a></p>
</blockquote>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://lowin.li/2022/06/27/pan-dian-kai-yuan-copilot/" target="_blank" rel="noopener">盘点开源“Copilot”，do it yourself</a><br><a href="https://blog.csdn.net/gel1234/article/details/127050405" target="_blank" rel="noopener">如何搭建免费的GitHub Copilot？</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>从短视频到短视频思维</title>
    <url>/today/20230105.html</url>
    <content><![CDATA[<h1 id="短视频的背景"><a href="#短视频的背景" class="headerlink" title="短视频的背景"></a>短视频的背景</h1><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>人类的需求——记录、表达、分享</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul>
<li>智能手机普及</li>
<li>法律法规允许</li>
<li>大数据、AI算法成熟</li>
</ul>
<a id="more"></a>
<h1 id="短视频讲解"><a href="#短视频讲解" class="headerlink" title="短视频讲解"></a>短视频讲解</h1><h2 id="AI辅助内容解析"><a href="#AI辅助内容解析" class="headerlink" title="AI辅助内容解析"></a>AI辅助内容解析</h2><ul>
<li>AI识别视频内容</li>
<li>分类视频模型，如：色情、低俗、性感、社会事件、武器模型、敏感人物、极端组织、高危等</li>
<li>内容审核</li>
</ul>
<h2 id="AI推荐算法"><a href="#AI推荐算法" class="headerlink" title="AI推荐算法"></a>AI推荐算法</h2><p>给你爱看，也给你好看的短视频。</p>
<ul>
<li>用户侧特征：爱好、年龄、职业等</li>
<li>视频侧特征：宠物、旅行、电影等</li>
<li>流行度特征：播放量、停留时间、完播率、分享率等</li>
</ul>
<h3 id="内容流转逻辑"><a href="#内容流转逻辑" class="headerlink" title="内容流转逻辑"></a>内容流转逻辑</h3><p>抖音流量池， 按照播放次数，做统计，如下</p>
<ul>
<li>种子流量池 ： 数百</li>
<li>初级流量池：1w~10w</li>
<li>中级流量池：10w~100w</li>
<li>高级流量池：100w~1000w</li>
<li>s级流量池：1000w+</li>
<li>王者流量池：全站、新手</li>
</ul>
<p><strong>扭转流程</strong>：</p>
<p>上传-&gt;程序判断-&gt;审核失败</p>
<p>上传&gt;程序判断-&gt;上传成功-&gt;种子池-&gt;达到推荐标准-&gt;初级-&gt;中级-&gt;高级-&gt;全站</p>
<h1 id="做短视频核心"><a href="#做短视频核心" class="headerlink" title="做短视频核心"></a>做短视频核心</h1><p>一句话，忘记涨粉，回归价值</p>
<ul>
<li>做短视频，有什么优势</li>
<li>能够提供什么有价值的视频给到用户</li>
</ul>
<h1 id="什么是短视频思维"><a href="#什么是短视频思维" class="headerlink" title="什么是短视频思维"></a>什么是短视频思维</h1><p>短视频，是从叙事基础设施改变： 重构生产、发行、宣传</p>
<p>影响抖音、快手推荐因素：<br>抖音：</p>
<ul>
<li>完播率</li>
<li>复播率</li>
<li>分享率</li>
<li>评论率</li>
<li>点赞率</li>
</ul>
<p>快手多了：（注重封面）</p>
<ul>
<li>点击率</li>
<li>转粉率</li>
</ul>
<h2 id="短视频思维原则"><a href="#短视频思维原则" class="headerlink" title="短视频思维原则"></a>短视频思维原则</h2><p>时长：能短一秒是一秒；</p>
<p>怎么做：</p>
<ul>
<li>后期：能少一帧是一帧；</li>
<li>编剧：能少一字是一字；</li>
<li>导演：画面上每一帧都是经过设计的；</li>
<li>运营：引导互动</li>
</ul>
<p>内容：用讲故事的方式建立认同感；</p>
<p>怎么做：</p>
<ul>
<li>要么好玩，要么有用，好内容满足人性；</li>
<li>黄金5秒；</li>
<li>多个梗与冲突；</li>
<li>设计的结尾</li>
</ul>
<h2 id="短视频思维本质"><a href="#短视频思维本质" class="headerlink" title="短视频思维本质"></a>短视频思维本质</h2><p>本质：数据与效率</p>
<ul>
<li>时长短，成品快</li>
<li>点赞率，播放率</li>
<li>快速迭代、低成本</li>
</ul>
<p>制作步骤：</p>
<ul>
<li>多维度快速迭代，多做尝试</li>
<li>定型IP,IP成立只差一个爆款</li>
<li>不断复盘总结、强化故事冲突、强化人物性格</li>
<li>深度运营、内容定制，简单说就是内容升级、不断满足粉丝的预期</li>
</ul>
<p>综上所述，短视频思维就是几点：</p>
<ul>
<li>秉持不断学习的态度，勇敢尝试各种类型</li>
<li>效率至上，迭代速度够快</li>
<li>用户价值是核心思想，你能够提供什么价值的视频给到用户</li>
</ul>
]]></content>
      <tags>
        <tag>每日更新</tag>
        <tag>短视频</tag>
      </tags>
  </entry>
  <entry>
    <title>从尝试搭建NAS了解各类云硬盘协议（一）</title>
    <url>/today/20230104.html</url>
    <content><![CDATA[<h1 id="NAS-是什么"><a href="#NAS-是什么" class="headerlink" title="NAS 是什么"></a>NAS 是什么</h1><p>NAS，全称Network Attached Storage，中文名： 网络附属存储。</p>
<p>可以理解成是长时间联网的存储设备，比如你有个硬盘，里面存储了一些教学视频，你想要别的地方去访问，比如在手机或者电脑上访问，那么NAS就能够解决你这个问题的解决方案。</p>
<p>NAS可以解决什么场景痛点：</p>
<ul>
<li>你的照片、视频可以随时上传，大小、题材不限制</li>
<li>访问速度快，尤其在家的时候局域网更快</li>
<li>信息安全，不再担心你的信息被云盘厂商泄露</li>
</ul>
<a id="more"></a>

<h1 id="部署NAS"><a href="#部署NAS" class="headerlink" title="部署NAS"></a>部署NAS</h1><p>部署NAS一般有两种部署方案：</p>
<ol>
<li>购买现成的NAS，一般服务厂商会将解决你的所有问题，一键傻瓜式部署</li>
<li>自己折腾搭建NAS，那么需要一台7*24小时服务器，搭建NAS服务，同时还需要搞个app支持NAS，支持手机客户端访问</li>
</ol>
<p>第一种方案简单，但是有点费钱</p>
<p>第二种方案困难，但是不费钱</p>
]]></content>
      <tags>
        <tag>每日更新</tag>
        <tag>动手实战</tag>
      </tags>
  </entry>
  <entry>
    <title>【引导页】功能实现原理分析</title>
    <url>/today/20230103.html</url>
    <content><![CDATA[<p>什么是引导页，就是引导用户对一些新功能使用说明UI展示。</p>
<p>遇到这种需求，一般的想法是：</p>
<ul>
<li>有没有办法可以快速实现</li>
<li>有时间对其背后原理研究一番</li>
</ul>
<h2 id="快速接入"><a href="#快速接入" class="headerlink" title="快速接入"></a>快速接入</h2><p>按照常用框架<code>Vue</code> <code>React</code> <code>原生js</code>进行分类，罗列一些开源比较好的框架使用。</p>
<a id="more"></a>
<h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><h4 id="vue-tour"><a href="#vue-tour" class="headerlink" title="vue-tour"></a>vue-tour</h4><p><a href="https://github.com/pulsardev/vue-tour" target="_blank" rel="noopener">vue-tour</a> 适用于Vue2,</p>
<blockquote>
<p>Vue Tour是一个轻量级、简单且可定制的导游插件，可与Vue.js一起使用。它提供了一种快速而简单的方法来指导用户完成您的应用程序。</p>
</blockquote>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> VueTour <span class="keyword">from</span> <span class="string">'vue-tour'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'vue-tour/dist/vue-tour.css'</span>)</span><br><span class="line"></span><br><span class="line">Vue.use(VueTour)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里使用vue组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div id=<span class="string">"v-step-0"</span>&gt;A DOM element on your page. The first step will pop on <span class="keyword">this</span> element because its ID is <span class="string">'v-step-0'</span>.&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="v-step-1"&gt;A DOM element on your page. The second step will pop on this element because its ID is 'v-step-1'.&lt;/</span>div&gt;</span><br><span class="line">    &lt;div data-v-step=<span class="string">"2"</span>&gt;A DOM element on your page. The third and final step will pop on <span class="keyword">this</span> element because its ID is <span class="string">'v-step-2'</span>.&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;v-tour name="myTour" :steps="steps"&gt;&lt;/</span>v-tour&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">'my-tour'</span>,</span><br><span class="line">    data () &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        steps: [</span><br><span class="line">          &#123;</span><br><span class="line">            target: <span class="string">'#v-step-0'</span>,  <span class="comment">// 使用 document.querySelector() 查询DOM节点</span></span><br><span class="line">            header: &#123;</span><br><span class="line">              title: <span class="string">'Get Started'</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            content: <span class="string">`Discover &lt;strong&gt;Vue Tour&lt;/strong&gt;!`</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            target: <span class="string">'.v-step-1'</span>,</span><br><span class="line">            content: <span class="string">'An awesome plugin made with Vue.js!'</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            target: <span class="string">'[data-v-step="2"]'</span>,</span><br><span class="line">            content: <span class="string">'Try it, you\'ll love it!&lt;br&gt;You can put HTML in the steps and completely customize the DOM to suit your needs.'</span>,</span><br><span class="line">            params: &#123;</span><br><span class="line">              placement: <span class="string">'top'</span> <span class="comment">// 展示方位 包括: top/bottom/left/right等</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.$tours[<span class="string">'myTour'</span>].start()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><p>React的生态比较丰富，插件也比较多，google React Tour就可以找到很多，下面罗列一下github上star较多的几个</p>
<ul>
<li><a href="https://github.com/gilbarbara/react-joyride" target="_blank" rel="noopener">react-joyride</a>：使用方便快捷的引导页插件</li>
<li><a href="https://github.com/elrumordelaluz/reactour" target="_blank" rel="noopener">reactour</a>： 功能更加丰富的React引导组件，分成好几种组件：<code>@reactour/tour</code> <code>@reactour/mask</code> <code>@reactour/popover</code> <code>@reactour/utils</code>等</li>
</ul>
<h3 id="原生js"><a href="#原生js" class="headerlink" title="原生js"></a>原生js</h3><p>原生js实现的引导页插件，比较有名有driver.js、intro.js和shepherd.js</p>
<h4 id="driver-js"><a href="#driver-js" class="headerlink" title="driver.js"></a>driver.js</h4><blockquote>
<p><strong><code>driver.js</code></strong> 是一个强大而轻量级的普通 JavaScript 引擎，可在整个页面上驱动用户的注意力，只有 4kb 左右的体积，并且没有外部依赖，不仅高度可定制，还可以支持所有主流浏览器。</p>
</blockquote>
<p>github地址: <a href="https://github.com/kamranahmedse/driver.js" target="_blank" rel="noopener">driver.js</a></p>
<p>使用demo教程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Driver <span class="keyword">from</span> <span class="string">'driver.js'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'driver.js/dist/driver.min.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高亮某个dom节点</span></span><br><span class="line"><span class="keyword">const</span> driver = <span class="keyword">new</span> Driver();</span><br><span class="line">driver.highlight(&#123;</span><br><span class="line">  element: <span class="string">'#some-element'</span>,</span><br><span class="line">  popover: &#123;</span><br><span class="line">    title: <span class="string">'Title for the Popover'</span>,</span><br><span class="line">    description: <span class="string">'Description for it'</span>,</span><br><span class="line">    position: <span class="string">'left'</span>,</span><br><span class="line">    offset: <span class="number">20</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤</span></span><br><span class="line"><span class="keyword">const</span> driver = <span class="keyword">new</span> Driver();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the steps for introduction</span></span><br><span class="line">driver.defineSteps([</span><br><span class="line">  &#123;</span><br><span class="line">    element: <span class="string">'#first-element-introduction'</span>,</span><br><span class="line">    popover: &#123;</span><br><span class="line">      className: <span class="string">'first-step-popover-class'</span>,</span><br><span class="line">      title: <span class="string">'Title on Popover'</span>,</span><br><span class="line">      description: <span class="string">'Body of the popover'</span>,</span><br><span class="line">      position: <span class="string">'left'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    element: <span class="string">'#second-element-introduction'</span>,</span><br><span class="line">    popover: &#123;</span><br><span class="line">      title: <span class="string">'Title on Popover'</span>,</span><br><span class="line">      description: <span class="string">'Body of the popover'</span>,</span><br><span class="line">      position: <span class="string">'top'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    element: <span class="string">'#third-element-introduction'</span>,</span><br><span class="line">    popover: &#123;</span><br><span class="line">      title: <span class="string">'Title on Popover'</span>,</span><br><span class="line">      description: <span class="string">'Body of the popover'</span>,</span><br><span class="line">      position: <span class="string">'right'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start the introduction</span></span><br><span class="line">driver.start();</span><br></pre></td></tr></table></figure>

<h4 id="intro-js"><a href="#intro-js" class="headerlink" title="intro.js"></a>intro.js</h4><blockquote>
<p><strong><code>intro.js</code></strong> 是是一个开源的 vanilla Javascript/CSS 库，用于添加分步介绍或提示，大小在 10kB左右，属于轻量级的且无外部依赖。</p>
</blockquote>
<p>github地址: <a href="https://github.com/usablica/intro.js/" target="_blank" rel="noopener">intro.js</a></p>
<p>使用demo教程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> introJs <span class="keyword">from</span> <span class="string">'intro.js'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'intro.js/introjs.css'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用HTML属性</span></span><br><span class="line">&lt;a href=<span class="string">'http://google.com/'</span> data-intro=<span class="string">'Hello step one!'</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用JSON配置</span></span><br><span class="line">&lt;section <span class="class"><span class="keyword">class</span></span>=<span class="string">"nav-menu"</span>&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li id=<span class="string">"step1"</span>&gt;步骤一&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        &lt;li id="step2"&gt;步骤2&lt;/</span>li&gt;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>section&gt;</span><br><span class="line"><span class="comment">// 配置</span></span><br><span class="line">introJs().setOptions(&#123;</span><br><span class="line">  steps: [&#123;</span><br><span class="line">    title: <span class="string">'Welcome'</span>,</span><br><span class="line">    intro: <span class="string">'Hello World! 👋'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    element: <span class="built_in">document</span>.querySelector(<span class="string">'#step1'</span>),</span><br><span class="line">    intro: <span class="string">'This step focuses on an image'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: <span class="string">'Farewell!'</span>,</span><br><span class="line">    element:<span class="built_in">document</span>.querySelector(<span class="string">'#step2'</span>),,</span><br><span class="line">    intro: <span class="string">'And this is our final step!'</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<h4 id="shepherd-js"><a href="#shepherd-js" class="headerlink" title="shepherd.js"></a>shepherd.js</h4><blockquote>
<p><strong><code>shepherd.js</code></strong> 包含的 API 众多，大多场景都可以通过其对应的配置得到，缺点就是整体的包体积较大，并且配置也比较复杂，配置复杂的内容一般都需要进行二次封装，将可变和不可变的配置项进行抽离</p>
</blockquote>
<p>github地址: <a href="https://github.com/shipshapecode/shepherd" target="_blank" rel="noopener">shepherd.js</a><br>使用demo教程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Shepherd <span class="keyword">from</span> <span class="string">'shepherd.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化配置</span></span><br><span class="line"><span class="keyword">const</span> tour = <span class="keyword">new</span> Shepherd.Tour(&#123;</span><br><span class="line">  defaultStepOptions: &#123;</span><br><span class="line">    cancelIcon: &#123;</span><br><span class="line">      enabled: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    classes: <span class="string">'class-1 class-2'</span>,</span><br><span class="line">    scrollTo: &#123; <span class="attr">behavior</span>: <span class="string">'smooth'</span>, <span class="attr">block</span>: <span class="string">'center'</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加步骤指引</span></span><br><span class="line">tour.addStep(&#123;</span><br><span class="line">  title: <span class="string">'Creating a Shepherd Tour'</span>,</span><br><span class="line">  text: <span class="string">`Creating a Shepherd tour is easy. too!\</span></span><br><span class="line"><span class="string">  Just create a \`Tour\` instance, and add as many steps as you want.`</span>,</span><br><span class="line">  attachTo: &#123;</span><br><span class="line">    element: <span class="string">'.hero-example'</span>,</span><br><span class="line">    on: <span class="string">'bottom'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  buttons: [</span><br><span class="line">    &#123;</span><br><span class="line">      action() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.back();</span><br><span class="line">      &#125;,</span><br><span class="line">      classes: <span class="string">'shepherd-button-secondary'</span>,</span><br><span class="line">      text: <span class="string">'Back'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      action() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.next();</span><br><span class="line">      &#125;,</span><br><span class="line">      text: <span class="string">'Next'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  id: <span class="string">'creating'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展示指引</span></span><br><span class="line">tour.start();</span><br></pre></td></tr></table></figure>

<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>引导页从它展示方式说起，要实现可以分为以下几个步骤：</p>
<ol>
<li><strong>高亮部分</strong>，通过<code>el.cloneNode(true)</code>复制元素节点，将节点复制到蒙层</li>
<li><strong>引导部分</strong>，展示引导框，并将引导框与高亮部分进行定位</li>
<li><strong>过度动画</strong>，通过设置<code>transition</code>实现</li>
<li><strong>页面监听</strong>，当页面发生变化的时候，引导页需要重新渲染计算</li>
</ol>
<p>具体实现可以点击查看源码<a href="/code/tour.js">tour.js</a>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/-O_AnG2pc5H5hLcwu9PTCA" target="_blank" rel="noopener">不使用第三方库怎么实现【前端引导页】功能？</a></li>
</ul>
]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器页面卡住定位分析</title>
    <url>/share/page-notwork.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>有童鞋在xxx系统页面反馈，遇到在弹出框后整个页面卡住无法使用的情况，属于必现问题。因此需要跟踪定位问题。</p>
<h1 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h1><p>一般在浏览器遇到这种问题，基本上都某段逻辑进入死循环导致浏览器内核处理不过来导致的页面卡住动，这个时候需要使用Chrome开发调试工具进行跟踪定位的。</p>
<a id="more"></a>

<h2 id="chrome-source调试工具"><a href="#chrome-source调试工具" class="headerlink" title="chrome source调试工具"></a>chrome source调试工具</h2><p>按照<code>F12</code>或者<code>Command + Alt + J</code>可以打开浏览器的调试工具，然后找到<code>Source</code> 或 <code>源代码</code>Tab页。如下图所示：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/106719ede96442b7a262bba5a68c9775~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<h3 id="步骤一：点击-按钮，进入调试模式："><a href="#步骤一：点击-按钮，进入调试模式：" class="headerlink" title="步骤一：点击=按钮，进入调试模式："></a>步骤一：点击<code>=</code>按钮，进入调试模式：</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb7c6dc349554dd284aca3684d281323~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<h3 id="步骤二：调试代码，查看卡住代码段："><a href="#步骤二：调试代码，查看卡住代码段：" class="headerlink" title="步骤二：调试代码，查看卡住代码段："></a>步骤二：调试代码，查看卡住代码段：</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b758994a5bb04938bc035b397465ab8b~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<h3 id="步骤三：-定位代码段"><a href="#步骤三：-定位代码段" class="headerlink" title="步骤三： 定位代码段"></a>步骤三： 定位代码段</h3><p>确定是哪段代码后，就可以开始分析代码段是属于哪里，最终找到classname，定位到是属于水印插件导致。</p>
<h1 id="问题分析-水印插件"><a href="#问题分析-水印插件" class="headerlink" title="问题分析(水印插件)"></a>问题分析(水印插件)</h1><h2 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h2><p>为什么水印插件会导致页面进行死循环呢？这个就要跟踪到水印插件，目前采用的<code>@pansy/watermark</code>开源插件，然后找到其github issues，看看有没有相关issues。果不其然，还真的找到了，如下：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95eab9a9613d4e409ad09f906acf9d33~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p><a href="https://github.com/pansyjs/watermark/issues/129" target="_blank" rel="noopener">全局水印与其它遮罩层冲突</a><br>那么接下来就开始跟踪他们的代码进行具体分析。</p>
<h1 id="水印插件实现原理"><a href="#水印插件实现原理" class="headerlink" title="水印插件实现原理"></a>水印插件实现原理</h1><p>在上面调试问题的时候，我们有看到一段代码<code>MoutationRecord</code>，其实这已经算是水印插件的重要实现原理之一了。</p>
<p>看了插件源代码，其实就几千行代码，水印插件实现原理有几个点：</p>
<ol>
<li>利用<code>Shadow DOM</code>或者<code>div</code>DOM节点去插入水印，利用z-index显示到最前方</li>
<li>同时设置<code>pointer-events: none;</code>禁止任何操作，包括：选择、点击等，实现不阻碍其他元素操作</li>
<li>利用canvas生成水印图片(base64)</li>
<li>设置水印节点背景图片为水印图片(base64)</li>
<li>使用MutationObserver监听dom元素变化重复渲染生成水印图片，防止水印被人为删除<br>其中涉及到几个关键技术点为:</li>
</ol>
<ul>
<li><code>pointer-events: none</code></li>
<li>通过canvas生成图片</li>
<li>MutationObserver监听<br>当然，还有<code>Shadow DOM</code>和canvas等技术点也可以自己去研究学习，后面再用一些篇章详细讲解。</li>
</ul>
<h2 id="pointer-events"><a href="#pointer-events" class="headerlink" title="pointer-events"></a>pointer-events</h2><p>从MDN中它是这么定义的：</p>
<blockquote>
<p>** <code>pointer-events</code> ** CSS 属性指定在什么情况下 (如果有) 某个特定的图形元素可以成为鼠标事件的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event/target" target="_blank" rel="noopener">target (en-US)</a>。</p>
</blockquote>
<p>简单解释一下，就是可以通过该属性设置DOM元素的鼠标事件，很多对应值都是给svg响应鼠标事件范围所设置的。</p>
<p>这里重点解释一下<code>auto</code>、<code>none</code>两种值：</p>
<blockquote>
<p><code>auto</code>:与 <code>pointer-events</code> 属性未指定时的表现效果相同，对于 SVG 内容，该值与 <code>visiblePainted</code> 效果相同</p>
<p><code>none</code>:元素永远不会成为鼠标事件的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Event/target" target="_blank" rel="noopener">target (en-US)</a>。但是，当其后代元素的 <code>pointer-events</code> 属性指定其他值时，鼠标事件可以指向后代元素，在这种情况下，鼠标事件将在捕获或冒泡阶段触发父元素的事件侦听器。</p>
</blockquote>
<p>简单说，<code>auto</code>是默认值，可以触发该元素本身就有的鼠标事件。<br><code>none</code>则代表取消该元素原有的鼠标事件，可以直接透过该元素直接触发下方元素鼠标事件。<br>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">a[href=&quot;http://example.com&quot;] &#123;</span><br><span class="line">  pointer-events: none;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/&quot;&gt;MDN&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">&lt;!-- 点击链接 http://example.com 时，不会跳转 --&gt;</span><br><span class="line">&lt;a href=&quot;http://example.com&quot;&gt;example.com&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<h2 id="MutationObserver监听"><a href="#MutationObserver监听" class="headerlink" title="MutationObserver监听"></a>MutationObserver监听</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>MDN定义：</p>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver" target="_blank" rel="noopener"><code>MutationObserver</code></a> 接口提供了监视对 DOM 树所做更改的能力。它被设计为旧的 Mutation Events 功能的替代品，该功能是 DOM3 Events 规范的一部分。</p>
</blockquote>
<p>简单说，就是可以监听某个DOM节点下元素发生变化触发的事件。<br>支持方法：</p>
<ul>
<li><code>disconnect()</code>，注销监听方法</li>
<li><code>observe()</code>,开始监听</li>
<li><code>takeRecords()</code>, 取消通知队列</li>
</ul>
<p>具体使用案例(来自MDN)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 选择需要观察变动的节点</span><br><span class="line">const targetNode = document.getElementById(&apos;some-id&apos;);</span><br><span class="line"></span><br><span class="line">// 观察器的配置（需要观察什么变动）</span><br><span class="line">const config = &#123; attributes: true, childList: true, subtree: true &#125;;</span><br><span class="line"></span><br><span class="line">// 当观察到变动时执行的回调函数</span><br><span class="line">const callback = function(mutationsList, observer) &#123;</span><br><span class="line">    // Use traditional &apos;for loops&apos; for IE 11</span><br><span class="line">    for(let mutation of mutationsList) &#123;</span><br><span class="line">        if (mutation.type === &apos;childList&apos;) &#123;</span><br><span class="line">            console.log(&apos;A child node has been added or removed.&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (mutation.type === &apos;attributes&apos;) &#123;</span><br><span class="line">            console.log(&apos;The &apos; + mutation.attributeName + &apos; attribute was modified.&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 创建一个观察器实例并传入回调函数</span><br><span class="line">const observer = new MutationObserver(callback);</span><br><span class="line"></span><br><span class="line">// 以上述配置开始观察目标节点</span><br><span class="line">observer.observe(targetNode, config);</span><br><span class="line"></span><br><span class="line">// 之后，可停止观察</span><br><span class="line">observer.disconnect();</span><br></pre></td></tr></table></figure>

<h3 id="常用场景"><a href="#常用场景" class="headerlink" title="常用场景"></a>常用场景</h3><ul>
<li>防止第三方注入js文件（运营商劫持）</li>
<li>防止删除前端生成的水印</li>
<li>用来处理页面的敏感数据</li>
<li>Vue.$nextTick的实现微任务原理</li>
</ul>
<p>所以从问题定位中，分析水印陷入死循环很可能就是这一部分代码。</p>
<h2 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h2><p>回到最开始，我们是什么时候会遇到页面卡顿，当页面出现弹框的时候，会出现页面卡顿。</p>
<p>同时找到插件的issues(查看issue也是一种快速解决问题的途径)，描述如下:</p>
<blockquote>
<p>vue版本使用全局水印 <code>:is-body=&quot;true&quot;</code>  并且开启保护模式的情况下,触发带遮罩的事件就会导致页面无响应,且无法恢复;<br>带遮罩的事件如对话框弹窗/图片点击放大;<br>测试后发现关闭保护模式 <code>watermark.options.monitor = false</code> ,或者不使用全局水印没有出现该问题;<br><a href="https://github.com/pansyjs/watermark/issues/129" target="_blank" rel="noopener">这里可以看全文</a></p>
</blockquote>
<h3 id="定位到源码"><a href="#定位到源码" class="headerlink" title="定位到源码"></a>定位到源码</h3><p><code>watermark/packages/core/src/index.ts</code>，第244行，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (MutationObserver &amp;amp;&amp;amp; <span class="keyword">this</span>.options.monitor) &#123;</span><br><span class="line">      <span class="keyword">this</span>.mutationObserver = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="params">mutations</span> =&gt;</span> &#123;</span><br><span class="line">        mutations.forEach(<span class="function"><span class="params">mutation</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>._isAgainRender(mutation)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.destroy();</span><br><span class="line">            <span class="keyword">this</span>._render();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">this</span>.mutationObserver.observe(<span class="keyword">this</span>.container, observeOptions);</span><br><span class="line">      <span class="keyword">this</span>.shadowRoot &amp;&amp; <span class="keyword">this</span>.mutationObserver.observe(<span class="keyword">this</span>.shadowRoot, observeOptions);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>结合上面<code>MutationObserver</code>的作用，主要是监听某个DOM容器内节点变化，然后重新渲染水印，从而避免水印被人删除。</p>
<p>那么我们可以很简单的猜测一下，在弹框出来后，会触发<code>MutationObserver</code>，然后<code>_render函数</code>改变dom，又会触发自己本身的dom节点变化，再触发<code>MutationObserver</code>，导致陷入死循环。</p>
<p>目前执行顺序：</p>
<ol>
<li>body容器被监听到DOM节点变化，触发<code>MutationObserver</code>事件</li>
<li><code>MutationObserver</code>事件返回参数<code>mutations</code>是一个数组，可能会重复执行<code>_render</code>函数</li>
<li>多次<code>_render</code>函数会继续注册<code>MutationObserver</code>事件，导致后续body容器变更持续被监听到，进入死循环逻辑中</li>
</ol>
<p>因此，只需要保证多次<code>MutationObserver</code>事件只触发一次<code>_render</code>函数，即可避免死循环逻辑。</p>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>直接下载源码，放到本地调试（过程忽略），最终代码暂时如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">... </span><br><span class="line"><span class="keyword">if</span> (MutationObserver &amp;amp;&amp;amp; <span class="keyword">this</span>.options.monitor) &#123;</span><br><span class="line">      <span class="keyword">this</span>.mutationObserver = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="params">mutations</span> =&gt;</span> &#123;</span><br><span class="line">	  <span class="keyword">this</span>.mutationObserver = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="params">mutations</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 避免多次执行render函数，导致多次注册MutationObserver 从而进入死循环逻辑</span></span><br><span class="line">        <span class="keyword">let</span> lastMoutation;</span><br><span class="line">        mutations.forEach(<span class="function"><span class="params">mutation</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>._isAgainRender(mutation)) &#123;</span><br><span class="line">            lastMoutation = mutation;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span>(lastMoutation)&#123;</span><br><span class="line">          <span class="keyword">this</span>.destroy();</span><br><span class="line">          <span class="keyword">this</span>._render();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">this</span>.mutationObserver.observe(<span class="keyword">this</span>.container, observeOptions);</span><br><span class="line">      <span class="keyword">this</span>.shadowRoot &amp;amp;&amp;amp; <span class="keyword">this</span>.mutationObserver.observe(<span class="keyword">this</span>.shadowRoot, observeOptions);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>后面可以研究一下<code>为什么forEach || map函数无法跳出循环？</code></p>
<p>最后可以提交PR到开源github，这里面也有一些东西可以了解一下，<a href="https://stephenzhou.net/2019/04/23/git-pr-tsg/" target="_blank" rel="noopener">如何在github上为开源项目提交PR？</a>。</p>
<p>这里是我提交的PR,<a href="https://github.com/pansyjs/watermark/pull/136" target="_blank" rel="noopener">全局水印与其它遮罩层冲突 [issue 129]</a></p>
<p>#参考资料<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver" target="_blank" rel="noopener">MutationObserver MDN资料</a></p>
]]></content>
      <tags>
        <tag>技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>java tomcat服务无缘无故挂掉分析和解决方案</title>
    <url>/share/tomcat-nowork.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近有同事反应有时候xxx系统有时候会时不时出现服务异常提示，一上机器，发现xxx服务进程不在，重启服务后又恢复了，所以这边就需要去跟进问题。</p>
<h1 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h1><p>java tomcat服务挂掉原因，主要怀疑方向有这几个：</p>
<ol>
<li>服务器被人重启，导致服务没有起来</li>
<li>错误异常导致程序挂掉</li>
<li>服务器占用内存过高，Linux强制退出程序</li>
<li>其他原因<br>下面就开始逐一排查</li>
</ol>
<a id="more"></a>

<h2 id="服务器重启"><a href="#服务器重启" class="headerlink" title="服务器重启"></a>服务器重启</h2><p>如何查看服务器是否被重启，主要依据下面的命令：</p>
<p><code>who -b</code>查看最后一次重启时间</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1aca3c9b441642a5b913e2ea7778efe1~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"><br><code>last reboot</code> 查看服务器历史重启</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fb16e2d74b74654a20289db8a0c31c4~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>发现服务器重启时间是几个月前的事，因此可以排除。</p>
<h2 id="错误异常导致程序挂掉"><a href="#错误异常导致程序挂掉" class="headerlink" title="错误异常导致程序挂掉"></a>错误异常导致程序挂掉</h2><p>java服务采用spring log分级日志，直接看对应时间点日志，并没有发现什么，因此可以排除掉。</p>
<h2 id="服务器占用内存过高，Linux强制退出程序"><a href="#服务器占用内存过高，Linux强制退出程序" class="headerlink" title="服务器占用内存过高，Linux强制退出程序"></a>服务器占用内存过高，Linux强制退出程序</h2><p>如何查看服务器系统日志，可以查看文件：<code>/var/log/messages</code>。</p>
<blockquote>
<p>message日志包含了系统启动时的引导消息，以及系统运行时的其他状态消息。IO 错误、网络错误和其他系统错误都会记录到这个文件中。</p>
</blockquote>
<p>如何排查呢？执行以下命令：<br><code>cat /var/log/messages | grep java</code><br>然后发现有下面日志：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Out of memory: Kill process 9682 (java) score 9 or sacrifice child</span><br></pre></td></tr></table></figure>

<p>因此判断由于内存占用过高，java服务被系统误杀了。<br>既然定位到问题根源，那么为了更好的解决问题，我们继续追踪问题，为什么系统会kill java服务，而不杀掉其他进程呢？这里就需要了解一下Linux Out of Memory (OOM) killer机制。</p>
<h1 id="Linux-OOM机制"><a href="#Linux-OOM机制" class="headerlink" title="Linux OOM机制"></a>Linux OOM机制</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>Linux内核设计的一种机制，在内存不足的时候，会选择一个占用内存较大的进程并kill掉这个进程，以满足系统内存申请需求。</p>
<h2 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h2><p>触发条件：内存不足，为什么会出现内存不足，这里涉及到Linux内存结构和使用机制：</p>
<ol>
<li>物理内存结构</li>
<li>overcommit机制</li>
<li>OOM killer机制</li>
</ol>
<h3 id="Linux内存结构"><a href="#Linux内存结构" class="headerlink" title="Linux内存结构"></a>Linux内存结构</h3><p>这里就简单讲一下，具体描述可以google一下Linux物理内存结构。<br>Linux物理内存结构，Linux内核会把物理内存按照<code>node（节点） &gt; zone（分区）&gt; page (内存页)</code>三级结构进行划分，俗称内存管理系统，然后CPU会根据这种内存管理系统去调用内存。简单介绍以下概念：</p>
<ul>
<li>node节点：每个CPU都有自己的node内存节点，可以多个也可以单个，单个叫UMA架构，多个叫NUMA架构</li>
<li>zone分区：每个Node划分很多zone，每个zone都有自己的功能定义，这种只是从软件层面划分定义。zone里还有一个概念叫分配价值链<ul>
<li>分配价值链： 普通的内存分配会有一个“价值”的层次结构</li>
</ul>
</li>
<li>page内存页：属于zone下面的内存页，每个页基础大小是4K，他们维护在一个叫free_area的数组结构中<br>下面是从网上找的Linux物理内存结构图：</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cca72d58e9a94f978d8cedf43a06a834~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<h3 id="虚拟内存-swap空间"><a href="#虚拟内存-swap空间" class="headerlink" title="虚拟内存(swap空间)"></a>虚拟内存(swap空间)</h3><p>相对于物理内存，在 Linux 下还有一个虚拟内存的概念，虚拟内存是为了满足物理内存的不足而提出的策略，它是利用磁盘空间虚拟出的一块逻辑内存。用作虚拟内存的磁盘空间被称为<code>交换空间</code>（又称 <code>swap 空间</code>）。</p>
<p>了解Linux物理内存结构，我们明白Linux 的内存管理采取的是分页存取机制，为了保证物理内存能得到充分的利用，内核会在适当的时候将物理内存中不经常使用的数据块自动交换到虚拟内存中，而将经常使用的信息保留到物理内存。</p>
<p>Linux 内存运行机制:</p>
<ul>
<li>Linux 系统会不时地进行页面交换操作，以保持尽可能多的空闲物理内存，即使并没有什么事情需要内存，Linux 也会交换出暂时不用的内存页面，因为这样可以大大节省等待交换所需的时间</li>
<li>Linux 进行页面交换是有条件的，不是所有页面在不用时都交换到虚拟内存，Linux 内核根据“最近最经常使用”算法，仅仅将一些不经常使用的页面文件交换到虚拟内存</li>
</ul>
<p>虚拟内存是允许设置大小，这也是解决OMM killer的一种解决方案，具体可以看后面的解决方案。</p>
<h3 id="overcommit机制"><a href="#overcommit机制" class="headerlink" title="overcommit机制"></a>overcommit机制</h3><p>有了虚拟内存的存在，那么进程就可以向系统申请比物理剩余内存更大的使用内存：</p>
<blockquote>
<p>在实际申请内存的时候，比如申请1G，并不会在物理区域中分配1G的真实物理内存，而是分配1G的虚拟内存，等到需要的时候才去真正申请物理内存，也就是说申请不等于分配</p>
</blockquote>
<p>这就是overcommit机制，允许进程申请比物理内存实际大的内存。但是这会面临一个问题，当进程真正需要这么多内存怎么办，Linux的解决方案就是OOM killer。</p>
<p>当然，overcommit也允许设置几种值(vm.overcommit_memory)：</p>
<ul>
<li>0 – Heuristic overcommit handling. 这是缺省值，它允许overcommit，但过于明目张胆的overcommit会被拒绝，比如malloc一次性申请的内存大小就超过了系统总内存</li>
<li>1 – Always overcommit. 允许overcommit，对内存申请来者不拒。</li>
<li>2 – Don’t overcommit. 禁止overcommit。</li>
</ul>
<h2 id="OOM-killer机制"><a href="#OOM-killer机制" class="headerlink" title="OOM killer机制"></a>OOM killer机制</h2><p>讲完overcommit，终于来到本文重点，OOM killer机制，这应该是很多Linux系统部署服务，开发者所要面临头疼地方。<br>OOM killer，全称 Out Of Memory Killer，俗称内存溢出杀手。它是如何执行的呢?</p>
<blockquote>
<p>OMM killer机制：linux会为每个进程算一个分数，最终他会将分数最高的进程kill</p>
</blockquote>
<p>有三个进程设置值可以影响到分数值，可手动设置，但是基本上都不会用上，仅用来了解或者临时解决方案：</p>
<ul>
<li><code>/proc/&lt;pid&gt;/oom_score_adj</code>, 取值范围为-1000到1000， 如果将该值设置为-1000，则进程永远不会被杀死，因为此时 badness score 永远返回0</li>
<li><code>/proc/&lt;pid&gt;/oom_adj</code>, 取值是-17到+15，取值越高，越容易被干掉。如果是-17，则表示不能被kill</li>
<li><code>/proc/&lt;pid&gt;/oom_score</code>, 是系统综合进程的内存消耗量、CPU时间(utime + stime)、存活时间(uptime - start time)和oom_adj计算出的，消耗内存越多分越高。</li>
</ul>
<p>除了这三个值，还有一种计算方式：子进程内存：Linux在计算进程的内存消耗的时候，会将子进程所耗内存的一半同时算到父进程中。这样，那些子进程比较多的进程就要小心了。</p>
<h3 id="如何确定进程是被OOM-killer干掉的"><a href="#如何确定进程是被OOM-killer干掉的" class="headerlink" title="如何确定进程是被OOM killer干掉的"></a>如何确定进程是被OOM killer干掉的</h3><p>java tomcat查看之前的进程id或进程名，可以通过命令<code>ps -ef | grep java</code>获取到。<br>其次，查找系统日志<code>grep &quot;Out of memory&quot; /var/log/messages</code>，对比一下进程id或进程名，进行判断。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e8bc25d25784a47ad2f4c2780581d1d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="关闭OOM机制-不推荐，可作为临时解决方案"><a href="#关闭OOM机制-不推荐，可作为临时解决方案" class="headerlink" title="关闭OOM机制(不推荐，可作为临时解决方案)"></a>关闭OOM机制(不推荐，可作为临时解决方案)</h2><p>执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sysctl -w vm.overcommit_memory=2</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "vm.overcommit_memory=2" &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure>

<p>或者修改进程oom_score_adj值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo echo -1000 &gt; /proc/$pid/oom_score_adj</span><br></pre></td></tr></table></figure>

<p>或者修改进程oom_adj值:</p>
<ul>
<li>/proc/PID/oom_adj文件，将其置位-17</li>
</ul>
<h2 id="设置java进程最大占用内存-推荐"><a href="#设置java进程最大占用内存-推荐" class="headerlink" title="设置java进程最大占用内存(推荐)"></a>设置java进程最大占用内存(推荐)</h2><p>java tomcat服务在启用进程的时候可以设置占用最大内存，具体数值可以参考当前服务器所剩余的内存设置，具体设置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -Xms512m -Xmx512m -jar xxx.jar</span><br></pre></td></tr></table></figure>

<ul>
<li>Xms: 最小内存</li>
<li>Xmx: 最大内存<br>tomcat可以在<code>TOMCAT_HOME/bin/catalina.sh</code>中设置:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在cygwin=<span class="literal">false</span>前</span></span><br><span class="line">JAVA_OPTS="-server -Xms256m -Xmx512m -XX:PermSize=64M -XX:MaxPermSize=128m"</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="java守护进程-推荐"><a href="#java守护进程-推荐" class="headerlink" title="java守护进程(推荐)"></a>java守护进程(推荐)</h2><p>除了设置最大占用内存设置，还可以增加守护进程从而避免服务异常挂掉进行重启，主要有两种方案：</p>
<ol>
<li>第一种常用，通过设置<code>crontab</code>脚本去守护。</li>
<li>第二种是Java <code>jsvc</code>方案，利用启动守护进程去监控控制服务进程，从而避免进程无缘无故挂掉自动重启，tomcat本身已有<code>daemon.sh</code>，可以直接该脚本即可。</li>
</ol>
<h2 id="优化代码-有能力者可以采用"><a href="#优化代码-有能力者可以采用" class="headerlink" title="优化代码(有能力者可以采用)"></a>优化代码(有能力者可以采用)</h2><p>这个可能需要具体问题具体分析了，优化代码占用内存，java网上有很多方案，大家各自采纳符合自己的方案即可。</p>
<h2 id="申请更多内存-土豪随意"><a href="#申请更多内存-土豪随意" class="headerlink" title="申请更多内存(土豪随意)"></a>申请更多内存(土豪随意)</h2><p>既然是内存不够，那么就直接申请更多资源，就可以满足了，看来还是有钱就能更快解决问题。</p>
]]></content>
      <tags>
        <tag>技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>React与Jest的单元测试(1)</title>
    <url>/study/react-test1.html</url>
    <content><![CDATA[<h1 id="什么是单元测试"><a href="#什么是单元测试" class="headerlink" title="什么是单元测试"></a>什么是单元测试</h1><p>如果你听说过“测试驱动开发”（TDD：Test-Driven Development），单元测试就不陌生。</p>
<p>单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。</p>
<a id="more"></a>
<h2 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h2><p>在github的开源项目经常会有单元测试覆盖率，长得比如<code>vuejs</code>框架，如下图所示：<br><img src="http://ww1.sinaimg.cn/large/68c990d9gy1g7c48fwqh5j21aa0ec408.jpg" alt="image.png"></p>
<ul>
<li>上图中的 build passing 表示 travis build 通过了，用绿色背景显示，表明很安全。</li>
<li>npm v2.6.10 表示最新版本是 v2.6.10，用蓝色背景显示，表明是稳定的版本。</li>
<li>downloads 4.7m/month 表示最近一个月 npm 里的下载数量为 4.7万 次。</li>
<li>coverage 97% 表示测试覆盖率达到了 100%，用蓝绿色背景显示，表明虽通过测试但是还存在未测试到地方。</li>
</ul>
<p>测试覆盖率就是运行的测试覆盖了多少代码里的逻辑，下一篇我们讲到如何建立github的测试覆盖率。</p>
<!-- https://juejin.im/entry/58c51defa22b9d0058ac1980 -->

<p>明白上面的概念后我们就开始进入学习。</p>
<h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><h2 id="Jest、Enzyme-介绍"><a href="#Jest、Enzyme-介绍" class="headerlink" title="Jest、Enzyme 介绍"></a>Jest、Enzyme 介绍</h2><p>Jest 是 Facebook 发布的一个开源的、基于 <code>Jasmine</code> 框架的 JavaScript 单元测试工具。提供了包括内置的测试环境 DOM API 支持、断言库、Mock 库等，还包含了 Spapshot Testing、 Instant Feedback 等特性。</p>
<p>Airbnb开源的 React 测试类库 Enzyme 提供了一套简洁强大的 API，并通过 jQuery 风格的方式进行DOM 处理，开发体验十分友好。不仅在开源社区有超高人气，同时也获得了React 官方的推荐。</p>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>通过<code>create-react-app</code>去创建项目，步骤如下：</p>
<ol>
<li><code>create-react-app test-app</code>后，等待几分钟安装依赖完成</li>
<li>项目自带<code>jest</code>测试框架，但是还需要安装其他测试框架</li>
<li>安装<code>yarn add enzyme enzyme-adapter-react-16 react-test-renderer</code></li>
</ol>
<h2 id="示例项目"><a href="#示例项目" class="headerlink" title="示例项目"></a>示例项目</h2><p>在项目中我们将实现一个待办事项，并进行TTD开发。</p>
<p>需求描述：在页面中有个输入框，并允许进行点击新增待办事项和删除事项。</p>
<p><a href>项目源码可以点击这里进行克隆</a></p>
<h2 id="jest常用API"><a href="#jest常用API" class="headerlink" title="jest常用API"></a>jest常用API</h2><ul>
<li>describe(name, fn)：描述块，讲一组功能相关的测试用例组合在一起</li>
<li>it(name, fn, timeout)：别名test，用来放测试用例</li>
<li>afterAll(fn, timeout)：所有测试用例跑完以后执行的方法</li>
<li>beforeAll(fn, timeout)：所有测试用例执行之前执行的方法</li>
<li>afterEach(fn)：在每个测试用例执行完后执行的方法</li>
<li>beforeEach(fn)：在每个测试用例执行之前需要执行的方法</li>
</ul>
]]></content>
      <tags>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title>周二技术周刊 20190924期</title>
    <url>/wx/20190924.html</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/68c990d9gy1g7au94i5grj21pe14x7wi.jpg" alt="好看的图片"></p>
<h1 id="一、技术知识"><a href="#一、技术知识" class="headerlink" title="一、技术知识"></a>一、技术知识</h1><h2 id="《降低软件复杂性一般原则和方法》"><a href="#《降低软件复杂性一般原则和方法》" class="headerlink" title="《降低软件复杂性一般原则和方法》"></a>《降低软件复杂性一般原则和方法》</h2><p>简介：</p>
<p>本篇文章是围绕着“降低复杂性”这个主题展开的，很多重要的结论来源于John Ousterhout的著作《A Philosophy of Software Design》，作者觉得很有共鸣，就做了一些相关话题的延伸、补充了一些实例。虽说是”一般原则“，也不意味着是绝对的真理，整理出来，只是为了引发大家对软件设计的思考。</p>
<a id="more"></a>

<h3 id="读后心得"><a href="#读后心得" class="headerlink" title="读后心得"></a>读后心得</h3><p><strong>现代系统复杂性解决原则</strong></p>
<ul>
<li>由于互联网的变化过快，系统是无法一次性满足的，都是通过一个个功能模块衍生迭代，系统才会逐步成型；</li>
<li>专业化分工和代码复用是促成了软件生产率的提升的准则，由专业的人负责专业的事；</li>
<li>分模块是从垂直方向来分解系统，如：微服务。分模块降低了单模块的复杂性，但是也会引入新的复杂性，例如模块与模块的交互；</li>
<li>完善文档和注释，因为代码能够描述程序的工作流程和结果，却很难描述开发人员的思路。</li>
</ul>
<blockquote>
<p>好的注释能够帮助解决软件复杂性问题，尤其是认知负担和不可知问题（Unknown Unknowns）。</p>
</blockquote>
<p><strong>设计技术方案前的两个问题</strong></p>
<ul>
<li>其一，为什么该方案可行？</li>
<li>其二，在已有资源限制下，为什么该方案是最优的？</li>
<li>为了回答第一个问题，我们需要在技术方案里补充架构图、接口设计和时间人力估算。</li>
<li>而要回答第二个问题，需要我们在关键点或争议处提供二到三种方案，并给出建议方案，这样才有说服力。</li>
</ul>
<p><strong>技术方案设计原则</strong></p>
<ul>
<li>复杂系统最好的设计原则就是严格分层——内部的层只对相邻的层次可见，这样就可以将一个复杂问题分解成增量步骤序列，分层系统最有名的实例是TCP/IP网络模型。</li>
<li>复杂性下沉，永远对用户友好的设计就是好设计。</li>
<li>异常错误处理原则就是：尽可能减少需要处理异常的可能性。而最佳实践就是确保错误终结，例如删除一个并不存在的文件，与其上报文件不存在的异常，不如什么都不做。确保文件不存在就好了。</li>
</ul>
<p><strong><em>阅读时间：15~20分钟</em></strong></p>
<p>其他更多关于软件设计原则可以前往:</p>
<blockquote>
<p><a href="https://tech.meituan.com/2019/09/19/common-method-of-reduce-complexity.html" target="_blank" rel="noopener">https://tech.meituan.com/2019/09/19/common-method-of-reduce-complexity.html</a></p>
</blockquote>
<h1 id="十大-npm-最佳安全指南，教你如何避免安全漏洞！"><a href="#十大-npm-最佳安全指南，教你如何避免安全漏洞！" class="headerlink" title="十大 npm 最佳安全指南，教你如何避免安全漏洞！"></a>十大 npm 最佳安全指南，教你如何避免安全漏洞！</h1><p>简介：</p>
<p>你重视 npm 漏洞吗？无论是前端还是后端开发人员，都应该重视 npm 的安全性最佳实践。开源代码的安全审查是提升安全性的关键所在，其中 npm 包的安全性应该是首要考虑因素，因为我们发现即使是官方的 npm 命令行工具也很容易受到攻击。</p>
<p>本文提供的这份备忘列表中，我们将列出针对开源维护人员和开发人员的十大最佳安全实践和生产力提示。</p>
<h2 id="快速阅读"><a href="#快速阅读" class="headerlink" title="快速阅读"></a>快速阅读</h2><p><strong>十大安全指南</strong></p>
<ol>
<li>不要把秘密发布到 npm 存储库上</li>
<li>强制锁文件</li>
<li>忽略运行脚本，最小化攻击面</li>
<li>评估 npm 项目的健康状况</li>
<li>审核开源依赖项中的漏洞(使用 Snyk 扫描安全漏洞)</li>
<li>使用本地 npm 代理</li>
<li>负责任地披露安全漏洞</li>
<li>启用 2FA</li>
<li>使用 npm 作者令牌</li>
<li>了解模块命名约定和域名仿冒攻击</li>
</ol>
<p>喜欢阅读或者对安全更加注意，请点击下方链接前往阅读：</p>
<blockquote>
<p><a href="https://www.infoq.cn/article/SI05RvA2QaeLhPx0kWmu" target="_blank" rel="noopener">https://www.infoq.cn/article/SI05RvA2QaeLhPx0kWmu</a></p>
</blockquote>
<h1 id="把网站升级到http-2"><a href="#把网站升级到http-2" class="headerlink" title="把网站升级到http/2"></a>把网站升级到http/2</h1><h1 id="二、一周新闻"><a href="#二、一周新闻" class="headerlink" title="二、一周新闻"></a>二、一周新闻</h1><h2 id="Vue-3-0-最新进展，Composition-API"><a href="#Vue-3-0-最新进展，Composition-API" class="headerlink" title="Vue 3.0 最新进展，Composition API"></a>Vue 3.0 最新进展，Composition API</h2><p>本文主要分以下几个主题讨论最新的Composition API：</p>
<ul>
<li>reactive API</li>
<li>ref API</li>
<li>watch API变化</li>
<li>computed API变化</li>
<li>生命周期钩子变化</li>
<li>TypeScript和JSX支持</li>
</ul>
<p>Composition API 可谓是修复了 Function API 诸多问题而提供的最新“修正案”，下面来看比起之前的vue-function-api，究竟修改了些什么呢？请前往阅读：</p>
<blockquote>
<p><a href="https://juejin.im/post/5d836458f265da03d871f6e9" target="_blank" rel="noopener">https://juejin.im/post/5d836458f265da03d871f6e9</a></p>
</blockquote>
<h1 id="三、玩遍前端"><a href="#三、玩遍前端" class="headerlink" title="三、玩遍前端"></a>三、玩遍前端</h1><h2 id="小tips-元素focus页面不滚动不定位的JS处理"><a href="#小tips-元素focus页面不滚动不定位的JS处理" class="headerlink" title="小tips: 元素focus页面不滚动不定位的JS处理"></a>小tips: 元素focus页面不滚动不定位的JS处理</h2><p>全新的API参数preventScroll，感觉请阅读原文：</p>
<blockquote>
<p><a href="https://www.zhangxinxu.com/wordpress/2019/09/js-focus-preventscroll/" target="_blank" rel="noopener">https://www.zhangxinxu.com/wordpress/2019/09/js-focus-preventscroll/</a></p>
</blockquote>
<h2 id="浏览器的一些“滚动”行为鉴赏"><a href="#浏览器的一些“滚动”行为鉴赏" class="headerlink" title="浏览器的一些“滚动”行为鉴赏"></a>浏览器的一些“滚动”行为鉴赏</h2><p>应该你遇到所有的“滚动”事件的相关问题和现象都可以在这篇文章里找到了：</p>
<blockquote>
<p><a href="https://juejin.im/post/5d75adfbe51d4561e84fcc9c" target="_blank" rel="noopener">https://juejin.im/post/5d75adfbe51d4561e84fcc9c</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>周二技术周刊</tag>
      </tags>
  </entry>
  <entry>
    <title>奇思妙想录</title>
    <url>/ideas/list.html</url>
    <content><![CDATA[<h1 id="2019-09-03"><a href="#2019-09-03" class="headerlink" title="2019-09-03"></a>2019-09-03</h1><h2 id="一个智能识别语音和输出的白板软件引擎"><a href="#一个智能识别语音和输出的白板软件引擎" class="headerlink" title="一个智能识别语音和输出的白板软件引擎"></a>一个智能识别语音和输出的白板软件引擎</h2><p>功能描述：</p>
<ul>
<li>通过人脸标识用户信息，得到当前输出用户</li>
<li>通过语音识别输出用户所描述内容</li>
<li>通过语义归类总结内容</li>
<li>通过流程图或思维导图输出最终白板任务图</li>
</ul>
<a id="more"></a>

<h1 id="2019-09-01"><a href="#2019-09-01" class="headerlink" title="2019-09-01"></a>2019-09-01</h1><h2 id="npm包评价系统"><a href="#npm包评价系统" class="headerlink" title="npm包评价系统"></a>npm包评价系统</h2><p>功能描述：</p>
<ul>
<li>通过cnpm或taobao搭建公有的npm包</li>
<li>筛选有github开源仓库</li>
<li>通过github的star数进行排名</li>
<li>增加类似豆瓣评分和评价系统</li>
</ul>
]]></content>
      <tags>
        <tag>奇思妙想</tag>
      </tags>
  </entry>
  <entry>
    <title>周二技术周刊 20190731期</title>
    <url>/wx/20190731.html</url>
    <content><![CDATA[<p><img src="https://pic.qqtn.com/up/2018-6/2018661629543719.jpg" alt="好看的图片"></p>
<h1 id="一、技术知识"><a href="#一、技术知识" class="headerlink" title="一、技术知识"></a>一、技术知识</h1><h2 id="1-1-蚂蚁金服前端框架和工程化实践"><a href="#1-1-蚂蚁金服前端框架和工程化实践" class="headerlink" title="1.1 蚂蚁金服前端框架和工程化实践"></a>1.1 蚂蚁金服前端框架和工程化实践</h2><p>作者：<a href="https://github.com/sorrycc" target="_blank" rel="noopener">阿里-云谦</a><br>简介：<br>讲述阿里Umi 和 Bigfish框架的发展历史，已经作者技术团队在里面做的哪些事情。</p>
<a id="more"></a>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>框架为什么能够成功的原因？</strong></p>
<ul>
<li>人：给使用者成就感和绩效——插件体系，插件体系是如何搭建的具体看原文详细介绍。</li>
<li>业务和流程：简化业务和流程，让程序员不必要浪费太多时间上上面。</li>
<li>开源：开源做地好，也更容易获得内部同学的认可。</li>
</ul>
<p><strong>资产市场分了四级:</strong></p>
<ul>
<li>组件，指通用组件，就是 antd，在下半年将要发布的 antd@4 里，我们会陆续提取更多通用组件到 antd 中。</li>
<li>业务组件，不能提取通用组件的，我们会提到内部统一的业务组件仓库中。</li>
<li>区块，由组件组成，可以想象成代码片段。</li>
<li>页面模板，由区块组成</li>
</ul>
<blockquote>
<p>后续要做配置化方案，可以参考一下。</p>
</blockquote>
<p><strong>微前端方案</strong></p>
<ul>
<li>相对狭义的理解，是一个解决多套技术栈共存的方案，比如首页用 jQuery，订单页用 React，客户系统用 Vue。</li>
<li>对微前端的理解是，他不仅是个技术方案，更是个解决流程、组织架构等问题的方案。</li>
</ul>
<blockquote>
<p>已有开源方案，乾坤:<a href="https://github.com/umijs/qiankun" target="_blank" rel="noopener">https://github.com/umijs/qiankun</a></p>
</blockquote>
<p><strong>前端永远不能忘记的：</strong></p>
<ul>
<li>优化：构建优化，性能优化等</li>
<li>测试+监控：单测、UI 测试、e2e 测试和集成测试，基本方案是基于 Jest + test-react-library + Puppeteer</li>
</ul>
<p><strong><em>阅读时间：15~20分钟</em></strong></p>
<p><a href="https://mp.weixin.qq.com/s/6-yjR_CsHaWUI8YqLK25rA" target="_blank" rel="noopener">点击原文阅读→</a></p>
<h2 id="1-2-哪些技术会决定前端开发者的未来发展？"><a href="#1-2-哪些技术会决定前端开发者的未来发展？" class="headerlink" title="1.2 哪些技术会决定前端开发者的未来发展？"></a>1.2 哪些技术会决定前端开发者的未来发展？</h2><p>简介：<br>大家有没有想过，通过学习Flutter，你的技术就提升了吗？</p>
<p>很多人第一反应是『当然了，学了一门新技术，学了一门新语言，难道技术不是提升了吗？』。</p>
<p>但是我觉得并没有，我其实依然在原地打转，<strong>一个Java开发者学会了用Ruby增删改查并不能代表能力提高了，一个前端开发者用RN或者Flutter开发了简单的APP也不能说明水平提高了，只不过是用另一种语言再写了一遍UI而已，会用三种框架写页面，并不是什么高技术含量的事情，会三种不如深入一种。</strong></p>
<p>##总结<br><strong>归纳两点</strong></p>
<ul>
<li>我们有时候看似在学很多技术，其实这些技术并不能提升你，但是给你造成了『我学了新东西能力提升了』的自我感觉偏差</li>
<li>不要盲目追寻社区的热点，很可能捡了芝麻丢了西瓜，要仔细思考这门技术对于你本身是否有提升，而不是被布道师们『洗脑』</li>
</ul>
<p><strong>处于趋势中的技术点</strong></p>
<ul>
<li><code>Flutter</code>，正是新框架，可以学习，但不要认为你的技术有了新的发展。</li>
<li><code>TypeScript</code>，会越来越多人用，因为其规范JavaScript的语法，降低很多不必要的类型错误，以及更多重大开源项目使用与支持。</li>
<li><code>图形技术</code>，将是未来所有前端程序员的痛点之一，进阶技术知识。</li>
<li><code>编辑器领域技术</code>，包括但不限于：代码编辑器（WebIDE）、图形编辑器（在线的3d建模或者ps）、文本编辑器等。</li>
<li><code>Serverless</code>是生产力上的直接提升，前端可以不考虑部署、运维、环境等场景，直接编写函数来实现后端逻辑的全干工程师。</li>
<li><code>IOT</code>（物联网 Internet of Things），js in IOT是因为js开发群众多，但是IOT是低性能低功耗低内存的设备，与js相反，所以最后js又会沦为写业务，但是和在浏览器开发有什么区别呢？</li>
<li><code>GraphQL</code>技术考验的是跨团队沟通协作能力，不是技术本身，干活是后端，得利的却是前端。</li>
<li><code>AI In FE</code>，tfjs的问题，基于浏览器的深度学习框架，其实应用范围非常非常窄，目前主要科研阶段。</li>
</ul>
<blockquote>
<p>因此，个人需要学习可以尝试学习<code>TypeScript</code>,<code>图形技术</code>和<code>编辑器领域技术</code>，顺便可以了解一下<code>Flutter</code>去实现HelloWorld。</p>
</blockquote>
<p>原文阅读链接：<br><a href="https://juejin.im/post/5d1589c8e51d45776031b02e" target="_blank" rel="noopener">https://juejin.im/post/5d1589c8e51d45776031b02e</a></p>
<h1 id="二、一周新闻"><a href="#二、一周新闻" class="headerlink" title="二、一周新闻"></a>二、一周新闻</h1><h2 id="2-1-npm-已落伍，下一代包管理器-Tink-正在孵化"><a href="#2-1-npm-已落伍，下一代包管理器-Tink-正在孵化" class="headerlink" title="2.1 npm 已落伍，下一代包管理器 Tink 正在孵化"></a>2.1 npm 已落伍，下一代包管理器 Tink 正在孵化</h2><blockquote>
<p>迄今为止，npm 生态系统已经拥有了近 1,000,000 个软件包，是规模最大的包管理平台。但这个生态系统及软件包管理器在诞生时并没有考虑如此复杂的局面，它们原本是适用于以 Node.js 生态系统为中心的小型项目和软件包的平台。</p>
</blockquote>
<blockquote>
<p>现在是时候重新定义适合现代 Web 开发的包管理技术了，而答案就是 Tink：它同样来自于 npm 团队，是下一代的 JS 包管理方案。Tink 将带来前所未有的性能表现、与 Node.js 等已有技术的深度兼容性，以及非常适合现代 Web 开发者的用户体验。<br><a href="https://www.infoq.cn/article/R*5JRVuOOHBRlw411PlZ" target="_blank" rel="noopener">https://www.infoq.cn/article/R*5JRVuOOHBRlw411PlZ</a></p>
</blockquote>
<h2 id="2-2-GMTC-2019-参会感想"><a href="#2-2-GMTC-2019-参会感想" class="headerlink" title="2.2 GMTC 2019 参会感想"></a>2.2 GMTC 2019 参会感想</h2><blockquote>
<p>得知 GMTC 2019 在北京举行还是今年 3 月份 EE 协作文档 的前端同学，推荐我们团队去 GMTC 做个分享，所以也顺便组织团队成员一起去向业界大佬学习。<br><a href="https://juejin.im/post/5d132ec16fb9a07efa092909" target="_blank" rel="noopener">https://juejin.im/post/5d132ec16fb9a07efa092909</a></p>
</blockquote>
<h1 id="三、玩遍前端"><a href="#三、玩遍前端" class="headerlink" title="三、玩遍前端"></a>三、玩遍前端</h1><h2 id="3-1-git-js"><a href="#3-1-git-js" class="headerlink" title="3.1 git-js"></a>3.1 git-js</h2><blockquote>
<p>一个可以在nodejs中去执行git命令的框架，大家可以尝试玩一下如何管理团队仓库，以及定制化的代码审核界面。<br><a href="https://github.com/steveukx/git-js" target="_blank" rel="noopener">https://github.com/steveukx/git-js</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>周二技术周刊</tag>
      </tags>
  </entry>
  <entry>
    <title>ios12 array.reverse问题</title>
    <url>/share/ios12-array-reverse.html</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>iOS12发布之后，在测试中发现一个关于Array.reverse的问题，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt;</span><br><span class="line">    &lt;title&gt;iOS 12 Safari bugs&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.addEventListener(&quot;load&quot;, function ()</span><br><span class="line">    &#123;</span><br><span class="line">        let arr = [1, 2, 3, 4, 5];</span><br><span class="line">        alert(arr.join());</span><br><span class="line"></span><br><span class="line">        document.querySelector(&quot;button&quot;).addEventListener(&quot;click&quot;, function ()</span><br><span class="line">        &#123;</span><br><span class="line">            arr.reverse();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button&gt;Array.reverse()&lt;/button&gt;</span><br><span class="line">    &lt;p style=&quot;color:red;&quot;&gt;test: click button and refresh page, code:&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>问题描述：第一次进入刷新alert:<code>1,2,3,4</code>，第二次刷新就一直为alert<code>4,3,2,1</code>。</p>
<h1 id="demo演示"><a href="#demo演示" class="headerlink" title="demo演示"></a>demo演示</h1><p><a href="https://fanmingfei.github.io/array-reverse-ios12/origin.html" target="_blank" rel="noopener">未修复的demo</a><br><a href="https://fanmingfei.github.io/array-reverse-ios12/fixed.html" target="_blank" rel="noopener">已修复的demo</a></p>
<a id="more"></a>

<h1 id="修复方法"><a href="#修复方法" class="headerlink" title="修复方法"></a>修复方法</h1><p>原理就是判断是否为iOS12版本，重写<code>Array.prototype.reverse</code>方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    var ua = navigator.userAgent;</span><br><span class="line">    if (!ua.match(/(iPhone|iPad|iPod)/)) return;</span><br><span class="line">    var matched = ua.match(/OS ([\d_\.]+) like Mac OS X/);</span><br><span class="line">    if (!matched || !matched[1]) return;</span><br><span class="line">    if (matched[1].indexOf(&apos;12&apos;) !== 0) return;</span><br><span class="line">    //以上判断是否为iOS12版本</span><br><span class="line">    </span><br><span class="line">    //以下为修复代码</span><br><span class="line">    Array.prototype._reverse = Array.prototype.reverse;</span><br><span class="line">    //重写reverse方法</span><br><span class="line">    Array.prototype.reverse = function reverse() &#123;</span><br><span class="line">        //重新设置数组长度 从而避免reverse方法改变数据后被缓存</span><br><span class="line">        if (Array.isArray(this)) this.length = this.length;</span><br><span class="line">        return Array.prototype._reverse.call(this);</span><br><span class="line">    &#125;</span><br><span class="line">    var nonenum = &#123;</span><br><span class="line">        enumerable: false</span><br><span class="line">    &#125;;</span><br><span class="line">    //设置Array原型链中的reverse方法不可枚举</span><br><span class="line">    Object.defineProperties(Array.prototype, &#123;</span><br><span class="line">        _reverse: nonenum,</span><br><span class="line">        reverse: nonenum,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>希望大家不要遇到该类生产问题咯！(否则你都不知道哪里出错了~~)</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://stackoverflow.com/questions/52390368/array-state-will-be-cached-in-ios-12-safari-is-bug-or-feature/52392901#52392901" target="_blank" rel="noopener">stackoverflow——iOS 12 Array.Reverse的Bug</a></li>
<li><a href="https://github.com/fanmingfei/array-reverse-ios12/" target="_blank" rel="noopener">github中阿里同事——如何修复iOS12 Array.reverse的bug方案</a></li>
</ul>
]]></content>
      <tags>
        <tag>技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS11.3 fastclick.js相关bug</title>
    <url>/share/iOS11-fastclick-js.html</url>
    <content><![CDATA[<p>最近遇到奇异的bug,在ios 11.3移动端页面 input输入框第一次触摸可以弹起键盘，后续再触摸需要很难弹起键盘，或者需要在输入框停一会才能弹起键盘。</p>
<h2 id="bug复现条件："><a href="#bug复现条件：" class="headerlink" title="bug复现条件："></a>bug复现条件：</h2><p>一、ios 11.3中app的webview为 UI WebView<br>二、在项目中使用了FastClick.js，页面包括输入框.</p>
<h2 id="发现源头问题："><a href="#发现源头问题：" class="headerlink" title="发现源头问题："></a>发现源头问题：</h2><p>在碰到问题脑子第一想法这不就是click延迟300ms的现象吗？所以就想到是不是FastClick.js导致，注释掉后发现bug现象消失了，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define([<span class="string">'zepto'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</span><br><span class="line"><span class="meta"> 'use strict'</span>;</span><br><span class="line"> <span class="comment">// FastClick.attach(document.body);</span></span><br><span class="line"> ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>但是这是为什么呢？我们一起看看为什么要加上FastClick，这个库解决了什么问题？</p>
<a id="more"></a>

<ul>
<li>click 300ms延迟：浏览器click会比touch延迟300ms触发</li>
<li>click穿透现象：当两个div同处一个position，上层div绑定touch，下层div绑定click,当上层div触发touch消失后，可能会触发下层div的click事件<br>既然Fastclick是为了解决这两类问题，其实现原理如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/11733108-a045cb92752f7ae8.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="fastclick原理"></li>
</ul>
<p>fastclick利用捕获顶层dom元素(如：body，html等)的click事件，拦截所有的click请求进行判断：是否有touch触发、是否需要阻碍click事件(stopImmediatePropagation)等。</p>
<h2 id="分析问题解决方案："><a href="#分析问题解决方案：" class="headerlink" title="分析问题解决方案："></a>分析问题解决方案：</h2><p>步骤一：input无法聚焦弹出键盘，fastclick中有一块判断当前元素targetElement是否需要needsFocus，看看其方法的实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">FastClick.prototype.needsFocus = <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123; <span class="comment">//判断当前元素是否需要focus</span></span><br><span class="line">        <span class="keyword">switch</span> (target.nodeName.toLowerCase()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'textarea'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'select'</span>:</span><br><span class="line">                <span class="keyword">return</span> !deviceIsAndroid;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'input'</span>:</span><br><span class="line">                <span class="keyword">switch</span> (target.type) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'button'</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'checkbox'</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'file'</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'image'</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'radio'</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'submit'</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// No point in attempting to focus disabled inputs</span></span><br><span class="line">                <span class="keyword">return</span> !target.disabled &amp;&amp; !target.readOnly;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> (<span class="regexp">/\bneedsfocus\b/</span>).test(target.className);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>步骤二：看到needsFocus下执行了什么？在touchEnd方法中，代码块如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.needsFocus(targetElement)) &#123;<span class="keyword">if</span> ((event.timeStamp - trackingClickStart) &gt; <span class="number">100</span> || (deviceIsIOS &amp;&amp; <span class="built_in">window</span>.top !== <span class="built_in">window</span> &amp;&amp; targetTagName === <span class="string">'input'</span>)) &#123;</span><br><span class="line"> <span class="keyword">this</span>.targetElement = <span class="literal">null</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">this</span>.focus(targetElement); <span class="comment">//调用focus进行聚焦</span></span><br><span class="line"> <span class="keyword">this</span>.sendClick(targetElement, event);</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">if</span> (!deviceIsIOS || targetTagName !== <span class="string">'select'</span>) &#123;</span><br><span class="line"> <span class="keyword">this</span>.targetElement = <span class="literal">null</span>;</span><br><span class="line"> event.preventDefault();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>步骤三：focus方法分析（包含解决方案），如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">FastClick.prototype.focus = <span class="function"><span class="keyword">function</span>(<span class="params">targetElement</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> length;</span><br><span class="line">        <span class="comment">//兼容处理:在iOS7中，有一些元素（如date、datetime、month等）在setSelectionRange会出现TypeError</span></span><br><span class="line">        <span class="comment">//这是因为这些元素并没有selectionStart和selectionEnd的整型数字属性，所以一旦引用就会报错，因此排除这些属性才使用setSelectionRange方法</span></span><br><span class="line">        <span class="keyword">if</span> (deviceIsIOS &amp;&amp; targetElement.setSelectionRange &amp;&amp; targetElement.type.indexOf(<span class="string">'date'</span>) !== <span class="number">0</span> &amp;&amp; targetElement.type !== <span class="string">'time'</span> &amp;&amp; targetElement.type !== <span class="string">'month'</span> &amp;&amp; targetElement.type !== <span class="string">'email'</span>) &#123;</span><br><span class="line">            length = targetElement.value.length;</span><br><span class="line">            targetElement.setSelectionRange(length, length);</span><br><span class="line">            <span class="comment">/*修复bug ios 11.3不弹出键盘，这里加上聚焦代码，让其强制聚焦弹出键盘*/</span></span><br><span class="line">            targetElement.focus();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            targetElement.focus();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>OK，上真机iphoneX验证bug已经消失了，但是我们并不知道为什么在ios 11.3会出现该问题，秉着探索真理的一颗心（ZZZZ），到github去查看FastClick的issues列表，果然发现早有人提出bug了，如下图：<br><img src="https://upload-images.jianshu.io/upload_images/11733108-dc00511b626e3496.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="fastclick issues"></p>
<p>下方有评论如下：<br>A：说framework7框架那边已经有解决方案啦，<a href="https://github.com/framework7io/framework7/issues/2314#issuecomment-377778034" target="_blank" rel="noopener">点击这里</a>。<br><img src="https://upload-images.jianshu.io/upload_images/11733108-2e17af0f0c9a7474.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="frameword7问题解决"></p>
<p>另外一位仁兄的解决方案和我类似，修改focus方法。<br><img src="https://upload-images.jianshu.io/upload_images/11733108-829a9db17ea2e4b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="focus解决方案"></p>
<p>因此跳到framework的issue中的解决方案，解决方案：<a href="https://stackoverflow.com/questions/49500339/cant-prevent-touchmove-from-scrolling-window-on-ios" target="_blank" rel="noopener">点击这里</a>，描述如下：<br><img src="https://upload-images.jianshu.io/upload_images/11733108-443f9d4c26e32cd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="解决方案描述"></p>
<p>跳过去stackoverflow后，其实根本源头已经查到了，ios 11.3更新 Safari 11.1，支持新web API :允许对事件支持 <code>{passive: false}</code>被动模式，减少滚动屏幕的性能损耗和奔溃。</p>
<h2 id="passive-mode解析"><a href="#passive-mode解析" class="headerlink" title="passive mode解析"></a>passive mode解析</h2><p>那么新的问题来了，{passive: false}是什么玩意？来，我们先看看它的使用方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'touchmove'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;, &#123; <span class="attr">passive</span>: <span class="literal">false</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>按照以往我们对添加事件监听的方法三个参数的认知，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(type , callback, capture); <span class="comment">//type是事件类型，callback是执行函数， capture是否进行捕获/冒泡，默认为false</span></span><br></pre></td></tr></table></figure>

<p>Passive event listeners是2016年Google I/O 上同 PWA 概念一起被提出，但是同PWA不同，Passive event listeners 的作用很简单，如果用简单一句话来解释就是：提升页面滑动的流畅度。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">target.addEventListener(type, listener[, options]);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">options 可选</span></span><br><span class="line"><span class="comment">一个指定有关 listener 属性的可选参数对象。</span></span><br><span class="line"><span class="comment">可用的选项如下：</span></span><br><span class="line"><span class="comment">capture:  Boolean，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发。</span></span><br><span class="line"><span class="comment">once:  Boolean，表示 listener 在添加之后最多只调用一次。如果是 true， listener 会在其被调用之后自动移除。</span></span><br><span class="line"><span class="comment">passive: Boolean，表示 listener 永远不会调用 preventDefault()。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//示例代码</span></span><br><span class="line">target.addEventListener(<span class="string">'touchstart'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">   e.preventDefault() <span class="comment">// 无效，报错</span></span><br><span class="line">&#125;, &#123;<span class="attr">passive</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>为什么增加支持这个属性会导致添加fastclick后input输入框很难弹出键盘？</p>
<p>在ios更新日志了，写到了“Updated root document touch event listeners to use passive mode improving scrolling performance and reducing crashes.”</p>
<p>翻译过来就是：针对document的touch事件监听添加passive配置，即是：{passive: true}，会永远不调用event.preventDefault()，以此来提高滚动性能。</p>
<p>源头推测：</p>
<p>fastclick是采用拦截click和监听touch事件去实现的，里面包括对tagetElement的focus方法重写，因此在11.3之前可能event.preventDefault生效了，同时用setSelectionRange是可以聚焦input的。</p>
<p>另外一个bug也是由这个导致的是：</p>
<p>在iOS11.3的UI webview使用fastclick.js，页面有个按钮点击事件，当app或锁屏超过几分钟时间，回到页面会导致click事件失效。</p>
<p>解决方案为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> passiveListener = (<span class="function"><span class="keyword">function</span> <span class="title">checkPassiveListener</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//判断浏览器是否支持 &#123;passive: true&#125;</span></span><br><span class="line">            <span class="keyword">var</span> supportsPassive = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> opts = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'passive'</span>, &#123;</span><br><span class="line">                    <span class="keyword">get</span>: function() &#123;</span><br><span class="line">                        supportsPassive = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="built_in">window</span>.addEventListener(<span class="string">'testPassiveListener'</span>, <span class="literal">null</span>, opts);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                supportsPassive = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> supportsPassive;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="keyword">var</span> activeListener = passiveListener ? &#123;<span class="attr">passive</span>:<span class="literal">false</span>&#125; : <span class="literal">false</span>;</span><br><span class="line">layer.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.onClick, <span class="literal">true</span>);</span><br><span class="line">layer.addEventListener(<span class="string">'touchstart'</span>, <span class="keyword">this</span>.onTouchStart, passiveListener);</span><br><span class="line">layer.addEventListener(<span class="string">'touchmove'</span>, <span class="keyword">this</span>.onTouchMove, passiveListener);</span><br><span class="line">layer.addEventListener(<span class="string">'touchend'</span>, <span class="keyword">this</span>.onTouchEnd, passiveListener);</span><br><span class="line">layer.addEventListener(<span class="string">'touchcancel'</span>, <span class="keyword">this</span>.onTouchCancel, passiveListener);</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="noopener">《EventTarget.addEventListener()增加passive属性说明——web MDN API网站》</a></li>
<li><a href="https://github.com/ftlabs/fastclick/issues/548" target="_blank" rel="noopener">《fastclick github issues#548》</a></li>
<li><a href="https://stackoverflow.com/questions/49500339/cant-prevent-touchmove-from-scrolling-window-on-ios" target="_blank" rel="noopener">《stackoverflow ——touchmove e.preventDefault失效问题》</a></li>
<li><a href="https://developer.apple.com/library/content/releasenotes/General/WhatsNewInSafari/Articles/Safari_11_1.html" target="_blank" rel="noopener">《Safari 11.1更新日志》</a></li>
</ul>
]]></content>
      <tags>
        <tag>技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>如何用自定义钩子重构 React 组件</title>
    <url>/translate/wait.html</url>
    <content><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://codescene.com/engineering-blog/refactoring-components-in-react-with-custom-hooks" target="_blank" rel="noopener">如何用自定义钩子重构 React 组件</a></p>
]]></content>
      <tags>
        <tag>翻译文章</tag>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>//404.html</url>
    <content><![CDATA[<html>
<head><meta name="generator" content="Hexo 3.9.0">
</head>
<body>
<script type="text/javascript" src="http://www.qq.com/404/search_children.js" charset="utf-8" homepageurl="http://leyar.me" homepagename="返回主页"></script>
</body>
</html>]]></content>
  </entry>
</search>
