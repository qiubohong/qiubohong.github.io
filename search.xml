<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>个人技术栈(持续更新)</title>
    <url>/study/front-stack.html</url>
    <content><![CDATA[<h1 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h1><p>主要总结个人技术栈，会不停更新，直到部分被淘汰。</p>
<a id="more"></a>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>个人<ul>
<li>语言<ul>
<li>JavaScript<ul>
<li>JavaScript</li>
<li>Typescript</li>
<li>Node.js</li>
</ul>
</li>
<li>CSS</li>
<li>HTML</li>
</ul>
</li>
<li>框架<ul>
<li>Vue</li>
<li>React</li>
</ul>
</li>
<li>工程化<ul>
<li>构建工具<ul>
<li>WebPack</li>
<li>Rollup</li>
<li>Vite</li>
<li>已淘汰<ul>
<li>gulp</li>
</ul>
</li>
</ul>
</li>
<li>测试<ul>
<li>单元测试</li>
<li>自动化测试</li>
</ul>
</li>
<li>脚手架</li>
</ul>
</li>
<li>运维</li>
<li>移动端<ul>
<li>Native<ul>
<li>React native</li>
<li>Weex</li>
<li>Flutter</li>
<li>hippy</li>
</ul>
</li>
<li>小程序<ul>
<li>Uniapp</li>
</ul>
</li>
</ul>
</li>
<li>算法</li>
<li>软技能<ul>
<li>PPT</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title>低代码系列——介绍</title>
    <url>/lowcode/index.html</url>
    <content><![CDATA[<h1 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h1><ul>
<li><a href="/lowcode/sandbox.html">《低代码系列——js沙箱设计》</a></li>
<li><a href="/lowcode/component.html">《低代码系列——组件描述DSL》(编写中)</a></li>
</ul>
<h1 id="低代码"><a href="#低代码" class="headerlink" title="低代码"></a>低代码</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>低代码，可以理解成开发人员为了快速完成页面开发而搭建一个快速构建页面平台，里面一般包括几个功能点：</p>
<ul>
<li>无需写代码即可完成页面UI布局</li>
<li>支持页面进行二次代码开发</li>
<li>支持页面或系统级别的导出或部署发布</li>
</ul>
<p>简单的说，就是快速、稳定的输出开发所需要的页面，减少重复性劳动，提高开发效率。</p>
<a id="more"></a>

<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>目前市面的低代码的实现方式主要有几种：</p>
<p>国内开源目前还在维护更新的：</p>
<ul>
<li><a href="https://github.com/baidu/amis" target="_blank" rel="noopener">百度 amis</a>  前端低代码框架，通过 JSON 配置就能生成各种页面。</li>
<li><a href="https://github.com/alibaba/lowcode-engine" target="_blank" rel="noopener">阿里 lowcode engine</a> 低代码引擎</li>
<li><a href="https://formilyjs.org/" target="_blank" rel="noopener">阿里 formilyjs</a> 表单编辑器</li>
<li><a href="https://github.com/steedos/steedos-platform/" target="_blank" rel="noopener">华炎魔方</a> 数据驱动低代码平台</li>
<li><a href="https://github.com/AnsGoo/openDataV" target="_blank" rel="noopener">OpenDataV </a>  纯前端的拖拽式、可视化、低代码数据可视化</li>
<li><a href="https://github.com/wangyuan389/mall-cook" target="_blank" rel="noopener">mall-cook</a> 商城低代码平台，可视化搭建H5、小程序多端商城</li>
<li><a href="https://github.com/nocobase/nocobase" target="_blank" rel="noopener">nocobase</a> 一个可伸缩性优先的开源无代码/低代码平台，用于构建内部工具</li>
</ul>
<p>基于后端api的低代码平台</p>
<ul>
<li><a href="https://github.com/strapi/strapi" target="_blank" rel="noopener">strapi</a> 领先的开源无头CMS，它是100%的JavaScript，完全可定制，开发者优先</li>
</ul>
<p>虽然有些项目不维护了，但是值得借鉴：</p>
<ul>
<li><a href="https://github.com/i5ting/imove" target="_blank" rel="noopener">imove 逻辑编排器</a> </li>
</ul>
<p>值得阅读一些文章</p>
<ul>
<li><a href="https://medium.com/@andreasmuelder/ai-powered-low-code-platform-by-example-how-to-use-chatgpt-to-abstract-from-domain-languages-625c3abf0e49" target="_blank" rel="noopener">AI驱动的无代码平台–如何使用chat GPT抽象域语言</a></li>
</ul>
<p>以上数据来源：<br><a href="https://github.com/taowen/awesome-lowcode" target="_blank" rel="noopener">github/awesome-lowcode 国内低代码平台从业者交流</a></p>
<h2 id="资料收集"><a href="#资料收集" class="headerlink" title="资料收集"></a>资料收集</h2><h3 id="组件相关"><a href="#组件相关" class="headerlink" title="组件相关"></a>组件相关</h3><ul>
<li><a href="https://juejin.cn/post/6986824393653485605" target="_blank" rel="noopener">如何设计可视化搭建平台的组件商店？</a></li>
<li><a href="https://juejin.cn/post/7127440050937151525" target="_blank" rel="noopener">浅谈低代码平台远程组件加载方案</a></li>
<li>Web components标准</li>
</ul>
<h3 id="拖拽相关"><a href="#拖拽相关" class="headerlink" title="拖拽相关"></a>拖拽相关</h3><ul>
<li><a href="https://juejin.cn/post/6908502083075325959" target="_blank" rel="noopener">可视化拖拽组件库一些技术要点原理分析</a></li>
<li><a href="https://juejin.cn/post/6918881497264947207" target="_blank" rel="noopener">可视化拖拽组件库一些技术要点原理分析（二）</a></li>
<li><a href="https://juejin.cn/post/6929302655118344200" target="_blank" rel="noopener">可视化拖拽组件库一些技术要点原理分析（三）</a></li>
<li><a href="https://juejin.cn/post/7129311619963682830" target="_blank" rel="noopener">可视化拖拽组件库一些技术要点原理分析（四）</a></li>
</ul>
<h1 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h1><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2>
<div class="mxgraph-container">
    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/lowcode.drawio&quot;}"></div>
</div>


<h2 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h2><blockquote class="pullquote mindmap mindmap-md"><ul>
<li>低代码平台<ul>
<li>核心模块<ul>
<li>编辑器</li>
<li>编译引擎</li>
</ul>
</li>
<li>平台能力<ul>
<li>管理能力<ul>
<li>系统</li>
<li>页面</li>
</ul>
</li>
<li>版本控制<ul>
<li>页面版本控制</li>
<li>页面发布流程</li>
</ul>
</li>
<li>权限登录<ul>
<li>登录</li>
<li>权限</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>

<h2 id="编辑器设计"><a href="#编辑器设计" class="headerlink" title="编辑器设计"></a>编辑器设计</h2><blockquote class="pullquote mindmap mindmap-md"><ul>
<li>编辑器<ul>
<li>组件描述<ul>
<li>DSL</li>
</ul>
</li>
<li>画布布局</li>
<li>拖拽</li>
<li>组件快速引入<ul>
<li>组件引入插件</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>

<h2 id="编译引擎"><a href="#编译引擎" class="headerlink" title="编译引擎"></a>编译引擎</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>低代码</tag>
      </tags>
  </entry>
  <entry>
    <title>从pnpm工具了解整个npm包核心管理原理</title>
    <url>/today/20230219.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>今年在github前端领域star上升速度比较主要有以下几个：</p>
<ul>
<li>Svelte, 一个将MVVM架构放到构建应用程序的编译阶段实现的框架，让你开发更少的代码实现更多的功能</li>
<li>Typescript, 几乎所有的前端框架不约而同的支持了Typescript，一个JavaScript的超集，支持变量类型声明</li>
<li>pnpm，一个现代化的npm包管理工具，采用link方式去全局管理包，这是本文介绍的重点。</li>
</ul>
<p>因此，选一个和我们项目中开发相关的作为一个知识扩展点，应该就是pnpm了。</p>
<a id="more"></a>
<p>其实从事前端这么多年，自从npm包出现以后，前端工程化就一路顺畅，但是随之也带来很多问题，包括但不限于：</p>
<ul>
<li>版本管理难</li>
<li>安装速度慢</li>
<li>多个项目安装依赖占用空间大</li>
<li>…</li>
</ul>
<p>那么其实我们应该了解完整的npm包管理生态，然后才可以得知为什么pnpm打击了哪些痛点，以及如何应用到我们的实际项目中。</p>
<h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><p>之前已经在<a href="https://qborfy.com/today/20230107.html" target="_blank" rel="noopener">《从npm版本依赖到Monorepo大仓项目》</a>已经介绍过npm是什么，定义如下：</p>
<blockquote>
<p>npm，Node Package Manager的缩写，也就是“Node的包管理器”。<br>npm（“Node 包管理器”）是 JavaScript 运行时 Node.js 的默认程序包管理器。</p>
</blockquote>
<p>也了解它的版本是如何管理的，但是我们还缺乏对它的核心功能需要了解，具体了解以下几个方面：</p>
<ul>
<li><code>npm install xxx</code>， npm如何将远程的npm包下载到我们的本地<code>node_modules</code></li>
<li><code>npm ls</code>， npm如何如何维护npm包在本地的关系的</li>
<li><code>npm run xxx</code>，npm如何执行我们的脚本命令</li>
</ul>
<p>首先，我们需要知道npm由三部分组成：</p>
<ul>
<li>npm包管理网站</li>
<li>npm-cli，命令行工具</li>
<li>npm包注册中心，npm registry</li>
</ul>
<p>接下来就是注册账号，以及包的发布，其中版本管理这块，是遵循APR版本规范(<code>major.minor.patch</code>版本模型规范)，具体可看这里<a href="https://qborfy.com/today/20230107.html#npm版本" target="_blank" rel="noopener">npm版本管理</a>。</p>
<h2 id="npm包管理"><a href="#npm包管理" class="headerlink" title="npm包管理"></a>npm包管理</h2><p>目前npm包下载方式分为两种，一种是全局，一种是当前项目，其都会放在<code>node_modules</code>目录下。下面通过以下几方面去讲述npm是如何管理npm包的：</p>
<ul>
<li>循环依赖</li>
<li>版本冲突</li>
<li>同个版本包收敛</li>
</ul>
<p>我们以这个下面这个包管理树为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo</span><br><span class="line">+-- blerg@1.2.5</span><br><span class="line">+-- bar@1.2.3</span><br><span class="line">|   +-- blerg@1.x (latest=1.3.7)</span><br><span class="line">|   +-- baz@2.x</span><br><span class="line">|   |   `-- quux@3.x</span><br><span class="line">|   |       `-- bar@1.2.3 (cycle)</span><br><span class="line">|   `-- asdf@*</span><br><span class="line">`-- baz@1.2.3</span><br><span class="line">    `-- quux@3.x</span><br><span class="line">        `-- bar</span><br></pre></td></tr></table></figure>

<p>我们从上面可以看出:</p>
<ul>
<li><code>blerg</code> 有两个版本分别是 <code>1.2.5</code> 和 <code>1.x</code>，这是同个次版本的包放在不同地方</li>
<li><code>bar</code> 版本是<code>1.2.3</code>，但是依赖 <code>blerg</code> 和 <code>baz</code>，但是依赖<code>baz</code>包的版本是<code>2.x</code>，这是版本冲突</li>
<li><code>baz</code> 版本是<code>1.2.3</code>，，但是所依赖的包中有个依赖<code>bar</code> 这就是循环依赖</li>
</ul>
<p>那么npm是如何解决这类问题的呢？npm会将上述包管理树优化成如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo</span><br><span class="line">+-- node_modules</span><br><span class="line">    +-- blerg (1.2.5) &lt;---[A]</span><br><span class="line">    +-- bar (1.2.3) &lt;---[B]</span><br><span class="line">    |   +-- node_modules</span><br><span class="line">    |       +-- baz (2.0.2) &lt;---[C]</span><br><span class="line">    +-- asdf (2.3.4)</span><br><span class="line">    +-- baz (1.2.3) &lt;---[D]</span><br><span class="line">    +-- quux (3.2.0) &lt;---[E]</span><br></pre></td></tr></table></figure>

<p>那么npm的遵循策略是什么呢？其实还是APR版本规范(<code>major.minor.patch</code>版本模型规范)。</p>
<ul>
<li>第一，会将依赖树打平，从树结构变成一级结构，解决了循环依赖问题</li>
<li>第二，会将主项目依赖的npm包提到一级，然后对于相同次版本<code>minor</code>中的包统一版本，这就是同个版本包收敛，节省空间</li>
<li>第三，接着将同一个包，但是不同版本的包一次放到对应依赖包内，形成二级依赖(node_modules)，这就解决了版本冲突</li>
</ul>
<p><strong>require加载顺序</strong></p>
<ul>
<li>加载核心模块，如：fs、path等</li>
<li>加上对应文件后缀，优先级为：test.js &gt; test.json &gt; test.node</li>
<li>搜索路径，如果有指定路径则按照路径去找，如：require(‘./test’) 则在当前目录寻找</li>
<li>如果没有指定路径，则从当前目录下往上去找 node_modules文件夹，然后从文件夹里去遍历寻找对应模块名，如果找不到则到上一层node_modules去找，直到最顶层目录</li>
<li>首次会加载比较慢，后面node.js 会将缓存相关信息到内存避免二次查询</li>
</ul>
<h2 id="npm-install执行过程"><a href="#npm-install执行过程" class="headerlink" title="npm install执行过程"></a>npm install执行过程</h2>
<div class="mxgraph-container">
    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/npm-install.drawio&quot;}"></div>
</div>


<h2 id="npm-run执行过程"><a href="#npm-run执行过程" class="headerlink" title="npm run执行过程"></a>npm run执行过程</h2><p>以<code>npm run serve</code>为例，执行过程如下：</p>

<div class="mxgraph-container">
    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/npm-run.drawio&quot;}"></div>
</div>


<h2 id="痛点问题"><a href="#痛点问题" class="headerlink" title="痛点问题"></a>痛点问题</h2><p>npm的管理包已经能解决大部分开发问题了，那么为什么还会有出现<code>yarn</code>和<code>pnpm</code>等新型管理工具，主要npm包存在目前难以解决的痛点问题：</p>
<ul>
<li>yarn新增yarn.lock，可以解决npm包版本变动问题，目前已被npm引入特性，生成package-lock.json</li>
<li>npm包多个项目依赖包一致，但每个项目都需要重新安装，不仅耗时，且占用磁盘空间，这是pnpm解决了的问题</li>
<li>包经常创建太深的依赖树，这导致 Windows 上的目录路径过长，这是pnpm解决的问题</li>
<li><a href="https://pnpm.io/zh/blog/2020/05/27/flat-node-modules-is-not-the-only-way" target="_blank" rel="noopener">平铺的结构不是 node_modules 的唯一实现方式</a>，pnpm作者描述：目前node_modules大部分为了解决重复依赖包的问题，把npm依赖树进行打平，这样子会产生一些问题：<ul>
<li>项目可以访问一些不依赖的npm包</li>
<li>打平依赖树的算法非常复杂，导致安装时更加慢</li>
<li>node_modules目录结构十分复杂</li>
</ul>
</li>
</ul>
<p>这些痛点问题都不是npm和yarn能解决的，因此才会pnpm的出现，接下来我们再了解一下pnpm。</p>
<h1 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h1><p>官网是这么定义的：</p>
<blockquote>
<p>快速的，节省磁盘空间的npm包管理工具</p>
</blockquote>
<p>同时还支持以下这些特性：</p>
<ul>
<li>快速： 比其他包管理器快 2 倍</li>
<li>高效：<code>node_modules</code> 中的文件为复制或链接自特定的内容寻址存储库</li>
<li>支持 <code>monorepos</code>：  内置支持单仓多包</li>
<li>严格：默认创建了一个非平铺的 node_modules，因此代码无法访问任意包</li>
</ul>
<p>这里安装教程就忽略了，推荐的用法是直接使用npm安装全局命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g pnpm</span><br></pre></td></tr></table></figure>

<p>其他安装方式可以参考官网教程:<a href="https://pnpm.io/zh/installation" target="_blank" rel="noopener">pnpm 安装</a></p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>从作者博客或者github源码，我们可以尝试去推测实现pnpm几个特性所需要关键原理。</p>
<h3 id="更快速的install"><a href="#更快速的install" class="headerlink" title="更快速的install"></a>更快速的install</h3><p>pnpm为了加快<code>npm install</code>，从以下两个方面进行优化：</p>
<ul>
<li>创建一个<code>.pnpm store</code>，除了第一次安装需要按照npm包，后续再次安装，将会创建一个符号链接到npm包</li>
<li>不打平<code>npm 依赖树</code>，节省复杂依赖树打平时间</li>
</ul>
<p>可以参考官网的架构图，去更好了解pnpm针对node_moduels的管理，如下：</p>
<p><img src="/assets/img/pnmp-node-modules-structure.jpg" alt></p>
<p>这里有几个设计点需要弄清楚：</p>
<ol>
<li>pnpm将所有依赖树的目录，软链接到<code>.pnpm store</code>中对应的npm包</li>
<li><code>node_moduels</code>将不会有<code>package.json</code>依赖(<code>devDependencies</code>和<code>dependencies</code>)外的npm包</li>
<li><code>node_moduels</code>的目录结构，和npm依赖树保持一致</li>
</ol>
<p>通过上述几个点，pnpm将拥有比<code>yarn</code>和<code>npm</code>更快的install速度。</p>
<p><strong>额外知识点</strong>：</p>
<ol>
<li>Linux文件链接分为软链接和硬链接，两者有什么区别？</li>
</ol>
<ul>
<li>Linux中的符号链接，就是我们平时说的软连接，可以针对文件、目录创建，但是源文件删除后链接不可用，命令:<code>ln -s xxx xxx</code></li>
<li>Linux中的硬链接，只能针对文件，但是文件删除仍可使用，命令:<code>ln xxx xxx</code></li>
</ul>
<ol start="2">
<li>Windows如何解决符号链接问题？</li>
</ol>
<p>pnpm采用<a href="https://learn.microsoft.com/en-us/windows/win32/fileio/hard-links-and-junctions" target="_blank" rel="noopener">junctions</a>，具体如下：</p>
<ul>
<li>Windows的文件系统是基于NTFS架构，本身就支持hard link 、junctions和symbolic links</li>
<li>Hard Link和Linux中硬链接没什么区别，同样只支持文件类型创建链接，采用函数:<code>CreateHardLinkA</code> <code>DeleteFileA</code></li>
<li>Junctions是符号链接，也叫软链接，支持文件、目录创建链接，实现：<code>junction 命令行</code></li>
</ul>
<h3 id="更安全的install"><a href="#更安全的install" class="headerlink" title="更安全的install"></a>更安全的install</h3><p>我们从上文可以得在Node.js中，<code>require()</code>是如何查询对应npm包，是从<code>node_modules</code>一层层向上查找获取的。</p>
<p>由于pnpm使用非扁平化的<code>node_modules</code>管理依赖树，因此对于非package.json依赖的npm包，是不会放在项目的<code>node_modules</code>中，从而使得开发者无法获取无依赖的npm包。具体可以参考下图：</p>

<div class="mxgraph-container">
    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/pnpm-safe-npm.drawio&quot;}"></div>
</div>



<h2 id="使用可能会遇到的问题"><a href="#使用可能会遇到的问题" class="headerlink" title="使用可能会遇到的问题"></a>使用可能会遇到的问题</h2><p>pnpm官网罗列了一些在使用过程可能会遇到的问题，具体有以下几个方面：</p>
<h3 id="peer-dependencies-如何解决"><a href="#peer-dependencies-如何解决" class="headerlink" title="peer dependencies 如何解决"></a>peer dependencies 如何解决</h3><h4 id="npm-workplace"><a href="#npm-workplace" class="headerlink" title="npm workplace"></a>npm workplace</h4><p>首先我们需要先了解一下<code>npm workplace</code> 或者 <code>yarn workplace</code>，工作空间的概念。</p>
<blockquote>
<p><code>Workspaces</code> 是一个通用术语，指的是 npm cli 中的一组功能，这些功能支持从单个顶级根包中管理本地文件系统中的多个包。<br>这组功能弥补了从本地文件系统处理链接包的更加简化的工作流程。自动链接过程作为 npm install 的一部分，避免手动使用 npm link 来添加对应该符号链接到当前 node_modules 文件夹中的包的引用。</p>
</blockquote>
<p>简单的说，<code>npm workplace</code>主要用来解决以下几个问题：</p>
<ul>
<li>在同一个git仓库中管理多个npm包</li>
<li>同时npm包之间可以存在互相依赖</li>
<li>多个子项目会依赖一些公共的npm包</li>
<li>减少之前因为<code>npm link</code>管理的混乱</li>
</ul>
<h3 id="peerDependencies"><a href="#peerDependencies" class="headerlink" title="peerDependencies"></a>peerDependencies</h3><p>通过上面<code>npm workplace</code>概念了解，当工作区里有多个子项目需要依赖一些公共的npm包，但是这些公共npm包版本可能大家所需要的都不一样，这个时候就需要<code>peerDependencies</code>去描述依赖和版本。它是这么定义的：</p>
<blockquote>
<p>在开发插件时，你的插件需要某些依赖的支持，但是你又没必要去安装，因为插件的宿主回去安装这些依赖。此时就可以用 <code>peerDependencies</code> 去声明一下需要依赖的插件和版本。如果出问题的话，npm 会有警告来提示使用者去解决版本中的冲突。</p>
</blockquote>
<p>因此，<code>peerDependencies</code>的目的很清晰，就为了解决workplace下不同子项目中公共依赖包版本问题。</p>
<p>所以回到<code>pnpm</code>中，由于<code>pnpm</code>是认定项目中只有一组<code>npm</code>依赖树，那么针对workplace中的 <code>peerDependencies</code>，它是如何解决的呢？</p>
<p><code>pnpm</code>的解决方案是：<strong>为不同的<code>peerDependencies</code> 依赖项创建不同的解析</strong>。</p>
<p>如何理解这句话呢？参考官网的解释：</p>
<p>当有两个子项目，他们的依赖分别如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- foo-parent-1</span><br><span class="line">  - bar@1.0.0</span><br><span class="line">  - baz@1.0.0</span><br><span class="line">  - foo@1.0.0</span><br><span class="line">- foo-parent-2</span><br><span class="line">  - bar@1.0.0</span><br><span class="line">  - baz@1.1.0</span><br><span class="line">  - foo@1.0.0</span><br></pre></td></tr></table></figure>

<p><code>foo-parent-2</code>或<code>foo-parent-1</code>公共依赖了<code>baz</code>，但是要求版本不一样，如果这个时候项目中没有声明<code>peerDependencies</code>，<code>.pnpm store</code>中保存的依赖树如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node_modules</span><br><span class="line">└── .pnpm</span><br><span class="line">    ├── foo@1.0.0</span><br><span class="line">    ├── bar@1.0.0</span><br><span class="line">    ├── baz@1.0.0</span><br><span class="line">    ├── baz@1.1.0</span><br></pre></td></tr></table></figure>

<p>如果有声明<code>peerDependencies</code>，<code>pnpm</code>会根据不同的<code>peerDependencies</code>创建对应的链接，<code>.pnpm store</code>中保存的依赖树如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node_modules</span><br><span class="line">└── .pnpm</span><br><span class="line">    ├── foo@1.0.0_bar@1.0.0+baz@1.0.0 #不同声明peerDependencies所创建的链接目录</span><br><span class="line">    │   └── node_modules</span><br><span class="line">    │       ├── foo</span><br><span class="line">    │       ├── bar   -&gt; ../../bar@1.0.0/node_modules/bar</span><br><span class="line">    │       ├── baz   -&gt; ../../baz@1.0.0/node_modules/baz</span><br><span class="line">    ├── foo@1.0.0_bar@1.0.0+baz@1.1.0   #不同声明peerDependencies所创建的链接目录</span><br><span class="line">    │   └── node_modules</span><br><span class="line">    │       ├── foo</span><br><span class="line">    │       ├── bar   -&gt; ../../bar@1.0.0/node_modules/bar</span><br><span class="line">    │       ├── baz   -&gt; ../../baz@1.1.0/node_modules/baz</span><br><span class="line">    ├── baz@1.0.0</span><br><span class="line">    ├── baz@1.1.0</span><br></pre></td></tr></table></figure>

<p>通过创建不同的<code>peerDependencies</code>的链接，去解决不同子项目中的依赖包版本问题。</p>
<h3 id="hosited配置"><a href="#hosited配置" class="headerlink" title="hosited配置"></a>hosited配置</h3><p>pnpm从2022年初支持<code>hoisted</code>配置，可以在 <code>.npmrc</code> 文件中使用 <code>node-linker=hoisted</code> 设置。</p>
<p>新增该设定，是为了基本上使 pnpm 可以兼容所有与 npm CLI 兼容的 Node.js 技术栈。</p>
<h3 id="删除npm包"><a href="#删除npm包" class="headerlink" title="删除npm包"></a>删除npm包</h3><p>这个是个人的疑问，既然将所有的依赖包统一归置到<code>.pnpm store</code>管理，那么针对一些过期或者无用的npm包什么时候进行删除呢？</p>
<p>pnpm的给出的方案如下：</p>
<ul>
<li>设置npm包的有效期，可以在<code>.npmrc</code>配置中设置<a href="https://pnpm.io/zh/npmrc#modules-cache-max-age" target="_blank" rel="noopener">modules-cache-max-age</a>配置项，单位为：分钟，默认值：10080，7天</li>
<li><code>pnpm prune</code>， 从存储中删除未引用的包</li>
</ul>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><p>官网同时也提出未解决的问题：</p>
<ul>
<li>针对<code>package-lock.json</code>等锁文件更新，npm允许每次安装同样版本的npm包可能会更新lock文件，从而更新<code>node_modules</code>文件内容，但是pnpm由于创建隔离布局，无法实时按照<code>package-lock.json</code>的更新而更新，因此pnpm推荐将使用<code>pnpm import</code>命令将<code>package-lock.json</code>等文件转为<code>pnpm-lock.yaml</code></li>
</ul>
<p>这个问题就是pnpm没法按照项目现有的<code>package-lock.json</code>去做自动更新，只能通过<code>pnpm import</code>去做转换。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>pnpm</code>确实给前端开发带来一些提醒，让我们关注到平时可能已经习惯的问题，比如<code>npm</code>包管理混乱导致的问题，虽然存在但是我们已经忽略或者已经习惯了。</p>
<p>总结一下学习<code>pnpm</code>后，在实际项目中引用会给我们带来什么：</p>
<ul>
<li>提高我们本地开发效率，毕竟多个前端项目同时在电脑，每次安装或更新都需要等待一段时间</li>
<li>提高项目的编译速度，利用<code>.pnpm store</code>在编译机上，不用每次都重新安装</li>
<li>提高项目npm依赖的安全性，清晰明白项目中npm依赖结构，不用担心非法npm包在项目中被开发使用</li>
</ul>
<p>这里联想扩展几个问题点：</p>
<ul>
<li><p>什么时候node.js才能支持es6的import和export</p>
</li>
<li><p>node.js或者浏览器，什么时候才能直接加载远程js包，而不是需要安装到本地才能使用</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1></li>
<li><p><a href="https://docs.npmjs.com/about-npm" target="_blank" rel="noopener">npm官网</a></p>
</li>
<li><p><a href="https://pnpm.io/" target="_blank" rel="noopener">pnpm官网</a></p>
</li>
<li><p><a href="https://www.kochan.io/nodejs/why-should-we-use-pnpm.html" target="_blank" rel="noopener">我们为什么要使用 pnpm？</a></p>
</li>
<li><p><a href="https://www.imaegoo.com/2021/node-modules-speed-up/" target="_blank" rel="noopener">浅析各家包管理工具是如何解决 npm 安装慢的痛点的</a></p>
</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>实现一个JS引擎竟如此简单</title>
    <url>/today/20230218.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>这是很久之前的一个念想，当时为了加深自己对js的理解，明白js引擎是如何工作的。<br>于是从上网找了一个<a href="https://github.com/webfansplz/giao-js" target="_blank" rel="noopener">giao-js</a>，感觉还不错，因此想学习一下。</p>
<h1 id="JS引擎"><a href="#JS引擎" class="headerlink" title="JS引擎"></a>JS引擎</h1><p>之前有篇文章<a href="https://qborfy.com/today/20230117.html" target="_blank" rel="noopener">理解React中Fiber架构(一)</a>中有讲到浏览器进程如何渲染网页和执行js代码的，我们再复习一遍。</p>
<p>一个完整的web网页在浏览器显示和交互的进程（chrome为主），需要涉及到线程主要以下几个部分：</p>
<ul>
<li><code>GUI 渲染线程</code>，负责渲染浏览器界面HTML元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行。</li>
<li><code>JavaScript引擎线程</code>，JS内核，负责处理Javascript脚本程序。 一直等待着任务队列中任务的到来，然后解析Javascript脚本，运行代码。</li>
<li><code>定时触发器线程</code>，定时器setInterval与setTimeout所在线程，为什么要单独弄个线程处理定时器？是因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确</li>
<li><code>事件触发线程</code>，用来控制事件轮询，JS引擎自己忙不过来，需要浏览器另开线程协助</li>
<li><code>异步http请求线程</code>，在<code>XMLHttpRequest</code>或<code>fetch</code>在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等待处理。这里需要注意<code>XMLHttpRequest</code>和<code>fetch</code>的区别，<code>fetch</code>是w3c标准化后一个专门提供给开发调用发起http的API接口，XMLHttpRequest是一个非标准化的Http请求对象，主要是可以发起http请求获取XML数据。</li>
</ul>
<p>针对JS引擎，官方的定义是：</p>
<a id="more"></a>

<blockquote>
<p>JavaScript引擎是一个专门处理JavaScript脚本的虚拟机，一般会附带在网页浏览器之中。 —— <a href="https://zh.wikipedia.org/zh-hans/JavaScript%E5%BC%95%E6%93%8E" target="_blank" rel="noopener">JS引擎 维基百科</a></p>
</blockquote>
<p>因此，我们了解JS引擎在浏览器中的主要作用就，解析JS代码，并运行代码，那么它是怎么做到的呢？</p>
<p>如同我们人一样去认识一门语言，电脑也一样，当我们写了一行代码，JS引擎要识别出来，它同样去分析代码，然后确定执行，主要有以下几个步骤：</p>
<ul>
<li>词法分析，主要是<code>分词（tokenize）</code>，将JS代码比较关键词（如：function、const、let等），拆出来放到解析器里</li>
<li>语法分析，主要解析（parse），主要用了<code>预解析器</code>和<code>解析器</code>:<ul>
<li><code>预解析器</code>会判断哪些代码需要立即执行，哪些代码不需要立即执行，需要立即执行的代码才会放到解析器里去解析</li>
<li><code>解析器</code>，从词法分析获取关键词做标记，将代码生成一个抽象语法树，也叫AST语法树</li>
</ul>
</li>
<li>生成AST语法树，AST语法树由<code>解析器</code>生成后，将会传递给到<code>解释器</code></li>
<li>生成字节码，主要由<code>解释器</code>将AST语法树编译成字节码</li>
<li>执行代码，将字节码转成机器代码，以更快的速度在电脑中执行</li>
</ul>

<div class="mxgraph-container">
    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/jsengine.drawio&quot;}"></div>
</div>


<p>所以我们要模拟JS引擎要实现功能主要以下几块：</p>
<ul>
<li><code>分词器</code>，将JS关键词进行标记</li>
<li><code>解析器</code>，生成AST语法树</li>
<li><code>解释器</code>，执行AST语法树</li>
</ul>
<h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><blockquote>
<p>将源代码分解并组织成一组有意义的单词,这一过程即为词法分析(Token)。</p>
</blockquote>
<p>词法分析的工作就是 将一个长长的字符串识别出一个个的单词，这一个个单词就是 Token，具体实现效果如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  经过词法分析会将上面拆分如下对象</span></span><br><span class="line">[</span><br><span class="line">  (<span class="string">"var"</span>: <span class="string">"keyword"</span>),</span><br><span class="line">  (<span class="string">"a"</span>: <span class="string">"identifier"</span>),</span><br><span class="line">  (<span class="string">"="</span>: <span class="string">"assignment"</span>),</span><br><span class="line">  (<span class="string">"1"</span>: <span class="string">"literal"</span>),</span><br><span class="line">  (<span class="string">";"</span>: <span class="string">"separator"</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>如果用图来显示的话，它应该是这样子的：</p>

<div class="mxgraph-container">
    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/jsengine-token.drawio&quot;}"></div>
</div>



<p>根据上面的结果，那么词法分析的实践步骤应该如下：</p>
<ul>
<li>先分词，分词的逻辑使用正则表达式<ul>
<li>先判断是否为关键词，如：运算符(+-*/=)、声明符(var、const、function)等</li>
<li>如果是则执行拆词</li>
<li>接着遇到空格也拆词</li>
<li>遇到换行符或;也拆词</li>
<li>…还有符合条件判断也拆词</li>
<li>最终会获取到一个数组，[“var”, “a”, “=”, “1”, “;”]</li>
</ul>
</li>
<li>再判断该词属于哪个类型，如： var属于keyword关键字。</li>
</ul>
<p>利用<code>Acron</code>做词法分析， 代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> acron = <span class="built_in">require</span>(<span class="string">'acorn'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用acorn库进行词法分析</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; code 代码</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; ecmaVersion ECMAScript的标准版本 </span></span><br><span class="line"><span class="comment"> * @returns </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> getToken = <span class="function">(<span class="params">code, ecmaVersion = <span class="string">'11'</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tokenObj = acron.tokenizer(code, &#123;</span><br><span class="line">        ecmaVersion,</span><br><span class="line">        locations: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> tokens = [];</span><br><span class="line">    <span class="keyword">let</span> token = tokenObj.getToken();</span><br><span class="line">    <span class="built_in">console</span>.log(token)</span><br><span class="line">    <span class="keyword">while</span> (token.end !== token.start) &#123;</span><br><span class="line">        tokens.push(token);</span><br><span class="line">        token = tokenObj.getToken();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tokens;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getToken(<span class="string">`const a= 1+1;`</span>); <span class="comment">// 最终输出Token数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出如下对象</span></span><br><span class="line">[ &#123;</span><br><span class="line">  <span class="string">"type"</span>: &#123; <span class="comment">// 关键词Token所属类型</span></span><br><span class="line">    <span class="string">"label"</span>: <span class="string">"const"</span>,  <span class="comment">// 解析到的关键词所属的类型 为const</span></span><br><span class="line">    <span class="string">"keyword"</span>: <span class="string">"const"</span>, <span class="comment">//  关键字</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"value"</span>: <span class="string">"const"</span>, <span class="comment">// 解析到的 关键词Token</span></span><br><span class="line">  <span class="string">"start"</span>: <span class="number">0</span>, <span class="comment">// 关键词的开始位置</span></span><br><span class="line">  <span class="string">"end"</span>: <span class="number">5</span> <span class="comment">// 关键词的结束位置 下一个位置是空白符</span></span><br><span class="line">&#125;, ...]</span><br></pre></td></tr></table></figure>

<h1 id="语法解析"><a href="#语法解析" class="headerlink" title="语法解析"></a>语法解析</h1><blockquote>
<p>将词法分析阶段生成的 Token 转换为抽象语法树(Abstract Syntax Tree),这一过程称之为语法解析(Parsing)。</p>
</blockquote>
<p>简单的说，就是利用Token标识符去生成AST语法树。</p>
<h2 id="AST语法树"><a href="#AST语法树" class="headerlink" title="AST语法树"></a>AST语法树</h2><p>在语法解析前，我们需要对AST语法树有一个认知，即是：什么是AST语法树？</p>
<blockquote>
<p>抽象语法树 (Abstract Syntax Tree)，简称 AST，它是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。</p>
</blockquote>
<p>用比较容易理解的话，用一个树形数据结构去描述我们源代码，从而能让机器能更好识别我们所想要实现的功能。</p>
<p>目前市面上Javascript语言的AST语法树的结构基本上都遵循<a href="https://github.com/estree/estree" target="_blank" rel="noopener">ESTree语法树规范</a>。</p>
<p>这里说明一下<a href="https://github.com/estree/estree" target="_blank" rel="noopener">ESTree语法树规范</a>的起源，能让我们更容易理解语法解析的过程：</p>
<blockquote>
<p>使用不同工具构建的抽象语法树可能会有不同的结构，如果大家都遵从同样的规范，那么相关联的生态链工具的开发会更为轻松、明晰。很早之前，FireFox 浏览器所使用的 JavaScript 引擎 SpiderMonkey 曾经提供了一个 JavaScript API，使得开发者可以直接调用 SpiderMonkey 的 JavaScript 分析器。这个 API 所描述的 JavaScript 抽象语法树格式渐渐流行起来，如今成为 JavaScript AST 的通用描述。<a href="https://github.com/estree/estree" target="_blank" rel="noopener">ESTree语法树规范</a> 正是在此基础上建立起来的，它现在是社区对 JavaScript 抽象语法树构建时采用最广泛的规则，可以认为是社区推动的事实标准。众多基础设施开发者一起维护着这个规范，包括 Dave Herman（Mozilla 研究中心的首席研究员和策略总监）、 Nicholas C. Zakas（ESLint 的作者）、Ingvar Stepanyan（Acorn 的作者）、Mike Sherov 与 Ariya Hidayat（Esprima 的作者）以及 Babel.js 团队等。</p>
<p><a href="https://github.com/estree/estree" target="_blank" rel="noopener">ESTree语法树规范</a> 的初始版本是基于 ES5 的[2]，后续的 ES6/ES7/ES8 等版本的规范，都只针对新增语言特性提出。</p>
</blockquote>
<p><a href="https://github.com/estree/estree" target="_blank" rel="noopener">ESTree语法树规范</a>基于ECMAScript标准去描述不同标准的AST树结构，具体如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 节点对象  下面这个版本属于ES2015的规范</span></span><br><span class="line">interface Node &#123;</span><br><span class="line">    type: string;</span><br><span class="line">    loc: SourceLocation | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extend interface Program &#123;</span><br><span class="line">    sourceType: <span class="string">"script"</span> | <span class="string">"module"</span>;</span><br><span class="line">    body: [ Statement | ImportOrExportDeclaration ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IfStatement &lt;: Statement &#123; <span class="comment">// &lt;: 标识前者是后者的子集 即是继承的关系</span></span><br><span class="line">    type: <span class="string">"IfStatement"</span>;</span><br><span class="line">    test: Expression;</span><br><span class="line">    consequent: Statement;</span><br><span class="line">    alternate: Statement | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此了解JS的AST语法树结构，需要对ESTree规范有了解，它分别定义不同类型节点的数据结构，拿几种常见的做一下介绍，具体如下所示：</p>
<ul>
<li><code>Program</code>，一个完整的程序源码树，就是树的跟节点，因此也属于<code>Node</code>类型</li>
<li><code>Node</code>，语法树的基础节点<ul>
<li><code>Function</code>，函数声明或表达式，继承节点<code>Node</code></li>
<li><code>Statement</code>，代码内容，标识任何声明，继承节点<code>Node</code><ul>
<li><code>Declaration</code> 声明节点</li>
</ul>
</li>
<li><code>Expression</code>， 表达式，标识任何声明，继承节点<code>Node</code></li>
<li><code>Pattern</code>，解构绑定和赋值节点，继承节点<code>Node</code></li>
</ul>
</li>
<li><code>Identifier</code>，标识符，如：变量名、函数名</li>
<li><code>Literal</code>， 字面量，对应 JavaScript，就是基本值，例如布尔值 true、数字 200、字符串 “this is a string”</li>
</ul>
<p>一个AST语法的组成结构大概如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Program</span><br><span class="line">|-- body: Node[] // 代码主体</span><br><span class="line">|     |-- Function // 函数声明</span><br><span class="line">|     |-- Statement // 代码内容</span><br><span class="line">|     |-- Declaration // 变量声明</span><br><span class="line">|     |-- Expression // 表达式</span><br><span class="line">|          |-- Literal</span><br><span class="line">|          |-- Identifier</span><br></pre></td></tr></table></figure>

<p>还需要解答一个问题，就是在AST语法树中，如何判断一个节点的完整性呢? </p>
<p>按照ESTree的规范：遇到一个空节点（比如：换行/分号/结构体结束符<code>}]</code>等），则拆成一个完整的节点。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>弄明白AST语法树的数据结构，接下来就是如何将之前<code>词法分析</code>的Token数组解析成语法树结构，解析流程图(Acron.js实现)如下：</p>

<div class="mxgraph-container">
    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/jsengine-parse.drawio&quot;}"></div>
</div>


<p>利用<code>Acron</code>做语法解析， 代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> code = <span class="string">`function sum(a, b)&#123;return a+b;&#125;; const a = sum(1, 2);`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> acron = <span class="built_in">require</span>(<span class="string">'acorn'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(acron.parse(code))</span><br></pre></td></tr></table></figure>

<p>最终得到结构如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Node &#123;</span><br><span class="line">  type: <span class="string">'Program'</span>,</span><br><span class="line">  start: <span class="number">0</span>,</span><br><span class="line">  end: <span class="number">53</span>,</span><br><span class="line">  body:</span><br><span class="line">   [ Node &#123;</span><br><span class="line">       type: <span class="string">'FunctionDeclaration'</span>,</span><br><span class="line">       start: <span class="number">0</span>,</span><br><span class="line">       end: <span class="number">31</span>,</span><br><span class="line">       id: [Node],</span><br><span class="line">       expression: <span class="literal">false</span>,</span><br><span class="line">       generator: <span class="literal">false</span>,</span><br><span class="line">       <span class="keyword">async</span>: <span class="literal">false</span>,</span><br><span class="line">       params: [<span class="built_in">Array</span>],</span><br><span class="line">       body: [Node] &#125;,</span><br><span class="line">     Node &#123; <span class="attr">type</span>: <span class="string">'EmptyStatement'</span>, <span class="attr">start</span>: <span class="number">31</span>, <span class="attr">end</span>: <span class="number">32</span> &#125;,</span><br><span class="line">     Node &#123;</span><br><span class="line">       type: <span class="string">'VariableDeclaration'</span>,</span><br><span class="line">       start: <span class="number">33</span>,</span><br><span class="line">       end: <span class="number">53</span>,</span><br><span class="line">       declarations: [<span class="built_in">Array</span>],</span><br><span class="line">       kind: <span class="string">'const'</span> &#125; ],</span><br><span class="line">  sourceType: <span class="string">'script'</span> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h1><blockquote>
<p>解释器，就是遍历AST语法树，然后根据Node节点类型，去执行或计算每个节点。</p>
</blockquote>
<p>这里实现一个JS解释器，需要对AST语法树Node节点每个类型做区分判断，主要有以下几种：</p>
<ul>
<li>变量</li>
<li>作用域以及作用域链</li>
<li>上下文This指向</li>
<li>条件判断</li>
<li>For循环，其中的 break和continue</li>
<li>函数部分 Function</li>
<li>生成器 Generator</li>
<li>异步 Async</li>
</ul>
<p>因此我们需要几个类去保存相关的值：</p>
<ul>
<li>Scope，作用域类，保存作用域内的值以及作用域链（当前作用域可以找到父级作用域链）</li>
<li>Visitor，AST树Node节点处理类，里面有函数<code>visitNode(node, scope)</code>，用来处理对应node类型，其中VISITOR是所有类型函数的Map对象，用来快速查询</li>
<li>Variable，变量存储类，用来存储变量类型和值</li>
</ul>
<p>参考代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历AST语法树，并执行对应的处理函数</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; node </span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; scope </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">visitNode(node, scope) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; type &#125; = node;</span><br><span class="line">    <span class="keyword">if</span> (VISITOR[type]) &#123;</span><br><span class="line">        <span class="keyword">return</span> VISITOR[type](&#123; node, scope, <span class="attr">context</span>: <span class="keyword">this</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变量和作用域"><a href="#变量和作用域" class="headerlink" title="变量和作用域"></a>变量和作用域</h2><p>在JavaScript中，对变量的声明通常是绑定在作用域中的，而作用域分为以下几种：</p>
<ul>
<li>全局作用域，全局作用域中仅存在一处，即为最上级的环境。</li>
<li>函数作用域，函数存在并执行时，内部存储函数作用域</li>
<li>块级作用域，每隔block块{}都可产生作用域，如if for while等</li>
</ul>
<p>我们举个例子，以<code>var a = 1;</code>为例，我们需要需要哪些代码，才能实现从AST树解析，将变量<code>a</code>被声明在全局变量作用域中，具体步骤如下图：</p>

<div class="mxgraph-container">
    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/jsengine-interpreter.drawio&quot;}"></div>
</div>


<p>这里实现一个作用域Scope类，参考代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scope</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; type </span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; parent </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">constructor</span>(type, parent) &#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent || <span class="literal">null</span>; <span class="comment">// 父级作用域</span></span><br><span class="line">        <span class="keyword">this</span>.type = type; <span class="comment">// 作用域类型 Global, Function, Block</span></span><br><span class="line">        <span class="keyword">this</span>.targetScope = <span class="keyword">new</span> <span class="built_in">Map</span>();  <span class="comment">// 当前作用域</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 变量声明方法,变量已定义则抛出语法错误异常</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; kind 变量类型</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; rawName  变量名</span></span><br><span class="line"><span class="comment">     * @param &#123;*&#125; value 变量值</span></span><br><span class="line"><span class="comment">     * @returns </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    declare(kind, rawName, value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.targetScope.set(rawName, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="上下文This"><a href="#上下文This" class="headerlink" title="上下文This"></a>上下文This</h3><p>上下文的this对象其实指的就是当前作用域，然而我们了解过JS中的this是可以改变的，如：</p>
<ul>
<li><code>call()</code> <code>bind()</code> <code>apply()</code>等函数，当执行到相关函数的时候，需要将传递进来scope的替换成当前的scope</li>
<li>ES6中的箭头函数等，this指向上一级</li>
</ul>
<p>这些都需要在解析代码的时候注意的逻辑问题。</p>
<h2 id="其他类型解释"><a href="#其他类型解释" class="headerlink" title="其他类型解释"></a>其他类型解释</h2><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p><code>IfStatement</code>，里面有属性: <code>test</code>为判断条件，<code>consequent</code>为条件成立时执行的语句，<code>alternate</code>为条件不成立时执行的语句，参考代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// visitNode会执行AST语法树节点函数</span></span><br><span class="line"><span class="keyword">const</span> &#123; test, consequent, alternate &#125; = node;</span><br><span class="line"><span class="keyword">const</span> testValue = visitNode(test, scope);</span><br><span class="line"><span class="keyword">if</span> (testValue) &#123;</span><br><span class="line">    <span class="keyword">if</span>(consequent)&#123;</span><br><span class="line">       visitNode(consequent, scope);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(alternate)&#123;</span><br><span class="line">       visitNode(alternate, scope);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他部分逻辑就不会在这里一一描述，具体Node类型都有自己的判断逻辑，因此想要了解完整逻辑，可以到完整源码里查看，注解都十分清晰。</p>
<p>完整源码地址在：<a href="https://github.com/qiubohong/qiubohong.github.io/tree/master/code/jsengine/src/interpreter/index.js" target="_blank" rel="noopener">https://github.com/qiubohong/qiubohong.github.io/tree/master/code/jsengine</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文涉及的东西有点多，花了好几天时间才弄明白，因此有些知识点在这里做一下小总结：</p>
<ul>
<li>JS引擎是有三部分组成的，分别是：<code>词法分析</code>,<code>语法解析</code>和<code>解释器</code></li>
<li>词法解析和语法解析，最终的目标是生成符合ESTree规范的<code>AST语法树</code></li>
<li>解释器的作用就是依据<code>AST语法树</code>去执行相关逻辑，输出所需要的最终结果<ul>
<li>比较重要的部分在于变量、作用域和作用域链的实现</li>
<li>其他部分则是依据对应<code>ECMAScript 规范</code>实现对应逻辑皆可</li>
</ul>
</li>
</ul>
<h2 id="ECMAScript-规范"><a href="#ECMAScript-规范" class="headerlink" title="ECMAScript 规范"></a>ECMAScript 规范</h2><p>其实，JS解释器实现起来不难，就是需要对JS执行逻辑有完整的认识，不仅仅只是上面几个部分，但是基本上AST语法树都已经包括在里面了，所以这个时候需要你对ECMAScript 规范有一定了解才能完整实现解释器。</p>
<p>所以这里贴一个ECMAScript 规范链接，作为后续完整解释器的扩展。</p>
<blockquote>
<p>使用 ECMAScript 指代由 Ecma International Technical Committee 39 负责编撰的 ECMAScript Language Specification，而使用 JavaScript 来指代我们日常使用的那个常见编程语言。</p>
<p>我们可以在 <a href="https://tc39.es/ecma262" target="_blank" rel="noopener">https://tc39.es/ecma262</a> 获取到最新的 ECMAScript 规范</p>
</blockquote>
<p>如何阅读规范呢？</p>
<ul>
<li>惯例与基础：如在 ECMAScript 中 Number 的定义是什么，亦或者 throw a TypeError exception 语句代表什么含义；</li>
<li>语言语法产生式：如如何写一个符合规范的 for-in 循环；</li>
<li>语言静态语义：如一个 VariableDeclaration 如何确定一个变量声明；</li>
<li>语言运行时语义：如一个 for-in 循环的执行例程的定义；</li>
<li>APIs：如 String.prototype.substring 等内置对象的方法例程定义。</li>
</ul>
<h2 id="能做什么"><a href="#能做什么" class="headerlink" title="能做什么"></a>能做什么</h2><p>有了我们自己的JS引擎后我们能做些什么，其实目前市面上已经有很多应用场景，比如:</p>
<ul>
<li><a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a>，最常见JavaScript编译器，能够将js代码编译成我们想要的任一版本的ECMAscript标准，基于 acorn.js优化</li>
<li><a href="https://eslint.org/" target="_blank" rel="noopener">ESlint</a>，最常用的代码质量扫描工具，能找到代码不符合规范的地方，基于Espree.js进行分析</li>
<li><a href="https://prettier.io/" target="_blank" rel="noopener">pretiier</a>,最常用的代码格式工具，能帮忙把代码格式优化</li>
<li>js沙箱安全机制，之前写过一篇文件<a href="https://qborfy.com/lowcode/sandbox.html" target="_blank" rel="noopener">低代码系列——js沙箱设计</a>里提到过，想要完整动态执行js代码，最好的方式是拥有自己的js解释器</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://juejin.cn/post/6943550570515038245" target="_blank" rel="noopener">编译原理实战一：如何用JS实现一个词法分析器？</a></li>
<li><a href="https://github.com/webfansplz/giao-js/blob/main/Article.md" target="_blank" rel="noopener">giao-js github源码</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1886888" target="_blank" rel="noopener">分享一篇可视化的JS引擎执行流程</a></li>
<li><a href="https://github.com/acornjs/acorn" target="_blank" rel="noopener">Acron 一个小巧又快速的js解析器</a></li>
<li><a href="https://github.com/estree/estree" target="_blank" rel="noopener">The ESTree Spec(ES语法树规范)</a></li>
<li><a href="https://astexplorer.net/" target="_blank" rel="noopener">astexplorer 在线语法解析器</a></li>
<li><a href="https://fed.taobao.org/blog/taofed/do71ct/mlgtox/" target="_blank" rel="noopener">ECMAScript 规范阅读导引 Part 1</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>前端架构成长之路——微前端架构理论篇</title>
    <url>/framework/frontend-microapp-1.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近项目开发中使用了<code>qiankun</code>框架去做微前端，我是属于半懂不懂的状态，大概了解过微前端是什么，可以解决什么问题，但是没有并系统的认识和从0实战过。</p>
<p>所以希望通过几篇文章去重新认识<code>微前端</code>这一架构，主要会从几个方面：</p>
<ul>
<li>是什么，以及为什么会出现</li>
<li>实现原理，以及主流框架</li>
<li>项目实战</li>
</ul>
<a id="more"></a>

<h1 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h1><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>在说微前端之前，我们需要先了解一下后端的微服务，因为微前端本身就是吸取微服务理念而产生的，所以我们先对微服务做一个简单的认识：</p>
<blockquote>
<p>2014年，Martin Fowler 与 James Lewis 共同提出了微服务的概念，定义了微服务是由以单一应用程序构成的小服务，自己拥有自己的进程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用HTTP API通信。同时服务会使用最小的规模的集中管理 (例如 Docker) 能力，服务可以用不同的编程语言与数据库等组件实现 —— <a href="https://zh.wikipedia.org/zh-sg/%E5%BE%AE%E6%9C%8D%E5%8B%99" target="_blank" rel="noopener">维基百科 微服务</a>。</p>
</blockquote>
<p><code>微服务</code>架构，通常拿来对比的架构是<code>单体软件</code>架构，<code>单体软件</code>存在以下几个问题：</p>
<ul>
<li>所有功能耦合在一起，互相影响，最终难以管理</li>
<li>哪怕只修改一行代码，整个软件就要重新构建和部署，成本非常高</li>
<li>不可能每个功能单独开发和测试，只能整体开发和测试，导致必须采用瀑布式开发模型</li>
</ul>
<p>因此开始出现将单体软件拆成一个个<code>功能单元服务</code>+<code>通讯协议</code>组成，这种叫<code>面向服务</code>(service-oriented architecture，简称 SOA)架构，也是微服务的雏形。</p>
<p>因此<code>微服务</code>架构的等于<code>面向服务</code>架构，它有多种实现方案，其中最佳实践是基于Docker容器实现的。</p>
<p>微服务的几大特性：</p>
<ul>
<li>敏捷性， 可快速迭代自己的微服务</li>
<li>弹性部署，快速持续集成与部署，服务独立性增加了应用程序应对故障的弹性</li>
<li>技术自由，可以自由选择最佳工具来解决他们的具体问题</li>
<li>可重复使用的代码，可以将专为某项功能编写的服务可以用作另一项功能的构建块</li>
</ul>
<p>Ok，微服务了解到这里基本上就有大概的认知，微服务当然不只是这些，还有一些其他技术点，如：服务发现、事件传播等。</p>
<h2 id="微前端"><a href="#微前端" class="headerlink" title="微前端"></a>微前端</h2><p>了解完微服务，那么微前端概念是什么开始提出的呢？</p>
<blockquote>
<p>微前端 这个名词，第一次被提出还是在2016年底，那是在 ThoughtWorks Technology Radar。这个概念将微服务这个被广泛应用于服务端的技术范式扩展到前端领域。<br>微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。 —— <a href="https://micro-frontends.org/" target="_blank" rel="noopener">微前端的完整介绍</a></p>
</blockquote>
<p>简单的说，微前端架构是从微服务理念扩展而来的，一个适用于前端的微服务架构。</p>
<h1 id="微前端-1"><a href="#微前端-1" class="headerlink" title="微前端"></a>微前端</h1><h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>从上面发展历程我们对<code>微前端</code>架构有个简单认知和它的定义，接下来我们通过不同类型的做比较去对微前端做更深的认知。</p>
<h2 id="单体巨石-VS-微前端"><a href="#单体巨石-VS-微前端" class="headerlink" title="单体巨石 VS 微前端"></a>单体巨石 VS 微前端</h2><p>用单体巨石架构和微前端架构做一个比较，能更好的理解微前端架构，具体如下图所示：</p>

<div class="mxgraph-container">
    <div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:false,&quot;page&quot;:0,&quot;toolbar&quot;:&quot;lightbox zoom layers pages&quot;,&quot;url&quot;:&quot;/assets/drawio/micro.drawio&quot;}"></div>
</div>


<p>简单的讲，就是将原本耦合在一起的单体巨石应用按照一定原则拆分成各种微前端小应用，最简单的拆分方案就是和微服务做一一映射。</p>
<h2 id="组件-VS-微前端"><a href="#组件-VS-微前端" class="headerlink" title="组件 VS 微前端"></a>组件 VS 微前端</h2><p>我们再从另外一个角度的去看待微前端，假设将微前端看做组件，是不是就好理解多了，只不过这个组件有点大，功能比较齐全，没有对外提供参数配置。</p>
<p>但是从两者的实际应用场景来说，还是有很多不同的地方，具体如下：</p>
<ul>
<li>从应用场景来看，组件是不可运行，被调用的，是应用中一部分，而微前端是完整可运行的一个应用</li>
<li>从技术上来看，组件是基于某个框架实现的，而微前端应用不依赖任何框架，但是微前端架构会依赖某个框架实现</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>微前端</code>架构，就是把复杂问题简单化，每个<code>微前端</code>项目都只需要关心自己的事情。因此<code>微前端</code>架构的核心思维如下：</p>
<ul>
<li><code>技术不可知</code>，每个<code>微前端</code>都应该选择自己的技术栈和技术进化路线，而不是和其他团队保持一致，同时架构师应该考虑的是<strong>如何高效的提供可复用的WebComponent会成为核心问题</strong></li>
<li><code>环境隔离</code>，<code>微前端</code>架构中每个子项目不共享运行时环境，即是：不依赖共享状态或全局变量，同时也可以通过命名规范（如：前缀）或命名空间，去隔离每个微前端应用</li>
<li><code>原生API优先</code>，使用 用于通信的原生浏览器事件机制 ，而不是自己构建一个PubSub系统</li>
<li><code>独立性</code>，<code>微前端</code>架构中每个子项目是完整的，可以独立运行、独立开发、独立部署</li>
<li><code>高可用</code>，<code>微前端</code>架构是高可用的，即使某个子应用异常也不会影响其他子应用的访问</li>
</ul>
<p>以上就是要实现<code>微前端</code>架构所需要考虑的点，同时也是架构中的核心思维。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>微前端架构在上面描述了很多优势，但是如果没做好架构设计，它也可能会带来一些问题，因此我们需要提前了解<code>微前端架构</code>可能会带来的缺陷：</p>
<ul>
<li>增加运维成本，因为由原本只需要发布一个应用，变成需要发布N个应用</li>
<li>拆分粒度越小，架构越复杂，开发维护成本越高</li>
<li>微前端支持不同技术栈，那么也带来了不同技术栈带来技术栈混乱的风险，同时也提高了开发维护成本</li>
<li>微前端架构本身就是将项目完全独立，可能导致部分公共代码无法通用</li>
<li>还有一些其他问题，如：当采用某类微前端框架增加开发成本等</li>
</ul>
<p>上面这些问题，在项目是否要用微前端架构都需要考虑的事情，但是也有一句话可以提供给大家参考。</p>
<blockquote>
<p>工程就是权衡的艺术，而微服务（microframeworks）架构给你提供了一个可以权衡的维度。</p>
</blockquote>
<p>了解完是什么，接下来就当项目中要实施<code>微前端</code>架构的时候要怎么做了。</p>
<h1 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h1><p>在项目要实施<code>微前端</code>架构，主要有几个工作项：</p>
<ul>
<li>首先，就是需要搞清楚如何将项目拆分一个个微前端子项目</li>
<li>其次，选型，采用哪种微前端框架去实施</li>
<li>最后，使用渐进式方案去实施，而不是一口气全切换，如果是新项目直接采用微前端架构，那么这里推荐采用<strong>Monorepo大仓+微前端</strong>，这里会让极大降低项目的管理成本。</li>
</ul>
<h2 id="如何拆分"><a href="#如何拆分" class="headerlink" title="如何拆分"></a>如何拆分</h2><p>微前端架构主要工作就是拆分，那么问题来了，我们应该依据什么样的标准去拆分呢？我们大体可以从下几点去考虑：</p>
<ul>
<li>第一，拆分条件，项目是否适合微前端架构</li>
<li>第二，拆分原则，项目拆分时候需要遵循的设计原则</li>
<li>第三，拆分方法，项目拆分可以依据哪些因素进行拆分</li>
</ul>
<h3 id="拆分条件"><a href="#拆分条件" class="headerlink" title="拆分条件"></a>拆分条件</h3><p>我们要对项目进行微前端架构设计的时候，我们应该从下面几方面去考虑是否适合：</p>
<ul>
<li>是否有快速迭代的需求，如果有快速迭代需求，则表示业务需要快速响应，那么采用微前端架构去拆分，不仅支持快速迭代，还支持业务快速试错</li>
<li>是否有代码提交出现大量冲突，如果有，则表示代码管理成本较高，微前端架构可以降低项目的管理成本</li>
<li>是否小功能需要等待大版本的场景，如果有，则表示小功能会影响到大版本的功能，这个时候微前端架构的<code>独立发布</code>特性，可随时回滚，风险变小，时间变短，影响面小，从而降低大版本发布延期风险</li>
</ul>
<p>从上面几个方面，我们可以很清晰的判断当前项目是否需要做微前端架构调整，只有这个时候，微前端的拆分才是有确定收益的，增加的运维成本才是值得的。</p>
<h3 id="拆分原则"><a href="#拆分原则" class="headerlink" title="拆分原则"></a>拆分原则</h3><p>当我们面对需要拆分微前端的时候，以下几个原则可以作为参考：</p>
<ul>
<li>单一职责原则，每个微前端只需关心自己的业务规则，确保职责单一，避免职责交叉</li>
<li>服务自治原则，每个微前端的开发，必须拥有开发、测试、运维、部署等整个过程，表示该应用可以独立运行而不需要依赖其他应用</li>
<li>持续演进原则，单体架构向微服务架构拆分过程中，无法做到一蹴而就，应逐步拆分细化，持续演进，避免微服务数量的瞬间爆炸性增长</li>
<li>服务粒度适中，先粗后细的原则，再按照拆分条件判断粗粒度的微前端是否需要拆分</li>
<li>避免循环依赖，循环依赖的情况会导致微前端在迭代发布的时候不知道优先发布哪个，在拆分的时候需要考虑，针对依赖部分进行下沉，拆分成公共模块</li>
<li>横向拆分原则，拆分微前端应该按照依赖层次的横向去拆，而不是纵向拆分，因为拆分越深，维护成本越高</li>
</ul>
<h3 id="拆分方法"><a href="#拆分方法" class="headerlink" title="拆分方法"></a>拆分方法</h3><p>以上两个主要针对拆分的假设条件，当真正去拆分操作的时候，我们应当从这些方面去入手：</p>
<ul>
<li>按照业务领域，参考<a href="https://zh.wikipedia.org/zh-hans/%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">领域模型</a>，将同类业务归为同一个微前端，按照单一职责原则、功能完整性进行拆分</li>
<li>按照组织架构，应尽量避免对组织架构和团队的调整，避免由于功能的重新划分，而增加大量且不必要的团队之间的沟通成本</li>
<li>按照技术栈，简单点说React的技术栈放一个微前端，Vue的技术栈放另外一个微前端</li>
<li>按需求迭代频率，将迭代频率高的放在一个微前端，频率低放在另外一个微前端</li>
</ul>
<p>学会了拆分方法，里面的优先级应该有大概排序，业务领域 &gt; 组织架构 &gt; 技术栈 &gt; 需求迭代频率，我推荐的做法如下：</p>
<ul>
<li>先按照业务领域去拆分</li>
<li>拆分的粒度不够，还要再拆分就按照组织结构再拆分</li>
<li>再往下，就是按照技术栈拆分</li>
<li>再往下，就是需求迭代频率</li>
</ul>
<h2 id="微前端框架"><a href="#微前端框架" class="headerlink" title="微前端框架"></a>微前端框架</h2><p>了解完如何拆分，那么接下来就是对微前端架构实现的框架进行选型，下面是我从网上收集目前市场主流的几大微前端框架：</p>
<ul>
<li><a href="https://github.com/single-spa/single-spa" target="_blank" rel="noopener">single-spa</a>，将多个单页面应用聚合为一个整体应用的 JavaScript 微前端框架</li>
<li><a href="https://qiankun.umijs.org/zh/guide" target="_blank" rel="noopener">qiankun</a>，基于single-spa，能更简单、无痛构建可用微前端架构的框架</li>
<li><a href="https://wujie-micro.github.io/doc/guide/" target="_blank" rel="noopener">无界</a>，基于iframe，实现路由同步机制的微前端架构框架</li>
<li><a href="https://zeroing.jd.com/docs.html#/" target="_blank" rel="noopener">micro-app</a>，借鉴WebComponent思想，结合自定义的ShadowDom，将微前端封装成一个类WebComponent组件的微前端框架</li>
<li><a href="https://webpack.docschina.org/concepts/module-federation/" target="_blank" rel="noopener">webpack 模块联邦</a>，在webpack构建时候加载远程应用而实现的微前端架构方案</li>
</ul>
<p>以上，就是目前实现微前端架构的主流框架，当然每个框架都自己的优缺点，我们在选型的时候主要还是通过以下几点去判断是否适合：</p>
<ul>
<li>对现有项目是否需要改造，改造成本多少</li>
<li>是否有学习成本，学习成本有多复杂</li>
<li>未来是否足够的扩展性</li>
<li>团队内是否有熟悉、精通该选型的人，否则遇到问题，容易入坑</li>
<li>项目维护的情况，issue 是否有响应，迭代是否在正常进行</li>
</ul>
<p>到了这里，本篇介绍微前端架构基本上就结束了，虽然很多理论知识，但是我们可以再次回顾一下，总结一下要点：</p>
<ul>
<li>微前端架构源自微服务架构，两者主要都是为了解决巨石应用的痛点，迭代慢、开发复杂</li>
<li>微前端架构拆分需要注意几个点：拆分条件、拆分原则和拆分方法</li>
<li>微前端架构主流框架：<a href="https://github.com/single-spa/single-spa" target="_blank" rel="noopener">single-spa</a>、<a href="https://qiankun.umijs.org/zh/guide" target="_blank" rel="noopener">qiankun</a>、<a href="https://wujie-micro.github.io/doc/guide/" target="_blank" rel="noopener">无界</a>、<a href="https://zeroing.jd.com/docs.html#/" target="_blank" rel="noopener">micro-app</a>、<a href="https://webpack.docschina.org/concepts/module-federation/" target="_blank" rel="noopener">webpack 模块联邦</a>等</li>
</ul>
<p>当然，我不会只写理论知识点，后面我会针对每个框架的写一篇深入实战文章，从背后原理，适用场景去一一描述，前端架构之路不好走，希望大家一起努力加油。</p>
<h1 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h1><h2 id="领域驱动设计"><a href="#领域驱动设计" class="headerlink" title="领域驱动设计"></a>领域驱动设计</h2><p>要了解一个新的东西，首先弄明白它解决了什么问题？领域驱动设计主要是为了解决：</p>
<ul>
<li>帮助团队更好理解业务世界</li>
<li>能协助开发构建良好的设计</li>
<li>降低业务逻辑与开发逻辑的耦合，降低复杂性</li>
</ul>
<p>那么现在，我们就明白领域驱动设计是什么了？它是强调业务概念、专业术语的开发设计理念。以下是一些官方解释，后面在前端架构系列文里，会写专门文章做深入介绍：</p>
<blockquote>
<p>领域驱动设计（Domain-Driven Design，简称DDD）是一种强调业务概念、专业术语以及原则的开发范式，旨在帮助用户，团队和软件开发者来解决复杂的信息系统和软件。它使用图形模型作为核心，其目标是使开发者能够理解、分析和把握业务概念，并将这些概念转化为可操作的软件。—— 【ChatGPT回答】</p>
</blockquote>
<h3 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h3><blockquote>
<p><code>领域模型</code>，来自领域驱动架构(DDD)中的一个概念，与<code>开发模型</code>(解决实际问题所抽象出来的概念模型) <code>设计模型</code>(描述了所要构建的系统)不同的是， <code>领域模型</code>是表达与业务相关的事实，它更加关注业务知识，能否显性化、清晰的表达业务语义。</p>
</blockquote>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://mp.weixin.qq.com/s/8vfTp-FZbYNk2k8gCIGc8w" target="_blank" rel="noopener">模块联邦在微前端架构中的实践</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2022/04/microservice.html" target="_blank" rel="noopener">微服务是什么？ —— 阮一峰</a></li>
<li><a href="https://micro-frontends.org/" target="_blank" rel="noopener">微前端的完整介绍</a></li>
<li><a href="https://www.zhihu.com/question/25089273" target="_blank" rel="noopener">领域驱动架构（DDD）建模中的模型到底是什么？</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
        <tag>架构系列</tag>
      </tags>
  </entry>
  <entry>
    <title>好玩有趣收集系列（二）</title>
    <url>/ideas/20230218.html</url>
    <content><![CDATA[<p>今日收集一些好玩有趣的开源api或框架或开源项目 </p>
<h1 id="自动生成1000个性化视频"><a href="#自动生成1000个性化视频" class="headerlink" title="自动生成1000个性化视频"></a>自动生成1000个性化视频</h1><p>通过<a href="https://shotstack.io/docs/guide/getting-started/core-concepts/" target="_blank" rel="noopener">Shotstack</a>提供的API服务制作不同视频。</p>
<blockquote>
<p>ShotStack是一个基于云的视频编辑API。与Adobe Premiere或After Effects等传统桌面视频编辑应用程序不同，ShotStack纯粹是基于代码的–您可以使用代码创建编辑。该API使用使用JSON的REST架构样式来描述应该如何编辑视频。有许多不同语言的SDK可用于与API交互并创建JSON请求。</p>
</blockquote>
<p>是否可以利用该api和小程序结合在一起做一些 生日祝福小视频定制服务。  </p>
<a id="more"></a>

<h1 id="ssh2-js-zx-js-快速实现运维"><a href="#ssh2-js-zx-js-快速实现运维" class="headerlink" title="ssh2.js + zx.js 快速实现运维"></a>ssh2.js + zx.js 快速实现运维</h1><ul>
<li><a href="https://github.com/mscdex/ssh2" target="_blank" rel="noopener">ssh2.js</a> 它是用纯JavaScript为Node.js编写的SSH2客户端和服务器模块</li>
<li><a href="https://www.npmjs.com/package/zx" target="_blank" rel="noopener">zx.js</a> 更加方便执行shell命令的API接口</li>
<li><a href="https://www.npmjs.com/package/inquirer" target="_blank" rel="noopener">inquirer.js</a> 提供终端交互的工具包</li>
</ul>
<blockquote>
<p>原文：<a href="https://github.com/CatsAndMice/blog/issues/42" target="_blank" rel="noopener">【Node.js】ssh2.js+Shell一套组合拳下来，一年要花2080分钟做的工作竟然节省到52分钟</a><br>其他好玩的文章：</p>
<ul>
<li><a href="https://juejin.cn/post/7068969844607189029" target="_blank" rel="noopener">自动生成npm版本号和发布npm包</a></li>
<li><a href="https://juejin.cn/post/7072972877628178440" target="_blank" rel="noopener">发属于自己的快速创建开发文件脚手架</a></li>
</ul>
</blockquote>
<h1 id="密码学工具"><a href="#密码学工具" class="headerlink" title="密码学工具"></a>密码学工具</h1><p><a href="https://crypto-online.cn/" target="_blank" rel="noopener">cryptography 加密密码相关工具网站</a></p>
<h1 id="自动生成证件照"><a href="#自动生成证件照" class="headerlink" title="自动生成证件照"></a>自动生成证件照</h1><p><a href="https://github.com/liuxiaojun666/certificate-photo" target="_blank" rel="noopener">certificate-photo  生成证件照的小程序源码</a></p>
<h1 id="常用小工具"><a href="#常用小工具" class="headerlink" title="常用小工具"></a>常用小工具</h1><p>回头可以自己搞一套，提高网站访问量</p>
<p><a href="https://tool.browser.qq.com/category/develop" target="_blank" rel="noopener">腾讯浏览器 帮小忙工具集合</a></p>
<h1 id="P2P私域聊天工具"><a href="#P2P私域聊天工具" class="headerlink" title="P2P私域聊天工具"></a>P2P私域聊天工具</h1><blockquote>
<p>webrtc file transfer tool，p2p网页在线文件传输，跨终端，不限平台，内网不限速，支持私有部署，支持多文件拖拽发送，支持本地屏幕录制，远程屏幕共享，远程音视频通话，密码房间，中继服务设置，webrtc检测，文字传输，公共聊天，丰富的后台管理，实时执行日志展示，机器人告警通知等功能</p>
</blockquote>
<p><a href="https://github.com/iamtsm/tl-rtc-file" target="_blank" rel="noopener">webrtc file transfer tool github 地址</a></p>
<h1 id="个人Linux服务器管理面板"><a href="#个人Linux服务器管理面板" class="headerlink" title="个人Linux服务器管理面板"></a>个人Linux服务器管理面板</h1><p>能够让你快速观看个人服务器的一些状态和信息。</p>
<p><a href="https://github.com/chaos-zhu/easynode" target="_blank" rel="noopener">github地址</a></p>
<h1 id="有趣的言论"><a href="#有趣的言论" class="headerlink" title="有趣的言论"></a>有趣的言论</h1><p>创业箴言：</p>
<p>领导者的作用不是行使权力，而是分配权力。</p>
<p>有效的领导者通过设定方向、确定人员（找到具有正确技能和背景的人）、授权他人、确保决策执行，来节省自己的时间，并扩大自己的影响。</p>
<p>– <a href="https://hackernoon.com/optimize-for-alignment-not-control-great-leaders-serve-and-more-startup-mantras" target="_blank" rel="noopener">《我的创业箴言》</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>奇思妙想</tag>
      </tags>
  </entry>
  <entry>
    <title>创业idea —— 一个小程序利用一句话画一幅画</title>
    <url>/ideas/20230217.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近从开源库看到一个很火的项目，就是用一句话画一幅画。</p>
<p>这里虽然他们开源只识别英文，我们可以调用第三方的翻译API转成英文，然后再返回到开源库。</p>
<p>小程序思路：</p>
<ul>
<li>一个人一天体验3次，转发可以获得次数</li>
<li>允许转发下载，以及个人签名等</li>
<li>提高用户量</li>
<li>如果访问量爆发的话，可以继续尝试</li>
<li>名字叫随意画</li>
</ul>
<h1 id="AI生成图片开源项目"><a href="#AI生成图片开源项目" class="headerlink" title="AI生成图片开源项目"></a>AI生成图片开源项目</h1><p><a href="https://github.com/cmdr2/stable-diffusion-ui?utm_source=gold_browser_extension" target="_blank" rel="noopener">stable-diffusion-ui 一句话生成一幅画</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>奇思妙想</tag>
      </tags>
  </entry>
  <entry>
    <title>可以从ChatGPT学到什么(一)</title>
    <url>/today/20230216.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近<code>chatgpt</code>智能对答火的一塌涂地，就是你找<code>chatgpt</code>咨询，它不仅能理解你的意思，还能给出准确的答案，而且能够从上下文理解你的意思。</p>
<p>简单的说，就不再是之前的智能对答，如果遇到不理解的问题回复【我好像不太理解你的问题】。</p>
<p>更有甚者，利用chatgpt完成论文编写，同时还有帮小孩子写作业、程序员利用它整理某个业务的实现思路，作者利用其帮忙写小说细节等等。</p>
<p>我尝试问了一些常规问题，如下图所示，可以更好的理解<code>chatgpt</code>的能力。</p>
<ol>
<li><p>如何以<code>Nest.js</code>框架实现用户登录功能</p>
<a id="more"></a>
<p><img src="/assets/img/20230216-1.jpeg" alt></p>
</li>
<li><p>直接将高考作文题要求放入，如下：</p>
<blockquote>
<p>请以“像一道闪电”为题目，写一段抒情文字或一首小诗。要求：感情真挚，语言生动，有感染力。要求800字。 —— 2022年北京卷</p>
</blockquote>
</li>
</ol>
<p><img src="/assets/img/20230216-2.png" alt></p>
<p>因此，作为程序员，没有理由不去深入且完整的了解它，故而有这篇小白科普文。</p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>为了更好的了解后面的内容，我们需要提前对一些知识概念了解一下。</p>
<h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h2><blockquote>
<p>人工智能 (AI) 是计算机模拟人类智能行为的功能。 通过 AI，计算机可以分析图像、理解语音、以自然方式交互，以及使用数据进行预测。</p>
</blockquote>
<p>目前AI开发流程分为：</p>
<ol>
<li>确定目的模型，AI最终是用来做什么，如：图像识别、语言识别等</li>
<li>准备训练数据，收集和预处理数据，如：要识别一只猫，可能需要几十万张不同猫的图片</li>
<li>训练模型，也叫建模，通过各种算法、方法和技巧去创建，最终输出模型，如：从不同图片中去识别猫的，需要写算法、然后标注结果是否准确，这里的模型你可以理解成“只会识别猫的眼睛”</li>
<li>评估模型，反复的调整算法参数、数据，不断评估训练生成的模型，最终得到满意的模型，如：告诉【眼睛模型】哪些图片是猫，哪些图片不是猫，猫的特征有什么，直到【眼睛模型】可以识别出所有的猫的图片和不是猫的图片</li>
<li>部署模型，将模型应用到正式的实际数据或新产生数据中，进行预测、评价，如：把【眼睛模型】去接触真实世界，看到一些真实猫图片或视频</li>
</ol>
<p>总结来说，AI就是可以模拟人的部分行为，如上文举例所说的【眼睛模型】，就是实现人类眼睛可以识别猫的功能，扩展开来就是可以充当人的眼睛去识别万物。</p>
<p>当然有些更加智能的模型可以重复2/3/4三个步骤让自己变得更加完善（这也叫【无监督模型或自监督模型】）。</p>
<h2 id="语言模型"><a href="#语言模型" class="headerlink" title="语言模型"></a>语言模型</h2><p>从前面了解到【模型】的概念，从通俗的理解模型是一个模仿人类某个功能，从技术上讲模型是一段算法代码。</p>
<p>因此语言模型从这两个方面来说：</p>
<ul>
<li>许多自然语言处理方面的应用，如：语音识别[1]，机器翻译[2]，词性标注，句法分析[3]，手写体识别[4]和资讯检索</li>
<li>从技术上来讲，是一个概率分布的算法</li>
</ul>
<p>我们对语言模型可以理解成，一个能够识别自然语言（包括语音，语义识别等）的算法模型即可。</p>
<p>常用的语言模型算法有以下几种：</p>
<ul>
<li>ELMo 华盛顿大学提出的算法 </li>
<li>GPT OpenAI提出的算法</li>
<li>BERT Google提出的算法</li>
</ul>
<h2 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h2><blockquote>
<p>Generative Pre-trained Transformer (GPT)，是一种基于互联网可用数据训练的文本生成深度学习模型。</p>
</blockquote>
<p>GPT的整个发展过程分为：</p>
<ul>
<li>GPT-1，有一定的泛化能力，能够用于和监督任务无关的 NLP 任务，如：自然语言推理：判断两个句子的关系；问答与常识推理：输入文章及若干答案，输出答案的准确率等</li>
<li>GPT-2，使用无监督预训练模型做有监督任务，比GTP-1拥有更加强大能力，能阅读摘要、聊天、续写、编故事，甚至生成假新闻等，甚至可以假扮网络角色进行会话聊天，如：微软的小冰。</li>
<li>GPT-3，作为一个无监督模型，几乎可以完成自然语言处理的绝大部分任务，如面向问题的搜索、阅读理解、语义推断、机器翻译、文章生成和自动问答等等。</li>
<li>GPT3.5，是一系列模型，使用<code>人类反馈强化学习(RLHF)</code>，与<code>GPT-3</code>最大的区别在使用互联网的资料直接训练。</li>
<li>GPT-4，针对GPT-3不分青红皂白和质量好坏地对网络上的所有文本进行学习，进而生产出错误的、恶意冒犯的、甚至是攻击性的语言输出的缺陷，而准备提出新的升级模型。</li>
</ul>
<p><strong>一个无监督模型功能多效果好，似乎让人们看到了通用人工智能的希望，可能这就是 GPT-3 影响如此之大的主要原因。</strong></p>
<p>有了这些概念性的知识后，我们就可以开始认识<code>ChatGPT</code>。</p>
<h1 id="ChatGPT"><a href="#ChatGPT" class="headerlink" title="ChatGPT"></a>ChatGPT</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>在官网上定义如下：</p>
<blockquote>
<p>ChatGPT: 专门针对对话而优化的语言模型。同时已经训练了一个名为ChatGPT的模型，它以对话的方式进行交互。对话形式使ChatGPT能够回答后续问题，承认错误，挑战不正确的前提，拒绝不适当的请求。ChatGPT是InstructGPT的兄弟模型，InstructGPT被训练为遵循提示中的说明并提供详细的响应。 —— <a href="https://openai.com/blog/chatgpt/" target="_blank" rel="noopener">ChatGPT官网</a></p>
</blockquote>
<p>按照我所理解来说，ChatGPT是：</p>
<ul>
<li>一个基于<code>GPT-3.5系列模型</code> + <code>人类反馈强化学习(RLHF)</code>实现的语言模型</li>
<li>一个可以正常对话聊天、自动纠正错误的智能对话机器人(快速，而不需要等待太长时间)</li>
<li>一个链接互联网所有公开信息，能检索到所有信息和总结的智能搜索引擎</li>
<li>一个可以辅助你实现相关工作（如：作业，代码，论文等）的智能工具</li>
</ul>
<p><strong><a href="https://openai.com/blog/instruction-following/" target="_blank" rel="noopener">InstructGPT</a> VS ChatGPT</strong></p>
<ul>
<li>两者都是基于<code>GPT-3.5系列模型</code>做调整的语言模型</li>
<li><code>InstructGPT</code>是一个问题就一个回答，如果回答不正确就调整， <code>ChatGPT</code>则是一个问题就多个回答，然后学习将这些回答进行排序</li>
</ul>
<p>如何使用：</p>
<p>其实如果可以直接访问<a href="https://chat.openai.com/" target="_blank" rel="noopener">ChatGPT官网</a>就可以直接用，国内也有很多插件可以使用。</p>
<h2 id="影响什么"><a href="#影响什么" class="headerlink" title="影响什么"></a>影响什么</h2><p>ChatGPT的火爆是AI多年沉淀的一次技术爆发，距离上一次AI技术的热点新闻还是在谷歌的阿尔法狗战胜世界围棋冠军李世石（2016年）。</p>
<p>我们可以先收集一下目前使用AI技术的一些场景：</p>
<ul>
<li>各种识别，人脸、指纹等</li>
<li>智能辅助驾驶</li>
<li>各种转义，如：语音转文字，文字转语音， 翻译等</li>
<li>各种语音助手，如：Siri，小爱同学等</li>
</ul>
<p>其实，AI在我们生活中已经随处可见，只是有时候我们觉得这些功能还是比较属于机器范围内的，如有时候小爱同学会说“我没听清楚你的问题”这种明显非智能回答，给我们造成一种认知觉得AI很傻。</p>
<p>因此，ChatGPT的火爆之处在于：它真的可以像一个人类给予你想要的回答，更加准确的说，它是一个负责任的智能AI，能竭尽所能的给你想要的答案。</p>
<p>接下来，我从网上搜索了一些资料，从几个行业讲一下它可能会带来的影响。</p>
<h3 id="教育行业"><a href="#教育行业" class="headerlink" title="教育行业"></a>教育行业</h3><p>其实最大的担心就是，大家利用chatgpt去写作业或论文，尤其是学龄前儿童和中小学阶段，正是属于知识探索期，chatgpt是否会影响学生的学习吗？</p>
<p>这里引用一段话，针对国内的，吴永和教授的一个观点：</p>
<blockquote>
<p>面向未来，作为承担2021年度国家社会科学基金重大项目“面向未成年人的人工智能技术规范研究”的首席专家，吴永和从五个方面给出了教育人工智能发展的建议：</p>
<ul>
<li>一、是进行理论的奠基，确定价值观、战略方向，做好顶层设计；</li>
<li>二、是提升人类的人工智能核心素养，从而使师生能正确驾驭智能工具；</li>
<li>三、是完善技术应用的监管，保持人工智能的向善性，使技术能够更好地为人服务；</li>
<li>四、是考虑技术和教育深度融合的伦理问题，更好地做到人机共融；</li>
<li>五、是落实相关标准，比如教育人工智能的算法描述信息、安全描述框架、伦理审查规范。</li>
</ul>
</blockquote>
<h3 id="IT行业"><a href="#IT行业" class="headerlink" title="IT行业"></a>IT行业</h3><p>网络已经有很多人利用chatgpt去生成代码甚至正式上线，那么是否会代替程序员，或者以后程序员已经如何学习发展？</p>
<p>这里引用知乎上的一个问答<a href="https://www.zhihu.com/question/570403406" target="_blank" rel="noopener">OpenAI 的超级对话模型 ChatGPT 会导致程序员大规模失业吗？</a>，总结一下精彩回答：</p>
<blockquote>
<ul>
<li>chatgpt作为一个管家型查找，把喂到你嘴里这个功能发挥到了极致。</li>
<li>chatgpt给出的代码实现和”背题家”也出奇的相似</li>
<li>chatGPT最多能看作一个助手, 对于广大程序员来说是一个不错的辅助工具</li>
<li>AI的发展已经明确告诉你了，不要卷细节上的东西，提升核心竞争力，就是你的解决问题的思路</li>
<li>没有思想的人才是最快被取代的</li>
<li>ChatGPT 又来了，这次我是什么感觉呢？感觉真的 Google 和 StackOverflow 已经不好用了</li>
<li>借助 Copilot 和 ChatGPT，程序员的自我感觉更棒了！可以更加肆无忌惮地在未知领域里自由探索了！</li>
</ul>
</blockquote>
<h3 id="其他行业"><a href="#其他行业" class="headerlink" title="其他行业"></a>其他行业</h3><p>引用知乎上的问答<a href="https://www.zhihu.com/question/582809884/answer/2883146417" target="_blank" rel="noopener">ChatGPT 会取代人的哪些工作？哪些人群的职业规划需要转变？</a>，总结一下精彩回答：</p>
<blockquote>
<ul>
<li>内容行业：文字+图像处理效率的提升，更加庞大的内容生态也有了存在的基础，推动芯片和硬件的提升，从而实现更宏大的数字世界</li>
<li>游戏行业：npc会和你流畅的对话，黄油里面可以根据你的xp来叫主人或者变态，新的需求会生成，也催生新的经济形态</li>
<li>这将是人工智能诞生以来，人类的工作第一次真正接近被大规模替代的时点——不是部分工作被替代，而是大规模被替代的开始。</li>
<li>ChatGPT的商业模式，可能不会像搜索那样依赖广告，难以出现大规模的2C级应用，而更可能是2B，主要运用于工作场景</li>
<li>会提问题的人将是最后的赢家，可以让你的工作不但不会被AI取代，反而创造了全新的工作方式</li>
</ul>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>第一篇关于ChatGPT的了解就先写到这里，作为AI小白，我们可以学习到：</p>
<ul>
<li>AI模型是的训练过程：确定模型&gt;准备数据&gt;训练模型&gt;调整模型&gt;部署模型</li>
<li>ChatGPT的实质定义，利用互联网的资料训练<code>GPT-3.5模型</code>而成的一个对话式的语言模型</li>
<li>ChatGPT的出现可能带来的改变，可以将某些行业岗位的价值重新定义，但是却能提高更多岗位的工作效率和价值，从而提升整个社会运转速度</li>
</ul>
<p>最后，问ChatGPT我能从你这里学到什么？如下图：</p>
<p><img src="/assets/img/20230216-3.png" alt></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://support.huaweicloud.com/productdesc-modelarts/modelarts_01_0010.html" target="_blank" rel="noopener">华为 AI开发基本流程介绍</a></li>
<li><a href="https://learn.microsoft.com/zh-cn/azure/architecture/data-guide/big-data/ai-overview" target="_blank" rel="noopener">谷歌 人工智能 (AI) 体系结构设计</a></li>
<li><a href="https://www.8btc.com/article/6791988" target="_blank" rel="noopener">ChatGPT的崛起：从GPT-1到GPT-3，AIGC时代即将到来</a></li>
<li><a href="https://github.com/BlinkDL/ChatRWKV" target="_blank" rel="noopener">自己搭建chatpt</a></li>
<li><a href="https://gpt3demo.com/" target="_blank" rel="noopener">GPT-3 demo应用收集</a></li>
<li><a href="http://edu.china.com.cn/2023-02/15/content_85106877.htm" target="_blank" rel="noopener">用ChatGPT写作业会毁了孩子的学业吗？</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>前端自动化UI测试的完整方案</title>
    <url>/today/20230215.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>开发公共平台项目，测试资源相对比较少，因此对开发者自身而言，为了维护项目的稳定性，需要对平台做各类测试，即使有测试环境，但是也很容易缺乏测试场景导致带着bug上线的情况。</p>
<p>因此我们需要做完整自动化测试方案，来避免这类常规错误，提高平台的可用性和稳定性。</p>
<p>这里先简单描述自动化测试的分类：</p>
<ul>
<li>单元测试，验证独立的单元模块代码或函数是否正常工作</li>
<li>集成测试，验证多个单元模块间的协同工作</li>
<li>UI 测试，只针对前端UI部分测试，后端数据采用mock方式</li>
<li>端到端测试，从用户的角度，通过机器来模仿用户在真实浏览器中验证应用交互</li>
<li>快照测试，验证程序的UI变化</li>
</ul>
<p>接下来我们将根据这些测试类如何在项目中落地完整方案。</p>
<a id="more"></a>

<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>前端项目主要用的单元测试框架为<code>Jest</code>和<code>Mocha</code>，下面就<code>Jest</code>框架如何实现一个单元测试。</p>
<h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ol>
<li><p>安装依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i jest --save-dev</span><br><span class="line"><span class="meta">#</span> 如果是typescript还需要安装 ts</span><br><span class="line">npm i ts-jest babel-jest --save-dev</span><br><span class="line"><span class="meta">#</span> 安装类型</span><br><span class="line">npm i @types/jest --save-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>新增测试命令，在<code>package.json</code>中<code>scripts</code>新增代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">"scripts"</span>: &#123;</span><br><span class="line">        <span class="string">"test"</span>: <span class="string">"node --experimental-vm-modules node_modules/jest/bin/jest.js"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新增配置文件<code>jest.config.js</code>，参考配置如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="string">"testEnvironment"</span>: <span class="string">"node"</span>,</span><br><span class="line">    testMatch: [ <span class="comment">//匹配测试用例的文件</span></span><br><span class="line">        <span class="string">'&lt;rootDir&gt;/test/**/*.test.ts'</span></span><br><span class="line">    ],</span><br><span class="line">    transform: &#123;</span><br><span class="line">        <span class="string">'^.+\\.js$'</span>: <span class="string">'&lt;rootDir&gt;/node_modules/babel-jest'</span>, <span class="comment">// babel编译</span></span><br><span class="line">        <span class="string">'^.+\\.ts$'</span>: <span class="string">'&lt;rootDir&gt;/node_modules/ts-jest'</span>, <span class="comment">// typescript编译</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"collectCoverage"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写单元测试代码，在根目录下新建测试文件<code>test/sum.test.js</code>，标识对<code>a.ts</code>文件做测试，代码如下：</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sum.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sum.test.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">'../src/sum'</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">"test two num sum"</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> res = sum(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    expect(<span class="keyword">typeof</span> res).toBe(<span class="string">"number"</span>)</span><br><span class="line">    expect(res).toBe(<span class="number">11</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>开始自动化测试<code>yarn test</code>或者<code>npm run test</code>，然后会出现如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PASS  ./sum.test.ts</span><br><span class="line">----------|---------|----------|---------|---------|-------------------</span><br><span class="line">File      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s </span><br><span class="line">----------|---------|----------|---------|---------|-------------------</span><br><span class="line">All files |     100 |      100 |     100 |     100 |                   </span><br><span class="line"> sum.ts   |     100 |      100 |     100 |     100 |                   </span><br><span class="line">----------|---------|----------|---------|---------|-------------------</span><br><span class="line">Test Suites: 1 passed, 1 total</span><br><span class="line">Tests:       1 passed, 1 total</span><br><span class="line">Snapshots:   0 total</span><br><span class="line">Time:        1.394 s, estimated 3 s</span><br></pre></td></tr></table></figure>

<p>简单说明一下上面的表格几个字段作用：</p>
<ul>
<li>File，标识当前测试的文件</li>
<li>Stmts，语句覆盖率（statement coverage）：是不是每个语句都执行了</li>
<li>Branch，分支覆盖率（branch coverage）：是不是每个if代码块都执行了</li>
<li>Funcs，函数覆盖率（function coverage）：是不是每个函数都调用了</li>
<li>Lines，行覆盖率（line coverage）：是不是每一行都执行了</li>
</ul>
<h2 id="怎么提高单元测试覆盖率"><a href="#怎么提高单元测试覆盖率" class="headerlink" title="怎么提高单元测试覆盖率"></a>怎么提高单元测试覆盖率</h2><p>分为两个部分：</p>
<ul>
<li>提高代码质量，减少代码块的大小，减少各类复杂逻辑判断，不去测试有依赖性函数，如：需接口、数据库等</li>
<li>提高开发意愿，一自动化生成单元测试，二采用设置覆盖率指标，三是确定单元测试规范（哪些模块需要写，哪些不需要写）</li>
</ul>
<h1 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h1><p>集成测试主要是测试当单元模块组合到一起之后是否功能正常。</p>
<p>相比较单元测试只是针对某个函数或方案做单一功能测试，集成测试是针对某个功能模块做完整的测试，因此在测试粒度上的选择，需要开发自己去衡量，但是一般的选择如下几种：</p>
<ul>
<li>如果有UI展示的，一般通过router分割页面粒度去进行测试，尽可能的少mock依赖，尽量的渲染全子组件</li>
<li>如果是库不含JS的，则以功能模块为粒度进行测试，测试数据尽量丰富且贴近真实数据</li>
</ul>
<p>具体实现步骤其实和单元测试一样，只是所写的测试功能比单元测试范围要大且完整。</p>
<h1 id="UI-测试"><a href="#UI-测试" class="headerlink" title="UI 测试"></a>UI 测试</h1><blockquote>
<p>相比较后面<code>端到端测试</code>，UI测试只是对于前端的测试，是脱离真实后端环境的，仅仅只是将前端放在真实环境中运行，而后端和数据都应该使用 Mock 的。</p>
</blockquote>
<p>UI 测试在前端上，也可以叫组件测试<br>那么如何实现UI测试，其实依旧可以使用<code>Jest</code>、<code>Enzyme</code> <code>selenium</code> <code>Vitest</code>等框架，目前都支持将<code>Vue</code>、<code>React</code>等组件进行模拟渲染完成。</p>
<p>利用<code>Jest</code>实现对React UI组件测试，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// React Home.jsx</span></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;Home&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// home.test.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createRoot &#125; <span class="keyword">from</span> <span class="string">"react-dom/client"</span>; <span class="comment">// createRoot 是React18 新出的特性</span></span><br><span class="line"><span class="keyword">import</span> &#123; act &#125; <span class="keyword">from</span> <span class="string">"react-dom/test-utils"</span>; <span class="comment">// react支持测试动作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">"../src/pages/home"</span>;</span><br><span class="line"></span><br><span class="line">global.IS_REACT_ACT_ENVIRONMENT = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> root = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> container = <span class="literal">null</span>;</span><br><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 DOM 元素作为渲染目标</span></span><br><span class="line">    container = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(container);</span><br><span class="line">    root = createRoot(container)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 退出时进行清理</span></span><br><span class="line">    <span class="comment">// root.unmount(container);</span></span><br><span class="line">    container.remove();</span><br><span class="line">    container = <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">it(<span class="string">"渲染有或无名称"</span>, () =&gt; &#123;</span><br><span class="line">    act(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        root.render(&lt;Home /&gt;);</span><br><span class="line">    &#125;);</span><br><span class="line">    expect(container.textContent).toBe("Home");</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当然你依然可以使用<code>Jest</code>去做Vue UI 测试，但是<code>Vitest</code>实现在vite项目中更加好用，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Home.vue</span></span><br><span class="line">&lt;script setup lang=<span class="string">"ts"</span>&gt;</span><br><span class="line">defineProps&lt;&#123; <span class="attr">msg</span>: string &#125;&gt;()</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;template&gt;</span></span><br><span class="line"><span class="regexp">  &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/</span>h1&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/home.test.js</span></span><br><span class="line"><span class="regexp">import &#123; mount &#125; from '@vue/</span>test-utils<span class="string">'</span></span><br><span class="line"><span class="string">import Home from '</span>../src/components/Home.vue<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">test('</span>mount component<span class="string">', async () =&gt; &#123;</span></span><br><span class="line"><span class="string">    expect(Home).toBeTruthy()</span></span><br><span class="line"><span class="string">    const wrapper = mount(Home, &#123;</span></span><br><span class="line"><span class="string">        props: &#123;</span></span><br><span class="line"><span class="string">            msg: '</span>Home<span class="string">',</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">      &#125;)</span></span><br><span class="line"><span class="string">    expect(wrapper.html()).toContain('</span>Home<span class="string">')</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure>

<h2 id="快照测试"><a href="#快照测试" class="headerlink" title="快照测试"></a>快照测试</h2><p>快照测试是属于UI测试的一种分类，主要用于区分同样的数据下，页面UI展示是否发生变化，如果不一样则比较测试结果失败，有异常或者功能迭代。针对快照测试详细说明如下：</p>
<blockquote>
<p>快照测试类似于“找不同”游戏。快照测试会给运行中的应用程序拍一张图片，并将其与以前保存的图片进行比较。如果图像不同，则测试失败。这种测试方法对确保应用程序代码变更后是否仍然可以正确渲染很有帮助。</p>
<p>当然，在前端中，其实并不是比较图片，而是比较前后生成的html结构，本质上是一个字符串的比较。</p>
</blockquote>
<p>同理，如果一个功能模块，针对同样的输入，得出的结果是不一样，那么也是一种快照测试。</p>
<p>利用<code>Jest</code>实现快照测试代码如下（基本和UI测试一样）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// home.test.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createRoot &#125; <span class="keyword">from</span> <span class="string">"react-dom/client"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; act &#125; <span class="keyword">from</span> <span class="string">"react-dom/test-utils"</span>;</span><br><span class="line"><span class="keyword">import</span> pretty <span class="keyword">from</span> <span class="string">"pretty"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">"../src/pages/home"</span>;</span><br><span class="line"></span><br><span class="line">global.IS_REACT_ACT_ENVIRONMENT = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> root = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> container = <span class="literal">null</span>;</span><br><span class="line">beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 DOM 元素作为渲染目标</span></span><br><span class="line">    container = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(container);</span><br><span class="line">    root = createRoot(container)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">afterEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 退出时进行清理</span></span><br><span class="line">    <span class="comment">// root.unmount(container);</span></span><br><span class="line">    container.remove();</span><br><span class="line">    container = <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">it(<span class="string">"渲染有或无名称"</span>, () =&gt; &#123;</span><br><span class="line">    act(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        root.render(&lt;Home /&gt;);</span><br><span class="line">    &#125;);</span><br><span class="line">    expect(container.textContent).toBe("Home");</span><br><span class="line"></span><br><span class="line">    // 快照对比 这里你可以先把html结构存储一份，然后再拿出来对比</span><br><span class="line">    expect(</span><br><span class="line">        pretty(container.innerHTML)).</span><br><span class="line">        toMatchInlineSnapshot(`</span><br><span class="line">"&lt;div&gt;</span><br><span class="line">  &lt;h1&gt;Home1&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;"</span><br><span class="line">`);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="E2E测试"><a href="#E2E测试" class="headerlink" title="E2E测试"></a>E2E测试</h1><p>E2E测试，也叫端到端测试，就是模拟真实环境下，用户不同操作行为的测试。</p>
<p>目前主要进行E2E测试框架有如下几种：</p>
<ul>
<li>puppeteer 一个 Node 库，它提供了一个高级 API 来通过 DevTools 协议控制 Chromium 或 Chrome</li>
<li>cypress  现代网络构建的下一代前端测试工具， 编写更快、更容易和更可靠的测试</li>
<li>Selenium  是开源的自动化测试工具，它主要是用于Web 应用程序的自动化测试，不只局限于此，同时支持所有基于web 的管理任务自动化</li>
<li>NightWatch 是一个用于web应用和网站上执行自动化端到端（end-to-end）测试的集成框架，用于主流浏览器中，简化编写和执行多种类型地测试程序</li>
</ul>
<p>这几者的区别后面会有专门文章去描述，现在我们先利用<code>cypress</code>实现E2E测试代码， 以Vue项目为主，如下：<br>步骤一，安装依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add cypress -D</span><br></pre></td></tr></table></figure>

<p>步骤二，新增脚本，package.json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">        <span class="attr">"cypress"</span>: <span class="string">"cypress open"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤三，后面按照其提示去添加测试文件，比如：<code>index.cy.ts</code>，然后修改代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'template spec'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'has home text'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 访问首页</span></span><br><span class="line">    cy.visit(<span class="string">'http://localhost:5173/'</span>)</span><br><span class="line">    <span class="comment">// 断言是否有 Home 文字</span></span><br><span class="line">    cy.contains(<span class="string">'Home'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>具体效果如下图：</p>
<p><img src="/assets/img/20230215.png" alt></p>
<p>当然E2E没有这么简单，还有一些点击、输入等事件，甚至可以模拟登录等，这些详细操作放在后面cypress实战篇去讲解。</p>
<h1 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h1><p>了解自动化测试后，我们还需要对测试覆盖率进行一个完整的了解。</p>
<blockquote>
<p>测试覆盖率(test coverage)是衡量软件测试完整性的一个重要指标。掌握测试覆盖率数据，有利于客观认识软件质量，正确了解测试状态，有效改进测试工作。</p>
</blockquote>
<p>其实上面提到单元测试的时候已经有讲过一些，这里再做一个完整都介绍。</p>
<p>覆盖率主要分为以下几种：</p>
<ul>
<li>代码覆盖率， 如上述所说分为几种，如：行覆盖率、函数覆盖率等</li>
<li>需求覆盖率，测试所覆盖的需求数量与总需求数量的比值</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>自动化测试在前端开发是必不可少的一个环节，因为前端是直接面向用户的，即使有测试团队支持，也难免会出现测试遗漏的场景，或者加大测试人力成本。</p>
<p>当然不同项目的自动化测试所需要的环节是不一样的，根据个人经验，建议不同场景采用自动化测试如下：</p>
<ul>
<li>开发纯函数库，建议写更多的单元测试 + 少量的集成测试</li>
<li>开发组件库，建议写更多的单元测试、为每个组件编写快照测试、写少量的集成测试 + 端到端测试</li>
<li>开发业务系统，建议写更多的集成测试、为工具类库、算法写单元测试、写少量的端到端测试</li>
<li>开发公共平台项目，建议写更多的集成测试和完整的端到端测试</li>
</ul>
<h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><ul>
<li><a href="https://github.com/qiubohong/qiubohong.github.io/tree/master/code/react/my-app" target="_blank" rel="noopener">React测试demo代码</a></li>
<li><a href="https://github.com/qiubohong/qiubohong.github.io/tree/master/code/vue/vite-project" target="_blank" rel="noopener">Vue测试demo代码</a></li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247493866&idx=1&sn=c4a3d5ddf6e3148360f3de9ea32e018f&chksm=cf0327d1f874aec72d630aa81d7b1b0b0961943287fbab023e6d39d466f33b642e12ca7f1ac0&token=953834215&lang=zh_CN#rd" target="_blank" rel="noopener">把 puppeteer 融入调试流程，调试体验爽翻了！</a></li>
<li><a href="https://github.com/goldbergyoni/javascript-testing-best-practices/blob/master/readme-zh-CN.md" target="_blank" rel="noopener">JS最佳测试实践</a></li>
<li><a href="https://blog.checklyhq.com/how-to-bypass-totp-based-2fa-login-flows-with-playwright/" target="_blank" rel="noopener">如何使用Playwright绕过验证登录做端到端测试</a></li>
<li><a href="https://juejin.cn/post/6844904194600599560" target="_blank" rel="noopener">前端自动化测试入门</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>数据可视化收集</title>
    <url>/ideas/20230215.html</url>
    <content><![CDATA[<h1 id="数据可视化收集"><a href="#数据可视化收集" class="headerlink" title="数据可视化收集"></a>数据可视化收集</h1><p>收集数据可视化或报表开源系统，为了能够根据不同数据源展示可视化界面。</p>
<h2 id="DataEase"><a href="#DataEase" class="headerlink" title="DataEase"></a>DataEase</h2><p>人人可用的开源数据可视化分析工具</p>
<ul>
<li>官网地址：<a href="https://dataease.io/" target="_blank" rel="noopener">https://dataease.io/</a><br>Github： <a href="https://github.com/dataease/dataease/" target="_blank" rel="noopener">https://github.com/dataease/dataease/</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>奇思妙想</tag>
      </tags>
  </entry>
  <entry>
    <title>创业idea——AI种植与花店</title>
    <url>/ideas/20230214.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>此想法源于一个抖音视频，里面有个商业模式，通过摄像头+气味嗅觉捕捉器+液体分析器，可以识别当前植物的状态，且占地面积不大，可以直接树立到家里墙上。大概如下图所示：</p>
<p><img src="/assets/img/idea-20230214-3.png" alt></p>
<a id="more"></a>
<p><img src="/assets/img/idea-20230214-1.png" alt><br><img src="/assets/img/idea-20230214-2.png" alt></p>
<h1 id="创业想法"><a href="#创业想法" class="headerlink" title="创业想法"></a>创业想法</h1><p>因此萌生出一种想法，目前还没有关注这一块，家里大部分的时候也有盆栽或者绿植，都是从花店里直接购买的，那么如果利用这种技术去实现互利网AI种植，是不是一种创新的创业思维呢？</p>
<p>目前花店主要有以下几种痛点：</p>
<ul>
<li>购买盆栽后，没有完整的种植经验，很快就死了</li>
<li>无法知道自己需要什么的盆栽</li>
</ul>
<p>商业模式：</p>
<ul>
<li>分尺寸，如：小盆栽适合办公位，中大型的适合放在家庭做墙壁或者隔墙板，超大型就是AI农业大棚型</li>
<li>商场里租一个大店铺，除了宣传，还可以将一些位置租给某些用户，给他们去做亲子活动</li>
</ul>
<p>后续可以尝试继续研究，留此文做一个念想。</p>
<h1 id="已经实施的项目"><a href="#已经实施的项目" class="headerlink" title="已经实施的项目"></a>已经实施的项目</h1><ul>
<li><a href="https://www.squarerootsgrow.com/about" target="_blank" rel="noopener">马斯克弟弟 火星种菜项目 SquareRoot</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>奇思妙想</tag>
      </tags>
  </entry>
  <entry>
    <title>Next、Nuxt、Nest的区别(翻译)</title>
    <url>/translate/nuxt-next-nest-diff.html</url>
    <content><![CDATA[<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>翻译文章</tag>
      </tags>
  </entry>
  <entry>
    <title>有了GPT-3，再也不用手写commit message(翻译)</title>
    <url>/translate/use-gpt3-auto-git-commit.html</url>
    <content><![CDATA[<blockquote>
<p>本文翻译的目的，主要想了解GPT3是什么，以及目前大家使用GPT3用来做什么，以及如何开发GPT3。</p>
</blockquote>
<h1 id="GPT-3"><a href="#GPT-3" class="headerlink" title="GPT-3"></a>GPT-3</h1><p>GPT-3是一个很多人或公司正在使用的协助开发的工具，比如：编写脚本、命令行等操作。</p>
<blockquote>
<p>GPT-3指的是生成型预训练变换模型3（英语：Generative Pre-trained Transformer 3，简称GPT-3）是一个自回归语言模型，目的是为了使用深度学习生成人类可以理解的自然语言[1]。GPT-3是由在旧金山的人工智能公司OpenAI训练与开发，模型设计基于谷歌开发的变换语言模型。GPT-3的神经网路包含1750亿个参数，为有史以来参数最多的神经网路模型[2]。OpenAI于2020年5月发表GPT-3的论文，在次月为少量公司与开发人团释出应用程式介面的测试版。微软在2020年9月22日宣布取得了GPT-3的独家授权。 —— <a href="https://zh.wikipedia.org/zh/GPT-3" target="_blank" rel="noopener">维基百科 GPT-3</a></p>
</blockquote>
<p>使用<code>gitcommit</code>,你将不需要花费时间去写git commit。 下面就让学习如何安装 <code>gptcommit</code>，以及享受一下GPT-3帮你写git commit。</p>
<a id="more"></a>

<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>首先，我们先了解一下 git commit， git commit提交信息，是程序员与程序员之间交流他们开发代码的重要信息，特别在code review中。<br>尤其当代码发生重大变化或者写的代码极为复杂，我们需要一一详细描述代码块功能，非常的耗时而且无聊。<br>平时开发代码后，由于一不小心容易写<code>fix: bug</code>之类的提交记录，很想修改后，但是又没有什么好的办法。<br>同时复杂的这些随意的话术对code review也很难理解这段代码的真正含义是什么。<br>更糟糕的是，如果提交记录是<code>fix: 修复文案错误</code>等，会让code review更加毫无意义，甚至忽略掉需要code review的地方。<br>所以问题是写 git commit很费时，而且描述不准确又容易造成不必要误会，那么使用<code>gptcommit</code>会让你摆脱这些烦恼。</p>
<h1 id="安装教程-几分钟"><a href="#安装教程-几分钟" class="headerlink" title="安装教程(几分钟)"></a>安装教程(几分钟)</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>在安装<code>gptcommit</code>之前，你需要先准备以下几个环境：</p>
<ul>
<li><a href="https://rustup.rs/" target="_blank" rel="noopener">Cargo</a>, <code>Rust</code>语言的包管理器</li>
<li><a href="https://platform.openai.com/account/api-keys" target="_blank" rel="noopener">OpenAI API Keys</a>, OpenAI的密钥</li>
</ul>
<p><strong>安装Rust</strong></p>
<p>Linux或Mac安装命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh</span><br></pre></td></tr></table></figure>

<p><strong>OpenAI API Keys获取方式</strong></p>
<p>国内没法正常访问，以下两种方式：</p>
<ul>
<li>这里去淘宝买一个API key</li>
<li>或者翻墙出去购买一个</li>
</ul>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol>
<li><p>使用<code>cargo</code>安装<code>gptcommit</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cargo install --locked gptcommit</span><br></pre></td></tr></table></figure>
</li>
<li><p>在本地某个仓库里安装执行一下命令，主要是初始化<code>gptcommit</code> git hook。这里需要你对这些仓库有git push的权限。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gptcommit install</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置全局变量<code>OPENAI_API_KEY</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export OPENAI_API_KEY="sk-..."</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>也可以直接将变量设置到全局文件中，如<code>~/.bashrc</code>, <code>~/.zshrc</code></p>
<h2 id="demo实战"><a href="#demo实战" class="headerlink" title="demo实战"></a>demo实战</h2><p>如果使用了后，会生成如下git commit:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Demo #1: the full installation and commit workflow, editing multiple rust files</span><br><span class="line">Demo #2: a one-line change to a string inside a rust file.</span><br><span class="line">Demo #3: Modifying non-code files, in this case a README.</span><br></pre></td></tr></table></figure>

<h2 id="参考对象"><a href="#参考对象" class="headerlink" title="参考对象"></a>参考对象</h2><p><code>gptcommit</code>参考之前的很受欢迎的commit 工具：</p>
<ul>
<li><a href="https://github.com/RomanHotsiy/commitgpt" target="_blank" rel="noopener">https://github.com/RomanHotsiy/commitgpt</a></li>
</ul>
<p><code>commitgpt</code>目前已无法使用，因为它使用第三方的OpenAI API Key，由于官方OpenAI访问次数受限，必须要求每个用户都用自己的API key。</p>
<p><code>gptcommit</code>集成了 git hook，可以直接用来git flow工作流的最后一步，同时，由于使用Rust，它执行速度会更快。</p>
<p>同时还参考<a href="https://github.com/KanHarI/gpt-commit-summarizer" target="_blank" rel="noopener">gpt-commit-summarizer</a>工具，它是直接作用在github Action持续集成中，而不是git 工作流。<br>总结commit记录是发生在PR阶段，而不是每次 commit。<br>该操作会直接将PR操作的commit进行汇总，然后直接提交，不需要再code review。</p>
<p><code>gptcommit</code>参考<code>gpt-commit-summarizer</code>的设计点，但是主要针对是git commit的提交信息进行总结。</p>
<h2 id="背后原理"><a href="#背后原理" class="headerlink" title="背后原理"></a>背后原理</h2><p>git commit提交劫持主要分为两个部分：</p>
<p>首先，会将每个文件单独汇总，然后到OpenAI去生成commit 信息记录。</p>
<p>其次，汇总所有文件修改内容，也有两个要点，分别是：</p>
<ul>
<li>告诉AI生成一个修改的标题</li>
<li>同时要生成修改的一些要点内容</li>
</ul>
<p>最终输出的提交记录如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[title]</span><br><span class="line"></span><br><span class="line">- [summary point 1]</span><br><span class="line">- [summary point 2...]</span><br><span class="line"></span><br><span class="line">[/changed/file A]</span><br><span class="line">- [file summary point 1]</span><br><span class="line">- [file summary point 2...]</span><br><span class="line">[/changed/file B...]</span><br><span class="line">- [file summary point 1...]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h2><p>接下来就在项目中实战吧。<br>执行命令<code>cargo install --locked gptcommit</code>安装或到<a href="https://github.com/zurawiki/gptcommit" target="_blank" rel="noopener">github 仓库</a>中去查看更多信息。<br>当然，你需要先在OpenAI里注册一个账号，同时拥有一个API key才能正在使用起来。</p>
<p>Github地址： <a href="https://github.com/zurawiki/gptcommit" target="_blank" rel="noopener">https://github.com/zurawiki/gptcommit</a></p>
<h1 id="下一步计划"><a href="#下一步计划" class="headerlink" title="下一步计划"></a>下一步计划</h1><p>后面也打算做一下更加有趣的功能：</p>
<ul>
<li>如何利用GPT-3去实现更加自动化 git flow工作流？</li>
<li>如何跳过哪些大的总结?</li>
<li>如何收集用户反馈，将commit信息更加有效？</li>
</ul>
<p>最后，如果在使用过程有任何问题或者建议，请到Github开源地址写一个issue给我，我会很快处理。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>原文地址：<a href="https://zura.wiki/post/never-write-a-commit-message-again-with-the-help-of-gpt-3/" target="_blank" rel="noopener">Never write a commit message again (with the help of GPT-3)</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>翻译文章</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux如何快速删除大量文件</title>
    <url>/today/20230213.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近服务器经常遇到磁盘占用空间满的告警，因此跟进定位问题后，发现原来是airflow的有好几个任务每分钟都在产生日志文件，导致磁盘空间占用率暴涨，因此想了几个策略：</p>
<ul>
<li>airflow降低日志文件输出大小，将原来<code>info</code>级别日志跳高到<code>warning</code></li>
<li>定时清理日志文件</li>
</ul>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>问题就出现在清理日志文件，打算先清除一遍，主要清除一个月以前的日志文件，命令为<code>find /data/airflow/ -name &#39;*.log&#39; -and -mtime +30 -type f |xargs rm</code>。</p>
<p>但是等了半天发现日志文件一直无法清除掉，不知道为什么？</p>
<a id="more"></a>

<p>后面直接上机器删除文件，采用<code>rm -rf ./*.log</code>，发现报错如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin/rm: argument list too long</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因：  删除文件中包含的小文件数量过多，通常是由于受到 shell 参数个数限制所致</p>
</blockquote>
<p>虽然网上有其他方案可以快速解决，比如：<code>find</code>减少文件数量。</p>
<p>这下子就搞的很郁闷了，后面上网找了方案，发现可以通过<code>rsync</code>去快速删除大量文件，因此想记录总结一下。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="Linux文件存储原理"><a href="#Linux文件存储原理" class="headerlink" title="Linux文件存储原理"></a>Linux文件存储原理</h2><p>我们需要对Linux文件存储原理做一个基本的了解，Linux文件存储数据是放在一张<code>inode 表</code>，里面每一个文件的节点，每个节点包括以下内容：</p>
<ul>
<li>文件类型</li>
<li>权限</li>
<li>UID，GID</li>
<li><code>i_nlink</code> 链接数（指向这个文件名路径名称个数）</li>
<li><code>i_count</code> 使用数（指使用这个文件的进程数）</li>
<li>该文件的大小和不同的时间戳</li>
<li>指向磁盘上文件的数据块指针</li>
<li>有关文件的其他数据</li>
</ul>
<p>Linux文件真正删除的过程：</p>
<ul>
<li><code>i_nlink=0</code> 没有人进行链接使用，包括任何硬链接</li>
<li><code>i_count=0</code> 没有任何进程使用</li>
</ul>
<h2 id="rm原理"><a href="#rm原理" class="headerlink" title="rm原理"></a>rm原理</h2><p>rm的原理：减少磁盘引用计数<code>i_nlink</code>，就是减少其他文件对这个文件链接，实际并没有删除文件内容。</p>
<p>因此，如果日志文件正在其他进程使用，<code>rm</code>并不是真正删除，<code>i_count</code>并不会减少，因此也不会释放磁盘空间。</p>
<p>如果想要真正删除一个文件，还需要同时将<code>i_count</code>降至0。</p>
<p>了解完rm的原理，也就真正明白为什么<code>find /opt/airflow/logs -name &#39;*.*&#39; -and -mtime +30 -type f | xargs rm -rvf</code>命令会这么慢，因为它要去找日志文件的所有link链接，然后一一删除掉。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>最终在网上找了最佳解决方案，就是使用<code>rsync</code>。</p>
<p><code>rsync</code>本身的就是将两个文件夹作同步使用，如何使用<code>rsync</code>删除文件，步骤是这样子:</p>
<ul>
<li>如果将一个空文件夹，同步到要删除的文件夹里，是不是等于将文件夹清空了呢？</li>
</ul>
<p>很取巧的方式，但是也很有效果，具体命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>制造一个空文件夹</span><br><span class="line">mkdir -p /opt/airflow/empty;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>执行rsync同步空文件夹</span><br><span class="line">rsync --delete-before -aO  /opt/airflow/empty/ /opt/airflow/logs/;</span><br></pre></td></tr></table></figure>

<p>命令详解：</p>
<ul>
<li><code>--delete-before</code> 接收者在传输之前进行删除操作</li>
<li><code>-a</code> 归档模式，表示以递归方式传输文件，并保持所有文件属性</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://cloud.tencent.com/developer/article/1647290" target="_blank" rel="noopener">Linux 下删除大量文件效率对比，看谁删的快！</a></li>
<li><a href="https://www.cnblogs.com/cherishry/p/5886069.html" target="_blank" rel="noopener">Linux下文件删除的原理</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>低代码系列——组件描述DSL</title>
    <url>/lowcode/component.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前写了一篇<a href="/lowcode/sandbox.html">《低代码系列——js沙箱设计》</a>，于是萌生了干脆将完整的低代码平台设计的整个过程都整理一遍，然后输出文章，同时准备搞个人开源项目用来实现低代码平台。</p>
<p>低代码平台核心部分是编辑器，编辑器里最重要一块如何将组件抽象化，存储到一个可描述的对象中。</p>
<p>下面我们就针对这种组件抽象描述做一次深入的设计。</p>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://json-schema.apifox.cn/" target="_blank" rel="noopener">JSON Schema 规范</a><br><a href="https://jsoncrack.com/" target="_blank" rel="noopener">JSON 可视化</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>低代码</tag>
      </tags>
  </entry>
  <entry>
    <title>从Copilot学到了什么</title>
    <url>/today/20230221.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://lowin.li/2022/06/27/pan-dian-kai-yuan-copilot/" target="_blank" rel="noopener">盘点开源“Copilot”，do it yourself</a><br><a href="https://blog.csdn.net/gel1234/article/details/127050405" target="_blank" rel="noopener">如何搭建免费的GitHub Copilot？</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>如何实现HTTP2.0</title>
    <url>/today/20230222.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://lowin.li/2022/06/27/pan-dian-kai-yuan-copilot/" target="_blank" rel="noopener">盘点开源“Copilot”，do it yourself</a><br><a href="https://blog.csdn.net/gel1234/article/details/127050405" target="_blank" rel="noopener">如何搭建免费的GitHub Copilot？</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>不要再使用轮询了，请用SSE服务端推送完成页面实时查询</title>
    <url>/today/20230223.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://mp.weixin.qq.com/s/K8g2PNO4Ixc1LrUafXunPQ" target="_blank" rel="noopener">数据不够实时：试试长连接？</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>性能优化我们到底能做些什么东西</title>
    <url>/today/20230224.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://mp.weixin.qq.com/s/ZfIWKRbF3Yq7sNFG2TsQFw" target="_blank" rel="noopener">性能优化经验分享</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>前端安全-JS原型链污染是怎么回事</title>
    <url>/today/20230209.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>面试题经常会提到一个问题，就是前端安全问题哪些，我们基本上都回答上来以下几个：</p>
<ul>
<li>XSS脚本攻击，利用网站漏洞，注入非法脚本</li>
<li>CSRF跨站请求伪造，攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求</li>
<li>运营商劫持，一般是经过某些运营商DNS网关后，在外层套入iframe，然后实现页面劫持</li>
</ul>
<p>但是在前端安全中，还有一个问题就是 ：<code>JS原型链污染</code>， 那么是原型链污染怎么回事，请看下面详细介绍。</p>
<blockquote>
<p>这里插入一条新闻，新出一个很邪恶的js库叫<a href="https://github.com/wll8/lodash-utils" target="_blank" rel="noopener">Evil.js</a>，名字还取得很lodash，其中主要就是利用原型prototype进行重写项目中常用的方法，如：</p>
<ul>
<li>Array.map 有5%概率会丢失最后一个元素，</li>
<li>当数组长度可以被7整除时，Array.includes 永远返回false。</li>
</ul>
</blockquote>
<p>所以学会如何防御项目内被攻击，了解更多JS原型安全知识很重要，起码周末不用调试半天问题，才发现项目中代码被恶意写入。</p>
<a id="more"></a>

<p>在看这篇文章，请确保自己对JS原型和原型链有一定了解，如果忘记或缺乏了解的话，可以看我之前的文案<a href="today/20220129.html#原型">从null、undefined、NaN的区别了解JS的原型链</a>再次复习和学习一下。</p>
<h1 id="原型链污染"><a href="#原型链污染" class="headerlink" title="原型链污染"></a>原型链污染</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>下面通过一段代码，我们能够快速了解原型链是如何污染的？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">    bar: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果这里将foo.__proto__改掉</span></span><br><span class="line"></span><br><span class="line">foo.__proto__.bar = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.bar); <span class="comment">// 这里正常输出 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新声明一个</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> zoo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(zoo.bar); <span class="comment">// 这里错误输出 2</span></span><br></pre></td></tr></table></figure>

<p>从上述代码可以概括一下，原型链攻击是：</p>
<blockquote>
<p>在一个应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是原型链污染。</p>
</blockquote>
<h2 id="攻击场景"><a href="#攻击场景" class="headerlink" title="攻击场景"></a>攻击场景</h2><p>其实我们主要看哪些场景会允许代码设置<code>__proto__</code>？主要有以下两种：</p>
<ul>
<li>对象merge</li>
<li>对象clone</li>
<li>Node.js的construtor</li>
</ul>
<h3 id="merge-demo案例"><a href="#merge-demo案例" class="headerlink" title="merge demo案例"></a>merge demo案例</h3><p>一般实现对象的merge代码实现如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key <span class="keyword">in</span> source &amp;&amp; key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            merge(target[key], source[key])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target[key] = source[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行代码</span></span><br><span class="line"><span class="keyword">let</span> o1 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> o2 = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="string">"__proto__"</span>: &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;&#125;</span><br><span class="line">merge(o1, o2)</span><br><span class="line"><span class="built_in">console</span>.log(o1.a, o1.b)</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(o3.b) <span class="comment">// 发现原型链没有被污染</span></span><br></pre></td></tr></table></figure>

<p>这是为什么呢？因为声明变量的时候，”<strong>_proto</strong>“并不是一个key，即使修改也不会改变Object的原型。</p>
<p>那么如何做到”<strong>_proto</strong>“成为一个key，可以将demo代码调整一下，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> o2 = <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"a": 1, "__proto__": &#123;"b": 2&#125;&#125;'</span>)</span><br><span class="line">merge(o1, o2)</span><br><span class="line"><span class="built_in">console</span>.log(o1.a, o1.b)</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(o3.b) <span class="comment">// 输出2</span></span><br></pre></td></tr></table></figure>

<p>merge操作是最常见可能控制键名的操作，也最能被原型链攻击，很多常见的库都存在这个问题。如： <code>lodash.merge</code>。</p>
<h2 id="实际应用问题"><a href="#实际应用问题" class="headerlink" title="实际应用问题"></a>实际应用问题</h2><blockquote>
<p>Code-Breaking 2018 Thejs 分析</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> lodash = <span class="built_in">require</span>(<span class="string">'lodash'</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">app.engine(<span class="string">'ejs'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">filePath, options, callback</span>) </span>&#123; </span><br><span class="line"><span class="comment">// define the template engine</span></span><br><span class="line">    fs.readFile(filePath, (err, content) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(err))</span><br><span class="line">        <span class="keyword">let</span> compiled = lodash.template(content)</span><br><span class="line">        <span class="keyword">let</span> rendered = compiled(&#123;...options&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> callback(<span class="literal">null</span>, rendered)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">app.all(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> data = req.session.data || &#123;<span class="attr">language</span>: [], <span class="attr">category</span>: []&#125;</span><br><span class="line">    <span class="keyword">if</span> (req.method == <span class="string">'POST'</span>) &#123;</span><br><span class="line">        data = lodash.merge(data, req.body)</span><br><span class="line">        req.session.data = data</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res.render(<span class="string">'index'</span>, &#123;</span><br><span class="line">        language: data.language, </span><br><span class="line">        category: data.category</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>题目是利用<code>lodash.template</code> + <code>lodash.merge</code>两个方法实现部分功能：</p>
<ul>
<li>用户提交的信息，用merge方法合并到session里，session里最终保存你提交的所有信息</li>
<li>然后利用merge方法注入原型污染</li>
<li>最后利用template中的方法，完成整个网站污染</li>
</ul>
<p>整个案例其实比较重要的一点就是，提交参数的时候序列化提交参数是否有做防御，如何没有的话那么很容易就中招了。</p>
<h2 id="如何防御"><a href="#如何防御" class="headerlink" title="如何防御"></a>如何防御</h2><p>分不同情况做防御：</p>
<h3 id="引入npm包导致的"><a href="#引入npm包导致的" class="headerlink" title="引入npm包导致的"></a>引入npm包导致的</h3><ul>
<li>项目代码扫描，主要是针对构建好的代码进行扫描，是否<code>Evil.js</code>修改内置原型的情况进行告警提示</li>
<li>禁止修改原型，如：使用<code>Object.freeze</code></li>
</ul>
<h3 id="针对node-js"><a href="#针对node-js" class="headerlink" title="针对node.js"></a>针对node.js</h3><ul>
<li>针对node服务端接口参数进行序列化的时候，禁止非法<code>key</code>值传入</li>
<li>禁止修改原型，如：使用<code>Object.freeze</code></li>
<li>采用<code>Object.create(null)</code>创建对象，避免直接使用<code>{}</code></li>
<li>使用<code>map</code>数据类型创建</li>
<li>不对参数做<code>JSON.parse</code>转换，采用封装后的反序列化方法</li>
<li>尽量采用安全的<code>merge</code>或<code>clone</code>库方法</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html" target="_blank" rel="noopener">深入理解 JavaScript Prototype 污染攻击</a></li>
<li><a href="https://xz.aliyun.com/t/7025" target="_blank" rel="noopener">再探 JavaScript 原型链污染到 RCE</a></li>
<li><a href="https://www.freebuf.com/articles/web/216373.html" target="_blank" rel="noopener">Javascript原型链攻击与防御</a></li>
</ul>
]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>css变量了解到项目落地</title>
    <url>/today/20230208.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在打开一些网站的，查看其CSS样式的时候，发现如下图：</p>
<p><img src="/assets/img/20230208-1.png" alt></p>
<p>所以就很好奇，原来现在CSS样式变量已经可以正式投入生产使用了，所以希望能够做个简单了解。</p>
<p>浏览器的兼容性：<br><img src="/assets/img/20230208-2.png" alt></p>
<a id="more"></a>

<h1 id="CSS变量var"><a href="#CSS变量var" class="headerlink" title="CSS变量var()"></a>CSS变量var()</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><blockquote>
<p>自定义属性（有时候也被称作CSS 变量或者级联变量）是由 CSS 作者定义的，它包含的值可以在整个文档中重复使用。由自定义属性标记设定值（比如： –main-color: black;），由 var() 函数来获取值（比如： color: var(–main-color);）</p>
</blockquote>
<p>通俗的说，就是CSS以后不需要用<code>less</code>或<code>css</code>也能正常使用变量去定义一些常用值。</p>
<h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><ol>
<li><p>声明以及对应作用域</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 可以HTML 文档的任何地方访问到它 */</span></span><br><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attribute">--main-bg-color</span>: brown;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-pseudo">:where(html)</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 只能在element元素下面所对应使用 */</span></span><br><span class="line"><span class="selector-tag">element</span> &#123;</span><br><span class="line">  <span class="attribute">--main-bg-color</span>: brown;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>引用变量</p>
</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">element</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">var</span>(--main-bg-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>自带继承</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.one</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="comment">/** 无法使用 var(--test) */</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.two</span> &#123;</span></span><br><span class="line">  --test: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-class">.three</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="comment">/** 重写 var(--test) = 2em */</span></span></span><br><span class="line">  --test: 2em;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="css"><span class="selector-class">.four</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="comment">/** 继承.two的变量 var(--test) = 10px */</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"one"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"two"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"three"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"four"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>自定义属性备用值</li>
</ol>
<p><code>var(--my-var, xxx)</code>，当一个变量未定义或非法值的时候，可以<code>red</code>用来做正常显示值，备用值并不是用于实现浏览器兼容性的。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.two</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--my-var, red); <span class="comment">/* 入股my-var 没有定义，则用red显示 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>JS获取变量值</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/设置变量</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'p'</span>).style.setProperty(<span class="string">'--weight'</span>,<span class="string">'bold'</span>);</span><br><span class="line"><span class="comment">//读取变量</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'p'</span>).style.getPropertyValue(<span class="string">'--weight'</span>);</span><br><span class="line"><span class="comment">//删除变量</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'p'</span>).style.removeProperty(<span class="string">'--weight'</span>);</span><br></pre></td></tr></table></figure>

<h1 id="CSS变量实战"><a href="#CSS变量实战" class="headerlink" title="CSS变量实战"></a>CSS变量实战</h1><p>在前端项目中如何使用CSS变量，一般是通过构建工具生成的兼容性代码。</p>
<h2 id="浏览器是否支持"><a href="#浏览器是否支持" class="headerlink" title="浏览器是否支持"></a>浏览器是否支持</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isSupported = <span class="built_in">window</span>.CSS &amp;&amp; <span class="built_in">window</span>.CSS.supports &amp;&amp; <span class="built_in">window</span>.CSS.supports(<span class="string">'--a'</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(isSupported) &#123;</span><br><span class="line">    <span class="comment">/* 这里面是支持css变量的操作 */</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 这里面是不支持css变量的操作 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以通过CSS中<code>@supports</code>做判断：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">supports</span> ( (--a: <span class="number">0</span>)) &#123;</span><br><span class="line">  <span class="comment">/* supported */</span></span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">supports</span> ( not (--a: <span class="number">0</span>)) &#123;</span><br><span class="line">  <span class="comment">/* not supported */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>最常用的是网站换主题，在开发过程直接按照CSS变量去编写，而不需要去了解SASS或LESS的语法</li>
<li>原本一些动画效果，需要多个css样式区分，现在可以通过css变量实现，从而减少代码</li>
<li>结合JS操作事件+更改CSS变量，实现更多CSS效果</li>
</ul>
<h2 id="变量库"><a href="#变量库" class="headerlink" title="变量库"></a>变量库</h2><p><a href="https://open-props.style/" target="_blank" rel="noopener">open-props CSS常用变量收集库</a></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">"https://unpkg.com/open-props"</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="built_in">var</span>(--radius-2);</span><br><span class="line">  <span class="attribute">padding</span>: <span class="built_in">var</span>(--size-fluid-3);</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="built_in">var</span>(--shadow-2);</span><br><span class="line"></span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    <span class="selector-tag">box-shadow</span>: <span class="selector-tag">var</span>(<span class="selector-tag">--shadow-3</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @<span class="keyword">media</span> (--motionOK) &#123;</span><br><span class="line">    <span class="selector-tag">animation</span>: <span class="selector-tag">var</span>(<span class="selector-tag">--animation-fade-in</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_custom_properties" target="_blank" rel="noopener">CSS自定义变量 MDN</a></p>
]]></content>
      <tags>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>低代码系列——js沙箱设计</title>
    <url>/lowcode/sandbox.html</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>由于自己参与过低代码平台开发，所以希望能把我自己开发低代码中遇到的问题或者一些设计思路进行总结汇总，这是开始写的第一篇，也是比较基础的一篇，关于低代码平台的介绍会放在介绍篇章，这篇就不做过多介绍。</p>
<p>这里为什么会一开始介绍js沙箱设计呢？</p>
<p>因为低代码平台，会运行用户本身自己编写的业务逻辑代码，这里就需要平台去运行用户写的js代码，但是js代码保存到数据库是一个字符串，那么平台应该怎么运行呢？</p>
<p>答案是js沙箱，那么如何设计一个沙箱呢？按照低代码平台的需要特性，主要以下几方面：</p>
<ul>
<li>隔离，隔离是为了保证当前执行代码不影响整个平台的代码</li>
<li>插入，沙箱允许插入平台的内置对象</li>
<li>容错，沙箱内代码即使有错误，也不影响整个平台执行</li>
</ul>
<a id="more"></a>
<h1 id="沙箱"><a href="#沙箱" class="headerlink" title="沙箱"></a>沙箱</h1><p>在设计沙箱之前，我们先对沙箱有个了解：</p>
<blockquote>
<p>在计算机安全中，沙箱（Sandbox）是一种用于隔离正在运行程序的安全机制，通常用于执行未经测试或不受信任的程序或代码，它会为待执行的程序创建一个独立的执行环境，内部程序的执行不会影响到外部程序的运行。</p>
</blockquote>
<p>通俗的讲，就是由我们主程序自己设定一个区域，用来执行代码，且这段代码如何执行都不会影响到外部的主程序。</p>
<p>举几个我们开发中经常会用的沙箱：</p>
<ul>
<li>Vue template里的表达式，如: <code>&lt;div&gt;2&lt;/div&gt;</code>，执行<code>1+1</code>就是Vue设计的一个沙箱机制</li>
<li>开发Chrome插件，插件里的代码有很多限制条件，循序Chrome插件规则，那么插件的运行环境和规则也是一个沙箱</li>
<li>在线代码编辑器， CodeSanbox在执行脚本也会单独成立一个沙箱去隔离执行代码，防止代码访问或影响主页面</li>
<li>微前端<code>qiangun</code>或<code>single-spa</code>框架里主应用和子应用之间的完全隔离，也是一种沙箱机制，如: 应用之间CSS样式不能互相影响</li>
</ul>
<p>在了解完沙箱是什么后，那么在JavaScript语言里如何实现沙箱呢？主要有以下几种方式：</p>
<ul>
<li>使用 with 声明</li>
<li>使用 new Function 声明</li>
<li>基于 Proxy实现</li>
<li>基于属性 diff实现</li>
<li>基于 iframe实现</li>
<li>基于 ES 提案 ShadowRealm API</li>
</ul>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="with关键字"><a href="#with关键字" class="headerlink" title="with关键字"></a>with关键字</h2><blockquote>
<p>with 扩展一个语句的作用域链。 —— <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/with" target="_blank" rel="noopener">MDN with</a><br>JavaScript 查找某个未使用命名空间的变量时，会通过作用域链来查找，作用域链是跟执行代码的 context 或者包含这个变量的函数有关。’with’语句将某个对象添加到作用域链的顶部，如果在 statement 中有某个未使用命名空间的变量，跟作用域链中的某个属性同名，则这个变量将指向这个属性值。如果沒有同名的属性，则将拋出ReferenceError异常。</p>
</blockquote>
<p>按照个人比较容易理解的意思，就是给一段代码加上指定对象为该作用的全局变量。示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="number">1.1</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用with</span></span><br><span class="line"><span class="keyword">with</span>(<span class="built_in">Math</span>)&#123;</span><br><span class="line">    floor(<span class="number">1.1</span>) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="new-Function"><a href="#new-Function" class="headerlink" title="new Function"></a>new Function</h2><p><code>new Function(argStr, codeStr)</code>是能将字符串代码转换为可执行的函数。具体示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'test'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'arg'</span>, <span class="string">'console.log(arg)'</span>);</span><br><span class="line"><span class="comment">// 这里等于 test = (arg)=&gt; &#123;console.log(arg)&#125;;</span></span><br><span class="line"></span><br><span class="line">test(name); <span class="comment">// test</span></span><br></pre></td></tr></table></figure>

<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><blockquote>
<p>Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">Proxy MDN</a></p>
</blockquote>
<p>Proxy只能代理<code>object</code>类型的变量，针对基础类型的代理只能将其封装到对象里再进行代理监听。</p>
<p>Proxy代理方法如下：</p>
<ul>
<li><code>getPrototypeOf(target)</code> 代理获取原型的方法</li>
<li><code>setPrototypeOf(target, newProto)</code> 设置原型，如果不想设置原型，可以<code>return false</code></li>
<li><code>isExtensible(target)</code>  拦截对对象的 <code>Object.isExtensible()</code>，必须返回一个 Boolean 值，判断一个对象是否是可扩展的</li>
<li><code>preventExtensions(target)</code> 拦截<code>Object.preventExtensions()</code>，让一个对象变的不可扩展，也就是永远不能再添加新的属性</li>
<li><code>getOwnPropertyDescriptor(target, prop)</code> 拦截<code>Object.getOwnPropertyDescriptor()</code>，拦截获取对象属性的描述符</li>
<li><code>defineProperty(target, property, descriptor)</code> 拦截<code>Object.defineProperty()</code></li>
<li><code>has(target, key)</code>，针对 in 操作符的代理方法</li>
<li><code>get(target, property, receiver)</code>，用于拦截对象的读取属性操作</li>
<li><code>set()</code>，设置属性值操作的捕获器。</li>
<li><code>construct()</code>，用于拦截 new 操作符</li>
</ul>
<p>与<code>Object.defineProperty</code>主要区别(可拦截方法比<code>Object.defineProperty</code>多)：</p>
<ul>
<li>Proxy代理的是整个对象，Object.defineProperty只代理对象上的某个属性,如果是多层嵌套的数据需要循环递归绑定;</li>
<li>对象上定义新属性时，Proxy可以监听到，Object.defineProperty监听不到，需要借助$set方法;</li>
<li>数组的某些方法(push、unshift和splice)Object.defineProperty监听不到，Proxy可以监听到;</li>
</ul>
<h2 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a>Symbol.unscopables</h2><blockquote>
<p>指用于指定对象值，其对象自身和继承的从关联对象的 with 环境绑定中排除的属性名称。</p>
</blockquote>
<p>可以这么理解，就是为了防止<code>with</code>添加作用域的时候，将某个属性从作用域中排除掉，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = &#123;</span><br><span class="line">    p: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 禁止将a.p放到with作用域中</span></span><br><span class="line">a[<span class="built_in">Symbol</span>.unscopables] = &#123;<span class="attr">p</span>: <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span>(a)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p) <span class="comment">// 报错 p not defined</span></span><br><span class="line">    <span class="built_in">console</span>.log(b) <span class="comment">// 正常输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此很多内置对象都设置该值为true，从而降低with的侵入，具体如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.unscopables];</span><br><span class="line"><span class="comment">/*&#123;</span></span><br><span class="line"><span class="comment">  copyWithin: true,</span></span><br><span class="line"><span class="comment">  entries: true,</span></span><br><span class="line"><span class="comment">  fill: true,</span></span><br><span class="line"><span class="comment">  find: true,</span></span><br><span class="line"><span class="comment">  findIndex: true,</span></span><br><span class="line"><span class="comment">  flat: true,</span></span><br><span class="line"><span class="comment">  flatMap: true,</span></span><br><span class="line"><span class="comment">  includes: true,</span></span><br><span class="line"><span class="comment">  keys: true,</span></span><br><span class="line"><span class="comment">  values: true,</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure>

<h1 id="沙箱实现"><a href="#沙箱实现" class="headerlink" title="沙箱实现"></a>沙箱实现</h1><p>沙箱实现步骤一般如下：</p>
<ul>
<li>解析代码，动态执行</li>
<li>修改代码的作用域，避免进行向上全局查询</li>
<li>创建全局对象的替代对象，避免污染全局对象</li>
<li>执行代码</li>
</ul>
<h2 id="基于Proxy实现"><a href="#基于Proxy实现" class="headerlink" title="基于Proxy实现"></a>基于Proxy实现</h2><p>前面基础知识将到Proxy是一个可以代理对象的方法，那么其实可以按照将一些全局对象做代理后放入到沙箱里。主要有两个步骤：</p>
<ul>
<li>使用<code>new Function</code>将代码字符串转为可执行函数</li>
<li>加<code>with</code>生成局部作用域</li>
<li>使用<code>createFake</code>方法生成替代对象<code>fakeWindow</code></li>
<li>使用<code>Proxy</code>代理拦截<code>set</code> <code>get</code>操作，更新到<code>fakeWindow</code>中</li>
<li>当沙箱不用时，将<code>window</code>重置回</li>
</ul>
<p>简易沙箱示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; complieCode2Fn, createFakeWindow &#125; = <span class="built_in">require</span>(<span class="string">'./complieCode.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxySandbox</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(global) &#123;</span><br><span class="line">        <span class="keyword">const</span> rawGlobal = global;</span><br><span class="line">        <span class="keyword">const</span> fakeWindow = createFakeWindow(global);</span><br><span class="line">        <span class="keyword">this</span>.proxyBox = <span class="keyword">new</span> <span class="built_in">Proxy</span>(fakeWindow, &#123;</span><br><span class="line">            <span class="comment">// 拦截所有属性，防止到 Proxy 对象以外的作用域链查找。</span></span><br><span class="line">            has(target, key) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">get</span>(target, key, receiver) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'get'</span>, key, target[key])</span><br><span class="line">                <span class="comment">// 加固，防止逃逸</span></span><br><span class="line">                <span class="keyword">if</span> (key === <span class="built_in">Symbol</span>.unscopables) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 通过Reflect获取</span></span><br><span class="line">                <span class="keyword">let</span> temp = <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">                <span class="keyword">if</span>(!target.hasOwnProperty(key))&#123;</span><br><span class="line">                    temp = rawGlobal[key];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">set</span>(target, key, newValue) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!target.hasOwnProperty(key) &amp;&amp; fakeWindow.hasOwnProperty(key)) &#123;</span><br><span class="line">                    <span class="keyword">const</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(sandbox, key);</span><br><span class="line">                    <span class="keyword">const</span> &#123; writable, configurable, enumerable &#125; = descriptor;</span><br><span class="line">                    <span class="keyword">if</span> (writable) &#123;</span><br><span class="line">                        <span class="comment">// 中独有的属性如果可以写，同样需要复制到fakeWindow中</span></span><br><span class="line">                        <span class="built_in">Object</span>.defineProperty(target, p, &#123;</span><br><span class="line">                            configurable,</span><br><span class="line">                            enumerable,</span><br><span class="line">                            writable,</span><br><span class="line">                            newValue,</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    target[key] = newValue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    excute(code)&#123;</span><br><span class="line">        <span class="keyword">const</span> fn = complieCode2Fn(code);</span><br><span class="line">        <span class="keyword">return</span> fn(<span class="keyword">this</span>.proxyBox);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fakeBox = <span class="keyword">new</span> ProxySandbox(global);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`a = 1;console.log('a:', a);return a;`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fakeBox.excute(code));  <span class="comment">// 输出a:1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'在沙箱外获取沙箱内设置的全局值a:'</span>, a); <span class="comment">// a is not defined</span></span><br></pre></td></tr></table></figure>

<p>问题1： 如何防止<code>Array.isArray</code>重写后不影响顶部window？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">const code = `</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Array</span>.isArray = <span class="function"><span class="params">()</span>=&gt;</span> <span class="literal">true</span>;</span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="string">console.log(Array.isArray('a')); // 输出true 正常应该是false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>生成<code>fakeWindow</code>对象时候，遍历内置<code>Array</code>，通过<code>Object.freeze</code>冻结其修改的可能性</li>
</ul>
<p>问题2： 提前关闭 sandbox 的 with 语境，如 ‘} alert(this); {‘  或者使用 eval 和 new Function 直接逃逸，如何解决？</p>
<ul>
<li>解析code字符串，利用堆栈深度检测算法，将非法字符串 <code>{}</code>做简单计算 或者 <code>eval</code> 等关键字，然后报错处理</li>
</ul>
<p>问题3： 如何解决修改原型链方法实现逃逸，既可以获取沙箱外的对象？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> code = <span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    (&#123;&#125;).constructor.prototype.toString = () =&gt; &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        console.log('Escape')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="built_in">console</span>.log((&#123;&#125;).toString()) <span class="comment">// 输出Escape 正常应该输出[object Object]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这种只能在原型链上下功夫，将所有的原型链做一次封装，从而</li>
</ul>
<h2 id="基于iframe实现"><a href="#基于iframe实现" class="headerlink" title="基于iframe实现"></a>基于iframe实现</h2><p>利用<code>iframe</code>天然隔离机制，加上<code>postMessage</code>通讯机制，可以快速实现一个简易沙箱，具体步骤如下：</p>
<ul>
<li>创建一个iframe，获取其window作为替代对象</li>
<li>将function执行放到iframe里，不会影响其沙箱外程序使用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IframeSandbox</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// 创建一个 iframe 对象，取出其中的原生浏览器全局对象作为沙箱的全局对象</span></span><br><span class="line">        <span class="keyword">const</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>, &#123;<span class="attr">url</span>: <span class="string">'about:blank'</span>&#125;)</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(iframe)</span><br><span class="line">        <span class="keyword">this</span>.sandboxGlobal = iframe.contentWindow <span class="comment">// 沙箱运行时的全局对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    excute(code)&#123;</span><br><span class="line">        <span class="keyword">const</span> fn = <span class="keyword">new</span> <span class="keyword">this</span>.sandboxGlobal.Function(<span class="string">'sandbox'</span>, <span class="string">`with(sandbox)&#123;<span class="subst">$&#123;code&#125;</span>&#125;`</span>)</span><br><span class="line">        <span class="keyword">return</span> fn(<span class="keyword">this</span>.sandboxGlobal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fakeBox = <span class="keyword">new</span> IframeSandbox();</span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`a = 1;console.log(a)`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fakeBox.excute(code));  <span class="comment">// 输出a:1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'在沙箱外获取沙箱内设置的全局值a:'</span>, a); <span class="comment">// a is not defined</span></span><br></pre></td></tr></table></figure>

<p>问题1： 需要解决其调用<code>parent</code>进行逃逸获取？</p>
<ul>
<li>最佳方案是通过<code>Proxy</code>对iframe的window对象进行拦截代理即可</li>
</ul>
<h2 id="基于ShadowRealm-提案的实现"><a href="#基于ShadowRealm-提案的实现" class="headerlink" title="基于ShadowRealm 提案的实现"></a>基于ShadowRealm 提案的实现</h2><blockquote>
<p>ShadowRealm API 是一个新的 JavaScript 提案，它允许一个 JS 运行时创建多个高度隔离的 JS 运行环境（realm），每个 realm 具有独立的全局对象和内建对象。</p>
</blockquote>
<p>通俗的说，这是JavaScript自带的沙箱API，你可以利用它快速实现上面需要通过proxy或iframe才能实现的隔离机制。</p>
<p>ShadowRealm声明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">declare <span class="class"><span class="keyword">class</span> <span class="title">ShadowRealm</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>();</span><br><span class="line">  evaluate(sourceText: string): PrimitiveValueOrCallable;</span><br><span class="line">  importValue(specifier: string, bindingName: string): Promise&lt;PrimitiveValueOrCallable&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>evaluate(sourceText: string)</code> 同步执行代码字符串，类似 eval()</li>
<li><code>importValue(specifier: string, bindingName: string)</code> 异步执行代码字符串</li>
</ul>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sr = <span class="keyword">new</span> ShadowRealm();</span><br><span class="line">globalThis.test = <span class="string">'test'</span>;</span><br><span class="line">sr.evaluate(<span class="string">`globalThis.test = 'test ShadowRealm'; console.log(globalThis.test)`</span>) <span class="comment">// 输出 test ShadowRealm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个文件  my-module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> values.reduce(<span class="function">(<span class="params">prev, value</span>) =&gt;</span> prev + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">const</span> sr = <span class="keyword">new</span> ShadowRealm();</span><br><span class="line"><span class="keyword">const</span> wrappedSum = <span class="keyword">await</span> sr.importValue(<span class="string">'./my-module.js'</span>, <span class="string">'sum'</span>); <span class="comment">// 加载js模块，然后获取里面函数</span></span><br><span class="line"><span class="built_in">console</span>.log(wrappedSum(<span class="string">'hi'</span>, <span class="string">' '</span>, <span class="string">'folks'</span>, <span class="string">'!'</span>)); <span class="comment">// 输出 hi folks !</span></span><br></pre></td></tr></table></figure>

<p>其实再来实现一个沙箱就很简单了，因为ShadownRealm本身就是一个沙箱。</p>
<h2 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h2><h3 id="Web-Workers"><a href="#Web-Workers" class="headerlink" title="Web Workers"></a>Web Workers</h3><p><code>Web Workers</code>代码运行在独立的进程中，通信是异步的，无法获取当前程序一些属性或共享状态，且有一点无法不支持 DOM 操作，必须通过 postMessage 通知 UI 主线程来实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workerSandbox</span>(<span class="params">appCode</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([appCode]);</span><br><span class="line"> <span class="keyword">var</span> appWorker = <span class="keyword">new</span> Worker(<span class="built_in">window</span>.URL.createObjectURL(blob));</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">workerSandbox(<span class="string">'const a = 1;console.log(a);'</span>) <span class="comment">// 输出1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// a not defined</span></span><br></pre></td></tr></table></figure>

<h3 id="vm-模块"><a href="#vm-模块" class="headerlink" title="vm 模块"></a>vm 模块</h3><p>Node.js 上的 vm 模块，与 ShadowRealm API 类似，但具有更多功能：缓存 JavaScript 引擎、拦截 import() 等等。但它唯一的缺点就是不能跨平台，只能在 Node.js 环境下使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="built_in">require</span>(<span class="string">'vm'</span>);</span><br><span class="line"><span class="keyword">const</span> sandbox = &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line">vm.createContext(sandbox)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> whatIsThis = vm.runInContext(<span class="string">`</span></span><br><span class="line"><span class="string">    a = 2 ;</span></span><br><span class="line"><span class="string">`</span>, sandbox);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sandbox) <span class="comment">// 输出2</span></span><br></pre></td></tr></table></figure>

<h1 id="沙箱错误捕获"><a href="#沙箱错误捕获" class="headerlink" title="沙箱错误捕获"></a>沙箱错误捕获</h1><p>在完成沙箱主体后，还需要对沙箱内部错误进行捕获再次处理，从而不影响主体程序的执行。</p>
<p>这一块其实就在执行动态代码那里，做一层<code>try/catch</code>基本上可以完成的错误捕获。</p>
<h1 id="沙箱逃逸"><a href="#沙箱逃逸" class="headerlink" title="沙箱逃逸"></a>沙箱逃逸</h1><p>沙箱逃逸（Sandbox Escape），沙箱于作者而言是一种安全策略，但于使用者而言可能是一种束缚。脑洞大开的开发者们尝试用各种方式摆脱这种束缚，也称之为沙箱逃逸。</p>
<p>沙箱逃逸的几种方式：</p>
<ul>
<li>访问沙箱执行上下文中某个对象内部属性时，如：通过window.parent</li>
<li>通过访问原型链实现逃逸</li>
</ul>
<p>如何解决沙箱逃逸：</p>
<blockquote>
<p>自定义解释器，分析源程序结构从而手动控制每一条语句的执行逻辑，如：<code>Babel</code>等</p>
</blockquote>
<p>简单的说，就是用JS去实现JS解释器，将每行代码进行解析，然后增加一些安全机制，从而避免非法代码入侵。</p>
<p>后续会专门写个文章去实现一个简单的JS解释器，这里就不做多阐述。更新后会放在这里链接。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">MDN Proxy</a></li>
<li><a href="https://github.com/careyke/frontend_knowledge_structure/blob/master/microFrontend/question02_03_js_sandbox.md" target="_blank" rel="noopener">qiankun中JS沙箱的实现</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1482264" target="_blank" rel="noopener">CodeSandbox 如何工作</a></li>
<li><a href="https://juejin.cn/post/7089822133559230501" target="_blank" rel="noopener">Javascript 新特性前瞻 —— ShadowRealms</a></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
        <tag>低代码</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo网站提高SEO优化方法</title>
    <url>/today/20230131.html</url>
    <content><![CDATA[<h1 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h1><ul>
<li>添加站点地图 <code>sitemap.xml</code>文件和搜索机器人文件<code>robots.txt</code></li>
<li>提交站点到搜索引擎(百度和谷歌)</li>
<li>hexo针对搜索的优化</li>
</ul>
<h2 id="添加站点地图"><a href="#添加站点地图" class="headerlink" title="添加站点地图"></a>添加站点地图</h2><h3 id="添加站点地图-sitemap-xml"><a href="#添加站点地图-sitemap-xml" class="headerlink" title="添加站点地图 sitemap.xml"></a>添加站点地图 <code>sitemap.xml</code></h3><ol>
<li><p>添加hexo插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改<code>_config.yml</code>配置</p>
</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sitemap:</span> </span><br><span class="line"><span class="attr">  path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">baidusitemap.xml</span></span><br></pre></td></tr></table></figure>

<h3 id="搜索机器人文件robots-txt"><a href="#搜索机器人文件robots-txt" class="headerlink" title="搜索机器人文件robots.txt"></a>搜索机器人文件<code>robots.txt</code></h3><p>在source目录下新建<code>robots.txt</code>文件，文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /archives/</span><br><span class="line">Allow: /categories/</span><br><span class="line">Allow: /tags/ </span><br><span class="line">Allow: /resources/ </span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /fancybox/</span><br><span class="line"></span><br><span class="line">Sitemap: https://hoxis.github.io/sitemap.xml</span><br><span class="line">Sitemap: https://hoxis.github.io/baidusitemap.xml</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="提交站点"><a href="#提交站点" class="headerlink" title="提交站点"></a>提交站点</h2><ul>
<li><a href="https://search.google.com/search-console?utm_source=about-page&resource_id=https://qborfy.com/" target="_blank" rel="noopener">谷歌Search Console</a>  直接按照引导添加即可<code>sitemap.xml</code>文件</li>
<li><a href="https://ziyuan.baidu.com/linksubmit/url" target="_blank" rel="noopener">百度站长平台</a>  按照其引导提交站点即可，主要是<code>sitemap.xml</code>文件</li>
</ul>
<h2 id="hexo优化建议"><a href="#hexo优化建议" class="headerlink" title="hexo优化建议"></a>hexo优化建议</h2><ul>
<li>出站链接添加<code>nofollow</code>标签</li>
<li>添加关键字，主要在文章首部地方添加<code>keywords</code>和<code>description</code></li>
<li>修改博文链接，将hexo默认<code>domain/year/month/day/postname</code>改为<code>title</code></li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://hoxis.github.io/Hexo+Next%20SEO%E4%BC%98%E5%8C%96.html" target="_blank" rel="noopener">Hexo博客Next主题SEO优化方法</a></p>
]]></content>
      <tags>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题目收集(持续更新)</title>
    <url>/study/face-test.html</url>
    <content><![CDATA[<p>主要以下几方面去收集？</p>
<ul>
<li>八股文，主要针对理论基础知识</li>
<li>框架类，主要针对React/Vue等</li>
<li>编程题，主要针对各种常用方法进行手动编写</li>
<li>算法题，主要是各类算法题进行汇总</li>
</ul>
<a id="more"></a>

<h1 id="八股文"><a href="#八股文" class="headerlink" title="八股文"></a>八股文</h1><ul>
<li>dom树是怎么生成的</li>
<li>浏览器缓存</li>
<li>一个页面在浏览器加载经历哪些阶段</li>
<li>TCP三次握手 四次挥手为什么？</li>
<li>为什么跨域？跨域实现方案</li>
<li>浏览器渲染机制、重绘、重排</li>
<li>script标签defer和async的区别</li>
</ul>
<h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><ul>
<li>v8垃圾回收</li>
<li>JS上下文执行栈和闭包</li>
<li>JS的模块化</li>
<li>JS的类型检查，如何判断Array数组类型</li>
<li>JS原型、原型链</li>
<li>JS Event Loop</li>
<li>JS new 实现一个对象过程</li>
<li>JS forEach和map的区别，如何跳出循环</li>
<li>JS 数组有哪些方法会影响自身，哪些方法不会影响自身</li>
</ul>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><ul>
<li>CSS 样式优先级(#,.等选择器)</li>
<li>CSS BFC</li>
<li>CSS 垂直居中</li>
<li>CSS 层叠上下文和层叠顺序</li>
<li>flex布局</li>
<li>CSS 响应式布局</li>
</ul>
<h1 id="框架类"><a href="#框架类" class="headerlink" title="框架类"></a>框架类</h1><h1 id="通用问题"><a href="#通用问题" class="headerlink" title="通用问题"></a>通用问题</h1><ul>
<li>如何看React和Vue</li>
<li>生命周期</li>
<li>路由实现机制</li>
<li>diff算法和key的作用</li>
<li>数据绑定原理</li>
<li>虚拟 DOM 实现原理</li>
<li>组件通信</li>
<li>Hook的实现原理</li>
<li>session与cookie的区别</li>
<li>性能优化完整方案</li>
<li>10个1m的文件 和 1个10m的文件 在浏览器哪个传输比较快</li>
</ul>
<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><ul>
<li>Fiber架构是什么</li>
<li>Hook函数的作用是什么</li>
<li>setState是异步还是同步，如果要获取更新后的state应该怎么做</li>
</ul>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><ul>
<li>Vue2和Vue3的区别</li>
<li>Vue3的组合式 API是什么？有什么好处？</li>
<li>Vue3中如何开发函数式组件？</li>
<li>nextTick 的原理是什么？</li>
<li>Vue通讯机制</li>
<li>computed与watch</li>
</ul>
<h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><ul>
<li>TypeScript是什么？有什么特性或者好处？</li>
<li>TypeScript 的缺点是什么？</li>
<li>Typescript 中的装饰器是什么？</li>
<li>TypeScript 如何设计 Class 的声明？</li>
<li>TypeScript 中 type 和 interface 的区别?</li>
<li>TypeScript 枚举是什么？</li>
<li>简单介绍一下 TypeScript 模块的加载机制？</li>
<li>TypeScript 的 tsconfig.json 中有哪些配置项信息？</li>
<li>如何初始化一个Typescript项目？</li>
</ul>
<h1 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h1><ul>
<li>目前市面上主流的构建工具有哪些？ webpack和 vite对比?</li>
</ul>
<h1 id="编码题"><a href="#编码题" class="headerlink" title="编码题"></a>编码题</h1><ul>
<li>深浅拷贝</li>
<li>Promise和Promise.all实现 </li>
<li>throttle节流 和 debounce防抖</li>
<li>如何通过原型实现继承</li>
</ul>
<h1 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h1><ul>
<li>排序题</li>
<li>去重题</li>
<li>反转题</li>
</ul>
<p>具体可以参考这些:</p>
<ul>
<li><a href="https://juejin.cn/post/6987320619394138148" target="_blank" rel="noopener">算法面试】leetcode最常见的150道前端面试题 — 简单题上</a></li>
</ul>
]]></content>
      <tags>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title>从null、undefined、NaN的区别了解JS的原型链</title>
    <url>/today/20230129.html</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>由于在面试经常会遇到问题null，undefined，NaN之间的区别，因此想要深入且系统了解一下这些代表空之间的区别，以及它们底层的原理——原型链，同时还要搞明白<code>__proto__</code>和<code>prototype</code>分别是什么。</p>
<p>为了更好系统的理解null，undefined，NaN之间的区别和关系，我们需要从Javascript语言设计底层去理解，为什么一个空值需要设计这么多个。为什么不能像Java，一个null就可以满足？</p>
<p>我们先简单认识三者：</p>
<ul>
<li><code>undefined</code> 表示原始值undefined。它是一个 JavaScript 的 原始数据类型 </li>
<li><code>null</code> 特指对象的值未设置。它是 JavaScript 基本类型 之一。</li>
<li><code>NaN</code> 是一个表示非数字的值</li>
</ul>
<p>接下来主要从以下两个点去认识null，undefined，NaN之间的区别和关系：</p>
<ul>
<li>数据类型 <code>typeof</code></li>
<li><code>===</code> 判断</li>
<li>原型 <code>prototype</code></li>
</ul>
<a id="more"></a>

<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>在Javascript中，<code>typeof</code>可以判断出当前变量的数据类型，主要以下几种数据类型：</p>
<ul>
<li><code>typeof undefined</code>，输出 <code>undefined</code></li>
<li><code>typeof NaN</code>，输出 <code>number</code></li>
<li><code>typeof null</code> 输出 <code>object</code></li>
</ul>
<p>从上面的结果可以得知 <code>undefined</code>在JavaScript中是一种数据类型，而<code>NaN</code>和<code>null</code>则是某种数据类型的值。</p>
<p>但是在JS在定义基础数据类型有以下集中种：</p>
<ul>
<li><code>number</code> 数字类型，包括数字 和 NaN</li>
<li><code>string</code> 字符串类型</li>
<li><code>boolean</code> 布尔类型 包括: true 和 false</li>
<li><code>undefined</code> undefined未定义类型</li>
<li><code>null</code>  null空数据类型</li>
<li><code>bigint</code> ES2020新定义 BigInt大整数类型，主要用来解决大于 2^53 - 1 的整数，如：<code>const theBiggestInt = 9007199254740991n; const alsoHuge = BigInt(9007199254740991);</code></li>
<li><code>symbol</code> ES6定义 Symbol类型，应用场景：解决属性命名唯一性的问题，比如一个object里有两个属性名都一样，但是分别对不同的意思，可以通过Symbol类型去解决，如：<code>a = Symbol(&#39;test&#39;); b = Symbol(&#39;test&#39;);obj = {[a]: &#39;test&#39;, [b]: &#39;test&#39;}</code></li>
</ul>
<p>同时typeof运算符还可以返回以下两种类型：</p>
<ul>
<li><code>function</code> 函数类型，新的<code>class</code>也是返回<code>function</code></li>
<li><code>object</code> 除了以上类型，其他对象统一返回<code>object</code></li>
</ul>
<p>因此 <code>null</code>被单独归类成一种基础数据类型，但是为什么<code>typeof null</code> 得到的却是 <code>object</code>？</p>
<h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p>先了解一下typeof是什么？</p>
<blockquote>
<p>typeof是一个操作符而不是函数，用来检测给定变量的数据类型。</p>
</blockquote>
<p>typeof是一个操作符，和 <code>+</code> <code>-</code> <code>=</code> 符号一样，只是用了<code>typeof</code>字母进行标识而已，类似还有：<code>delete</code> <code>void</code> <code>in</code> <code>instanceof</code>等。</p>
<p>使用typeof需要注意以下几点：</p>
<ul>
<li>typeof 操作符的优先级高于加法（+）等二进制操作符。因此，需要用括号来计算加法结果的类型。 如：<code>typeof someData + &quot; Wisen&quot;; // &quot;number Wisen&quot;</code> <code>typeof (someData + &quot; Wisen&quot;); // &quot;string&quot;</code></li>
<li>typeof 通常总是保证为它提供的任何操作数返回一个字符串。即使使用未声明的标识符，typeof 也会返回 “undefined”，而不是抛出错误。 但是在<code>let</code> <code>const</code>声明的变量，使用 typeof 会抛出一个 ReferenceError。因为<code>let</code> <code>const</code>声明的变量块作用域变量在块的头部处于“暂存死区”。</li>
<li><code>typeof document.all === &#39;undefined&#39;; // true</code> 因为所有浏览器都公开了一个类型为 undefined 的非标准宿主对象 <code>document.all</code>，但是 <code>document.all</code> 不等于 <code>undefined</code>，这种情况出现是在 Web 标准中，document.all 具有 “undefined” 类型的情况被归类为“故意违反”原始 ECMAScript Web 兼容性标准。</li>
<li>typeof 并不能检查出所有的类型，只能检查出上述所说的8种，针对其他类型可以通过原型链去判断获取，如： <code>Object.prototype.toString.call(x)</code> <code>x.constructor.name</code></li>
</ul>
<h3 id="typeof-工作原理"><a href="#typeof-工作原理" class="headerlink" title="typeof 工作原理"></a>typeof 工作原理</h3><p>那么typeof真正是如何工作的呢？</p>
<ul>
<li>首先，会将所运算的变量数据在底层转换成二进制，而在Javascript设计中，是利用二进制前（低）三位存储其类型信息，如：000: 对象，1：整数， 100：字符串等</li>
<li>其次，null存储起来转成二进制为<code>0000000000000000</code>，那么按照JS的设计原则， 低三位为<code>000</code>则代表对象</li>
<li>因此，null在typeof计算后，会直接返回<code>object</code></li>
</ul>
<p>PS： 注意细节， <code>undefined</code>：用 - （−2^30）表示。</p>
<p>这里引用一下<a href="https://github.com/justjavac" target="_blank" rel="noopener">迷渡 justjavac</a>老师的几个解释：</p>
<p><a href="https://segmentfault.com/q/1010000011846328" target="_blank" rel="noopener">JavaScript中typeof原理探究？</a><br><a href="https://www.zhihu.com/question/62732293/answer/201723301" target="_blank" rel="noopener">v8引擎是如何知道js数据类型的？</a></p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="===运算符"></a>===运算符</h1><p>要讲三者的区别，还有一种方式就是通过 <code>===</code> 全等运算符，它们的表现如下：</p>
<ul>
<li><code>null === null // true</code> </li>
<li><code>undefined === undefined // true</code></li>
<li><code>NaN === NaN // false</code></li>
</ul>
<p>前两者比较好理解，毕竟都是等于自身，但是<code>NaN</code>不等于<code>NaN</code>就很容易给人带来误解。</p>
<p>这里就需要先解释<code>===</code>和<code>==</code>的区别：</p>
<ul>
<li>==， 两边值类型不同的时候，要先进行类型转换，再比较两者的值。</li>
<li>===，不做类型转换，类型不同的一定不等，然后对比两者的值。</li>
</ul>
<p>因此我们可以得到<code>===</code>的实现过程：</p>
<ul>
<li>先判断两者的数据类型是否一致</li>
<li>再判断两者是否为基础数据类型，如果是数字类型还需要判断两者是否有为NaN，如果没有返回true，其他基础类型直接对比值</li>
<li>如果是引用数据类型，如：object或function，则判断它们的引用对象是否为同一个，如：<code>a = function(){}; b= a; c=a; b===c;</code></li>
</ul>
<h2 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h2><blockquote>
<p>NaN 即 Not a Number ，代表该值不是一个数字number类型</p>
</blockquote>
<p>那么如何判断<code>NaN</code>值呢？答案是通过<code>isNaN(x)</code>或者<code>Number.isNaN(x)</code>函数去判断，这里也有坑就是<code>Number.isNaN(x)</code> 不会强制转换<code>x</code>为<code>number</code>,只是会判断x是否为<code>NaN</code></p>
<p>为什么JS要设计一直<code>NaN</code>值？ 个人猜测是因为JS是一门弱类型语言，它支持类型之间互相转换，其他基础数据类型都可以直接转换或者报类型错误，但是在<code>number</code>为了更好兼容加减乘除运算符，设计一个值为NaN(非数字)，当值无法转换<code>number</code>类型，将返回NaN。</p>
<p><strong>同时，我们也需要了解<code>NaN</code>与<code>Infinity</code>的区别：</strong></p>
<ul>
<li>NaN，是Not a Number的缩写，不是一个数字的意思。</li>
<li>Infinity，是指无穷大的数字，后面可以用BigInt数据类型代替。</li>
</ul>
<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><p>如果要了解到三者的本质，从三者的原型去区分：</p>
<ul>
<li><code>Object.prototype.toString.call(undefined) // [object Undefined]</code>，原型为自己本身或者没有原型，因为它是一个基础数据类型，且是全局对象(window)的一个属性，并不是一个实例化的对象</li>
<li><code>Object.prototype.toString.call(null) // [object Null]</code>， 原型为自己本身，因为它是原型链上的最后一个</li>
<li><code>Object.prototype.toString.call(null) // [object Number]</code>，原型为<code>Number</code>，因为它是属于<code>Number类型</code></li>
</ul>
<p>那么什么是原型呢？</p>
<p>我们需要明白原型是怎么出现的，是为了解决什么问题？</p>
<blockquote>
<p>原型机制，是JS语言实现面向对象编程中继承特性是设计的一种机制，这种继承机制与经典的面向对象编程语言的继承机制不同。<br>传统的面向对象编程，实现对象继承，通过是定义一个父类，如果有个子类继承父类，那么在子类在实例化，会将父类的属性和方法都复制一份到子类的实例中<br>而原型机制是每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推，最终形成<code>原型链 (prototype chain)</code>。<br>这些属性和方法定义在 Object 的构造器函数 (constructor functions) 之上的prototype属性上，而非对象实例本身</p>
</blockquote>
<p>如何理解呢？下面通过一下几个点：</p>
<ul>
<li>new一个对象的全过程</li>
<li>如何实现继承？以及继承中的原型链？</li>
</ul>
<p>但是在搞清楚这个之前，我们还需要了解JS原型中经常会混淆两个属性，<code>prototype</code>和<code>__proto__</code>，所以我们先弄明白这两个属性分别是做什么的。</p>
<h2 id="prototype和proto"><a href="#prototype和proto" class="headerlink" title="prototype和proto"></a>prototype和<strong>proto</strong></h2><blockquote>
<p>在JS里，万物皆对象。方法（Function）是对象，方法的原型(Function.prototype)是对象。因此，它们都会具有对象共有的特点。<br>那么只要是对象就会有属性<code>__proto__</code>，称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型对象<code>prototype</code>。</p>
</blockquote>
<p>为了更好的理解，我们通过一段代码和对应原型关系图去对比了解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">a = <span class="keyword">new</span> A();</span><br></pre></td></tr></table></figure>

<p>上述代码<code>prototype</code>和<code>__proto__</code>的关系如下图：</p>
<p><img src="/assets/img/20230130-1.png" alt></p>
<p>通过上图我们可以很清晰的知道两者的区别：</p>
<ul>
<li><code>prototype</code>是一个对象，只有函数才有，实例化后的变量是没有的，且<code>prototype</code>原型允许扩展函数的方法或者属性，从而让实例化后的对象进行使用，再者就是<code>prototype</code>既然是对象那么它自己也会有<code>__proto__</code>属性</li>
<li><code>__proto__</code>是实例化对象后拥有的属性，它的值主要指向该对象构造函数的原型<code>prototype</code>，从而形成<code>原型链</code></li>
<li>当一个实例化对象在调用某方法或某属性时，会先判断<code>__proto__</code>的<code>prototype</code>对象上是否有，如果没有则会往下一层<code>__proto__</code>去寻找</li>
</ul>
<h2 id="new的实现过程"><a href="#new的实现过程" class="headerlink" title="new的实现过程"></a>new的实现过程</h2><p>demo代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">a = <span class="keyword">new</span> A();</span><br></pre></td></tr></table></figure>

<p>那么在这一个过程中，js在底层中，做了哪些事情呢？ 通过上图我们可以很清楚的知道：</p>
<ul>
<li>创建全新的函数A实例化一个对象</li>
<li>然后将对象的<strong>proto</strong>指向构造函数的prototype</li>
<li>将对象的this指向到调用方的this</li>
<li>如果函数无返回对象类型Object，则返回该函数对象</li>
</ul>
<h2 id="继承与原型链"><a href="#继承与原型链" class="headerlink" title="继承与原型链"></a>继承与原型链</h2><p>继承其实在ES6后来说已经很简单了，因为定义了<code>class</code>和<code>extends</code>等语法糖，所以不需要再像之前通过原型去解决，但是为了更好的了解原型链，我们接下来尝试一下几种ES5时代实现继承的方式。</p>
<h3 id="原型指向实现"><a href="#原型指向实现" class="headerlink" title="原型指向实现"></a>原型指向实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="string">'test'</span>;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 需要将A的属性继承</span></span><br><span class="line">    A.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">B.prototype.__proto__ = A.prototype;</span><br><span class="line"><span class="comment">// 思考一下，为什么要将隐性原型指向A？</span></span><br><span class="line">B.__proto__ = A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line">b.a; <span class="comment">// test</span></span><br><span class="line">b.say(); <span class="comment">// test</span></span><br><span class="line"></span><br><span class="line">b <span class="keyword">instanceof</span> B; <span class="comment">// true</span></span><br><span class="line">b <span class="keyword">instanceof</span> A; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这里需要注意几个点：</p>
<ol>
<li>在B构造函数里实现<code>A.call(this)</code>，是因为需要将A函数实现一遍，且A中this指向的属性绑定B函数中</li>
<li><code>B.prototype.__proto__ = A.prototype</code>这行是继承A的方法，后续如果要重写相同方法需要放在这行代码后面</li>
<li><code>B.__proto__ = A</code> 如果没有这行代码，貌似上面的结果并不会有太多异常，那么为什么要这行代码呢？(等待后续解释)</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里再总结一下，在数据类型上，三者的区别主要是：</p>
<ul>
<li><code>undefined</code> 是一种基础数据类型，可以通过<code>typeof</code>直接识别</li>
<li><code>null</code> 虽然也是一种基础数据类型，但是由于<code>typeof</code>从一开始实现机制问题，<code>typeof null</code>一直遗留下来返回的<code>object</code></li>
<li><code>NaN</code> 是<code>number</code>数据类型的一个值，代表无法识别为数字类型的值，如：<code>Number(&#39;abc&#39;) // NaN</code></li>
</ul>
<p>在 <code>===</code> 运算符号上，区别主要是：</p>
<ul>
<li><code>undefined</code>，可以等于任何值为<code>undefined</code>的变量</li>
<li><code>null</code>，可以等于任何值为<code>null</code>的变量</li>
<li><code>NaN</code>，不等于任何值的变量，只能通过<code>isNaN</code>函数判断</li>
</ul>
<p>从原型上去了解三者，他们本质就完全不同：</p>
<ul>
<li><code>undefined</code>，原型为自己本身或者没有原型</li>
<li><code>null</code>，原型为自己</li>
<li><code>NaN</code>，原型为Number</li>
</ul>
<p>同时我们也清楚的认识到JS中原型和原型链，原型是JS设计实现面向对象的一种机制，主要通过两个东西实现原型对象<code>prototype</code>和隐性原型<code>__proto__</code>实现，这两者主要关系在于：</p>
<ul>
<li>隐性原型<code>__proto__</code>是一个实例化对象后的属性，会指向声明该对象的构造函数的原型对象<code>prototype</code></li>
<li>原型对象<code>prototype</code>是一个对象，一般只有函数才会有，它通常包括<code>constructor</code>构造函数指向函数本身，以及其他扩展方法和属性，同时它本身也拥有<code>__proto__</code>隐性原型属性</li>
</ul>
<p>当然JS的原型和原型链并没有那么简单，不仅仅只是实现继承这么简单，后续我们还需要关注原型链安全问题，后续请看<a href="/2023/01/06/today/20220203/">《JS原型链污染是怎么回事》</a>。</p>
]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>:has伪类的到来延伸到其他伪元素和伪类的区别</title>
    <url>/today/20230128.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近从网上看到一个有趣的CSS应用，就是纯用CSS也能是父子树展示，具体效果如下：</p>
<ul class="tree">
  <li>
    <details open>
      <summary style="display: list-item;">目录节点1</summary>
      <ul>
        <li>
          <details>
            <summary style="display: list-item;">节点1</summary>
            <ul>
              <li>子节点1-1</li>
              <li>子节点1-2</li>
            </ul>
          </details>
        </li>
        <li>
          <details>
            <summary style="display: list-item;">节点2</summary>
            <ul>
              <li>子节点2-1</li>
              <li>子节点2-2</li>
            </ul>
          </details>
        </li>
      </ul>
    </details>
  </li>
</ul>

<p>然后里面关联到一篇新闻，就是<code>:has</code>伪元素的出现会给CSS带来极大的变动，这是为什么，不就是一个CSS伪元素吗？因此去了解一下，才发现这个伪元素确实不一样，主要有以下几点：</p>
<ul>
<li>可以选择父级元素， <code>a:has(&gt; img)</code>，包含<code>img元素</code>的<code>a元素</code></li>
<li>可以选择兄弟元素， <code>h1:has(+ p)</code>，后面为<code>p元素</code>的<code>h1元素</code></li>
</ul>
<p>为什么有了它之后，CSS会有大变动，因为以往我们的样式都是直接选择 元素 或者 子元素 或者 后面的元素，如果要选择父元素或前面的元素只能通过命名规范去确定，比如上述两个例子：</p>
<ul>
<li><code>a:has(&gt; img)</code>，我们只能通过<code>a.has-img</code>类似样式去命名</li>
<li><code>h1:has(+ p)</code>，只能通过<code>h1.next-p</code>类似样式去命名</li>
</ul>
<p>大概清楚它能带来的变化，接下来我们来详细了解一下它。</p>
<a id="more"></a>

<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>在<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/:has" target="_blank" rel="noopener">MDN</a>里是这么定义<code>:has()</code>的:</p>
<blockquote>
<p>CSS 函数式伪类 <code>:has()</code> 表示一个元素，如果作为参数传递的任何相对选择器在锚定到该元素时，至少匹配一个元素。这个伪类通过把可容错相对选择器列表作为参数，提供了一种针对引用元素选择父元素或者先前的兄弟元素的方法。</p>
</blockquote>
<p>你可以这么理解<code>h1:has(+ p)</code>伪元素:</p>
<ul>
<li>第一步，会先筛选<code>h1</code>元素列表，如果列表长度大于1才会执行has()</li>
<li>第二步，执行<code>+ p</code>，就是判断<code>h1</code>元素列表中哪些元素的下个元素为<code>p</code></li>
<li>第三步，将筛选后的元素列表返回</li>
</ul>
<p>再简单点说就是一个过滤器，过滤条件可以是任意CSS表达式。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>除了上述的场景外，<code>:has()</code> 还可以做以下几个场景：</p>
<ul>
<li>与<code>:is()</code> <code>:not()</code> 结合使用，如：<code>is:(h1, h2, h3):has(+ :not(h2,h3, h4))</code> </li>
<li>表单必填项, 给每个必填项增加”*””文字，代码如下：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-tag">label</span><span class="selector-pseudo">:has(+input</span><span class="selector-pseudo">:required)</span><span class="selector-pseudo">::before</span>&#123;</span></span><br><span class="line">  content: '*';</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>备注<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<div style="border:1px solid #ccc;margin:20px;padding:20px;">
<style>
label:has(+input:required)::before{
  content: '*';
  color: red;
  width:1em;
  display:inline-block;
}
</style>
<form>
  <div style="margin:10px">
    <label style="display:inline-block;width:4em; text-align:right;">用户名</label>
    <input required>
  </div>
  <div style="margin:10px">
    <label style="display:inline-block;width:4em; text-align:right;">备注</label>
    <input>
  </div>
</form>
</div>


<h1 id="伪类与伪元素"><a href="#伪类与伪元素" class="headerlink" title="伪类与伪元素"></a>伪类与伪元素</h1><p>了解完<code>:has()</code>伪类，那么来复习一下CSS中的其他伪类与伪元素。</p>
<h2 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h2><p>伪元素，又称为伪类，是添加到CSS选择器上的关键字，给指定DOM元素添加特殊状态。MDN是这么定义的：</p>
<blockquote>
<p>CSS 伪类是添加到选择器的关键字，用于指定所选元素的特殊状态。例如，伪类 :hover 可以用于选择一个按钮，当用户的指针悬停在按钮上时，设置此按钮的样式。 ——<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes" target="_blank" rel="noopener">MDN 伪类</a></p>
</blockquote>
<p>伪类一般组成为两部分： <code>:</code> + <code>伪类名</code>，按照伪类的功能进行划分，主要分为以下几类：</p>
<ul>
<li>元素显示状态伪类，如：<code>:fullscreen</code> <code>:hover</code></li>
<li>输入状态伪类，如：<code>:focus</code> <code>:actived</code></li>
<li>语言的伪类，如：<code>:lang()</code></li>
<li>位置伪类，如：<code>:left</code></li>
<li>资源状态伪类，如：<code>:playing</code> <code>:paused</code></li>
<li>时间方面的伪类</li>
<li>树结构的伪类，如： <code>:nth-child()</code></li>
<li>用户行为伪类，如：<code>:actived</code></li>
<li>函数式伪类，如：<code>:where</code> <code>:is</code> <code>:not</code></li>
</ul>
<p>其实我们真正在使用的没有几个，但是我们仍然要重点关注一下，能加快我们的开发效率，比如：元素显示状态伪类，用户行为伪类, 函数式伪类等</p>
<h2 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h2><blockquote>
<p>伪元素是一个附加至选择器末的关键词，允许你对被选择元素的特定部分修改样式。——<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-elements" target="_blank" rel="noopener">伪元素 MDN</a></p>
</blockquote>
<p>从命名上你就可以看出来，伪元素其实是一个类似的元素东西，虽然有部分写法可以改变样式，但是大部分还是给CSS选择器对应元素增加元素，比较常见的伪元素有：</p>
<p>而且从书写规范来讲，伪元素为<code>::</code>+<code>伪元素名</code>，比较常见的伪元素有以下几种：</p>
<ul>
<li><code>::before</code> 给元素添加最前面添加一个子伪元素</li>
<li><code>::after</code> 给元素添加最后面添加一个子伪元素</li>
<li><code>::first-line</code> 选择元素第一个</li>
<li><code>::placeholder</code> 修改有<code>placehodler</code>的样式</li>
</ul>
<p>部分demo代码测试案例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.article-inner</span>  <span class="selector-tag">p</span><span class="selector-class">.demo-20230108</span><span class="selector-pseudo">::first-line</span> &#123; <span class="attribute">color</span>:<span class="number">#f00</span> &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.article-inner</span>  <span class="selector-tag">p</span><span class="selector-class">.demo-20230108</span><span class="selector-pseudo">::first-letter</span> &#123; <span class="attribute">text-transform</span>: uppercase &#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width:400px; padding:20px; border:1px solid;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">'demo-20230108'</span> <span class="attr">style</span>=<span class="string">"word-break:break-all"</span>&gt;</span>abcdefg,首字母要大写，然后第一行是要红色的字体，换行后就变成正常的，这里是一段很长的测试文字。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<style>
    .article-inner  p.demo-20230108::first-line { color:#f00 }
    .article-inner  p.demo-20230108::first-letter { text-transform: uppercase }
</style>
<div style="width:400px; padding:20px; border:1px solid;">
    <p class="demo-20230108" style="word-break:break-all">abcdefg,首字母要大写，然后第一行是要红色的字体，换行后就变成正常的，这里是一段很长的测试文字。</p>
</div>

<h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2><p>只有一句话： <code>与伪元素比较，伪类能够根据状态改变元素样式。</code></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.zhangxinxu.com/wordpress/2022/08/css-has-pseudo-class/" target="_blank" rel="noopener">CSS :has()伪类她来了</a></p>
]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>从0开始学习FlexBox布局</title>
    <url>/today/20230124.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前研究过一篇<a href="https://qborfy.com/today/20230111.html" target="_blank" rel="noopener">《移动端适配总结》</a>，里面主要通过布局不变，改变布局组件元素的大小去适应移动端。但是这种方式对于PC端或者Pad等大屏幕并不适合，所以从想找找看是否有新的方案能否满足跨端自适应布局方式。</p>
<p>目前同时解决PC端和移动端的响应式布局的解决方案以下几种：</p>
<ul>
<li>通过<code>@media</code>媒体查询去设置不同尺寸的样式</li>
<li>通过<code>Flexbox</code> <code>Grid</code>等现代化布局去做响应式布局</li>
</ul>
<a id="more"></a>

<h1 id="CSS排版布局"><a href="#CSS排版布局" class="headerlink" title="CSS排版布局"></a>CSS排版布局</h1><p>先简单再复习一下css是什么：</p>
<blockquote>
<p>CSS（层叠样式表）用于设置和布置网页——例如，更改内容的字体、颜色、大小和间距，将其拆分为多个列的布局，或添加动画和其他装饰功能。</p>
</blockquote>
<p>除了基础样式和动画外，CSS最大的一个功能就是告诉浏览器应该怎么对HTML元素进行排版布局。</p>
<blockquote>
<p>CSS 页面布局技术允许我们拾取网页中的元素，并且控制它们相对正常布局流、周边元素、父容器或者主视口/窗口的位置。</p>
</blockquote>
<p>目前，CSS布局分为以下几个：</p>
<ul>
<li>正常布局流，Flow layout，流式布局，是由块级盒子(block)和内联盒子(inline-block)，块级盒子从上至下排列，每个块级盒子会独自占一行，内联盒子则会被父级块级元素的宽度内，它们与其他内联元素、相邻的文本内容（或者被包裹的）被安排在同一行。如果空间不够，溢出的文本或元素将移到新的一行。</li>
<li>弹性盒子，Flexbox，与Flow layout最大的不同点在于，弹性盒子默认支持内部子元素（不管是块级还是内联）水平对齐，还支持等高，从而使得很多布局任务变得更加容易。后面我们详细讲解。</li>
<li>网格，Grid，有点类似表格table布局，相比较Flexbox，Grid更加强大，能适用更加复杂的排版，它包含了列(Columns)、行(Row)等布局。</li>
<li>浮动，Float，最初只用于在成块的文本内浮动图像，但是后来发现它能实现复杂的布局。一个浮动元素会被移出正常文档流，附到其父容器的左或右边，在正常布局中位于该浮动元素之下的内容，此时会围绕着浮动元素，填满其左或右侧的空间。</li>
<li>定位，Position，正常的文档流布局中取出元素，并使它们具有不同的行为，例如放在另一个元素的上面，或者始终保持在浏览器视窗内的同一位置。</li>
<li>多列布局，Column，有点类似Grid，比Grid简单，只是简单将容器分割成几列(<code>column-count</code>)，且可以设置（<code>column-width</code>）每一列的宽度</li>
</ul>
<h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p><code>BFC</code>(block formatting context)，块级格式化上下文，CSS中基于box的一个布局对象和单位，它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p>
<p>满足以下条件之一即为BFC:</p>
<ol>
<li>float的值不为none</li>
<li>position的值不为static或者relative</li>
<li>display的值为 table-cell, table-caption, inline-block,flex, 或者 inline-flex中的其中一个，现代化css用 <code>display:flow-root</code></li>
<li>overflow的值不为visible</li>
<li>根元素</li>
</ol>
<p>BFC有几个特点：</p>
<ul>
<li>不影响外部元素，外部元素也影响不到其内部</li>
<li>计算BFC高度的时候，浮动元素的高度也计算在内</li>
</ul>
<h3 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h3><blockquote>
<p>随着人们使用的屏幕尺寸的种类越来越多，出现了<code>响应式网页设计的概念（responsive web design，RWD）</code>，RWD 指的是允许 Web 页面适应不同屏幕宽度因素等，进行布局和外观的调整的一系列实践。</p>
</blockquote>
<p>响应式设计不是一种技术，而是一种设计方式或者理念，它指的是网页的布局应该随着屏幕的变化而自适应改变。</p>
<h1 id="Flexbox"><a href="#Flexbox" class="headerlink" title="Flexbox"></a>Flexbox</h1><p>Flexbox，Flexible Box， 俗称弹性盒子，是从网页默认流式布局(Flow layout)脱离出来的一种布局模式，其父元素容器还是遵循Flow layout，但是Flexbox中的元素都会遵循Flexbox新的布局方式。</p>
<blockquote>
<p>MDN介绍，弹性盒子是一种用于按行或按列布局元素的一维布局方法。元素可以膨胀以填充额外的空间，收缩以适应更小的空间。</p>
</blockquote>
<p>Flexbox的出现主要是为了解决Flow layout布局的一些无法很好解决的问题，如下：</p>
<ul>
<li>一个子元素需要垂直居中显示在容器中</li>
<li>多个子元素需要水平平均对齐在容器中，以及一旦子元素超过父容器的宽度，需要自动换行</li>
<li>所有子元素需要显示同样的高度或者宽度</li>
</ul>
<p>所以弹性盒子其实是由两部分组成：</p>
<ul>
<li>容器，需要设置为<code>display:flex</code>，用来控制子元素内的布局</li>
<li>子元素，遵循Flex布局方式所控制，但是也可以按照Flex布局做一些调整</li>
</ul>
<p><strong>同时需要注意一点，Flexbox弹性盒子内，元素的宽度不再是自身所设定的宽度，而是会根据容器设置的规则而发生变化。</strong></p>
<p>实现一个弹性盒子，其实很简单，只需要设置容器的<code>display:flex</code>，即可实现，代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.container&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.item&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item1"</span>&gt;</span>item1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item2"</span>&gt;</span>item1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item3"</span>&gt;</span>item1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Flexbox的两条轴"><a href="#Flexbox的两条轴" class="headerlink" title="Flexbox的两条轴"></a>Flexbox的两条轴</h2><p>要了解Flexbox，首先得知道盒子内部是按照两条轴去进行布局，分别为：</p>
<ul>
<li>主轴，Primary axis，子元素将按照该轴的方向进行排版布局</li>
<li>横轴，Cross axis，子元素默认会按照该轴的宽高度去拉伸自己本身的宽度高</li>
</ul>
<p>如下图所示：</p>
<p><img src="/assets/img/20230124-1.png" alt></p>
<p>那么Flexbox的属性设置，主要就是围绕这两个轴，分别调整容器内部子元素的对齐方向，子元素的在轴的位置，轴之间的间隔等。</p>
<h2 id="Flexbox的属性"><a href="#Flexbox的属性" class="headerlink" title="Flexbox的属性"></a>Flexbox的属性</h2><p>当然Flex布局的容器还支持其他设置属性：</p>
<ul>
<li>flex-direction 设置子元素的对齐方向，如：垂直(column)、水平(row)</li>
<li>justify-content 控制子元素主轴对齐方向</li>
<li>align-items 控制子元素横轴对齐方向</li>
<li>gap 设置子元素的间隔距离</li>
<li>order 设置子元素展示顺序，忽略html的顺序</li>
<li>flex-wrap 子元素超过容器大小后是否换行</li>
</ul>
<p>子元素也可以设置自身属性：</p>
<ul>
<li>flex-grow 设置子元素是否占用剩余空间，如果子元素都设置了，则会按照设置数字大小去做占用比例</li>
<li>flex-basis 子元素弹性宽度或者高度设置，当容器空间足够，则会按照此属性设置，如果空间不够，则会占据剩余的空间</li>
<li>flex-shrink 当子元素占用空间比容器大，默认会按照子元素占据比例进行缩放，该属性可以改变被压缩比例大小</li>
<li>align-self 子元素控制自己横轴对齐方向</li>
<li>margin 子元素设置auto后，可以达到类似<code>justify-content</code> 或 <code>align-items</code>的效果</li>
</ul>
<p>所有属性设置demo可以查看<a href="/code/flex/demo.html">Flexbox布局属性设置demo</a>。</p>
<h2 id="Flexbox的响应式布局"><a href="#Flexbox的响应式布局" class="headerlink" title="Flexbox的响应式布局"></a>Flexbox的响应式布局</h2><p>其实了解Flexbox布局，其实再去实现响应式布局，其实已经没有那么难了，不需要<code>@media</code>媒体查询那么麻烦一个个设置对应屏幕尺寸，只需要按照以下几个属性去设置对应的即可完成响应式布局：</p>
<ul>
<li>设置一个Flex容器，预先设置好当子元素在不同屏幕的展示排版</li>
<li>利用<code>flex-wrap: wrap;</code> 允许子元素自动换行</li>
<li>在设置不同子元素<code>flex-basis</code> <code>flex-grow</code> 占据容器占比</li>
<li>设置子元素<code>flex-shrink</code>是否缩放，从而避免元素被压缩的导致布局展示不对</li>
<li>设置子元素的最小宽度<code>min-width</code>，从而避免元素被压缩太小</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.joshwcomeau.com/css/interactive-guide-to-flexbox/" target="_blank" rel="noopener">Flexbox 交互式指南</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo Yilia主题支持搜索功能</title>
    <url>/share/hexo-search.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>当hexo的文章越来越多，依靠标题和tag去搜索有点不够用，因此需要支持搜索功能，hexo查询主要依赖本地索引文件生成，具体步骤如下：</p>
<ul>
<li>安装插件: <code>npm install --save hexo-generator-search</code></li>
<li>根目录下的_config.yml中添加如下配置即可</li>
</ul>
<a id="more"></a>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">search.xml</span></span><br><span class="line"><span class="attr">  field:</span> <span class="string">all</span></span><br></pre></td></tr></table></figure>

<ul>
<li>添加搜索框，在主题目录<code>themes/yilia/layout/layout.ejs</code>下的<code>&lt;div id=&quot;wrapper&quot; class=&quot;body-wrap&quot;&gt;</code>后面添加如下代码：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span>(<span class="attr">theme.search</span>) &#123; %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page-header"</span> <span class="attr">style</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">%#</span> 《集成本地搜索 %&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/search.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"local-search"</span> <span class="attr">class</span>=<span class="string">"local-search local-search-plugin"</span> <span class="attr">style</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"search"</span> <span class="attr">placeholder</span>=<span class="string">"站内搜索"</span> <span class="attr">id</span>=<span class="string">"local-search-input"</span> <span class="attr">class</span>=<span class="string">"local-search-input-cls"</span> <span class="attr">style</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">id</span>=<span class="string">"local-search-icon-search"</span> <span class="attr">class</span>=<span class="string">"icon"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span> <span class="attr">title</span>=<span class="string">"站内搜索"</span>&gt;</span>🔍<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"local-search-result"</span> <span class="attr">class</span>=<span class="string">"local-search-result-cls"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">if</span> ($(<span class="string">'.local-search'</span>).size()) &#123;</span></span><br><span class="line"><span class="javascript">            $.getScript(<span class="string">'/search/search.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">              searchFunc(<span class="string">"/search.xml"</span>, <span class="string">'local-search-input'</span>, <span class="string">'local-search-result'</span>);</span></span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">%#</span> 集成本地搜索》 %&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"wrapper"</span> <span class="attr">class</span>=<span class="string">"body-wrap"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>新建<code>themes/yilia/source/search</code>目录，同时新增<code>search.js</code>和<code>search.css</code>文件</li>
</ul>
<p>代码如下：</p>
<p><strong>search.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A local search script with the help of hexo-generator-search</span></span><br><span class="line"><span class="comment">// Copyright (C) 2015 </span></span><br><span class="line"><span class="comment">// Joseph Pan &lt;http://github.com/wzpan&gt;</span></span><br><span class="line"><span class="comment">// Shuhao Mao &lt;http://github.com/maoshuhao&gt;</span></span><br><span class="line"><span class="comment">// This library is free software; you can redistribute it and/or modify</span></span><br><span class="line"><span class="comment">// it under the terms of the GNU Lesser General Public License as</span></span><br><span class="line"><span class="comment">// published by the Free Software Foundation; either version 2.1 of the</span></span><br><span class="line"><span class="comment">// License, or (at your option) any later version.</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// This library is distributed in the hope that it will be useful, but</span></span><br><span class="line"><span class="comment">// WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class="line"><span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span></span><br><span class="line"><span class="comment">// Lesser General Public License for more details.</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// You should have received a copy of the GNU Lesser General Public</span></span><br><span class="line"><span class="comment">// License along with this library; if not, write to the Free Software</span></span><br><span class="line"><span class="comment">// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</span></span><br><span class="line"><span class="comment">// 02110-1301 USA</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> searchFunc = <span class="function"><span class="keyword">function</span> (<span class="params">path, search_id, content_id</span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">    <span class="keyword">var</span> BTN = <span class="string">"&lt;i id='local-search-close'&gt;x&lt;/i&gt;"</span>;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: path,</span><br><span class="line">        dataType: <span class="string">"xml"</span>,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params">xmlResponse</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// get the contents from search data</span></span><br><span class="line">            <span class="keyword">var</span> datas = $(<span class="string">"entry"</span>, xmlResponse).map(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    title: $(<span class="string">"title"</span>, <span class="keyword">this</span>).text(),</span><br><span class="line">                    content: $(<span class="string">"content"</span>, <span class="keyword">this</span>).text(),</span><br><span class="line">                    url: $(<span class="string">"url"</span>, <span class="keyword">this</span>).text()</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;).get();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> $input = <span class="built_in">document</span>.getElementById(search_id);</span><br><span class="line">            <span class="keyword">var</span> $resultContent = <span class="built_in">document</span>.getElementById(content_id);</span><br><span class="line"></span><br><span class="line">            $input.addEventListener(<span class="string">'input'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> str = <span class="string">'&lt;ul class=\"search-result-list\"&gt;'</span>;</span><br><span class="line">                <span class="keyword">var</span> keywords = <span class="keyword">this</span>.value.trim().toLowerCase().split(<span class="regexp">/[\s\-]+/</span>);</span><br><span class="line">                $resultContent.innerHTML = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.value.trim().length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// perform local searching</span></span><br><span class="line">                datas.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">var</span> isMatch = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">var</span> content_index = [];</span><br><span class="line">                    <span class="keyword">if</span> (!data.title || data.title.trim() === <span class="string">''</span>) &#123;</span><br><span class="line">                        data.title = <span class="string">"Untitled"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">var</span> data_title = data.title.trim().toLowerCase();</span><br><span class="line">                    <span class="keyword">var</span> data_content = data.content.trim().replace(<span class="regexp">/&lt;[^&gt;]+&gt;/g</span>, <span class="string">""</span>).toLowerCase();</span><br><span class="line">                    <span class="keyword">var</span> data_url = data.url;</span><br><span class="line">                    <span class="keyword">var</span> index_title = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">var</span> index_content = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">var</span> first_occur = <span class="number">-1</span>;</span><br><span class="line">                    <span class="comment">// only match artiles with not empty contents</span></span><br><span class="line">                    <span class="keyword">if</span> (data_content !== <span class="string">''</span>) &#123;</span><br><span class="line">                        keywords.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">keyword, i</span>) </span>&#123;</span><br><span class="line">                            index_title = data_title.indexOf(keyword);</span><br><span class="line">                            index_content = data_content.indexOf(keyword);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (index_title &lt; <span class="number">0</span> &amp;&amp; index_content &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                                isMatch = <span class="literal">false</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (index_content &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                                    index_content = <span class="number">0</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                                    first_occur = index_content;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// content_index.push(&#123;index_content:index_content, keyword_len:keyword_len&#125;);</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        isMatch = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// show search results</span></span><br><span class="line">                    <span class="keyword">if</span> (isMatch) &#123;</span><br><span class="line">                        str += <span class="string">"&lt;li&gt;&lt;a href='"</span> + data_url +</span><br><span class="line">                            <span class="string">"' class='search-result-title'&gt;"</span> + data_title + <span class="string">"&lt;/a&gt;"</span>;</span><br><span class="line">                        <span class="keyword">var</span> content = data.content.trim().replace(<span class="regexp">/&lt;[^&gt;]+&gt;/g</span>, <span class="string">""</span>);</span><br><span class="line">                        <span class="keyword">if</span> (first_occur &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// cut out 100 characters</span></span><br><span class="line">                            <span class="keyword">var</span> start = first_occur - <span class="number">20</span>;</span><br><span class="line">                            <span class="keyword">var</span> end = first_occur + <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (start &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                                start = <span class="number">0</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (start == <span class="number">0</span>) &#123;</span><br><span class="line">                                end = <span class="number">100</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (end &gt; content.length) &#123;</span><br><span class="line">                                end = content.length;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">var</span> match_content = content.substr(start, end);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// highlight all keywords</span></span><br><span class="line">                            keywords.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">keyword</span>) </span>&#123;</span><br><span class="line">                                <span class="keyword">var</span> regS = <span class="keyword">new</span> <span class="built_in">RegExp</span>(keyword, <span class="string">"gi"</span>);</span><br><span class="line">                                match_content = match_content.replace(regS,</span><br><span class="line">                                    <span class="string">"&lt;em class=\"search-keyword\"&gt;"</span> +</span><br><span class="line">                                    keyword + <span class="string">"&lt;/em&gt;"</span>);</span><br><span class="line">                            &#125;);</span><br><span class="line"></span><br><span class="line">                            str += <span class="string">"&lt;p class=\"search-result\"&gt;"</span> + match_content +</span><br><span class="line">                                <span class="string">"...&lt;/p&gt;"</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        str += <span class="string">"&lt;/li&gt;"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                str += <span class="string">"&lt;/ul&gt;"</span>;</span><br><span class="line">                <span class="keyword">if</span> (str.indexOf(<span class="string">'&lt;li&gt;'</span>) === <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> $resultContent.innerHTML = BTN +</span><br><span class="line">                        <span class="string">"&lt;ul&gt;&lt;span class='local-search-empty'&gt;没有找到内容，更换下搜索词试试吧~&lt;span&gt;&lt;/ul&gt;"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                $resultContent.innerHTML = BTN + str;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    $(<span class="built_in">document</span>).on(<span class="string">'click'</span>, <span class="string">'#local-search-close'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="string">'#local-search-input'</span>).val(<span class="string">''</span>);</span><br><span class="line">        $(<span class="string">'#local-search-result'</span>).html(<span class="string">''</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    $(<span class="built_in">document</span>).on(<span class="string">'focus'</span>, <span class="string">'#local-search'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="string">'#local-search-icon-search'</span>).html(<span class="string">'❌'</span>);</span><br><span class="line">        $(<span class="string">'#local-search-icon-search'</span>).attr(<span class="string">'id'</span>, <span class="string">'local-search-icon-close'</span>);</span><br><span class="line">        <span class="comment">//console.log("66666");</span></span><br><span class="line">    &#125;);</span><br><span class="line">    $(<span class="built_in">document</span>).on(<span class="string">'click'</span>, <span class="string">'#local-search-icon-close'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $(<span class="string">'#local-search-input'</span>).val(<span class="string">''</span>);</span><br><span class="line">        $(<span class="string">'#local-search-result'</span>).html(<span class="string">''</span>);</span><br><span class="line">        $(<span class="string">'#local-search-icon-close'</span>).html(<span class="string">'🔍'</span>);</span><br><span class="line">        $(<span class="string">'#local-search-icon-close'</span>).attr(<span class="string">'id'</span>, <span class="string">'local-search-icon-search'</span>);</span><br><span class="line">        <span class="comment">//console.log("1111");</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>search.css</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.local-search</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">16px</span> <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-input-cls</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">80%</span>;</span><br><span class="line">    <span class="comment">/* margin: 10px 0; */</span></span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">8px</span> <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#4d4d4d</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#666</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-input-cls</span><span class="selector-pseudo">::-webkit-input-placeholder</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#2d2626</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-input-cls</span><span class="selector-pseudo">::-moz-input-placeholder</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#2d2626</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-input-cls</span><span class="selector-pseudo">::-ms-input-placeholder</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#2d2626</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#local-search-close</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">'x'</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#888</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: consolas;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">    <span class="attribute">font-style</span>: normal;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">400</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(0);</span><br><span class="line">    <span class="attribute">transition</span>: all .<span class="number">3s</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#local-search-close</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="number">#666</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#222</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(180deg);</span><br><span class="line">    <span class="attribute">transition</span>: all .<span class="number">3s</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-result-cls</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">99</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="comment">/* top: 50px; */</span></span><br><span class="line">    <span class="attribute">right</span>: -<span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-result-cls</span> <span class="selector-class">.local-search-empty</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#888</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">44px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">400</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-result-cls</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">360px</span>;</span><br><span class="line">    <span class="attribute">max-height</span>: <span class="number">450px</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: auto;</span><br><span class="line">    <span class="attribute">overflow-y</span>: auto;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(255, 255, 255, 0.9);</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">3px</span> <span class="number">4px</span> <span class="number">10px</span> <span class="number">#7dc3d8</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-result-cls</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: left;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#bdb7b7</span>;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">400</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-result-cls</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">    <span class="attribute">border-bottom</span>: none;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-result-cls</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>:none;</span><br><span class="line">    <span class="attribute">transition</span>: all .<span class="number">3s</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-result-cls</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>:underline;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-result-cls</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">max-height</span>: <span class="number">124px</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-result-cls</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">em</span><span class="selector-class">.search-keyword</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#e58c7c</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>:bold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-plugin</span> <span class="selector-class">.local-search-input-cls</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: .<span class="number">6</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">80%</span>;</span><br><span class="line">    <span class="attribute">transition</span>: all .<span class="number">3s</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-plugin</span> <span class="selector-class">.local-search-input-cls</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">80%</span>;</span><br><span class="line">    <span class="attribute">transition</span>: all .<span class="number">3s</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.local-search-plugin</span> <span class="selector-class">.icon</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#999</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://gaomf.cn/2016/10/10/%E4%B8%BAHexo%E5%8D%9A%E5%AE%A2Yilia%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener">为Hexo博客Yilia主题添加本地站内搜索功能</a></p>
]]></content>
      <tags>
        <tag>技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>从nest.js中了解IoC和DI的实现</title>
    <url>/today/20230122.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>从上一篇<a href="/2023/01/10/today/20220110/">《从egg.js转到nest.js》</a>，想对其再深入了解一下，尤其比较好奇Typescript是如何实现<code>IoC</code>和<code>DI</code>，因为在Java的是通过的反射(Spring IoC实现原理)去创建对应的类。因此下文将详细讲解Nest.js中IoC和DI的实现原理。</p>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>在了解实现原理之前有几个知识概念，需要了解一下：</p>
<ul>
<li>IoC和DI</li>
<li>JavaScript的Reflect</li>
<li>TypeScript的装饰器</li>
</ul>
<a id="more"></a>

<h2 id="IoC和DI"><a href="#IoC和DI" class="headerlink" title="IoC和DI"></a>IoC和DI</h2><p>IoC和DI其实同属于一个技术理念，下面维基百科的介绍：</p>
<blockquote>
<p>IoC，控制反转（英语：Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。</p>
</blockquote>
<p>简单的说IoC是一个开发代码的设计原则，DI则是实现这个设计原则的方案。</p>
<h3 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h3><p>从代码层上来讲解IoC，简单的说就是：</p>
<ul>
<li>Class A中用到了Class B的对象b，一般情况下，需要在A的代码中显式地用 new 创建 B 的对象。</li>
<li>使用IoC设计原则后，A 的代码只需要定义一个 private 的B对象，不需要直接 new 来获得这个对象，而是通过相关的容器控制程序来将B对象在外部new出来并注入到A类里的引用中。</li>
<li>IoC将采用依赖注入或依赖查找两种方案去实现</li>
</ul>
<p>再通俗一点，就是有一个IoC容器管家，负责你开发的代码类的归置，你只管使用代码类，不用管它放在哪里，只需要调用即可。</p>
<h3 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h3><p>DI，Dependency Injection，依赖注入</p>
<blockquote>
<p>依赖注入是被动的接收对象，在类A的实例创建过程中即创建了依赖的B对象，通过类型或名称来判断将不同的对象注入到不同的属性中<br>依赖查找是主动索取相应类型的对象，获得依赖对象的时间也可以在代码中自由控制</p>
</blockquote>
<p>简单的说，就是依赖注入是将需要注入的对象完全交给框架去实现，而依赖查找则是开发者通过框架提供的方法，由自己控制需要注入的时间点。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>采用IoC和DI，需要注意的问题是：</p>
<ul>
<li>循环依赖，就是A依赖B，B依赖A，如何避免这种情况发生，或者框架提供什么样的方案去避免？</li>
<li>如果依赖的类越来越多，会不会导致项目启动速度变慢，因为需要初始化类很多，尤其当遇到一些类初始化可能会错误，但其实是可以忽略的？</li>
<li>初始化类的顺序如何控制，如：A依赖B，需要B实例化后才能实例？</li>
</ul>
<h2 id="JavaScript的Reflect"><a href="#JavaScript的Reflect" class="headerlink" title="JavaScript的Reflect"></a>JavaScript的Reflect</h2><p>Reflect在MDN网站是这么解释的：</p>
<blockquote>
<p>Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与proxy handlers (en-US)的方法相同。Reflect不是一个函数对象，因此它是不可构造的。<br>其中的一些方法与 Object 相同，尽管二者之间存在某些细微上的差别。</p>
</blockquote>
<p>按照前端开发者理解来说，Reflect能解决开发中遇到很多this的代理问题，虽然大部分方案都可以通过其他方式解决，但是Reflect的定义能帮助我们快速实现这些功能。</p>
<p>Reflect符合ES6标准的提供的API有如下几个：</p>
<ul>
<li><code>Reflect.apply(target, thisArgument, argumentsList)</code>,和 <code>Function.prototype.apply(thisArgument, argumentsList)</code> 功能类似，也是调用函数，且允许将函数的this指向<code>thisArgument</code></li>
<li><code>Reflect.construct(target, argumentsList[, newTarget])</code>，new一个target，且可以将target的this的指向新的newTarget对象</li>
<li><code>Reflect.defineProperty(target, propertyKey, attributes)</code>，拦截target对象的操作，和 <code>Object.defineProperty()</code> 类似</li>
<li><code>Reflect.deleteProperty(target, propertyKey)</code>，作为函数的delete操作符，相当于执行 delete target[name]。</li>
<li><code>Reflect.get(target, propertyKey[, receiver])</code>，获取target的属性值，和<code>target[name]</code>的区别在于可以<code>receiver</code>，可以指定调用属性值的时候<code>this</code></li>
<li><code>Reflect.getOwnPropertyDescriptor(target, propertyKey)</code>，类似于 Object.getOwnPropertyDescriptor()。如果对象中存在该属性，则返回对应的属性描述符，否则返回 undefined。</li>
<li><code>Reflect.getPrototypeOf(target)</code>，返回指定对象的原型（即内部的 [[Prototype]] 属性的值）</li>
<li><code>Reflect.has(target, propertyKey)</code>，判断一个对象是否存在某个属性，和 <code>in 运算符</code> 的功能完全相同</li>
<li><code>Reflect.ownKeys(target)</code>，返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 Object.keys(), 但不会受enumerable 影响).</li>
<li><code>Reflect.isExtensible(target)</code>， 判断一个对象是否可扩展（即是否能够添加新的属性）</li>
<li><code>Reflect.preventExtensions(target)</code>，阻止新属性添加到对象</li>
<li><code>Reflect.set(target, propertyKey, value[, receiver])</code>，将值分配给属性的函数。返回一个Boolean，如果更新成功，则返回true。</li>
<li><code>Reflect.setPrototypeOf(target, prototype)</code>，可设置对象的原型，即内部的 [[Prototype]] 属性）为另一个对象或 null，利用原型链用来强制给某个对象增加额外方法</li>
</ul>
<p>当然还有一些没有进入标准，但是在ES7提案的方法<code>Reflect Metadata</code>（Typescript已实现），后面Nest.js已采用的方法，主要有以下几个：</p>
<ul>
<li><code>Reflect.getMetadata(metadataKey, target, propertyKey)</code>, 用于获取某个类的元数据</li>
<li><code>Reflect.defineMetadata(metadataKey, metadataValue, target, propertyKey);</code>, 用于设置某个类的元数据</li>
</ul>
<p>简单理解这个api方法，你可以通过<code>Reflect.defineMetadata</code>获取到类或者函数的参数类型，也可以给类或者函数设置元数据再获取，具体代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Prop</span>(<span class="params"></span>): <span class="title">PropertyDecorator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">target, key: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">type</span> = Reflect.getMetadata(<span class="string">'design:type'</span>, target, key);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> type: <span class="subst">$&#123;<span class="keyword">type</span>.name&#125;</span>`</span>);</span><br><span class="line">    <span class="comment">// other...</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> SomeClass &#123;</span><br><span class="line">  <span class="meta">@Prop</span>()</span><br><span class="line">  <span class="keyword">public</span> Aprop!: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TypeScript 的优势了，TypeScript 支持编译时自动添加一些 metadata 数据，如下所示：</p>
<ul>
<li><code>Reflect.getMetadata(&quot;design:type&quot;, target, key)</code>， 获取target函数类型</li>
<li><code>Reflect.getMetadata(&quot;design:paramtypes&quot;, target, key)</code>， 获取target函数参数类型</li>
<li><code>Reflect.getMetadata(&quot;design:returntype&quot;, target, key)</code>， 获取target函数返回值类型</li>
</ul>
<p>这个<code>Reflect.getMetadata(&quot;design:paramtypes&quot;, target, key)</code>基本上就是Nest.js实现Ioc和DI的核心代码。</p>
<h2 id="TypeScript的装饰器"><a href="#TypeScript的装饰器" class="headerlink" title="TypeScript的装饰器"></a>TypeScript的装饰器</h2><blockquote>
<p>装饰器（Decorators）为我们在类的声明及成员上通过元编程语法添加标注提供了一种方式。<br>装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。</p>
</blockquote>
<p>如何实现一个装饰器呢？</p>
<p>如果我们要定制一个修饰器如何应用到一个声明上，我们得写一个装饰器工厂函数。 装饰器工厂就是一个简单的函数，它返回一个表达式，以供装饰器在运行时调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">color</span>(<span class="params">value: string</span>) </span>&#123; <span class="comment">// 这是一个装饰器工厂</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123; <span class="comment">//  这是装饰器</span></span><br><span class="line">        <span class="comment">// do something with "target" and "value"...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@color(<span class="string">'blue'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="IoC和DI实现原理"><a href="#IoC和DI实现原理" class="headerlink" title="IoC和DI实现原理"></a>IoC和DI实现原理</h1><p>其实在了解完<code>Reflect.getMetadata</code>，我们就大概知道IoC和DI的实现原理，我们以一个<code>@Controller</code>为例, 具体步骤如下：</p>
<ul>
<li>实现<code>@Controller</code>装饰器工厂，标识待注入的类</li>
<li>实现IoC容器，注册要被依赖注入的类</li>
<li>获取待注入的类其构造函数所需要的参数类型，并实例化，返回待注入的类</li>
</ul>
<p>具体代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现Controller装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Controller</span>(<span class="params">path: <span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>)</span>&#123;</span><br><span class="line">        Reflect.defineMetadata(<span class="string">'Controller'</span>, path, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要依赖注入的类</span></span><br><span class="line"><span class="keyword">class</span> A()&#123;</span><br><span class="line">    say()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'aaaaaa'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用</span></span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">"/api"</span>)</span><br><span class="line"><span class="keyword">class</span> Demo()&#123;</span><br><span class="line">    construtor(a: A )&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = A;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    say()&#123;</span><br><span class="line">        <span class="keyword">this</span>.a.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Ioc容器和DI依赖注入</span></span><br><span class="line"><span class="keyword">class</span> Container &#123;</span><br><span class="line">  provides = <span class="keyword">new</span> Map()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 注册要被依赖注入类，形成IoC容器 后续可以做</span></span><br><span class="line">  addProvide(provider) &#123;</span><br><span class="line">    <span class="keyword">this</span>.provides.set(provider.name, provider)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注入依赖类</span></span><br><span class="line">  inject(target) &#123;</span><br><span class="line">      <span class="comment">// 获取参数类型</span></span><br><span class="line">      <span class="keyword">const</span> paramTypes = Reflect.getMetadata(<span class="string">'design:paramtypes'</span>, target) || []</span><br><span class="line">      <span class="keyword">const</span> args = paramTypes.map(<span class="function">(<span class="params"><span class="keyword">type</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">type</span>() <span class="comment">// 简单做一下实例化</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">return</span> Reflect.construct(target, args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> container = <span class="keyword">new</span> Container()</span><br><span class="line"><span class="keyword">const</span> project = container.inject(Project)</span><br><span class="line"></span><br><span class="line"><span class="comment">// project就是最终生成返回使用的类</span></span><br><span class="line"></span><br><span class="line">project.say(); <span class="comment">// 输出 aaaaaa</span></span><br></pre></td></tr></table></figure>

<p>所以Nest.js实现IoC和DI的核心实现原理：</p>
<ul>
<li>通过装饰器给 class 或者对象添加 metadata</li>
<li>运行的时候通过这些元数据来实现依赖的扫描，对象的创建等等功能</li>
</ul>
<p>当然，还有很多问题没解决，目前只是简单实现了依赖注入，上述IoC的问题还没有解决，由于篇幅较长，所以拆成几篇，放到后续继续研究。</p>
]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>有趣的工具收集</title>
    <url>/ideas/20230120.html</url>
    <content><![CDATA[<h1 id="Deprank-js重要性排名"><a href="#Deprank-js重要性排名" class="headerlink" title="Deprank js重要性排名"></a>Deprank js重要性排名</h1><p>一个 JS 工具，按照重要性对本项目的所有脚本进行排序。原理是计算依赖关系，被依赖最多的脚本最重要。</p>
<p>官网：<a href="https://github.com/codemix/deprank" target="_blank" rel="noopener">Deprank</a></p>
<p>例子如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| Filename               | Lines | Dependents | PageRank |</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">| fixtures/core.js       | 3     | 1          | 0.284098 |</span><br><span class="line">| fixtures/utils.js      | 4     | 3          | 0.268437 |</span><br><span class="line">| fixtures/user/user.js  | 4     | 1          | 0.132253 |</span><br><span class="line">| fixtures/todo.js       | 6     | 1          | 0.089796 |</span><br><span class="line">| fixtures/user/index.js | 1     | 1          | 0.089796 |</span><br><span class="line">| fixtures/concepts.js   | 4     | 1          | 0.079694 |</span><br><span class="line">| fixtures/index.js      | 4     | 0          | 0.055926 |</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="FFmpeg-guide流程图生成FFmpeg命令"><a href="#FFmpeg-guide流程图生成FFmpeg命令" class="headerlink" title="FFmpeg.guide流程图生成FFmpeg命令"></a>FFmpeg.guide流程图生成FFmpeg命令</h1><p>一个图形界面，用户拖曳生成线框，表示视频处理的各种命令节点。这个软件会根据节点线框，生成对应的 FFmpeg 命令。</p>
<p>官网：<a href="https://ffmpeg.guide/" target="_blank" rel="noopener">FFmpeg.guide</a></p>
<p><img src="https://camo.githubusercontent.com/88f4911c4947e769f79adb3f3d8133015be0ae4b1c46be98f0faa9f93454b60c/68747470733a2f2f63646e2e6265656b6b612e636f6d2f626c6f67696d672f61737365742f3230323231312f6267323032323131303331342e77656270" alt></p>
<h1 id="blurhash-生成模糊缩略图的工具"><a href="#blurhash-生成模糊缩略图的工具" class="headerlink" title="blurhash 生成模糊缩略图的工具"></a>blurhash 生成模糊缩略图的工具</h1><p>这个工具可以提取图片的颜色分布，生成一个哈希字符串。网页就可以用这个哈希，生成图片的模糊缩略图。</p>
<p>官网：<a href="https://github.com/woltapp/blurhash" target="_blank" rel="noopener">blurhash</a></p>
<p>js应用:<a href="https://github.com/Dens49/blurhash-js" target="_blank" rel="noopener">https://github.com/Dens49/blurhash-js</a></p>
<p>例子如下：</p>
<img src="https://blurha.sh/12c2aca29ea896a628be.jpg" width="269" height="173">
<img src="/assets/img/20230120-idea.png" width="269" height="173">


<h1 id="iconbolt-免费svg-icon网站"><a href="#iconbolt-免费svg-icon网站" class="headerlink" title="iconbolt 免费svg icon网站"></a>iconbolt 免费svg icon网站</h1><p>有点类似阿里的iconfont，但是这个免费的，不需要登录直接使用。</p>
<p><a href="https://www.iconbolt.com/" target="_blank" rel="noopener">iconbolt</a></p>
]]></content>
      <tags>
        <tag>奇思妙想</tag>
      </tags>
  </entry>
  <entry>
    <title>从lerna到初步了解和使用Nx(一)</title>
    <url>/today/20230119.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>自从组内开发架构采用Monorepo大仓项目后，了解一些Monorepo的常用技术，主要采用了<code>lerna</code>框架去做多个子项目统一package.json命令脚本，因此想要了解一下lerna框架，同时也查到lerna的公司同步开发<code>Nx</code>项目，尝试一下它的应用。</p>
<p>想了解Monorepo大仓项目如何设计的可以翻到前往阅读 <a href="https://qborfy.com/today/20230107.html" target="_blank" rel="noopener">《从npm版本依赖到Monorepo大仓项目》</a>。</p>
<a id="more"></a>
<h1 id="lerna"><a href="#lerna" class="headerlink" title="lerna"></a>lerna</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><blockquote>
<p>Lerna是用于TypeScrip/JavaScript的原始monorepo工具。它已经存在多年，被数以万计的项目使用，包括Reaction和Jest。</p>
</blockquote>
<p>了解Lerna，必须想要了解一下<code>monorepo</code>架构， 简单点说，<code>monorepo</code>架构就是将许多不同业务项目的归纳一个仓库中，抽取公共部分，降低版本依赖的复杂度，达到所有项目统一化的架构。</p>
<p>Lerna解决了<code>monorepo</code>架构以下问题：</p>
<ul>
<li>将不同子项目链接在一起，不用发布npm就可以互相引用</li>
<li>可以将命令顺序执行，从而实现将不同项目分发到不同机器</li>
<li>参与CI/CD工作流中，拥有自由的定制脚本功能，从而满足不同的工作流</li>
</ul>
<h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><p>主要有以下几个步骤：</p>
<ul>
<li>初始化项目： <code>npx lerna init</code></li>
<li>修改<code>package.json</code>，去添加一个npm/yarn/pnpm workspace</li>
<li>运行命令<code>lerna run xxx</code>： 统一执行所有子项目的scripts命令，如：lerna run build</li>
</ul>
<p>更加具体的操作，可以到官方文档去查看<a href="https://lerna.js.org/docs/features/run-tasks" target="_blank" rel="noopener">https://lerna.js.org/docs/features/run-tasks</a></p>
<h1 id="Nx"><a href="#Nx" class="headerlink" title="Nx"></a>Nx</h1><p>先说明一下Nx与Lerna的关系：</p>
<blockquote>
<p>Nrwl(开源构建系统NX背后的公司)已经接管了Lerna。NX是一个由前谷歌员工开发的构建系统，它利用了谷歌内部工具使用的许多技术。Lerna v5是这种新管理方式下的第一个版本，它更新了过时的包，并开始对存储库本身进行一些清理。从V5.1+开始，Lerna提供了集成NX的新可能性，并将许多任务调度工作推迟到NX。</p>
</blockquote>
<h2 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h2><p>官方介绍：</p>
<blockquote>
<p>Nx是一个智能、快速和可扩展的构建系统，具有一流的Monorepo支持和强大的集成。</p>
</blockquote>
<p>Nx的目标是：</p>
<ul>
<li>加快你的前端项目工程化</li>
<li>提供一流的开发体验</li>
</ul>
<h2 id="实践-第一个nx项目"><a href="#实践-第一个nx项目" class="headerlink" title="实践-第一个nx项目"></a>实践-第一个nx项目</h2><ul>
<li><p>初始化项目， <code>npx create-nx-workspace@latest package-based --preset=npm</code></p>
</li>
<li><p>添加子项目， 目录下新建标准npm项目<code>packages/is-even</code></p>
</li>
<li><p>安装依赖，在根目录下执行<code>npm i typescript -D -W</code></p>
</li>
<li><p>第一次编译，根目录下执行<code>npx nx build is-even</code></p>
</li>
<li><p>新建第二个子项目，<code>packages/is-odd</code>，在项目中引用<code>is-even</code></p>
</li>
<li><p>关联依赖，在根目录下执行<code>npm install</code>，即可自动实现关联依赖</p>
</li>
<li><p>项目编译依赖，在根目录<code>nx.json</code>新增build依赖，如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "targetDefaults": &#123;</span><br><span class="line">    "build": &#123;</span><br><span class="line">      "dependsOn": ["^build"]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译打包，单独打包子项目<code>is-odd</code>，命令<code>npx nx build is-even</code>，同时会编译打包<code>is-even</code>，因为引用了</p>
</li>
<li><p>再次打包，nx会自动引入上一次build的cache缓存，从而加快编译速度</p>
</li>
<li><p>将所有的子项目统一打包编译，命令:<code>npx nx run-many --target=build</code></p>
</li>
<li><p>如果不需要使用cache缓存，可以使用命令:<code>npx nx run-many --target=build --skip-nx-cache</code></p>
</li>
<li><p>如果需要查看当前子项目依赖的项目是否被修改，可以使用命令：<code>npx nx affected --target=build</code></p>
</li>
</ul>
<p>到此，一个Nx的Monrepo项目就完成了。</p>
<p>当然实际应用中，没有那么简单，后续我们将通过Vue(vite) 、 React去完成一个Nx项目，已经如何和现有的CI工作流结合运行。</p>
<p>同时我们还需要解决这些问题：</p>
<ol>
<li>如何解决非Monrepo项目依赖Monrepo项目的公共代码</li>
<li>如何解决子项目需要发布，但是所依赖的其他子项目不发布问题</li>
<li>如何解决不同项目将采用不同的框架，如Vue、React，项目之间依赖问题？</li>
<li>如何解决不同子项目中依赖同一个npm包，但是版本不一致的问题？是通过前置检查？还是各自完全安装好？</li>
<li>实际应用中，如果遇到子项目需要单独剥离开成立单独项目，应该如何操作？</li>
<li>后续如果子项目越来越多，导致本地开发中项目运行开销过大，无法运行，如何解决？</li>
<li>子项目越来越多，是否有规范可以定义是否需要单独成立子项目？</li>
<li>如何定制公共代码剥离规则？如何检查规则应用？</li>
<li>前后端分离项目和SSR项目能否一起囊括？</li>
<li>项目权限问题如何解决？如：外包人员无法查看其它子项目代码？</li>
<li>……</li>
</ol>
<p>我们有很多问题，但是基本上都是引入Monrepo大仓项目导致的问题，我们希望Nx能有相关的解决方案提供参考或者应用，减少我们实际开发的阻塞。</p>
<p>所以，Nx项目还是持续跟进研究学习，找个实际项目去落地实践，或者将现有一些项目去整合试试看。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>理解React中Fiber架构(一)</title>
    <url>/today/20230117.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>自从React16版本更新了Hook用法，同时引入了新的Fiber架构去重构整个渲染和事件处理过程，React团队引入Hook是为了更好剥离业务代码，让开发能更加友好的抽象代码，达到低耦合的函数组件目的，那么重构Diff算法，引入Fiber架构是为了什么呢？ 其实只是为了能够一个目标<code>快速响应</code>，原先Diff算法时间复杂度为<span>$$ O(n^3)$$</span> ，最后经过Fiber重构达到了$$ O(n) $$，这里面具体有什么门道，值得我们去深入研究一下。</p>
<a id="more"></a>

<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在了解Fiber架构之前，我们需要对原有React16之前版本是有什么问题，才需要引入Fiber架构去解决该问题？</p>
<p>React15及以前的版本采用的是Stack Reconciler（栈协调器）架构，使用同步递归方式去创建虚拟DOM，一旦进入创建过程，就无法中断，如果创建过程超过16ms，用户就会出现页面卡顿感觉。具体可以参考下图：</p>
<p><img src="/assets/img/20230117-1.png" alt></p>
<p>因此，从网上搜索了一下React15及以前的版本反馈，的主要问题有如下几个：</p>
<ul>
<li>React的动画效果表现不佳</li>
<li>React在有大量DOM节点渲染卡顿</li>
</ul>
<h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>为什么会出现卡顿的情况，主要原因如下：</p>
<ol>
<li>JavaScript是单线程，与渲染线程互斥，当其中一个线程执行时，另一个线程只能挂起等待。</li>
<li>Stack Reconciler 栈协调器某个任务是长期占用JavaScript主线程</li>
</ol>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>为了更好了解Fiber架构设计，需要提前了解一些前置知识，每个知识点其实都需要深入了解，这里只是简单描述，主要有以下几点：</p>
<ul>
<li>单线程的 JavaScript 与多线程的浏览器</li>
<li>React生命周期</li>
<li>React虚拟DOM<h2 id="单线程的-JavaScript-与多线程的浏览器"><a href="#单线程的-JavaScript-与多线程的浏览器" class="headerlink" title="单线程的 JavaScript 与多线程的浏览器"></a>单线程的 JavaScript 与多线程的浏览器</h2></li>
</ul>
<p>在我们学习前端知识的时候，有个结论是： <code>单线程的 JavaScript 与多线程的浏览器</code>。</p>
<p>一个完整的web网页在浏览器显示和交互的进程（chrome为主），需要涉及到线程主要以下几个部分：</p>
<ul>
<li><code>GUI 渲染线程</code>，负责渲染浏览器界面HTML元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行。</li>
<li><code>JavaScript引擎线程</code>，JS内核，负责处理Javascript脚本程序。 一直等待着任务队列中任务的到来，然后解析Javascript脚本，运行代码。</li>
<li><code>定时触发器线程</code>，定时器setInterval与setTimeout所在线程，为什么要单独弄个线程处理定时器？是因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确</li>
<li><code>事件触发线程</code>，用来控制事件轮询，JS引擎自己忙不过来，需要浏览器另开线程协助</li>
<li><code>异步http请求线程</code>，在<code>XMLHttpRequest</code>或<code>fetch</code>在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等待处理。这里需要注意<code>XMLHttpRequest</code>和<code>fetch</code>的区别，<code>fetch</code>是w3c标准化后一个专门提供给开发调用发起http的API接口，XMLHttpRequest是一个非标准化的Http请求对象，主要是可以发起http请求获取XML数据。</li>
</ul>
<p>上述就是浏览器的多线程，然后单线程的JavaScript通常指的是<code>JavaScript引擎线程</code>，为什么需要单线程？因为多线程可能会出现各种UI交互冲突问题。因此了解单线程JS需要注意几点：</p>
<ul>
<li>GUI线程和JS引擎是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。</li>
<li>JS 引擎只是任意的 JS 代码按需执行的环境，是其他线程调用触发JS引擎执行JS代码，比如：一个按钮点击触发事件，接着调用js引擎执行等</li>
</ul>
<p>JS 引擎工作流程图如下：</p>
<p><img src="/assets/img/20230117-3.png" alt></p>
<h2 id="React-生命周期"><a href="#React-生命周期" class="headerlink" title="React 生命周期"></a>React 生命周期</h2><p>为了更好了解React Fiber架构，我们需要对比React15和React16的生命周期，具体如下：</p>
<h3 id="React15的生命周期"><a href="#React15的生命周期" class="headerlink" title="React15的生命周期"></a>React15的生命周期</h3><p>在15版本的时候，一个完整的组件生命周期如下（按照执行顺序）：</p>
<ul>
<li>constructor()，组件的构造函数，用来初始化state</li>
<li>componentWillMount()，初始化渲染前时调用</li>
<li>componentDidMount()，初始化渲染后调用</li>
<li>componentWillReceiveProps()，父组件修改组件的props时会调用</li>
<li>render()，每次渲染时候会调用</li>
<li>componentWillUpdate()，组件更新前调用</li>
<li>shouldComponentUpdate()，组件更新时调用，主要判断组件要不要更新</li>
<li>componentDidUpdate()，组件更新后调用</li>
<li>componentWillUnmount()，组件卸载时调用</li>
</ul>
<p><img src="/assets/img/20230117-4.png" alt></p>
<p>按照不同时期，执行过程是不一样，具体可以见React的生命周期更改相关文章。</p>
<h3 id="React16生命周期"><a href="#React16生命周期" class="headerlink" title="React16生命周期"></a>React16生命周期</h3><p>相比较React15，16版本基于Fiber架构主要对更新周期的函数做了调整，整个生命周期如下：</p>
<ul>
<li>constructor()，组件的构造函数，用来初始化state</li>
<li>getDerivedStateFromProps()，初始化/更新时调用，使用 props 来派生/更新 state。</li>
<li>componentDidMount()，初始化渲染后调用</li>
<li>shouldComponentUpdate()，</li>
<li>render()，每次渲染时候会调用</li>
<li>shouldComponentUpdate()，组件更新时调用，主要判断组件要不要更新</li>
<li>getSnapshotBeforeUpdate()，返回值会作为第三个参数给到 componentDidUpdate。它的执行时机是在 render 方法之后，真实 DOM 更新之前。可以同时获取到更新前的真实 DOM 和更新前后的 state&amp;props 信息。</li>
<li>componentDidUpdate()，组件更新后调用，从 getSnapshotBeforeUpdate 获取到的值</li>
<li>componentWillUnmount()，组件卸载时调用</li>
</ul>
<p>对比一下，React 16 废弃的是哪些生命周期：</p>
<ul>
<li>componentWillMount；</li>
<li>componentWillUpdate；</li>
<li>componentWillReceiveProps</li>
</ul>
<p>这些生命周期的共性，就是它们都处于 render 阶段，都可能重复被执行，而且由于这些 API 常年被滥用，它们在重复执行的过程中都存在着不可小觑的风险。</p>
<p>为什么废弃这些生命周期，因为引用了Fiber架构，render 阶段是允许暂停、终止和重启的。这就导致 render 阶段的生命周期都是有可能被重复执行的。</p>
<p>React16生命周期图如下：</p>
<p><img src="/assets/img/20230117-5.png" alt></p>
<h2 id="React-虚拟DOM"><a href="#React-虚拟DOM" class="headerlink" title="React 虚拟DOM"></a>React 虚拟DOM</h2><blockquote>
<p>虚拟 DOM（Virtual DOM）本质上是JS 和 DOM 之间的一个映射缓存，它在形态上表现为一个能够描述 DOM 结构及其属性信息的 JS 对象。</p>
</blockquote>
<p>记住两个点：</p>
<ul>
<li>虚拟 DOM 是 JS 对象</li>
<li>虚拟 DOM 是对真实 DOM 的描述</li>
</ul>
<p>虚拟DOM出现react生命周期的两个节点：</p>
<ol>
<li>挂载阶段，React 将结合 JSX 的描述，构建出虚拟 DOM 树，然后通过 ReactDOM.render 实现虚拟 DOM 到真实 DOM 的映射</li>
<li>更新阶段，页面的变化在作用于真实 DOM 之前，会先作用于虚拟 DOM，虚拟 DOM 将在 JS 层借助算法先对比出具体有哪些真实 DOM 需要被改变，然后再将这些改变作用于真实 DOM，这里就需要DOM Diff算法。</li>
</ol>
<p>为什么需要虚拟DOM？并不是因为虚拟DOM有更高的性能，而是因为虚拟 DOM 的优越之处在于，它能够在提供更爽、更高效的研发模式（也就是函数式的 UI 编程方式）的同时，仍然保持一个还不错的性能。解决了以下问题：</p>
<ol>
<li>研发体验/研发效率的问题，解决以往模板和数据，需要重复调整的问题</li>
<li>跨平台的问题，从web、小程序、app等，一套虚拟DOM，结合不同渲染逻辑，满足各类跨端场景</li>
</ol>
<p>而在虚拟DOM这一块，Fiber架构的引入，最大的调整就是虚拟DOM更新中的diff算法，由于分片渲染，不需要一次将diff执行，可以分批计算从而减少diff算法的复杂度。</p>
<h2 id="Stack-Reconciler-栈协调器"><a href="#Stack-Reconciler-栈协调器" class="headerlink" title="Stack Reconciler(栈协调器)"></a>Stack Reconciler(栈协调器)</h2><p>在了解Fiber架构之前，需要对React15的Stack Reconciler(栈协调器)做一次完整了解。先了解一下什么Reconciler协调器，在React中是这么定义的：</p>
<blockquote>
<p>Virtual DOM 是一种编程概念。在这个概念里，UI 以一种理想化的，或者说“虚拟的”表现形式被保存于内存中，并通过如 ReactDOM 等类库使之与“真实的” DOM 同步。这一过程叫作Reconciler 协调（调和）。</p>
</blockquote>
<p>所以实现Reconciler，其实就是实现虚拟DOM到真实DOM渲染的整个逻辑过程，因此调和 !== Diff，但是Diff 确实是调和过程中最具代表性的一环。</p>
<p>那么要了解React15是如何实现Stack Reconciler，最重要的两块：</p>
<ul>
<li>Diff算法策略</li>
<li>找到diff节点并<code>同步</code>更新渲染</li>
</ul>
<p>Diff算法策略要点：(主要是树递归)</p>
<ol>
<li>Diff 算法性能突破的关键点在于“分层对比”；</li>
<li>类型一致的节点才有继续 Diff 的必要性；</li>
<li>key 属性的设置，可以帮我们尽可能重用同一层级内的节点。</li>
</ol>
<h1 id="Fiber架构"><a href="#Fiber架构" class="headerlink" title="Fiber架构"></a>Fiber架构</h1><p>我们先来看看 React  团队在“React 哲学”中对 React 的定位：</p>
<blockquote>
<p>我们认为，React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式。它在 Facebook 和 Instagram 上表现优秀。</p>
</blockquote>
<p><code>快速响应</code>是React哲学理念，因此Fiber架构的出现是为了让React框架能更加快速响应用户的操作。</p>
<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>什么是 Fiber？从字面上来理解，Fiber 这个单词翻译过来是“丝、纤维”的意思，是比线还要细的东西。在计算机科学里，我们有进程、线程之分，而 Fiber 就是比线程还要纤细的一个过程，也就是所谓的“纤程”。纤程的出现，意在对渲染过程实现更加精细的控制。</p>
<p>Fiber的概念理解：</p>
<ul>
<li>从架构角度来看，Fiber 是对 React 核心算法（即调和过程）的重写</li>
<li>从编码角度来看，Fiber 是 React 内部所定义的一种数据结构，它是 Fiber 树结构的节点单位，也就是 React 16 新架构下的“虚拟 DOM”；</li>
<li>从工作流的角度来看，Fiber 节点保存了组件需要更新的状态和副作用，一个 Fiber 同时也对应着一个工作单元。</li>
</ul>
<p>从架构角度理解Fiber:</p>
<ul>
<li>架构核心：“可中断”“可恢复”与“优先级”</li>
<li>可中断，指的是在Fiber架构下，任何工作任务都可以被更高优先级的任务中断</li>
<li>可恢复，指的是被中断的任务可以被恢复继续执行</li>
<li>优先级，指的是每个任务都有自己的优先级定义</li>
<li>因此需要增加“Scheduler（调度器）”，作用是调度更新的优先级的任务</li>
</ul>
<h2 id="怎么解决问题"><a href="#怎么解决问题" class="headerlink" title="怎么解决问题"></a>怎么解决问题</h2><p>有了Fiber架构，怎么解决React15所面临的问题，虚拟DOM同步渲染真实DOM导致页面卡顿？</p>
<ul>
<li>将虚拟DOM，从原有的树结构，改为链表结构，拆分成一个个Fiber树节点</li>
<li>利用Fiber架构，将渲染过程拆分成一个个工作单元任务，设置优先级，支持可中断、可恢复</li>
<li>这样子当需要渲染复杂DOM时候，同时不影响其他优先级较高工作任务执行</li>
</ul>
<p>可以参考下图，了解一下Fiber架构工作图：</p>
<p><img src="/assets/img/20230117-2.png" alt></p>
<p>当然这样子讲只是简单的原理，还需要弄明白异步后可能产生更多问题？比如如何定制优先级，当两个同样优先级的任务相遇的时候如何解决，这些放在第二章讲解。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过第一篇Fiber文章学习，大概了解到Fiber架构出现的背景和原因，以及它是什么，是如何工作的解决之前所遇到问题。简单总结一下：</p>
<ul>
<li>React中定义Reconciler协调，指的是将虚拟DOM渲染到真实DOM的过程，React15之前采用是stack Reconciler栈协调，同步渲染机制导致页面卡顿</li>
<li>React16之后采用Fiber Reconciler，实现异步渲染DOM</li>
<li>采用新的Fiber架构，同时影响到React的整个生命周期，主要是在更新阶段的生命周期</li>
</ul>
<p>后续深入了解请看第二篇章《从React中学习Fiber架构(二)》。</p>
<h1 id="额外话题（Vue-js对比）"><a href="#额外话题（Vue-js对比）" class="headerlink" title="额外话题（Vue.js对比）"></a>额外话题（Vue.js对比）</h1><p>相比较React做Fiber架构优化，主要是针对事件做了时间分片，那么为什么Vue3(Vue@next)版本并不需要做呢？Vue.js作者尤雨溪是这样子回答的：</p>
<blockquote>
<p>尤雨溪：在 Web 应用中，「可中断式更新」主要是由大量 CPU 计算加上复杂 DOM 操作引起的。时间分片旨在让应用在 CPU 进行大量计算时也能与用户交互，但时间分片只能对大量 CPU 计算进行优化，无法优化复杂 DOM 操作，因为要确保用户正在操作的界面是最新的状态才行。因此，我们可以考虑两种不同的可中断式更新的场景：</p>
<ol>
<li>CPU 计算量不大，但 DOM 操作非常复杂（比如说你向页面中插入了十万个节点）。这种场景下不管你做不做时间分片，页面都会很卡。</li>
<li>CPU 计算量非常大。理论上时间分片在这种场景里会有较大收益，但是人机交互研究表明，除了动画之外，大部分用户不会觉得 10 毫秒和 100 毫秒有很大区别。<br>也就是说，时间分片只在 CPU 需要连续计算 100 毫秒以上的情况下才有较大收益。有意思的地方就出现了，在 React 经常会出现 100 毫秒以上的计算量，因为</li>
<li>Fiber 架构的复杂性导致 React 的虚拟 DOM 协调效率较低，这是系统性的问题。</li>
<li>React 使用 JSX 导致它的渲染效率比 template 低，因为 template 很容易做静态分析和优化。</li>
<li>React Hooks 将大部分组件树的优化 API 暴露给开发者，开发者很多时候需要手动调用 useMemo 来优化渲染效率。这意味着 React 应用默认就有 render 过多的问题。更严重的是，这些优化在 React 里很难自动化。</li>
<li>这些优化要求开发者正确设置依赖数组</li>
<li>盲目添加 useMemo 会导致应该 render 的没 render。<br>很不幸，大部分开发者都很懒，不会在每个地方都加上优化，因此大部分 React 应用都会有大量的没必要的 CPU 计算工作。<br>对比较而言，Vue 解决了上述问题：</li>
<li>Vue 的架构里没有时间分片，也就没有 Fiber，因此简单了很多，这使得渲染可以更快。</li>
<li>Vue 通过分析 template、简化协调过程，做了大量的 AOT 优化，性能测试结果表明大部分的 DOM 内容有 80% 属于静态内容，因此 Vue 3 的协调速度比 Svelte 快，花费的时间比 React 的 1/10 还少。</li>
<li>通过数据响应式追踪，Vue 可以做到组件树级别的优化，比如把插槽编译为函数以避免 children 的变化引发 re-render，比如自动缓存内联事件处理函数以避免 re-render。Vue 3 可以做到在不借助开发者的任何手动优化的情况下，防止子组件在非必要的情况下 re-render。这意味着同样一次更新，React 应用可能要 re-render 多个组件，而 Vue 应用很可能只 re-render 一个组件。<br>因此，在默认情况下，Vue 3 应用会比 React 应用少花费很多 CPU 时间，因而遇到 CPU 连续计算时间超过 100 毫秒的机会相当少，除非是极端情况。但大部分极端情况是 DOM 操作过于复杂，而不是 CPU 计算量太大。</li>
</ol>
</blockquote>
<p>进行汇总一下描述，Vue3之所以没有使用Fiber架构，主要有以下几个原因：</p>
<ol>
<li>Vue.js针对template渲染机制做了多重优化，包括AOT优化(在构建的时候提前进行编译，提前将template转义成render函数)等，使得DOM元素渲染更快</li>
<li>复杂DOM渲染出现超过100ms以上的计算，是因为React本身机制导致，并不是所有复杂的DOM渲染都会需要100ms</li>
<li>React Hook的暴露增加渲染效率的复杂度，从而导致React渲染更慢，从而需要Fiber架构去协调</li>
<li>Vue数据响应式追踪机制，避免了多次重复render组件树，提高渲染效率</li>
<li>Vue使用Fiber架构去实现，确实可以有好处，但是会增加整体代码体积和复杂度，投入产出比太低</li>
</ol>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="AOT-vs-JIT"><a href="#AOT-vs-JIT" class="headerlink" title="AOT vs JIT"></a>AOT vs JIT</h3><ul>
<li>AOT，Ahead Of Time，提前编译或预编译，宿主环境获得的是编译后的代码，在浏览器中我们可以直接下载并运行编译后的代码，比如：Vue的template是通过Vue-loader编译后才能使用。</li>
<li>JIT，Just In Time，即时编译 ，代码在宿主环境编译并执行，每个文件都是单独编译的，当我们更改代码时不需要再次构建整个项目，比如：React中JSX只有在浏览器运行的时候才知道具体代码。</li>
</ul>
]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>从Z-Library到了解IPFS去中心化技术</title>
    <url>/today/20230116.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近想下载一些免费的电子书，然后找到一个推荐的网站，说是去中心化图书馆，利用去中心化，可以永久有效的，就是<code>Z-Library</code>，因此觉得挺有趣，所以适合简单研究一下。</p>
<h1 id="Z-Library"><a href="#Z-Library" class="headerlink" title="Z-Library"></a>Z-Library</h1><blockquote>
<p>Z-Library（简称Z-Lib，前身为BookFinder）是一个影子图书馆和开放获取文件分享计划，用户可在此一网站上下载期刊文章以及各种类型的书籍。根据Z-Library的说法，截至2022年6月12日，其共收录了10,456,034本书和84,837,646篇文章[1]。Z-Library在其电子书搜索页面上宣称自己是“全球最大的数字图书馆”[2]，并在文章搜索页面上称自身是“全球最大的科学文章存储库”[3]。它原是创世纪图书馆的镜像网站，并从该图书馆获得大部分馆藏。但它的一些馆藏由用户自行上载，并且不为创世纪图书馆所收藏[4]。该平台公开网域已于2022年11月3日遭到美国政府屏蔽。</p>
</blockquote>
<p>ZLibrary虽然是一个俄国网站，但它拥有16种语言版本可供选择，下滑至网页末尾，即可切换语言。</p>
<p>访问地址：<a href="https://zlib.cydiar.com/" target="_blank" rel="noopener">https://zlib.cydiar.com/</a><br>访问地址：<a href="https://bk.hallowlib.org/" target="_blank" rel="noopener">https://bk.hallowlib.org/</a> 国内备用网址</p>
<a id="more"></a>
<h2 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h2><p>除了上述提供的网址后，可以在里面访问直接跳转下载，但是同时也提供了IPFS节点下载地址。具体如下图：</p>
<p><img src="/assets/img/20230116.png" alt></p>
<h2 id="IPFS下载"><a href="#IPFS下载" class="headerlink" title="IPFS下载"></a>IPFS下载</h2><p>需要在本地搭建IPFS节点，才可以正常文件，但是国内经常会访问不了，所以不建议搭建，因此只是简单了解一下背后技术即可。</p>
<p>接下来具体讲解一下什么是IPFS。</p>
<h1 id="IPFS"><a href="#IPFS" class="headerlink" title="IPFS"></a>IPFS</h1><blockquote>
<p>星际文件系统(InterPlanetary File System). IPFS 是一个分布式的web, 点到点超媒体协议. 可以让我们的互联网速度更快, 更加安全, 并且更加开放. IPFS协议的目标是取代传统的互联网协议HTTP。</p>
</blockquote>
<p>HTTP协议的缺陷：</p>
<ul>
<li>使用HTTP协议每次需要从中心化的服务器下载完整的文件</li>
<li>Web文件经常被删除</li>
<li>经常受各种限制，导致文件无法正常下载</li>
</ul>
<p>IPFS是一个协议，类似http协议，主要定义了：</p>
<ul>
<li>定义了基于内容的寻址文件系统</li>
<li>内容分发</li>
<li>使用的技术分布式哈希、p2p传输、版本管理系统</li>
<li>可以像http那样查看互联网页面</li>
<li>IPFS是一个文件系统，有文件夹和文件，可挂载文件系统</li>
<li>未来浏览器可以直接支持 ipfs:/ 或者 fs:/ 协议</li>
</ul>
<p>底层架构介绍：</p>
<ul>
<li>IPFS是模块化的协议， 分为连接层、路由层、数据块交换</li>
<li>连接层：通过其他任何网络协议连接</li>
<li>路由层：寻找定位文件所在位置</li>
<li>数据块交换：采用BitTorrent技术</li>
<li>p2p系统：世界范围内的p2p文件传输网络</li>
<li>是一个CDN，文件添加到IPFS网络，将会在全世界进行CDN加速</li>
<li>IPNS：基于SFS（自认证系统）命名体系，可以和现有域名系统绑定</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>IPFS主要是使用go语言实现的，目前主流的IPFS实现有几个框架，具体如下：</p>
<ul>
<li><a href="https://github.com/ipfs/kubo" target="_blank" rel="noopener">go-ipfs</a></li>
<li><a href="https://github.com/ipfs/js-ipfs" target="_blank" rel="noopener">js-ipfs</a></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Z-Library是一个去中心化的图书馆，大家都有各自的节点维护自己的个人图书，也可以从其他节点去下载，降低现有web文件存储的缺陷。</p>
<p>而IPFS的出现刚好可以满足这个理想目标，IPFS是一个协议，同时已经有现有框架go-ipfs去快速搭建个人的IPFS节点，所以能够很快体验一下去中心化体验，但是很多时候由于网络问题，并不能很快完成书籍的下载。</p>
<p>虽然IPFS同时实现HTTP协议，但是访问其他节点的时候是有网络访问速度问题，因此体验不是特别好，但是新的技术概念还是需要时间去沉淀和学习，留此文章做个mark，继续保留学习的态度。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/ipfs/ipfs-desktop/releases" target="_blank" rel="noopener">IPFS下载桌面端</a><br><a href="https://cloud.tencent.com/developer/article/1815072" target="_blank" rel="noopener">IPFS搭建HTTPS去中心化网站，真实可用</a></p>
]]></content>
      <tags>
        <tag>每日更新</tag>
        <tag>技术探鲜</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端适配方案总结</title>
    <url>/today/20230111.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>由于自己太久没开发移动端的页面，个人觉得移动端开发相比较PC端开发最大的不同，在于需要去适配各种尺寸的手机屏幕，尤其还有1px的问题。</p>
<p>因此需要再次收集一下，除了自己认知(rem适配)以外，是否还有移动端适配的方案吗？</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>移动端存在几类问题，如下所列：</p>
<ul>
<li>1px显示过粗问题</li>
<li>手机屏幕出现刘海屏、滴水屏等，如何适配</li>
<li>如何在不同屏幕，显示正确高清图片</li>
<li>meta 的 viewport 值 能否用来适配</li>
<li>rem，vw，vh计算单位的区别</li>
<li>…</li>
</ul>
<a id="more"></a>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h2><blockquote>
<p>像素是计算机屏幕上所能显示的最小单位。用来表示图像的单位。</p>
</blockquote>
<p>按照我个人理解，把屏幕比做一张白纸，然后像素就是一个点，接着同一水平线上的点形成一条线，水平线和垂直线同时就形成一个画面。</p>
<p>然后对于我们前端开发而言，像素又需要分成几类：</p>
<ul>
<li><code>设备独立像素</code>, 俗称<code>DIP</code>，你可以理解成我们平时用css像素 又等于 逻辑像素，简单说就是同一个尺寸的屏幕，设备独立像素是一样的，从而减少误解</li>
<li><code>物理像素</code>，其实就是我们真实肉眼可见的像素，物理像素 = 分辨率</li>
<li><code>设备像素比</code>， <code>DPR</code> <code>devicePixelRatio</code> = 设备像素 / 设备独立像素，当物理像素和设备独立像素不一样的时候，这个时候就需要一个标准来做适配，利用<code>DPR</code>我们能将同样的画面适应不同的屏幕</li>
<li><code>每英寸像素</code> <code>ppi</code> （pixel per inch），表示每英寸所包含的像素点数目，更确切的说法应该是像素密度。数值越高，说明屏幕能以更高密度显示图像</li>
</ul>
<h2 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h2><blockquote>
<p>分辨率指屏幕上像素的数目，一般用水平<em>垂直，比如：屏幕分辨率为 800</em> 600， 水平有800个像素点，垂直有600个像素</p>
</blockquote>
<p>所以平时我们将2k、4k屏幕，通常指的是水平方向的存放像素超过2000或4000个。</p>
<h2 id="视口（viewport）"><a href="#视口（viewport）" class="headerlink" title="视口（viewport）"></a>视口（viewport）</h2><blockquote>
<p>视口代表当前可见的计算机图形区域。在 Web 浏览器术语中，通常与浏览器窗口相同，但不包括浏览器的 UI，菜单栏等——即指你正在浏览的文档的那一部分。<br>视口一般是指用户访问页面时，当前的可视区域范围。通过滚动条滑动，视口可以显示页面的其他部分。<br>通过 document.documentElement.clientWidth 或 window.innerWidth 可以获取视口宽度。</p>
</blockquote>
<p>简单的说，视口就是浏览器肉眼可见的区域，是随时可变化，视口是一个概念，它又可以根据不同情况分为以下几种：</p>
<ul>
<li>布局视口，对于开发来说的一种视口概念，在移动端可以通过 <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=980, initial-scale=1.0&quot;&gt;&lt;/meta&gt;</code>调整从而将打屏显示的内容完整缩小适配到移动端小屏</li>
<li>视觉视口，是一种针对移动端屏幕提出来的概念，具体是指的屏幕的可见区域，当键盘弹起、浏览器工具栏隐藏等，视觉视口都会随之变化，而布局视口不会</li>
</ul>
<h2 id="布局视口（layout-viewport）"><a href="#布局视口（layout-viewport）" class="headerlink" title="布局视口（layout viewport）"></a>布局视口（layout viewport）</h2><blockquote>
<p>innerHeight 和 innerWidth 所组成的区域通常被认为是布局视口（layout viewport）。浏览器的框架不被认为是视口的一部分。</p>
</blockquote>
<p>在PC端的时候， 视口=布局视口=视觉视口。</p>
<p>在移动端的时候，布局视口 = 内容宽度，可以通过<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=980, initial-scale=1.0&quot;&gt;&lt;/meta&gt;</code>调整，下面举几个例子(移动端为375*667)：</p>
<ul>
<li><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=980, initial-scale=1.0&quot;&gt;&lt;/meta&gt;</code>， 布局视口=window.innerWidth=980</li>
<li><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;/meta&gt;</code>, 布局视口=window.innerWidth=375</li>
</ul>
<h2 id="视觉视口（visual-viewport）"><a href="#视觉视口（visual-viewport）" class="headerlink" title="视觉视口（visual viewport）"></a>视觉视口（visual viewport）</h2><blockquote>
<p>视觉视口指当前浏览器中可见的部分，并且可以变化。当使用双指缩放，或键盘在手机上弹出的时候，或者之前隐藏的地址栏变得可见的时候，视觉视口缩小了，但是布局视口却保持不变。</p>
</blockquote>
<p>相比较<code>布局视口</code>概念，视觉视口是由苹果 乔布斯提出，为了更好的在移动端展示web网页，视觉视口=屏幕的可见区域，下面通过几个例子去认知(移动端为375*667)：</p>
<ul>
<li><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=980, initial-scale=1.0&quot;&gt;&lt;/meta&gt;</code>，视觉视口=window.screen.width=375</li>
<li><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;/meta&gt;</code>，视觉视口=window.screen.width=375</li>
</ul>
<h2 id="viewport设置项"><a href="#viewport设置项" class="headerlink" title="viewport设置项"></a>viewport设置项</h2><p><code>viewport</code>的设置主要是在移动端配置视口大小，从width宽度，initial-scale缩放等设置属性，具体如下：</p>
<ul>
<li>width：控制 viewport 的大小，可以给它指定一个值(正整数)，或者是一个特殊的值(如：device-width 设备独立像素宽度，单位缩放为 1 时)；</li>
<li>initial-scale：初始缩放比例，即当页面第一次加载时的缩放比例，为一个数字(可以带小数)；</li>
<li>maximum-scale：允许用户缩放到的最大比例，为一个数字(可以带小数)；</li>
<li>minimum-scale：允许用户缩放到的最小比例，为一个数字(可以带小数)；</li>
<li>user-scalable：是否允许用户手动缩放，值为 “no”(不允许) 或 “yes”(允许)；</li>
<li>height：与 width 相对应(很少使用)。</li>
</ul>
<h2 id="注意项"><a href="#注意项" class="headerlink" title="注意项"></a>注意项</h2><ul>
<li>iframe的视口等于是其内部高度和宽度的大小。</li>
<li>SVG的视口即 SVG 图片的可视区域。</li>
</ul>
<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p>这些兼容方案都是基于视口不缩放配置才能生效：<br><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;/meta&gt;</code></p>
<p>目前市面主流的几种适配方案如下：</p>
<ul>
<li><code>rem</code> ，通过一个宽度尺寸作为统一的单位值，然后通过js计算出不同尺寸对比值，得到适配效果</li>
<li><code>vw</code> ，一个浏览器支持的单位，利用 CSS 视窗的特性，总宽度为 100vw，每一份为一个单位 1vw，设置 1rem 单位为 10vw</li>
<li><code>px + calc + clamp</code>，大漠在2021年提出，根据 CSS 的新特性：css变量、calc()函数、clamp()、@container函数实现</li>
</ul>
<h2 id="rem方案"><a href="#rem方案" class="headerlink" title="rem方案"></a>rem方案</h2><p><code>rem</code>是指的html元素的<code>font-size</code>的大小，如：<code>html{font-size:50px}; 1rem=50px</code>。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>通过一个具体的例子，更好理解它的原理。比如你拿到一张设计稿为750px宽度的，里面有个长方形为100*200，这个时候需要在不同屏幕去做适配。</p>
<p>rem的解决方案思路为：</p>
<ul>
<li>将标准尺寸宽度 750/10= 75px，设置:<code>html{font-size:75px} 1rem=75px</code></li>
<li>将长方形的 100*200，100/75 * 200/75，设置为：<code>.rectangle{width: 1.33rem;height:2.66rem}</code></li>
<li>那么当屏幕的尺寸发生变话的时候， 变成从750减少为375，那么这个时候，设置: <code>html{font-size:37.5px} 1rem=37.5px</code></li>
<li>长方形的css设置无需变化，从而达到适配的效果</li>
<li></li>
</ul>
<p>所以rem的解决方案就是在web应用在加载的时候，提前计算好rem单位，所以就可以完成适配。</p>
<p>目前主流的方案有：</p>
<ul>
<li><a href="https://github.com/amfe/lib-flexible" target="_blank" rel="noopener">flexible</a></li>
<li><a href="https://github.com/songsiqi/px2rem" target="_blank" rel="noopener">px2rem</a></li>
</ul>
<p>源码实现：</p>
<p><a href="/code/h5-shipei/flexible.js">h5-shipei.js</a></p>
<p>PS: 里面涉及到<code>pageshow</code>事件，基本上是因为移动端缓存了web页面，当浏览器历史记录前进或后退的是会触发，可以通过<code>e.persisted</code>判断是否从缓存获取</p>
<p>缺点：</p>
<ul>
<li>需要前置js才能实现，根据设备的视窗宽度进行计算，影响性能</li>
<li>在 PC 端浏览破相，一般设置一个最大宽度</li>
</ul>
<h2 id="vw方案"><a href="#vw方案" class="headerlink" title="vw方案"></a>vw方案</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>vw是css的一种计算单位，定义： </p>
<blockquote>
<p>1vw 等于1/100的视口宽度 （Viewport Width）</p>
</blockquote>
<p>同理vh也是:</p>
<blockquote>
<p>1vh 等于1/100的视口高度 （Viewport Height）</p>
</blockquote>
<p>那么vmax，vmin，我在网上找到比较好解释如下：</p>
<blockquote>
<p>vmin — vmin的值是当前vw和vh中较小的值。<br>vmax — vw和vh中较大的值。<br>在横竖屏的切换中，十分有用。</p>
</blockquote>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>了解到vw的概念，那么如何利用vw去解决移动端的适配呢？其实和rem方案是一样，具体代码可以如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* rem 方案 */</span></span><br><span class="line"><span class="selector-tag">html</span> &#123; <span class="attribute">font-size</span>: width / <span class="number">100</span>&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123; <span class="attribute">width</span>: <span class="number">26.67rem</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* vw 方案 */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123; <span class="attribute">width</span>: <span class="number">26.67vw</span> &#125;</span><br></pre></td></tr></table></figure>

<p>已实现的框架方案如下：</p>
<p><a href="https://github.com/evrone/postcss-px-to-viewport/blob/master/README_CN.md" target="_blank" rel="noopener">postcss-px-to-viewport</a></p>
<p>利用打包编译过程，将设置好的px单位转换为vw或vh，具体使用可以看使用文档。</p>
<p>缺点：</p>
<ul>
<li>和rem一样，容易在pc端适配错误，可以用@media媒体查询去做样式兼容</li>
</ul>
<p><strong>后续添加</strong></p>
<p>如果利用flex/grid布局，加上vw、vh单位，是否可以做到自适应布局呢？</p>
<p>答案是肯定，而且相对而言会比其他方案，会更加容易开发些，实现步骤如下：</p>
<ul>
<li>利用flex弹性布局，加上vw设置flex弹性盒子的宽度，从而做到不同宽度屏幕，是否换行或者垂直布局</li>
</ul>
<p>后续可以专门写个文章用来描述flex布局的原理。</p>
<h2 id="px-calc-clamp"><a href="#px-calc-clamp" class="headerlink" title="px + calc + clamp"></a>px + calc + clamp</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p><code>calc()</code> 此 CSS 函数允许在声明 CSS 属性值时执行一些计算。 支持  + ， - ， / ,* 等运算。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* property: calc(expression) */</span></span><br><span class="line"><span class="selector-tag">width</span>: <span class="selector-tag">calc</span>(100% <span class="selector-tag">-</span> 80<span class="selector-tag">px</span>);</span><br></pre></td></tr></table></figure>

<p><code>clamp()</code> 函数的作用是把一个值限制在一个上限和下限之间，当这个值超过最小值和最大值的范围时，在最小值和最大值之间选择一个值使用。它接收三个参数：最小值、首选值、最大值。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">font-size</span>: <span class="selector-tag">clamp</span>(1<span class="selector-tag">rem</span>, 2<span class="selector-class">.5vw</span>, 2<span class="selector-tag">rem</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>当<code>2.5vw</code>大于<code>2rem</code>，使用2rem</li>
<li>当<code>2.5vw</code>小于<code>1rem</code>，使用1rem</li>
<li>其他使用<code>2.5vw</code>单位</li>
</ul>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>了解到上面css两个函数，如果通过只用px单位去做适配呢？原理步骤如下：</p>
<ul>
<li>假设我们拿到的设计稿750px宽度，那么这个时候有个长方体是200*100</li>
<li>利用css变量，设置一个首先值，然后计算出去其他尺寸所需的最大值、最小值，设置clamp()</li>
<li>同时利用calc()去计算偏差值</li>
</ul>
<p>缺点：</p>
<ul>
<li>calc 和clamp 函数在浏览器支持度还不够</li>
<li>需要了解这套方案还需要较深的技术方案</li>
</ul>
<h1 id="1px高清显示问题"><a href="#1px高清显示问题" class="headerlink" title="1px高清显示问题"></a>1px高清显示问题</h1><p>1像素问题： 1像素指在 Retina 屏显示 1单位物理像素</p>
<ul>
<li>DPR = 1，此时 1 物理像素 等于 1 CSS 像素</li>
<li>DPR = 2，此时 1 物理像素等于 0.5 CSS 像素</li>
<li>border-width: 1px，这里的 1px 其实是 1 CSS 像素宽度，等于 2 物理像素，设计师其实想要的是 border-width: 0.5px<br>DPR = 3，此时 1 物理像素等于 0.33 CSS 像素。设计师想要的是 border-width: 0.33px</li>
</ul>
<p>解决方案：</p>
<ul>
<li>渐变实现 ： background-image: linear-gradient(to top, ,,,)</li>
<li>使用缩放实现：transform: scaleY(0.333)</li>
<li>使用图片实现：base64</li>
<li>使用 SVG 实现：嵌入 background url</li>
<li>border-image，低端机下支持度不好</li>
</ul>
<p>以上方案都是基于媒体查询解决的</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">media</span> only screen and (-webkit-min-device-pixel-ratio: <span class="number">2</span>),</span><br><span class="line">    only screen and (min-device-pixel-ratio: <span class="number">2</span>) &#123;&#125;</span><br><span class="line">@<span class="keyword">media</span> only screen and (-webkit-min-device-pixel-ratio: <span class="number">3</span>),</span><br><span class="line">    only screen and (min-device-pixel-ratio: <span class="number">3</span>) &#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h1><blockquote>
<p>媒体查询（Media queries）非常实用，尤其是当你想要根据设备的大致类型（如打印设备与带屏幕的设备）或者特定的特征和设备参数（例如屏幕分辨率和浏览器视窗宽度）来修改网站或应用程序时。</p>
</blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>一般有几种用法，如下所示：</p>
<ul>
<li>通过 <code>@media</code> 和 <code>@import at-rules</code> 用CSS 装饰样式</li>
<li>用 <code>media=</code> 属性为<code>&lt;style&gt;, &lt;link&gt;, &lt;source&gt;</code>和其他HTML元素指定特定的媒体类型</li>
<li>使用<code>Window.matchMedia()</code>和 <code>MediaQueryList.addListener()</code> 方法来测试和监控媒体状态</li>
</ul>
<p>CSS装饰样式用法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen, print &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>HTML元素引入</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">src</span>=<span class="string">"styles.css"</span> <span class="attr">media</span>=<span class="string">"screen"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">src</span>=<span class="string">"styles.css"</span> <span class="attr">media</span>=<span class="string">"print"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>js用法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mql = <span class="built_in">window</span>.matchMedia(<span class="string">'(max-width: 600px)'</span>);</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">".mq-value"</span>).innerText = mql.matches;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mql = <span class="built_in">window</span>.matchMedia(<span class="string">'(max-width: 600px)'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">screenTest</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.matches) &#123;</span><br><span class="line">    <span class="comment">/* the viewport is 600 pixels wide or less */</span></span><br><span class="line">    para.textContent = <span class="string">'This is a narrow screen — less than 600px wide.'</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.style.backgroundColor = <span class="string">'red'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* the viewport is more than than 600 pixels wide */</span></span><br><span class="line">    para.textContent = <span class="string">'This is a wide screen — more than 600px wide.'</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.style.backgroundColor = <span class="string">'blue'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mql.addListener(screenTest);</span><br></pre></td></tr></table></figure>

<h1 id="图片高清问题"><a href="#图片高清问题" class="headerlink" title="图片高清问题"></a>图片高清问题</h1><p>图片高清问题，一般是指的：不同 DPR 下图片的高清解决方案。</p>
<p>这种问题解决方案，通常是利用媒体查询+提供不同尺寸的图片去显示。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>移动端适配方案，结合开发中，大家都是直接写px，然后利用编译过程的进行转换，比如: <code>px2rem</code> ，<code>px2vw</code>。</p>
<p>再就是排版问题，不同屏幕问题需要做自动排版优化方案，这个需要后面去研究一下<a href="https://news.sangniao.com/p/1729687518" target="_blank" rel="noopener">《如何正确的使用 CSS Clamp 进行响应式排版》</a>。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>从egg.js转到nest.js</title>
    <url>/today/20230110.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>进入部门工作后，接触到的node.js服务端框架，是egg.js，后面基于扩展增加了很多插件，比如：@Controller @Service等注解，还有针对egg-framework 定制化部门使用的底层framework。</p>
<p>但是，随着时间的迁移，egg已经不太能满足我们的开发效率和开发模式，主要有以下几点：</p>
<ul>
<li>对typescript支持度不够，这是由于egg.js本身就不是typescript开发</li>
<li>egg.js封装web架构，约定大于编码，如：强制将web应用分级为： controller、service、middleware、extend等，自由度相对比较弱，当你需要定制化开发内容，你需要深入了解egg.js的整个运行原理才能实现</li>
<li>虽然部门内部定制化开发 @Controller @Service等注解，减少路由配置，但是这一块插件还存在一些隐藏规则，需要开发注意</li>
</ul>
<p>当然egg.js运行的web应用还是比较稳定，而且相关插件生态也比较丰富，只是当egg.js迭代更新速度在2020年后就逐步放缓，更不上变化，我们就需要迎接一些新的框架来满足要求。</p>
<h1 id="框架对比"><a href="#框架对比" class="headerlink" title="框架对比"></a>框架对比</h1><p>我从近两年听到或者网上收集的，基于Node.js的框架主要有以下几个：</p>
<ul>
<li>基础框架，基本上还是以express、koa、Fastify.js等为主</li>
<li>egg.js，以MVC为架构的web框架</li>
<li>nest.js，以Ioc 控制反转作为核心概念的web框架，对typescript支持友好</li>
<li>nuxt.js，以Vue.js作为SSR服务端渲染核心的web框架，最新是Nuxt3（以Vue3为核心）</li>
<li>next.js，以React.js作为SSR服务端渲染核心的</li>
<li>Meteor.js，full-stack javascript平台，最大的特点是当数据发生改变的时候，所有依赖该数据的地方自动发生相应的改变。</li>
<li>Fastify.js，号称最快的node.js web框架，特点是内置了基于 JSON schema 的 validation 和 serialization，比JSON.stringify还快的json序列化算法，虽然是借助借助第三方库 ajv。</li>
<li>strapi.js，快速生成API接口的web框架，同时实现各种后端所需要的鉴权、权限、文件上传等轮子</li>
</ul>
<a id="more"></a>

<p>对比一下，我们主要用来开发后端api接口，不需要SSR，不需要过于重或过于轻量的框架，因此最后挑选了nest.js。</p>
<h1 id="nest-js"><a href="#nest-js" class="headerlink" title="nest.js"></a>nest.js</h1><blockquote>
<p>Nest (NestJS) 是一个用于构建高效、可扩展的Node.js服务器端应用程序的框架。它使用渐进式 JavaScript，构建并完全支持TypeScript（但仍然允许开发人员使用纯 JavaScript 进行编码）并结合了 OOP（面向对象编程）、FP（函数式编程）和 FRP（函数式响应式编程）的元素。</p>
</blockquote>
<p>术语介绍：</p>
<ul>
<li>什么是渐进式？简单说，就一开始你不需要了解它的全部功能，能快速上手，有些功能特性不用也可以正常使用。</li>
<li>OOP 面向对象编程，万物皆可用对象来描述，如： <code>class Dog{ say(return &#39;one one!&#39;)}</code></li>
<li>FP 函数式编程，以函数作为入口，而不是去声明一个对象类，如： <code>say(&#39;one one!&#39;)</code></li>
<li>RP 响应式编程，一种面向数据流和变化传播的编程范式，如：<code>a = 5; b=6; c=a+b;</code> 当<code>a</code>或<code>b</code>变化的时候，<code>c</code>会随之变化</li>
<li>FRP 函数式响应式编程，依赖数据流的函数式编程，如：<code>str=&#39;one one~&#39;; say(str)</code>， 当<code>str</code>变化，会自动触发<code>say</code></li>
</ul>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>Nest.js的核心是基于IoC控制反转 + DI 依赖注入 去实现类的声明和实例化的。如果你了解过Spring Boot其实很容易上手nest.js。</p>
<h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>Module 其实是nest.js用来将一个web应用拆分成各个子模块的分类规定，web应用根模块一般叫<code>app.module.ts</code>，官方设计图如下：</p>
<p><img src="https://docs.nestjs.com/assets/Modules_1.png" alt></p>
<p>Module应该由以下几个部分组成：</p>
<ul>
<li>providers： 允许交给模块实例化的类，包括不限于Service等</li>
<li>controllers：必须实例的controller类</li>
<li>imports： 模块依赖其他模块</li>
<li>exports：模块对外提供的方法类</li>
</ul>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>Controller就一个作用，分割路由，调用处理方法，返回http请求结果。</p>
<p><img src="https://docs.nestjs.com/assets/Controllers_1.png" alt></p>
<p>支持写法：</p>
<ul>
<li><code>@Controller(&#39;test&#39;)</code></li>
<li><code>@Get()</code> <code>@Post()</code> <code>@Put()</code> <code>@Del()</code>代表各种请求方法(http Method)</li>
<li>还支持一些特殊写法： <code>@Session()</code>  <code>@Body(key?: string)</code> <code>@Param(key?: string)</code></li>
</ul>
<h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><p>Provider其实就是不仅仅是Service层，还包括：Sql的Dao层、工具方法等提供。它和其他层关系如下图：</p>
<p><img src="https://docs.nestjs.com/assets/Components_1.png" alt></p>
<p>写法：</p>
<ul>
<li><code>@Injectable()</code> 声明该类是一个Provider，允许其他类实现依赖注入</li>
<li><code>@Optional()</code> 允许构造不传</li>
<li><code>@Inject()</code> 自动依赖注入</li>
</ul>
<h2 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a>Middleware</h2><p>Middleware中间件，其实和egg.js的中间件概念一样，就是当http请求来了之后，被中间件处理一遍之后才会到对应的Controller层。</p>
<p><img src="https://docs.nestjs.com/assets/Middlewares_1.png" alt></p>
<p>写法：</p>
<ul>
<li><code>implements NestMiddleware</code>，必须实现<code>NestMiddleware</code>接口，以及内部方法<code>use(req: Request, res: Response, next: NextFunction)</code>，同时内部方法必须调用<code>next</code></li>
<li>在<code>Module</code>层注册中间件，这里需要可以设置</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module, NestModule, MiddlewareConsumer &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; LoggerMiddleware &#125; <span class="keyword">from</span> <span class="string">'./common/middleware/logger.middleware'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsModule &#125; <span class="keyword">from</span> <span class="string">'./cats/cats.module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  imports: [CatsModule],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule <span class="keyword">implements</span> NestModule &#123;</span><br><span class="line">  configure(consumer: MiddlewareConsumer) &#123;</span><br><span class="line">    consumer</span><br><span class="line">      .apply(LoggerMiddleware)</span><br><span class="line">      .forRoutes(<span class="string">'cats'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>了解 <code>MiddlewareConsumer</code>，中间件消费者工具类，主要把中间件加上一些配置项功能，如：<code>forRoutes</code>支持路由匹配，<code>exclude</code>不包含路由</li>
<li>函数式声明中间件，因为Middleware是基于expres，所以写法与express基本上一致</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Request, Response, NextFunction &#125; <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">logger</span>(<span class="params">req: Request, res: Response, next: NextFunction</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Request...`</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="ExceptionFilter"><a href="#ExceptionFilter" class="headerlink" title="ExceptionFilter"></a>ExceptionFilter</h2><p>Filter过滤器，这个应该是所有web框架都具备的功能，拦截用户请求和web返回数据。在Nest.js中，只实现ExeptionFilter，你也可以基于这个去自定义自己的异常过滤器，具体如下图：</p>
<p><img src="https://docs.nestjs.com/assets/Filter_1.png" alt></p>
<p>写法：</p>
<ul>
<li><code>@Catch(HttpException) class HttpExceptionFilter implements ExceptionFilter</code> 实现自定义异常过滤器</li>
<li><code>@UseFilters(new HttpExceptionFilter())</code> 能给具体接口包裹上一层自定义的异常过滤器</li>
</ul>
<h2 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h2><p>Pipe 管道流，是指的Http请求里的内容数据流，它支持数据验证、数据转换等功能，有点类似Filter的功能。</p>
<p>写法：</p>
<ul>
<li><code>@Param(&#39;id&#39;, ParseIntPipe) id: number</code>，将参数id转换为number类型</li>
<li><code>class ValidationPipe implements PipeTransform</code>自定义 Pipe，同时必须实现方法<code>transform(value: any, metadata: ArgumentMetadata)</code></li>
<li><code>@UsePipes(new Pipe())</code>，支持在controller配置自定义的Pipe</li>
</ul>
<h2 id="Guard"><a href="#Guard" class="headerlink" title="Guard"></a>Guard</h2><p>Guard 守卫，也是处Http请求中的一层特殊中间件，但是与中间件不同的时候，中间件不知道next()是去哪个执行代码，而Guard则可以获取<code>ExecutionContext</code>实例，可以获知整个请求的生命周期和内置内容，通常用来接口登录和权限控制。</p>
<p><img src="https://docs.nestjs.com/assets/Guards_1.png" alt></p>
<p>写法：</p>
<ul>
<li><code>class AuthGuard implements CanActivate</code></li>
<li>必须实现方法<code>canActivate(context: ExecutionContext): boolean | Promise&lt;boolean&gt; | Observable&lt;boolean&gt;</code></li>
<li>注册使用：<code>@UseGuards</code> Controller层使用， <code>app.useGlobalGuards(new RolesGuard());</code> 全局注册</li>
</ul>
<h2 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h2><p>Interceptor是面向切面编程理念影响的概念，它允许你在方法执行前后扩展原有函数功能，如：改变返回结果，扩展基本功能等，常用的场景：添加常规日志。</p>
<p><img src="https://docs.nestjs.com/assets/Interceptors_1.png" alt></p>
<p>写法：</p>
<ul>
<li><code>class LoggingInterceptor implements NestInterceptor</code>,自定义实现</li>
<li><code>intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt;</code>方法实现，同时需要返回对应结果<code>next()</code></li>
<li>注册使用：<code>@UseInterceptors(LoggingInterceptor)</code>可以在类或方法前进行注册， <code>app.useGlobalInterceptors(new LoggingInterceptor());</code>全局注册</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>自定义参数装饰器<code>createParamDecorator</code>，可以从request对象中抽取固定的参数。</li>
<li><code>applyDecorators</code> 可以将多个装饰器 方法合在一起验证，然后形成一个新的注装饰器</li>
</ul>
<p>PS: 装饰器是什么？</p>
<ul>
<li>装饰器在JavaScript中暂时是没有，只有TypeScript才可以实现一种语法糖</li>
<li>装饰器使用 @expression 的形式，其中 expression 必须能够演算为在运行时调用的函数，其中包括装饰声明信息。</li>
<li>自定义装饰器代码如下：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个装饰器工厂——有助于将用户参数传给装饰器声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"f(): evaluated"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"f(): called"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"g(): evaluated"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"g(): called"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> C &#123;</span><br><span class="line">  <span class="meta">@f</span>()</span><br><span class="line">  <span class="meta">@g</span>()</span><br><span class="line">  method() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f(): evaluated</span></span><br><span class="line"><span class="comment">// g(): evaluated</span></span><br><span class="line"><span class="comment">// g(): called</span></span><br><span class="line"><span class="comment">// f(): called</span></span><br></pre></td></tr></table></figure>

<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>Nest.js的生命周期分为三个阶段：初始化、运行和终止，下图详细生命周期的各个子阶段：</p>
<p><img src="https://docs.nestjs.com/assets/lifecycle-events.png" alt></p>
<p>允许监听的生命周期函数：</p>
<ul>
<li><code>onModuleInit()</code>, 模块初始化时候调用</li>
<li><code>onApplicationBootstrap()</code>，所有模块都准备好了，但是在web应用正式启用前会被调用</li>
<li><code>onModuleDestroy()</code>，模块准备被停止</li>
<li><code>beforeApplicationShutdown()</code>, web应用准备被停止之前</li>
<li><code>onApplicationShutdown()</code>，web应用被停止之后，在进程退出之前</li>
</ul>
<h2 id="上手实战"><a href="#上手实战" class="headerlink" title="上手实战"></a>上手实战</h2><h3 id="第一步安装："><a href="#第一步安装：" class="headerlink" title="第一步安装："></a>第一步安装：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm i -g @nestjs/cli</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nest new project-name --strict</span></span><br></pre></td></tr></table></figure>

<h3 id="生成项目结构"><a href="#生成项目结构" class="headerlink" title="生成项目结构"></a>生成项目结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">|-- app.controller.spec.ts // controller层的单元测试</span><br><span class="line">|-- app.controller.ts // controller层 控制路由接口层</span><br><span class="line">|-- app.module.ts // 应用根模块</span><br><span class="line">|-- app.service.ts // service层 给controller提供各种业务处理方法</span><br><span class="line">|-- main.ts // 入口文件</span><br></pre></td></tr></table></figure>

<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yarn</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yarn start:dev</span></span><br></pre></td></tr></table></figure>

<p>打开 <a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a> 就可以访问了。</p>
<p>后面有篇文章叫<a href="/2023/01/22/today/20220122/">《从nest.js中了解Ioc和DI》</a>，大家想了解可以去看看。</p>
]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>对CMDB进行一个系统完整认知</title>
    <url>/today/20230109.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近半年，都在开发部门内部的CMDB平台和申请流程，因此对CMDB有了一定了解，但是又不够系统，所以希望写一篇文章能够系统完整的认知一下CMDB，包括以下几点：</p>
<ul>
<li>是什么</li>
<li>能做什么和怎么做</li>
<li>优秀方案</li>
<li>未来方向</li>
</ul>
<a id="more"></a>
<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><blockquote>
<p>CMDB(Configuration Management Database)，配置管理数据库，主要包含了配置项全生命周期的信息以及配置项之间的关系(包括物理关系、实时通信关系、非实时通信关系和依赖关系)。<br>CMDB存储与管理企业IT架构中设备的各种配置信息，它与所有服务支持和服务交付流程都紧密相联，支持这些流程的运转、发挥配置信息的价值，同时依赖于相关流程保证数据的准确性。<br>CMDB存储目标定义为：配置管理致力于通过维护IT基础设施和IT服务的逻辑模式来协助管理IT服务的经济价值(客户需求、质量和成本的结合)，并将与此相关的信息提供给其他业务流程。它通过识别、监测、控制和提供有关配置项及其版本方面的信息来实现目标。<br>以上描述来自百度百科<a href="https://baike.baidu.com/item/CMDB/5403317" target="_blank" rel="noopener">CMDB</a>。</p>
</blockquote>
<p>按照个人理解，CMDB按照比较容易理解的说法，CMDB主要存储公司内部IT基础架构数据存储和配置，能够数字化IT资产与业务的关联关系。</p>
<p>更加明确的说，CMDB是运维的基础核心系统，包括运维所需要的元数据，同时共享数据管理源。 CMDB存储的数据包括但不限于：</p>
<ul>
<li>逻辑资源，指的是底层物理资源对应的逻辑资源，包括：xxx系统、xxx服务、xxxApp等</li>
<li>物理资源，指的是可供运维人员实际操作的物理资源，包括：服务器(cvm、物理机、容器)，机房、机柜、网络设备、链路资源、配件等</li>
</ul>
<h1 id="能做什么"><a href="#能做什么" class="headerlink" title="能做什么"></a>能做什么</h1><p>上面描述CMDB是什么，CMDB到底能做什么呢？或者它对运维有什么作用呢？</p>
<p>这里需要简单介绍几个概念：</p>
<ul>
<li>ITSM(IT service management), IT服务管理，主要是给用户提供标准流程完成IT资产交付，和管理这些IT流程的系统</li>
<li>ITIL(Information Technology Infrastructure Library)，IT服务管理标准库， 是ITSM最常用的实现方案，侧重于使 IT服务与业务需求保持紧密关联</li>
<li>DevOps由英文 Development（开发）和 Operations（运维）组合而成，是开发和运维紧密结合的思想理念，是开发和运维团队之间的流程能够自动化和持续集成、交付，从开发到交付部署形成一个循环的过程。后面我们会单独抽出一个文章做详细了解。</li>
</ul>
<p>上面的几个概念，只要是IT从业者或多或少都有接触到，那么CMDB在这些系统或者流程中，起到一个数据基石的作用，我们举几个例子：</p>
<ol>
<li>如果没有CMDB的配置数据，ITSM流程对用户(开发)就很难入手，比如要申请一台机器，流程里会有很多IT专用描述，开发无法快速申请流程</li>
<li>如果没有CMDB，那么DevOps中要实现自动化持续集成和交付，开发要将服务部署到哪台机器，运维无法得知</li>
</ol>
<p>那么总结一下，CMDB能做的事情，主要有以下几点：</p>
<ol>
<li>能数字化IT资产，并且提供到IT资产管理一个可靠的参考数据</li>
<li>能帮忙快速完成ISM流程，以及更加有效管理ITSM流程</li>
<li>能将业务与IT资产做关联，实现业务与IT资产的有效管理</li>
</ol>
<h1 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h1><p>明白CMDB能做什么，那么我们应该如何设计一个合理CMDB呢？</p>
<p>首先，市场上已经存在各色各样的CMDB平台，主要有以下几个：</p>
<ul>
<li><a href="https://bk.tencent.com/docs/document/6.0/142/8600" target="_blank" rel="noopener">腾讯蓝鲸平台CMDB配置系统</a>，基于腾讯蓝鲸平台的CMDB配置系统</li>
<li><a href="https://github.com/Combodo/iTop" target="_blank" rel="noopener">ITOP</a>，一个完整的开源，ITIL，基于Web的服务管理工具，包括完全可定制的CMDB，帮助台系统和文档管理工具。</li>
<li>怎么开发CMDB平台这里就不做描述，无非几点：</li>
</ul>
<ol>
<li>可自由配置的CMDB模型的 管理web界面</li>
<li>开发标准API接口（主要模型的CRUD），对第三方工具提供服务</li>
</ol>
<h2 id="模型设计"><a href="#模型设计" class="headerlink" title="模型设计"></a>模型设计</h2><p>一个可维护的CMDB平台，肯定脱离不了前期模型设计，所以一个良好且能够向前兼容的模型设计至关重要，因此我这边简单罗列了一下模型几大类，以及它们之间的关系：</p>
<ul>
<li>业务模型，这里业务模型可以拆分多级，最多三级，因为三级业务树基本上能够满足大部分业务等级拆分</li>
<li>模块模型，模块即是从开发角度去理解的项目粒度，通俗的说，就是一个单独且完整的项目，</li>
<li>设备模型，就是服务器，包括：虚拟机、物理机、容器等</li>
<li>持续集成相关模型，主要包括：CI(持续集成)、CD(持续交付)等模型</li>
<li>网络架构相关模型，主要包括：网络策略、域名、证书等</li>
</ul>
<p>再就是需要设计模型与模型之间的关系，这里会很绕，但是为了让大家更加清晰了解CMDB的设计，这里简单绘画了一下：</p>
<p><img src="/assets/img/cmdb1.svg" alt></p>
<h3 id="模型生命周期"><a href="#模型生命周期" class="headerlink" title="模型生命周期"></a>模型生命周期</h3><p>每个CMDB中模型，都有其生命周期流程，结合ITSM就可以完成实现模型的生命周期状态扭转。</p>
<h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><p>** 在CMDB实现阶段：一定要变成运维和运维研发的共同项目，并且具体的配置项管理人要全程参与，比如说需求讨论、测试、上线验收等等（运维研发项目都可以遵循该模式） **</p>
<h3 id="导致CMDB失败的因素"><a href="#导致CMDB失败的因素" class="headerlink" title="导致CMDB失败的因素"></a>导致CMDB失败的因素</h3><ol>
<li>在复杂流程上消耗太多的时间—我们是创建一个CMDB库，不是一个流程系统。</li>
<li>没有指定配置项负责人—-确保配置项有人专职维护。</li>
<li>目标过大，涵盖太多的功能—-比如说IT采购和预算管理等等。</li>
<li>颗粒度不合适—-配置合理的CMDB的配置项层次和粒度非常重要。</li>
<li>存在组织隔阂—-CMDB是一个集成体系，靠流程中的每一个人通力协作，而不是某个人。</li>
</ol>
<h3 id="导致CMDB成功的因素"><a href="#导致CMDB成功的因素" class="headerlink" title="导致CMDB成功的因素"></a>导致CMDB成功的因素</h3><ol>
<li>业务导向。比如说我们在CMDB的新的系统中实时加入QR码技术，为了降低资产盘点的工作量。</li>
<li>能自动发现就自动发现，降低配置管理的成本，但自动发现的信息不能用来做告警。</li>
<li>配置项的管理员必须全程参与，需求定型、测试及验收等等。</li>
<li>CMDB系统建设完成之后，其他系统必须和他联动。比如说监控、质量、容量等等，用场景驱动配置项的管理。</li>
<li>流程一定要平台化，不要让流程脱离CMDB存在，比如说搞一个OA流程，这个是很致命的。</li>
<li>CMDB要持续演进，特别是云端资源的管理。</li>
<li>配置项和流程必须要文档化，后期要进行CMDB培训。</li>
</ol>
<h1 id="未来规划——自动化-智能化-更安全的运维"><a href="#未来规划——自动化-智能化-更安全的运维" class="headerlink" title="未来规划——自动化/智能化/更安全的运维"></a>未来规划——自动化/智能化/更安全的运维</h1><p>目前绝大部分的CMDB数据都是走运维人工手动录入，是否能够做到自动化，甚至智能化。</p>
<p>让数据自动化主要靠以下几点：</p>
<ol>
<li>建立数据生命周期管理，自动化流程驱动数据更新</li>
<li>与多个运维工具对接，促进数据消费，提高数据流动性</li>
<li>通过规则校验以及人工审计确保及时发现和修复异常数据</li>
</ol>
<p>依托CMDB的数据基石，能让运维走向智能化，运维的价值在于交付能力，主要：</p>
<ol>
<li>开发能够随时交付，无需运维过多参与，自动化运维</li>
<li>实时监控，智能化告警，提前告知开发进行预警</li>
<li>服务异常自愈，依托CMDB数据，能够自动重启服务完成服务异常自愈</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>CMDB其实就是一个数据管理平台，开发技术上难度不大，最大难度在于数据，以下几点：</p>
<ul>
<li>第一要保证数据的准确性</li>
<li>第二要能快速自动化获取数据</li>
<li>第三数据模型以及其关联设计，主要完成这三点</li>
</ul>
<p>但是完成CMDB数据后，只是迈开自动化/智能化运维的第一步，后面还需要基于CMDB去完成整个DevOps流程自动化/智能化。</p>
]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在页面展示数学公式之Latex语法</title>
    <url>/today/20230108.html</url>
    <content><![CDATA[<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>最近在做markdown 算法文章分享，算法肯定会涉及到数学复杂度，比如: $$ O(log_nX) $$ 等数学公式的展示，但是如果写成这样子<code>lognX</code>，估计很难准确表达，因此上网搜索了一下数学表达式在前端页面如何展示的相关技术。</p>
<h1 id="web-数学表达式展示解决方案"><a href="#web-数学表达式展示解决方案" class="headerlink" title="web 数学表达式展示解决方案"></a>web 数学表达式展示解决方案</h1><p>一般需要在web页面展示数学表达式相关技术，基本上都是在线编辑器，但是markdown也算是一种编辑器语法，所以上网收集了主要以下几种</p>
<ul>
<li>TeX，前期计算机无法生成数学公式排版或者排版很丑，因此<code>Donald E. Knuth</code>设计了一套排版技术，拥有很多计算机的命令或者技术语言</li>
<li>LaTeX，是一种基于TeX的实现排版系统，准确的基于TeX的应用系统，已经封装很多公式模板，直接套用即可</li>
<li>MathJaX，基于LaTeX实现的JavaScript渲染器， 渲染稍慢，支持更多复杂的表示</li>
<li>KaTeX，也基于LaTeX实现的是一个JavaScript库，对比MathJaX，渲染更快，支持若干简写字符，但是本身支持的范围较小</li>
</ul>
<a id="more"></a>

<h1 id="对比说明"><a href="#对比说明" class="headerlink" title="对比说明"></a>对比说明</h1><h2 id="MathJaX"><a href="#MathJaX" class="headerlink" title="MathJaX"></a>MathJaX</h2><blockquote>
<p>MathJaX 是一个适用所有浏览器的展示数学表达式的js引擎。</p>
</blockquote>
<p>官网地址：<a href="https://www.mathjax.org/" target="_blank" rel="noopener">https://www.mathjax.org/</a></p>
<h2 id="KaTex"><a href="#KaTex" class="headerlink" title="KaTex"></a>KaTex</h2><blockquote>
<p>KaTeX 是一个支持在网页上显示 TeX 公式的 JavaScript 库</p>
</blockquote>
<p>通俗的说，Tex就是一种数学公式的排版语言规范，KaTeX是以Tex作为基础语言规范的实现版本。</p>
<p>官网地址：<a href="https://katex.org/" target="_blank" rel="noopener">https://katex.org/</a></p>
<h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><p>快速使用，这里尝试<a href="/code/latex/index.html">demo</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>LaTex公式 demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">integrity</span>=<span class="string">"sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- The loading of KaTeX is deferred to speed up page rendering --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">integrity</span>=<span class="string">"sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- To automatically render math in text elements, include the auto-render extension: --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">integrity</span>=<span class="string">"sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">onload</span>=<span class="string">"renderMathInElement(document.body);"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span> 对数： <span class="tag">&lt;<span class="name">span</span>&gt;</span>$$ log_nX $$<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span> 统计表达式： <span class="tag">&lt;<span class="name">span</span>&gt;</span>$$  \sum_&#123;i=1&#125;^&#123;n&#125;&#123;X_i&#125; $$<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在gitbook中，你只需要添加相关插件即可：</p>
<ul>
<li><code>npm install gitbook-plugin-katex</code>，安装插件</li>
<li>在<code>book.json</code>中的<code>plugins</code>，新增:<code>katex</code></li>
<li>然后就可以在页面中使用语法<code>$$ log_nX $$</code>展示为$$ log_nX $$</li>
</ul>
<p>在hexo等博客，需要以下步骤：</p>
<ul>
<li>找到主题配置文件：<code>themes\landscape\layout\_partial\after-footer.ejs</code>，添加js文件 <code>&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.js&quot;&gt;&lt;/script&gt;</code></li>
<li>找到主题配置文件：<code>themes\landscape\layout\_partial\after-footer.ejs</code>，添加css文件 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css&quot;&gt;</code></li>
<li>后续再安装hexo的katex插件即可 <code>npm install hexo-katex --save</code></li>
</ul>
<h2 id="LaTeX数学公式编写"><a href="#LaTeX数学公式编写" class="headerlink" title="LaTeX数学公式编写"></a>LaTeX数学公式编写</h2><p>简单语法如下：</p>
<ul>
<li><code>$$ log_nX $$</code> 对数表达式 $$ O(log_nX) $$ </li>
<li><code>$$  \sum_{i=1}^{n}{X_i} $$</code> 统计表达式 $$  \sum_{i=1}^{n}{X_i} $$</li>
</ul>
<p>有个在线编辑网站能帮你快速生成公式，请访问<a href="https://www.latexlive.com/##" target="_blank" rel="noopener">Latex公式编辑器</a></p>
<p>如果要想学习更多公式，这里分享一些教程：</p>
<p><a href="https://zhuanlan.zhihu.com/p/110756681" target="_blank" rel="noopener">LaTeX 公式篇</a></p>
<p><a href="https://qyxf.github.io/2020/01/03/latex-formula-beginner" target="_blank" rel="noopener">LaTeX 公式语法速成</a></p>
]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>从npm版本依赖到Monorepo大仓项目</title>
    <url>/today/20230107.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前端的发展很快，自从node.js的出现，打开前端新的大门，npm让js有了自己的包管理能力，能够让前端项目工程化，从而能够处理更加复杂的前端项目。</p>
<p>但是随之而来的是，同一个项目的npm依赖越来越多，有些是开源的，有些是自研的，尤其在同一个团队，当你开发一个新的npm包的时候，只是为了服务特定几个项目，但是这几个项目不在你管理范围内，当你需要更新的时候需要通知到他们，有时候会出现版本依赖问题，然后反复沟通和测试，最终达到协调。但是下次更新的时候又再次遇到这个问题，重复一次。</p>
<h1 id="npm依赖"><a href="#npm依赖" class="headerlink" title="npm依赖"></a>npm依赖</h1><h2 id="npm是什么"><a href="#npm是什么" class="headerlink" title="npm是什么"></a>npm是什么</h2><blockquote>
<p>npm，Node Package Manager的缩写，也就是“Node的包管理器”。<br>npm（“Node 包管理器”）是 JavaScript 运行时 Node.js 的默认程序包管理器。</p>
</blockquote>
<a id="more"></a>

<p>通俗的说，npm是管理js包的工具，它包括以下几个部分：</p>
<ol>
<li>npm源，存放各类npm包的网站，可以注册，上传npm包</li>
<li>npm-cli 命令工具，允许你自由下载任何npm包</li>
</ol>
<h2 id="npm如何管理包"><a href="#npm如何管理包" class="headerlink" title="npm如何管理包"></a>npm如何管理包</h2><p>那么npm是如何管理包的呢？主要项目下<code>package.json</code>对npm进行描述，主要有以下几个属性：</p>
<ul>
<li>name：JavaScript 项目或库的名称。</li>
<li>version：项目的版本。</li>
<li>scripts： 当作在项目本地运行的命令行工具</li>
<li>dependencies：当项目被人依赖的时候，需要安装的npm包，描述：<code>npm包名： npm包版本</code></li>
<li>devDependencies：本地开发的时候，需要安装的npm包，描述：<code>npm包名： npm包版本</code></li>
</ul>
<p>同时<code>package-lock.json</code>文件描述了 npm JavaScript 项目中使用的依赖项的确切版本，确保下次安装项目依赖的npm包升级版本后导致项目无法运行（这个是很多新手安装npm包的时候会遇到的一个错误）。</p>
<h2 id="npm版本"><a href="#npm版本" class="headerlink" title="npm版本"></a>npm版本</h2><p>npm包版本遵循<code>major.minor.patch</code>版本模型规范，什么是<code>major.minor.patch</code>版本模型规范，下面引用一下说明：</p>
<blockquote>
<p>APR版本规范，major是当前的主版本号，minor则是次版本号，patch对应的则是APR的补丁号，同时还有版本所处阶段<code>base</code>, <code>alpha</code>, <code>beta</code>, <code>RC</code>, <code>release</code>。</p>
</blockquote>
<p>因此在package.json描述的依赖npm包的版本号，如:<code>~1.0.0</code>，<code>^1.0.0</code>，几个符号代表的意思如下：</p>
<ul>
<li><code>^</code>：表示最新的次版本，例如， <code>^1.0.4</code>  可能会安装主版本系列  <code>1</code> 的最新次版本 <code>1.3.0</code>。</li>
<li><code>〜</code>：表示最新的补丁程序版本，与  <code>^</code>  类似， <code>〜1.0.4</code>  可能会安装次版本系列 <code>1.0</code>  的最新次版本<code>1.0.7</code>。</li>
</ul>
<h2 id="npm包版本依赖问题"><a href="#npm包版本依赖问题" class="headerlink" title="npm包版本依赖问题"></a>npm包版本依赖问题</h2><p>即使有<code>package-lock.json</code>或者<code>yarn.lock</code>等约束文件解决项目依赖包的版本的问题，但是当项目越来越庞大，拆分的公共npm包越来越多，这些npm管理难度和数量成正比提升，团队需要面临npm包版本问题也越来越多，尤其当<code>微前端</code>概念提出，当大项目被拆分成N个子项目的时候，团队成员需要面临以下几个问题：</p>
<ul>
<li>公共包npm更新了，如何通知到其他子项目依赖的npm包更新版本</li>
<li>子项目有些公共的代码需要抽象到公共一起维护，是抽离成npm包，但是又需要新起一个项目</li>
<li>公共npm越来越多，子项目也越拆越多，如何管理这些项目的开发、测试和持续发布</li>
<li>其他各种开发细节问题…</li>
</ul>
<p>因此，大家迫切需要去一个标准去统一维护管理这些项目，因此<code>Monorepo</code>统一项目管理规范，就是我们的最佳选择。</p>
<h1 id="Monorepo"><a href="#Monorepo" class="headerlink" title="Monorepo"></a>Monorepo</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><blockquote>
<p>Monorepo是包含多个不同项目的单一存储库，具有明确定义的关系。</p>
</blockquote>
<p>通俗的讲，<code>Monorepo</code>就是将几个不同项目放到一个git仓库里，通过制定一个大家遵循的管理规范和子项目之间依赖关系。</p>
<p><code>Monorepo</code>大仓项目与<code>monolithic</code>单体巨石项目还是有很大的区别，下面简单说明：</p>
<ul>
<li>Monorepo !== 单体巨石项目，monorepos 简化了代码共享和跨项目重构，它们显着降低了创建库、微服务和微前端的成本，不需要做到一起发布</li>
<li>能够有效解决子项目与子项目的之间版本依赖关系，而不是单纯将几个项目放在一起形成一堆代码山</li>
</ul>
<p>为了更好的了解<code>Monorepo</code>大仓，可以和对立面<code>Polyrepo</code>多个标准式项目 作对比：</p>
<p><img src="/assets/img/monorepo-polyrepo.svg" alt="大仓与多个对比"></p>
<h2 id="monorepo-工具"><a href="#monorepo-工具" class="headerlink" title="monorepo 工具"></a>monorepo 工具</h2><p>Monorepos 有很多优势，但要使它们发挥作用，您需要拥有合适的工具。随着工作空间的扩大，工具必须帮助您保持快速、易于理解和管理。</p>
<p>市面上主流的<code>Monorepo</code>管理工具有：</p>
<ul>
<li>Bazel（谷歌）</li>
<li>Gradle Build Tool（Gradle, Inc）</li>
<li>Lage（微软）</li>
<li>Lerna  </li>
<li>Nx（Nrwl）</li>
<li>Pants（Pants Build 社区）</li>
<li>Rush（由 Microsoft)</li>
<li>Turborepo（由 Vercel）</li>
</ul>
<p>工具应该具备以下几点能力：</p>
<ul>
<li>本地计算缓存，能够提供本地构建缓存、单元测试缓存等能力</li>
<li>本地任务编排，能够以正确的顺序并行运行任务</li>
<li>分布式计算缓存，跨不同环境共享缓存工件的能力。这意味着你的整个组织，包括 CI 代理，永远不会构建或测试相同的东西两次。</li>
<li>分布式任务执行，在多台机器上分发命令的能力，同时在很大程度上保留在单台机器上运行它的开发人体工程学。</li>
<li>透明远程执行，在本地开发时在多台机器上执行任何命令的能力。</li>
<li>检测受影响的项目/包，确定更改可能会影响什么，以仅运行构建/测试受影响的项目。</li>
<li>工作区分析，无需额外配置即可理解工作区项目图的能力。</li>
<li>依赖图可视化，可视化项目和/或任务之间的依赖关系。可视化是交互式的，这意味着您可以搜索、过滤、隐藏、聚焦/突出显示和查询图中的节点。</li>
<li>源码分享，促进分散的源代码片段的共享。</li>
<li>一致的工具，无论您使用什么来开发项目，如JavaScript 框架、Go、Rust、Java 等，工具都可以帮助您获得一致的体验</li>
<li>代码生成，本机支持生成代码</li>
<li>项目限制和可见性，支持定义规则以限制 repo 中的依赖关系。例如，开发人员可以将某些项目标记为他们团队的私有项目，这样其他人就无法依赖它们。开发人员还可以根据使用的技术（例如 React 或 Nest.js）标记项目，并确保后端项目不会导入前端项目。</li>
</ul>
<h2 id="monorepo单一原则"><a href="#monorepo单一原则" class="headerlink" title="monorepo单一原则"></a>monorepo单一原则</h2><p>单一原则指的是单一版本(One Version)原则，具体定义如下：</p>
<blockquote>
<p>单一版本(One Version)原则，是指在任意时间，代码库内的每一份组件、每一个依赖只有一个版本。</p>
</blockquote>
<p>对内部库而言，这意味着使用主干开发（见下），并且必须在主干 HEAD 上依赖。这是一个非常强的约束——这意味着除了终端制品，任何一个内部被依赖的库都不能通过分支发布，而必须保持自己在单仓的主干上一直是发布状态。</p>
<p>对外部依赖而言，同一个第三方库在单仓中永远只会引入一个版本。</p>
<p>为什么？</p>
<p>因为原来的git flow开发流，从feature-&gt;dev-&gt;master，每个分支里面的依赖版本都可能会不一样，从而导致依赖版本难以维护。</p>
<h2 id="monorepo挑战"><a href="#monorepo挑战" class="headerlink" title="monorepo挑战"></a>monorepo挑战</h2><ul>
<li>并非所有服务都适用于 monorepos</li>
<li>需要更复杂的 CI 设置</li>
<li>需要考虑代码架构大规模的改变</li>
</ul>
<h1 id="monorepo实战"><a href="#monorepo实战" class="headerlink" title="monorepo实战"></a>monorepo实战</h1><p>作为前端开发者，<a href="https://lerna.js.org" target="_blank" rel="noopener">Lerna</a>框架是肯定要尝试一番，同时功能比较齐全的<a href>Nx</a>框架要去体验一番。</p>
<p>但是其实两者的关系非常紧密，都是同一个公司<code>Nrwl</code>开发的，所以有很多类似点。</p>
<h2 id="Lerna"><a href="#Lerna" class="headerlink" title="Lerna"></a>Lerna</h2><p>快速开始安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx lerna init</span><br></pre></td></tr></table></figure>

<p>PS: npx是什么？</p>
<ul>
<li>npx：Node Package Execute 即node包执行器</li>
<li>npx 是npm v5.2.0版本之后随npm 一起打包安装的一个包执行器。</li>
<li>它会自动去寻找二进制命令文件且不必全局安装依赖包。</li>
<li>npx 可以在不指定项目中的确切位置或使用别名的情况下运行正确版本的工具，比如<code>npx lerna init</code>命令会执行去npm源安装<code>lerna-cli</code>命令工具到本地，然后执行<code>lerna init</code>命令</li>
</ul>
<p>安装完以后，项目的初始化架构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">packages/</span><br><span class="line">    header/</span><br><span class="line">        src/</span><br><span class="line">            ...</span><br><span class="line">        package.json</span><br><span class="line">        rollup.config.json</span><br><span class="line">        jest.config.js</span><br><span class="line"></span><br><span class="line">    footer/</span><br><span class="line">        src/</span><br><span class="line">            ...</span><br><span class="line">        package.json</span><br><span class="line">        rollup.config.json</span><br><span class="line">        jest.config.js</span><br><span class="line"></span><br><span class="line">    remixapp/</span><br><span class="line">        app/</span><br><span class="line">            ...</span><br><span class="line">        public/</span><br><span class="line">        package.json</span><br><span class="line">        remix.config.js</span><br><span class="line"></span><br><span class="line">package.json</span><br><span class="line">lerna.json # 需要自己手动新建， 用来描述</span><br></pre></td></tr></table></figure>

<p>修改<code>package.json</code>，去添加一个npm/yarn/pnpm workspace</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;root&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;workspaces&quot;: [&quot;packages/*&quot;],</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;lerna&quot;: &quot;6.0.1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h2><ul>
<li><code>lerna run xxx</code>： 统一执行所有子项目的scripts命令，如：lerna run build</li>
<li><code>npx nx graph</code>：查看项目依赖图</li>
<li><code>npx lerna add-caching</code>：设置子项目的一些缓存设置，会在根目录下生成<code>nx.json</code></li>
<li><code>npx lerna publish --no-private</code>: 统一发布npm包</li>
<li><code>npx lerna run xxx --scope=header</code>：允许只针对某个子项目header执行命令</li>
</ul>
<p>其他命令可以到官网查看， <a href="https://lerna.js.org/docs/api-reference/commands" target="_blank" rel="noopener">Lerna命令</a></p>
<h2 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h2><p>官网里定义是：</p>
<blockquote>
<p><a href="https://nx.dev/" target="_blank" rel="noopener">NX</a>是一个智能、快速和可扩展的构建系统，具有一流的Monorepo支持和强大的集成。</p>
</blockquote>
<p>实战步骤如下：</p>
<p>创建一个新工作区：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx create-nx-workspace@latest package-based --preset=npm</span><br></pre></td></tr></table></figure>

<p>然后在<code>packages</code>创建自己的子项目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package-based/</span><br><span class="line">├── packages/</span><br><span class="line">│   └── is-even/</span><br><span class="line">│       ├── index.ts</span><br><span class="line">│       └── package.json</span><br><span class="line">│   └── is-odd/</span><br><span class="line">│       ├── index.ts</span><br><span class="line">│       └── package.json</span><br><span class="line">├── nx.json</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure>

<p>接下来就是配置 <code>nx.json</code>，子项目之间的依赖，已经任务执行顺序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// nx.json</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;targetDefaults&quot;: &#123;</span><br><span class="line">    &quot;build&quot;: &#123;</span><br><span class="line">      &quot;dependsOn&quot;: [&quot;^build&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行构建命令<code>npx nx build is-odd</code> 可以看到要先构建<code>is-event</code>项目</p>
<p>最后是构建全部项目<code>npx nx run-many --target=build</code></p>
<h2 id="CI-CD构建流程改造"><a href="#CI-CD构建流程改造" class="headerlink" title="CI/CD构建流程改造"></a>CI/CD构建流程改造</h2><p>这个按照各自团队的CI/CD构建流程去改造，但是主要有以下几点：</p>
<ul>
<li>CI/CD流水线职责分离</li>
<li>统一镜像NPM凭证管理</li>
<li>手动触发CD流水线发布，使用统一版本进行管理发布</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://monorepo.tools/#what-is-a-monorepo" target="_blank" rel="noopener">Monorepo Explain</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>从Prometheus学会搭建监控系统</title>
    <url>/today/20230220.html</url>
    <content><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://yunlzheng.gitbook.io/prometheus-book/" target="_blank" rel="noopener">Prometheus中文教程</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>微前端系列——结合Monorepo大仓架构实战</title>
    <url>/today/20230226.html</url>
    <content><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>Meteor.js尝鲜实战</title>
    <url>/today/20230225.html</url>
    <content><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&mid=2247493866&idx=1&sn=c4a3d5ddf6e3148360f3de9ea32e018f&chksm=cf0327d1f874aec72d630aa81d7b1b0b0961943287fbab023e6d39d466f33b642e12ca7f1ac0&token=953834215&lang=zh_CN#rd" target="_blank" rel="noopener">把 puppeteer 融入调试流程，调试体验爽翻了！</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>Jamstack尝鲜体验</title>
    <url>/today/20230229.html</url>
    <content><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>GraphQL尝鲜体验</title>
    <url>/today/20230228.html</url>
    <content><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>Svelte尝鲜体验</title>
    <url>/today/20230227.html</url>
    <content><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>从审批流到bpmn-js入门</title>
    <url>/today/20230106.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>公司内部由于需要很多审批地方，一开始采用邮件或者企业微信进行口头审批，一般会抄送相关人员，以达到初步审批的效果，但是随着审批越来越复杂，比如有时候需要驳回或者转接，甚至需要调用其他系统接口继续流程的时候，就很麻烦，因此迫切需要一个工作流去解决审批相关事情。</p>
<h1 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h1><p>在选型前，我们需要知道工作流是什么？</p>
<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>工作流就是通过计算机技术对业务流程进行自动化管理。实现多个参与者按照预定的流程去自动执行业务流程。</p>
<blockquote>
<p>工作流定义: 通过计算机对业务流程自动化执行管理</p>
</blockquote>
<p>再通俗一点，工作流就是通过程序去自动实现平时需要人工操作的流程节点，所以工作流能解决的问题一定是可以被流程化的问题。</p>
<p>然而这一过程被大家统称为业务流程建模，通常对已经存在复杂问题进行模型化的抽象，通过模型来推导解决问题的方案。</p>
<a id="more"></a>

<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="BPM"><a href="#BPM" class="headerlink" title="BPM"></a>BPM</h3><p><code>BPM(Business Process Management)</code>， 业务流程管理，是指的在工作流的基础上，基于业务流程建模，支持业务流程的分析、建模、模拟、优化、协同与监控等功能的新一代企业应用系统核心。</p>
<p>简单点说，<code>BPM</code>其实一个业务流程管理系统的统称，不单单可以实现审批流，还可以实现各种更为复杂的业务流程，如：数据同步等。</p>
<h3 id="BPMN"><a href="#BPMN" class="headerlink" title="BPMN"></a>BPMN</h3><p><code>BPMN（Business Process Model And Notation）</code>， 业务流程模型和符号，由<code>BPMI（Business Process Management Initiative）</code>开发的一套标准的业务流程建模符号，使用BPMN 提供的符号可以创建业务流程。</p>
<p>更加容易理解的说，<code>BPMN</code>是实现<code>BPM</code>的一套标准，制定很多建模符号标准。</p>
<p>这里简单比喻一下，<code>BPMN</code>是一门语言，你可以用它去开发<code>BPM</code>系统。</p>
<p>后面会更加详细讲解 <code>BPMN</code> 的基础知识。</p>
<p>建模符号了解，可以放到下一章节分享。</p>
<h3 id="工作流引擎选型"><a href="#工作流引擎选型" class="headerlink" title="工作流引擎选型"></a>工作流引擎选型</h3><p>由于<code>BPMN</code>是市面主流的工作流标准， 那么市面绝大部分工作流引擎都是基于该标准去实现。下面罗列一下目前市面上主流的各种引擎：</p>
<ul>
<li><code>Osworkflow</code>,一个轻量化的流程引擎，基于状态机机制，但不支持会签、跳转、退回、加签等这些操作，需要自己扩展开发，有一定难度，如果流程比较简单，osworkflow是很好的选择但该开源组件已过时，长时间没有版本升级了。</li>
<li><code>JBPM</code>, 以<code>JBPM4</code>版本作为分割点，JBPM5以后版本基于<code>Drools Flow</code>， JBPM4已停止维护，也不建议选择。</li>
<li><code>Activiti</code>, activiti5和activiti6是基于<code>JBPM4</code>开源，<code>activiti7</code>是基于6升级的，内核基本不变，但是由于<code>Tijs Rademakers</code>离开，谨慎选择。</li>
<li><a href="https://flowable.com/open-source" target="_blank" rel="noopener"><code>flowable</code></a>, 基于activiti6衍生出来的版本，以flowable6.4.1版本为分水岭，大力发展其商业版产品，开源版本维护不及时，部分功能已经不再开源版发布，可以考虑选择。</li>
<li><a href="https://docs.camunda.org/manual/7.18/" target="_blank" rel="noopener"><code>Camunda</code></a>, Camunda基于activiti5，所以其保留了PVM，商业版本和开源版本功能相差不大，建议选择。</li>
</ul>
<h3 id="流程设计器选型"><a href="#流程设计器选型" class="headerlink" title="流程设计器选型"></a>流程设计器选型</h3><p>对于低代码平台中的流程可视化，流程设计器是重要的支撑工具，目前市场上比较主流的流程:</p>
<ul>
<li><a href="https://bpmn.io/" target="_blank" rel="noopener">bpmn-js</a>,是 BPMN 2.0 渲染工具包和 Web 模型，使用 Web 建模工具可以很方便的构建 BPMN 图表，可以把 BPMN 图表嵌入到你的项目中，容易扩展。</li>
<li><a href="http://jgraph.github.io/mxgraph/" target="_blank" rel="noopener">mxGraph</a>是一个强大的JavaScript流程图前端库，由于mxGraph是一个开放的js绘图开发框架，我们可以开发出很炫的样式，或者完全按照项目需求定制。</li>
<li>[Activiti-Modeler] Activiti 开源版本中带了web版流程设计器,界面不美观，用户体验差</li>
<li>[flowable-modeler]flowable开源版本中带了web版流程设计器,界面不美观，用户体验差</li>
</ul>
<h3 id="建议选型"><a href="#建议选型" class="headerlink" title="建议选型"></a>建议选型</h3><p>推荐大家使用<a href="https://docs.camunda.org/manual/7.18/" target="_blank" rel="noopener"><code>Camunda</code></a>（流程引擎）+<a href="https://bpmn.io/" target="_blank" rel="noopener">bpmn-js</a>（流程设计器）组合。</p>
<h1 id="快速部署"><a href="#快速部署" class="headerlink" title="快速部署"></a>快速部署</h1><p>选型后就是实战，推荐的选型都有很完整的安装部署文档，下面简单说一下部署步骤。</p>
<p>再次说明一下两者的区别：</p>
<ul>
<li><code>Camunda</code>是工作流引擎，用来执行工作流模型文件任务，同时管理各种流程执行。</li>
<li><code>bpmn-js</code>是前端的流程设计器，基于<code>bnpm</code>标准实现，用来生成工作流模型文件。</li>
</ul>
<h2 id="Camunda部署"><a href="#Camunda部署" class="headerlink" title="Camunda部署"></a>Camunda部署</h2><ol>
<li>docker快速安装后端：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull camunda/camunda-bpm-platform:run-latest</span><br><span class="line">docker run -d --name camunda -p 8080:8080 camunda/camunda-bpm-platform:run-latest</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>通过<code>spring boot</code>快速创建项目：<br>更新pom.xml文件内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.tencent<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>camunda_spring_boot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>camunda_spring_boot<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>camunda_spring_boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>17<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">camunda.spring-boot.version</span>&gt;</span>7.15.0<span class="tag">&lt;/<span class="name">camunda.spring-boot.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.camunda.bpm.springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>camunda-bpm-spring-boot-starter-webapp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;camunda.spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改登录用户配置， application.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">camunda.bpm</span>:<span class="string"></span></span><br><span class="line">  <span class="meta">admin-user</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">id</span>: <span class="string">demo</span></span><br><span class="line">    <span class="attr">password</span>: <span class="string">demo</span></span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">Demo</span></span><br><span class="line">  <span class="attr">filter</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">create</span>: <span class="string">All tasks</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将<code>bpmn-js</code>操作好的xml文件保存到<code>src/main/resources/loan-approval.bpmn</code></p>
</li>
</ol>
<p>运行程序，访问<a href="http://localhost:8080/camunda/app/cockpit/default/#/dashboard" target="_blank" rel="noopener">http://localhost:8080/camunda/app/cockpit/default/#/dashboard</a>，就可以看到相关任务。</p>
<p>后面是运行任务等，就不属于入门教程，可以放到后面教程慢慢学习。</p>
<h2 id="bpmn-js部署"><a href="#bpmn-js部署" class="headerlink" title="bpmn-js部署"></a>bpmn-js部署</h2><p><a href="/fedlearn/code/bpmn-js/index.html">demo访问</a>， 快速使用，代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, user-scalable=no"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>BPMNJS测试案例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">&lt;!-- 引入BPMN-JS的CSS文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://unpkg.com/bpmn-js@11.1.0/dist/assets/diagram-js.css"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://unpkg.com/bpmn-js@11.1.0/dist/assets/bpmn-font/css/bpmn.css"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"canvas"</span> <span class="attr">style</span>=<span class="string">"height:80vh;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入BPMN-JS的JS文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/bpmn-js@11.1.0/dist/bpmn-modeler.development.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- xml文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./bpmn.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> bpmnModeler = <span class="keyword">new</span> BpmnJS(&#123;</span></span><br><span class="line"><span class="actionscript">      container: <span class="string">'#canvas'</span></span></span><br><span class="line">    &#125;);</span><br><span class="line">		</span><br><span class="line"><span class="actionscript">    bpmnModeler.importXML(xml, <span class="function"><span class="keyword">function</span><span class="params">(err)</span> </span>&#123;</span></span><br><span class="line"><span class="vbscript">	  <span class="keyword">if</span> (<span class="built_in">err</span>) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">console</span>.error(<span class="string">'failed to load diagram'</span>, err);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>BPNM</code>是大家统一认知的业务流建模标准，实现它的工作流引擎有很多，经过选型最终确定使用<a href="https://docs.camunda.org/manual/7.18/" target="_blank" rel="noopener">camunda</a> + <a href="https://bpmn.io/" target="_blank" rel="noopener">bpmn-js</a>。</p>
<p>简单尝试一下，还是很简单实现了一个简单工作流管理系统，从设计工作流到工作流执行。</p>
<p>如果要真正用起来，还是需要发心思去了解<code>BPNM</code>的整体标准，以及<a href="https://docs.camunda.org/manual/7.18/" target="_blank" rel="noopener">camunda</a>是如何运作执行的，同时需要将<a href="https://bpmn.io/" target="_blank" rel="noopener">bpmn-js</a>流程设计器。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://shaochenfeng.com/camunda/10.%E5%88%9B%E5%BB%BA_camunda_spring_boot_%E9%A1%B9%E7%9B%AE/" target="_blank" rel="noopener">camunda Spring Boot项目</a></p>
<p><a href="https://juejin.cn/post/6844904017592614919" target="_blank" rel="noopener">全网最详bpmn.js教材-http请求篇</a></p>
]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>从短视频到短视频思维</title>
    <url>/today/20230105.html</url>
    <content><![CDATA[<h1 id="短视频的背景"><a href="#短视频的背景" class="headerlink" title="短视频的背景"></a>短视频的背景</h1><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>人类的需求——记录、表达、分享</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul>
<li>智能手机普及</li>
<li>法律法规允许</li>
<li>大数据、AI算法成熟</li>
</ul>
<a id="more"></a>
<h1 id="短视频讲解"><a href="#短视频讲解" class="headerlink" title="短视频讲解"></a>短视频讲解</h1><h2 id="AI辅助内容解析"><a href="#AI辅助内容解析" class="headerlink" title="AI辅助内容解析"></a>AI辅助内容解析</h2><ul>
<li>AI识别视频内容</li>
<li>分类视频模型，如：色情、低俗、性感、社会事件、武器模型、敏感人物、极端组织、高危等</li>
<li>内容审核</li>
</ul>
<h2 id="AI推荐算法"><a href="#AI推荐算法" class="headerlink" title="AI推荐算法"></a>AI推荐算法</h2><p>给你爱看，也给你好看的短视频。</p>
<ul>
<li>用户侧特征：爱好、年龄、职业等</li>
<li>视频侧特征：宠物、旅行、电影等</li>
<li>流行度特征：播放量、停留时间、完播率、分享率等</li>
</ul>
<h3 id="内容流转逻辑"><a href="#内容流转逻辑" class="headerlink" title="内容流转逻辑"></a>内容流转逻辑</h3><p>抖音流量池， 按照播放次数，做统计，如下</p>
<ul>
<li>种子流量池 ： 数百</li>
<li>初级流量池：1w~10w</li>
<li>中级流量池：10w~100w</li>
<li>高级流量池：100w~1000w</li>
<li>s级流量池：1000w+</li>
<li>王者流量池：全站、新手</li>
</ul>
<p><strong>扭转流程</strong>：</p>
<p>上传-&gt;程序判断-&gt;审核失败</p>
<p>上传&gt;程序判断-&gt;上传成功-&gt;种子池-&gt;达到推荐标准-&gt;初级-&gt;中级-&gt;高级-&gt;全站</p>
<h1 id="做短视频核心"><a href="#做短视频核心" class="headerlink" title="做短视频核心"></a>做短视频核心</h1><p>一句话，忘记涨粉，回归价值</p>
<ul>
<li>做短视频，有什么优势</li>
<li>能够提供什么有价值的视频给到用户</li>
</ul>
<h1 id="什么是短视频思维"><a href="#什么是短视频思维" class="headerlink" title="什么是短视频思维"></a>什么是短视频思维</h1><p>短视频，是从叙事基础设施改变： 重构生产、发行、宣传</p>
<p>影响抖音、快手推荐因素：<br>抖音：</p>
<ul>
<li>完播率</li>
<li>复播率</li>
<li>分享率</li>
<li>评论率</li>
<li>点赞率</li>
</ul>
<p>快手多了：（注重封面）</p>
<ul>
<li>点击率</li>
<li>转粉率</li>
</ul>
<h2 id="短视频思维原则"><a href="#短视频思维原则" class="headerlink" title="短视频思维原则"></a>短视频思维原则</h2><p>时长：能短一秒是一秒；</p>
<p>怎么做：</p>
<ul>
<li>后期：能少一帧是一帧；</li>
<li>编剧：能少一字是一字；</li>
<li>导演：画面上每一帧都是经过设计的；</li>
<li>运营：引导互动</li>
</ul>
<p>内容：用讲故事的方式建立认同感；</p>
<p>怎么做：</p>
<ul>
<li>要么好玩，要么有用，好内容满足人性；</li>
<li>黄金5秒；</li>
<li>多个梗与冲突；</li>
<li>设计的结尾</li>
</ul>
<h2 id="短视频思维本质"><a href="#短视频思维本质" class="headerlink" title="短视频思维本质"></a>短视频思维本质</h2><p>本质：数据与效率</p>
<ul>
<li>时长短，成品快</li>
<li>点赞率，播放率</li>
<li>快速迭代、低成本</li>
</ul>
<p>制作步骤：</p>
<ul>
<li>多维度快速迭代，多做尝试</li>
<li>定型IP,IP成立只差一个爆款</li>
<li>不断复盘总结、强化故事冲突、强化人物性格</li>
<li>深度运营、内容定制，简单说就是内容升级、不断满足粉丝的预期</li>
</ul>
<p>综上所述，短视频思维就是几点：</p>
<ul>
<li>秉持不断学习的态度，勇敢尝试各种类型</li>
<li>效率至上，迭代速度够快</li>
<li>用户价值是核心思想，你能够提供什么价值的视频给到用户</li>
</ul>
]]></content>
      <tags>
        <tag>每日更新</tag>
        <tag>短视频</tag>
      </tags>
  </entry>
  <entry>
    <title>从尝试搭建NAS了解各类云硬盘协议（一）</title>
    <url>/today/20230104.html</url>
    <content><![CDATA[<h1 id="NAS-是什么"><a href="#NAS-是什么" class="headerlink" title="NAS 是什么"></a>NAS 是什么</h1><p>NAS，全称Network Attached Storage，中文名： 网络附属存储。</p>
<p>可以理解成是长时间联网的存储设备，比如你有个硬盘，里面存储了一些教学视频，你想要别的地方去访问，比如在手机或者电脑上访问，那么NAS就能够解决你这个问题的解决方案。</p>
<p>NAS可以解决什么场景痛点：</p>
<ul>
<li>你的照片、视频可以随时上传，大小、题材不限制</li>
<li>访问速度快，尤其在家的时候局域网更快</li>
<li>信息安全，不再担心你的信息被云盘厂商泄露</li>
</ul>
<a id="more"></a>

<h1 id="部署NAS"><a href="#部署NAS" class="headerlink" title="部署NAS"></a>部署NAS</h1><p>部署NAS一般有两种部署方案：</p>
<ol>
<li>购买现成的NAS，一般服务厂商会将解决你的所有问题，一键傻瓜式部署</li>
<li>自己折腾搭建NAS，那么需要一台7*24小时服务器，搭建NAS服务，同时还需要搞个app支持NAS，支持手机客户端访问</li>
</ol>
<p>第一种方案简单，但是有点费钱</p>
<p>第二种方案困难，但是不费钱</p>
]]></content>
      <tags>
        <tag>每日更新</tag>
        <tag>动手实战</tag>
      </tags>
  </entry>
  <entry>
    <title>【引导页】功能实现原理分析</title>
    <url>/today/20230103.html</url>
    <content><![CDATA[<p>什么是引导页，就是引导用户对一些新功能使用说明UI展示。</p>
<p>遇到这种需求，一般的想法是：</p>
<ul>
<li>有没有办法可以快速实现</li>
<li>有时间对其背后原理研究一番</li>
</ul>
<h2 id="快速接入"><a href="#快速接入" class="headerlink" title="快速接入"></a>快速接入</h2><p>按照常用框架<code>Vue</code> <code>React</code> <code>原生js</code>进行分类，罗列一些开源比较好的框架使用。</p>
<a id="more"></a>
<h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><h4 id="vue-tour"><a href="#vue-tour" class="headerlink" title="vue-tour"></a>vue-tour</h4><p><a href="https://github.com/pulsardev/vue-tour" target="_blank" rel="noopener">vue-tour</a> 适用于Vue2,</p>
<blockquote>
<p>Vue Tour是一个轻量级、简单且可定制的导游插件，可与Vue.js一起使用。它提供了一种快速而简单的方法来指导用户完成您的应用程序。</p>
</blockquote>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> VueTour <span class="keyword">from</span> <span class="string">'vue-tour'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'vue-tour/dist/vue-tour.css'</span>)</span><br><span class="line"></span><br><span class="line">Vue.use(VueTour)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里使用vue组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div id=<span class="string">"v-step-0"</span>&gt;A DOM element on your page. The first step will pop on <span class="keyword">this</span> element because its ID is <span class="string">'v-step-0'</span>.&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="v-step-1"&gt;A DOM element on your page. The second step will pop on this element because its ID is 'v-step-1'.&lt;/</span>div&gt;</span><br><span class="line">    &lt;div data-v-step=<span class="string">"2"</span>&gt;A DOM element on your page. The third and final step will pop on <span class="keyword">this</span> element because its ID is <span class="string">'v-step-2'</span>.&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;v-tour name="myTour" :steps="steps"&gt;&lt;/</span>v-tour&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">'my-tour'</span>,</span><br><span class="line">    data () &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        steps: [</span><br><span class="line">          &#123;</span><br><span class="line">            target: <span class="string">'#v-step-0'</span>,  <span class="comment">// 使用 document.querySelector() 查询DOM节点</span></span><br><span class="line">            header: &#123;</span><br><span class="line">              title: <span class="string">'Get Started'</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            content: <span class="string">`Discover &lt;strong&gt;Vue Tour&lt;/strong&gt;!`</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            target: <span class="string">'.v-step-1'</span>,</span><br><span class="line">            content: <span class="string">'An awesome plugin made with Vue.js!'</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            target: <span class="string">'[data-v-step="2"]'</span>,</span><br><span class="line">            content: <span class="string">'Try it, you\'ll love it!&lt;br&gt;You can put HTML in the steps and completely customize the DOM to suit your needs.'</span>,</span><br><span class="line">            params: &#123;</span><br><span class="line">              placement: <span class="string">'top'</span> <span class="comment">// 展示方位 包括: top/bottom/left/right等</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.$tours[<span class="string">'myTour'</span>].start()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><p>React的生态比较丰富，插件也比较多，google React Tour就可以找到很多，下面罗列一下github上star较多的几个</p>
<ul>
<li><a href="https://github.com/gilbarbara/react-joyride" target="_blank" rel="noopener">react-joyride</a>：使用方便快捷的引导页插件</li>
<li><a href="https://github.com/elrumordelaluz/reactour" target="_blank" rel="noopener">reactour</a>： 功能更加丰富的React引导组件，分成好几种组件：<code>@reactour/tour</code> <code>@reactour/mask</code> <code>@reactour/popover</code> <code>@reactour/utils</code>等</li>
</ul>
<h3 id="原生js"><a href="#原生js" class="headerlink" title="原生js"></a>原生js</h3><p>原生js实现的引导页插件，比较有名有driver.js、intro.js和shepherd.js</p>
<h4 id="driver-js"><a href="#driver-js" class="headerlink" title="driver.js"></a>driver.js</h4><blockquote>
<p><strong><code>driver.js</code></strong> 是一个强大而轻量级的普通 JavaScript 引擎，可在整个页面上驱动用户的注意力，只有 4kb 左右的体积，并且没有外部依赖，不仅高度可定制，还可以支持所有主流浏览器。</p>
</blockquote>
<p>github地址: <a href="https://github.com/kamranahmedse/driver.js" target="_blank" rel="noopener">driver.js</a></p>
<p>使用demo教程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Driver <span class="keyword">from</span> <span class="string">'driver.js'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'driver.js/dist/driver.min.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高亮某个dom节点</span></span><br><span class="line"><span class="keyword">const</span> driver = <span class="keyword">new</span> Driver();</span><br><span class="line">driver.highlight(&#123;</span><br><span class="line">  element: <span class="string">'#some-element'</span>,</span><br><span class="line">  popover: &#123;</span><br><span class="line">    title: <span class="string">'Title for the Popover'</span>,</span><br><span class="line">    description: <span class="string">'Description for it'</span>,</span><br><span class="line">    position: <span class="string">'left'</span>,</span><br><span class="line">    offset: <span class="number">20</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤</span></span><br><span class="line"><span class="keyword">const</span> driver = <span class="keyword">new</span> Driver();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the steps for introduction</span></span><br><span class="line">driver.defineSteps([</span><br><span class="line">  &#123;</span><br><span class="line">    element: <span class="string">'#first-element-introduction'</span>,</span><br><span class="line">    popover: &#123;</span><br><span class="line">      className: <span class="string">'first-step-popover-class'</span>,</span><br><span class="line">      title: <span class="string">'Title on Popover'</span>,</span><br><span class="line">      description: <span class="string">'Body of the popover'</span>,</span><br><span class="line">      position: <span class="string">'left'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    element: <span class="string">'#second-element-introduction'</span>,</span><br><span class="line">    popover: &#123;</span><br><span class="line">      title: <span class="string">'Title on Popover'</span>,</span><br><span class="line">      description: <span class="string">'Body of the popover'</span>,</span><br><span class="line">      position: <span class="string">'top'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    element: <span class="string">'#third-element-introduction'</span>,</span><br><span class="line">    popover: &#123;</span><br><span class="line">      title: <span class="string">'Title on Popover'</span>,</span><br><span class="line">      description: <span class="string">'Body of the popover'</span>,</span><br><span class="line">      position: <span class="string">'right'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start the introduction</span></span><br><span class="line">driver.start();</span><br></pre></td></tr></table></figure>

<h4 id="intro-js"><a href="#intro-js" class="headerlink" title="intro.js"></a>intro.js</h4><blockquote>
<p><strong><code>intro.js</code></strong> 是是一个开源的 vanilla Javascript/CSS 库，用于添加分步介绍或提示，大小在 10kB左右，属于轻量级的且无外部依赖。</p>
</blockquote>
<p>github地址: <a href="https://github.com/usablica/intro.js/" target="_blank" rel="noopener">intro.js</a></p>
<p>使用demo教程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> introJs <span class="keyword">from</span> <span class="string">'intro.js'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'intro.js/introjs.css'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用HTML属性</span></span><br><span class="line">&lt;a href=<span class="string">'http://google.com/'</span> data-intro=<span class="string">'Hello step one!'</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用JSON配置</span></span><br><span class="line">&lt;section <span class="class"><span class="keyword">class</span></span>=<span class="string">"nav-menu"</span>&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li id=<span class="string">"step1"</span>&gt;步骤一&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        &lt;li id="step2"&gt;步骤2&lt;/</span>li&gt;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>section&gt;</span><br><span class="line"><span class="comment">// 配置</span></span><br><span class="line">introJs().setOptions(&#123;</span><br><span class="line">  steps: [&#123;</span><br><span class="line">    title: <span class="string">'Welcome'</span>,</span><br><span class="line">    intro: <span class="string">'Hello World! 👋'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    element: <span class="built_in">document</span>.querySelector(<span class="string">'#step1'</span>),</span><br><span class="line">    intro: <span class="string">'This step focuses on an image'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: <span class="string">'Farewell!'</span>,</span><br><span class="line">    element:<span class="built_in">document</span>.querySelector(<span class="string">'#step2'</span>),,</span><br><span class="line">    intro: <span class="string">'And this is our final step!'</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<h4 id="shepherd-js"><a href="#shepherd-js" class="headerlink" title="shepherd.js"></a>shepherd.js</h4><blockquote>
<p><strong><code>shepherd.js</code></strong> 包含的 API 众多，大多场景都可以通过其对应的配置得到，缺点就是整体的包体积较大，并且配置也比较复杂，配置复杂的内容一般都需要进行二次封装，将可变和不可变的配置项进行抽离</p>
</blockquote>
<p>github地址: <a href="https://github.com/shipshapecode/shepherd" target="_blank" rel="noopener">shepherd.js</a><br>使用demo教程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Shepherd <span class="keyword">from</span> <span class="string">'shepherd.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化配置</span></span><br><span class="line"><span class="keyword">const</span> tour = <span class="keyword">new</span> Shepherd.Tour(&#123;</span><br><span class="line">  defaultStepOptions: &#123;</span><br><span class="line">    cancelIcon: &#123;</span><br><span class="line">      enabled: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    classes: <span class="string">'class-1 class-2'</span>,</span><br><span class="line">    scrollTo: &#123; <span class="attr">behavior</span>: <span class="string">'smooth'</span>, <span class="attr">block</span>: <span class="string">'center'</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加步骤指引</span></span><br><span class="line">tour.addStep(&#123;</span><br><span class="line">  title: <span class="string">'Creating a Shepherd Tour'</span>,</span><br><span class="line">  text: <span class="string">`Creating a Shepherd tour is easy. too!\</span></span><br><span class="line"><span class="string">  Just create a \`Tour\` instance, and add as many steps as you want.`</span>,</span><br><span class="line">  attachTo: &#123;</span><br><span class="line">    element: <span class="string">'.hero-example'</span>,</span><br><span class="line">    on: <span class="string">'bottom'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  buttons: [</span><br><span class="line">    &#123;</span><br><span class="line">      action() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.back();</span><br><span class="line">      &#125;,</span><br><span class="line">      classes: <span class="string">'shepherd-button-secondary'</span>,</span><br><span class="line">      text: <span class="string">'Back'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      action() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.next();</span><br><span class="line">      &#125;,</span><br><span class="line">      text: <span class="string">'Next'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  id: <span class="string">'creating'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展示指引</span></span><br><span class="line">tour.start();</span><br></pre></td></tr></table></figure>

<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>引导页从它展示方式说起，要实现可以分为以下几个步骤：</p>
<ol>
<li><strong>高亮部分</strong>，通过<code>el.cloneNode(true)</code>复制元素节点，将节点复制到蒙层</li>
<li><strong>引导部分</strong>，展示引导框，并将引导框与高亮部分进行定位</li>
<li><strong>过度动画</strong>，通过设置<code>transition</code>实现</li>
<li><strong>页面监听</strong>，当页面发生变化的时候，引导页需要重新渲染计算</li>
</ol>
<p>具体实现可以点击查看源码<a href="/code/tour.js">tour.js</a>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/-O_AnG2pc5H5hLcwu9PTCA" target="_blank" rel="noopener">不使用第三方库怎么实现【前端引导页】功能？</a></li>
</ul>
]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>每日更新</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器页面卡住定位分析</title>
    <url>/share/page-notwork.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>有童鞋在xxx系统页面反馈，遇到在弹出框后整个页面卡住无法使用的情况，属于必现问题。因此需要跟踪定位问题。</p>
<h1 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h1><p>一般在浏览器遇到这种问题，基本上都某段逻辑进入死循环导致浏览器内核处理不过来导致的页面卡住动，这个时候需要使用Chrome开发调试工具进行跟踪定位的。</p>
<a id="more"></a>

<h2 id="chrome-source调试工具"><a href="#chrome-source调试工具" class="headerlink" title="chrome source调试工具"></a>chrome source调试工具</h2><p>按照<code>F12</code>或者<code>Command + Alt + J</code>可以打开浏览器的调试工具，然后找到<code>Source</code> 或 <code>源代码</code>Tab页。如下图所示：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/106719ede96442b7a262bba5a68c9775~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<h3 id="步骤一：点击-按钮，进入调试模式："><a href="#步骤一：点击-按钮，进入调试模式：" class="headerlink" title="步骤一：点击=按钮，进入调试模式："></a>步骤一：点击<code>=</code>按钮，进入调试模式：</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb7c6dc349554dd284aca3684d281323~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<h3 id="步骤二：调试代码，查看卡住代码段："><a href="#步骤二：调试代码，查看卡住代码段：" class="headerlink" title="步骤二：调试代码，查看卡住代码段："></a>步骤二：调试代码，查看卡住代码段：</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b758994a5bb04938bc035b397465ab8b~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<h3 id="步骤三：-定位代码段"><a href="#步骤三：-定位代码段" class="headerlink" title="步骤三： 定位代码段"></a>步骤三： 定位代码段</h3><p>确定是哪段代码后，就可以开始分析代码段是属于哪里，最终找到classname，定位到是属于水印插件导致。</p>
<h1 id="问题分析-水印插件"><a href="#问题分析-水印插件" class="headerlink" title="问题分析(水印插件)"></a>问题分析(水印插件)</h1><h2 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h2><p>为什么水印插件会导致页面进行死循环呢？这个就要跟踪到水印插件，目前采用的<code>@pansy/watermark</code>开源插件，然后找到其github issues，看看有没有相关issues。果不其然，还真的找到了，如下：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95eab9a9613d4e409ad09f906acf9d33~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p><a href="https://github.com/pansyjs/watermark/issues/129" target="_blank" rel="noopener">全局水印与其它遮罩层冲突</a><br>那么接下来就开始跟踪他们的代码进行具体分析。</p>
<h1 id="水印插件实现原理"><a href="#水印插件实现原理" class="headerlink" title="水印插件实现原理"></a>水印插件实现原理</h1><p>在上面调试问题的时候，我们有看到一段代码<code>MoutationRecord</code>，其实这已经算是水印插件的重要实现原理之一了。</p>
<p>看了插件源代码，其实就几千行代码，水印插件实现原理有几个点：</p>
<ol>
<li>利用<code>Shadow DOM</code>或者<code>div</code>DOM节点去插入水印，利用z-index显示到最前方</li>
<li>同时设置<code>pointer-events: none;</code>禁止任何操作，包括：选择、点击等，实现不阻碍其他元素操作</li>
<li>利用canvas生成水印图片(base64)</li>
<li>设置水印节点背景图片为水印图片(base64)</li>
<li>使用MutationObserver监听dom元素变化重复渲染生成水印图片，防止水印被人为删除<br>其中涉及到几个关键技术点为:</li>
</ol>
<ul>
<li><code>pointer-events: none</code></li>
<li>通过canvas生成图片</li>
<li>MutationObserver监听<br>当然，还有<code>Shadow DOM</code>和canvas等技术点也可以自己去研究学习，后面再用一些篇章详细讲解。</li>
</ul>
<h2 id="pointer-events"><a href="#pointer-events" class="headerlink" title="pointer-events"></a>pointer-events</h2><p>从MDN中它是这么定义的：</p>
<blockquote>
<p>** <code>pointer-events</code> ** CSS 属性指定在什么情况下 (如果有) 某个特定的图形元素可以成为鼠标事件的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event/target" target="_blank" rel="noopener">target (en-US)</a>。</p>
</blockquote>
<p>简单解释一下，就是可以通过该属性设置DOM元素的鼠标事件，很多对应值都是给svg响应鼠标事件范围所设置的。</p>
<p>这里重点解释一下<code>auto</code>、<code>none</code>两种值：</p>
<blockquote>
<p><code>auto</code>:与 <code>pointer-events</code> 属性未指定时的表现效果相同，对于 SVG 内容，该值与 <code>visiblePainted</code> 效果相同</p>
<p><code>none</code>:元素永远不会成为鼠标事件的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Event/target" target="_blank" rel="noopener">target (en-US)</a>。但是，当其后代元素的 <code>pointer-events</code> 属性指定其他值时，鼠标事件可以指向后代元素，在这种情况下，鼠标事件将在捕获或冒泡阶段触发父元素的事件侦听器。</p>
</blockquote>
<p>简单说，<code>auto</code>是默认值，可以触发该元素本身就有的鼠标事件。<br><code>none</code>则代表取消该元素原有的鼠标事件，可以直接透过该元素直接触发下方元素鼠标事件。<br>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">a[href=&quot;http://example.com&quot;] &#123;</span><br><span class="line">  pointer-events: none;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/&quot;&gt;MDN&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">&lt;!-- 点击链接 http://example.com 时，不会跳转 --&gt;</span><br><span class="line">&lt;a href=&quot;http://example.com&quot;&gt;example.com&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<h2 id="MutationObserver监听"><a href="#MutationObserver监听" class="headerlink" title="MutationObserver监听"></a>MutationObserver监听</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>MDN定义：</p>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver" target="_blank" rel="noopener"><code>MutationObserver</code></a> 接口提供了监视对 DOM 树所做更改的能力。它被设计为旧的 Mutation Events 功能的替代品，该功能是 DOM3 Events 规范的一部分。</p>
</blockquote>
<p>简单说，就是可以监听某个DOM节点下元素发生变化触发的事件。<br>支持方法：</p>
<ul>
<li><code>disconnect()</code>，注销监听方法</li>
<li><code>observe()</code>,开始监听</li>
<li><code>takeRecords()</code>, 取消通知队列</li>
</ul>
<p>具体使用案例(来自MDN)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 选择需要观察变动的节点</span><br><span class="line">const targetNode = document.getElementById(&apos;some-id&apos;);</span><br><span class="line"></span><br><span class="line">// 观察器的配置（需要观察什么变动）</span><br><span class="line">const config = &#123; attributes: true, childList: true, subtree: true &#125;;</span><br><span class="line"></span><br><span class="line">// 当观察到变动时执行的回调函数</span><br><span class="line">const callback = function(mutationsList, observer) &#123;</span><br><span class="line">    // Use traditional &apos;for loops&apos; for IE 11</span><br><span class="line">    for(let mutation of mutationsList) &#123;</span><br><span class="line">        if (mutation.type === &apos;childList&apos;) &#123;</span><br><span class="line">            console.log(&apos;A child node has been added or removed.&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (mutation.type === &apos;attributes&apos;) &#123;</span><br><span class="line">            console.log(&apos;The &apos; + mutation.attributeName + &apos; attribute was modified.&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 创建一个观察器实例并传入回调函数</span><br><span class="line">const observer = new MutationObserver(callback);</span><br><span class="line"></span><br><span class="line">// 以上述配置开始观察目标节点</span><br><span class="line">observer.observe(targetNode, config);</span><br><span class="line"></span><br><span class="line">// 之后，可停止观察</span><br><span class="line">observer.disconnect();</span><br></pre></td></tr></table></figure>

<h3 id="常用场景"><a href="#常用场景" class="headerlink" title="常用场景"></a>常用场景</h3><ul>
<li>防止第三方注入js文件（运营商劫持）</li>
<li>防止删除前端生成的水印</li>
<li>用来处理页面的敏感数据</li>
<li>Vue.$nextTick的实现微任务原理</li>
</ul>
<p>所以从问题定位中，分析水印陷入死循环很可能就是这一部分代码。</p>
<h2 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h2><p>回到最开始，我们是什么时候会遇到页面卡顿，当页面出现弹框的时候，会出现页面卡顿。</p>
<p>同时找到插件的issues(查看issue也是一种快速解决问题的途径)，描述如下:</p>
<blockquote>
<p>vue版本使用全局水印 <code>:is-body=&quot;true&quot;</code>  并且开启保护模式的情况下,触发带遮罩的事件就会导致页面无响应,且无法恢复;<br>带遮罩的事件如对话框弹窗/图片点击放大;<br>测试后发现关闭保护模式 <code>watermark.options.monitor = false</code> ,或者不使用全局水印没有出现该问题;<br><a href="https://github.com/pansyjs/watermark/issues/129" target="_blank" rel="noopener">这里可以看全文</a></p>
</blockquote>
<h3 id="定位到源码"><a href="#定位到源码" class="headerlink" title="定位到源码"></a>定位到源码</h3><p><code>watermark/packages/core/src/index.ts</code>，第244行，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (MutationObserver &amp;amp;&amp;amp; <span class="keyword">this</span>.options.monitor) &#123;</span><br><span class="line">      <span class="keyword">this</span>.mutationObserver = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="params">mutations</span> =&gt;</span> &#123;</span><br><span class="line">        mutations.forEach(<span class="function"><span class="params">mutation</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>._isAgainRender(mutation)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.destroy();</span><br><span class="line">            <span class="keyword">this</span>._render();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">this</span>.mutationObserver.observe(<span class="keyword">this</span>.container, observeOptions);</span><br><span class="line">      <span class="keyword">this</span>.shadowRoot &amp;&amp; <span class="keyword">this</span>.mutationObserver.observe(<span class="keyword">this</span>.shadowRoot, observeOptions);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>结合上面<code>MutationObserver</code>的作用，主要是监听某个DOM容器内节点变化，然后重新渲染水印，从而避免水印被人删除。</p>
<p>那么我们可以很简单的猜测一下，在弹框出来后，会触发<code>MutationObserver</code>，然后<code>_render函数</code>改变dom，又会触发自己本身的dom节点变化，再触发<code>MutationObserver</code>，导致陷入死循环。</p>
<p>目前执行顺序：</p>
<ol>
<li>body容器被监听到DOM节点变化，触发<code>MutationObserver</code>事件</li>
<li><code>MutationObserver</code>事件返回参数<code>mutations</code>是一个数组，可能会重复执行<code>_render</code>函数</li>
<li>多次<code>_render</code>函数会继续注册<code>MutationObserver</code>事件，导致后续body容器变更持续被监听到，进入死循环逻辑中</li>
</ol>
<p>因此，只需要保证多次<code>MutationObserver</code>事件只触发一次<code>_render</code>函数，即可避免死循环逻辑。</p>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>直接下载源码，放到本地调试（过程忽略），最终代码暂时如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">... </span><br><span class="line"><span class="keyword">if</span> (MutationObserver &amp;amp;&amp;amp; <span class="keyword">this</span>.options.monitor) &#123;</span><br><span class="line">      <span class="keyword">this</span>.mutationObserver = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="params">mutations</span> =&gt;</span> &#123;</span><br><span class="line">	  <span class="keyword">this</span>.mutationObserver = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="params">mutations</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 避免多次执行render函数，导致多次注册MutationObserver 从而进入死循环逻辑</span></span><br><span class="line">        <span class="keyword">let</span> lastMoutation;</span><br><span class="line">        mutations.forEach(<span class="function"><span class="params">mutation</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>._isAgainRender(mutation)) &#123;</span><br><span class="line">            lastMoutation = mutation;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span>(lastMoutation)&#123;</span><br><span class="line">          <span class="keyword">this</span>.destroy();</span><br><span class="line">          <span class="keyword">this</span>._render();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">this</span>.mutationObserver.observe(<span class="keyword">this</span>.container, observeOptions);</span><br><span class="line">      <span class="keyword">this</span>.shadowRoot &amp;amp;&amp;amp; <span class="keyword">this</span>.mutationObserver.observe(<span class="keyword">this</span>.shadowRoot, observeOptions);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>后面可以研究一下<code>为什么forEach || map函数无法跳出循环？</code></p>
<p>最后可以提交PR到开源github，这里面也有一些东西可以了解一下，<a href="https://stephenzhou.net/2019/04/23/git-pr-tsg/" target="_blank" rel="noopener">如何在github上为开源项目提交PR？</a>。</p>
<p>这里是我提交的PR,<a href="https://github.com/pansyjs/watermark/pull/136" target="_blank" rel="noopener">全局水印与其它遮罩层冲突 [issue 129]</a></p>
<p>#参考资料<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver" target="_blank" rel="noopener">MutationObserver MDN资料</a></p>
]]></content>
      <tags>
        <tag>技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>java tomcat服务无缘无故挂掉分析和解决方案</title>
    <url>/share/tomcat-nowork.html</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近有同事反应有时候xxx系统有时候会时不时出现服务异常提示，一上机器，发现xxx服务进程不在，重启服务后又恢复了，所以这边就需要去跟进问题。</p>
<h1 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h1><p>java tomcat服务挂掉原因，主要怀疑方向有这几个：</p>
<ol>
<li>服务器被人重启，导致服务没有起来</li>
<li>错误异常导致程序挂掉</li>
<li>服务器占用内存过高，Linux强制退出程序</li>
<li>其他原因<br>下面就开始逐一排查</li>
</ol>
<a id="more"></a>

<h2 id="服务器重启"><a href="#服务器重启" class="headerlink" title="服务器重启"></a>服务器重启</h2><p>如何查看服务器是否被重启，主要依据下面的命令：</p>
<p><code>who -b</code>查看最后一次重启时间</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1aca3c9b441642a5b913e2ea7778efe1~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"><br><code>last reboot</code> 查看服务器历史重启</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fb16e2d74b74654a20289db8a0c31c4~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<p>发现服务器重启时间是几个月前的事，因此可以排除。</p>
<h2 id="错误异常导致程序挂掉"><a href="#错误异常导致程序挂掉" class="headerlink" title="错误异常导致程序挂掉"></a>错误异常导致程序挂掉</h2><p>java服务采用spring log分级日志，直接看对应时间点日志，并没有发现什么，因此可以排除掉。</p>
<h2 id="服务器占用内存过高，Linux强制退出程序"><a href="#服务器占用内存过高，Linux强制退出程序" class="headerlink" title="服务器占用内存过高，Linux强制退出程序"></a>服务器占用内存过高，Linux强制退出程序</h2><p>如何查看服务器系统日志，可以查看文件：<code>/var/log/messages</code>。</p>
<blockquote>
<p>message日志包含了系统启动时的引导消息，以及系统运行时的其他状态消息。IO 错误、网络错误和其他系统错误都会记录到这个文件中。</p>
</blockquote>
<p>如何排查呢？执行以下命令：<br><code>cat /var/log/messages | grep java</code><br>然后发现有下面日志：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Out of memory: Kill process 9682 (java) score 9 or sacrifice child</span><br></pre></td></tr></table></figure>

<p>因此判断由于内存占用过高，java服务被系统误杀了。<br>既然定位到问题根源，那么为了更好的解决问题，我们继续追踪问题，为什么系统会kill java服务，而不杀掉其他进程呢？这里就需要了解一下Linux Out of Memory (OOM) killer机制。</p>
<h1 id="Linux-OOM机制"><a href="#Linux-OOM机制" class="headerlink" title="Linux OOM机制"></a>Linux OOM机制</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>Linux内核设计的一种机制，在内存不足的时候，会选择一个占用内存较大的进程并kill掉这个进程，以满足系统内存申请需求。</p>
<h2 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h2><p>触发条件：内存不足，为什么会出现内存不足，这里涉及到Linux内存结构和使用机制：</p>
<ol>
<li>物理内存结构</li>
<li>overcommit机制</li>
<li>OOM killer机制</li>
</ol>
<h3 id="Linux内存结构"><a href="#Linux内存结构" class="headerlink" title="Linux内存结构"></a>Linux内存结构</h3><p>这里就简单讲一下，具体描述可以google一下Linux物理内存结构。<br>Linux物理内存结构，Linux内核会把物理内存按照<code>node（节点） &gt; zone（分区）&gt; page (内存页)</code>三级结构进行划分，俗称内存管理系统，然后CPU会根据这种内存管理系统去调用内存。简单介绍以下概念：</p>
<ul>
<li>node节点：每个CPU都有自己的node内存节点，可以多个也可以单个，单个叫UMA架构，多个叫NUMA架构</li>
<li>zone分区：每个Node划分很多zone，每个zone都有自己的功能定义，这种只是从软件层面划分定义。zone里还有一个概念叫分配价值链<ul>
<li>分配价值链： 普通的内存分配会有一个“价值”的层次结构</li>
</ul>
</li>
<li>page内存页：属于zone下面的内存页，每个页基础大小是4K，他们维护在一个叫free_area的数组结构中<br>下面是从网上找的Linux物理内存结构图：</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cca72d58e9a94f978d8cedf43a06a834~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<h3 id="虚拟内存-swap空间"><a href="#虚拟内存-swap空间" class="headerlink" title="虚拟内存(swap空间)"></a>虚拟内存(swap空间)</h3><p>相对于物理内存，在 Linux 下还有一个虚拟内存的概念，虚拟内存是为了满足物理内存的不足而提出的策略，它是利用磁盘空间虚拟出的一块逻辑内存。用作虚拟内存的磁盘空间被称为<code>交换空间</code>（又称 <code>swap 空间</code>）。</p>
<p>了解Linux物理内存结构，我们明白Linux 的内存管理采取的是分页存取机制，为了保证物理内存能得到充分的利用，内核会在适当的时候将物理内存中不经常使用的数据块自动交换到虚拟内存中，而将经常使用的信息保留到物理内存。</p>
<p>Linux 内存运行机制:</p>
<ul>
<li>Linux 系统会不时地进行页面交换操作，以保持尽可能多的空闲物理内存，即使并没有什么事情需要内存，Linux 也会交换出暂时不用的内存页面，因为这样可以大大节省等待交换所需的时间</li>
<li>Linux 进行页面交换是有条件的，不是所有页面在不用时都交换到虚拟内存，Linux 内核根据“最近最经常使用”算法，仅仅将一些不经常使用的页面文件交换到虚拟内存</li>
</ul>
<p>虚拟内存是允许设置大小，这也是解决OMM killer的一种解决方案，具体可以看后面的解决方案。</p>
<h3 id="overcommit机制"><a href="#overcommit机制" class="headerlink" title="overcommit机制"></a>overcommit机制</h3><p>有了虚拟内存的存在，那么进程就可以向系统申请比物理剩余内存更大的使用内存：</p>
<blockquote>
<p>在实际申请内存的时候，比如申请1G，并不会在物理区域中分配1G的真实物理内存，而是分配1G的虚拟内存，等到需要的时候才去真正申请物理内存，也就是说申请不等于分配</p>
</blockquote>
<p>这就是overcommit机制，允许进程申请比物理内存实际大的内存。但是这会面临一个问题，当进程真正需要这么多内存怎么办，Linux的解决方案就是OOM killer。</p>
<p>当然，overcommit也允许设置几种值(vm.overcommit_memory)：</p>
<ul>
<li>0 – Heuristic overcommit handling. 这是缺省值，它允许overcommit，但过于明目张胆的overcommit会被拒绝，比如malloc一次性申请的内存大小就超过了系统总内存</li>
<li>1 – Always overcommit. 允许overcommit，对内存申请来者不拒。</li>
<li>2 – Don’t overcommit. 禁止overcommit。</li>
</ul>
<h2 id="OOM-killer机制"><a href="#OOM-killer机制" class="headerlink" title="OOM killer机制"></a>OOM killer机制</h2><p>讲完overcommit，终于来到本文重点，OOM killer机制，这应该是很多Linux系统部署服务，开发者所要面临头疼地方。<br>OOM killer，全称 Out Of Memory Killer，俗称内存溢出杀手。它是如何执行的呢?</p>
<blockquote>
<p>OMM killer机制：linux会为每个进程算一个分数，最终他会将分数最高的进程kill</p>
</blockquote>
<p>有三个进程设置值可以影响到分数值，可手动设置，但是基本上都不会用上，仅用来了解或者临时解决方案：</p>
<ul>
<li><code>/proc/&lt;pid&gt;/oom_score_adj</code>, 取值范围为-1000到1000， 如果将该值设置为-1000，则进程永远不会被杀死，因为此时 badness score 永远返回0</li>
<li><code>/proc/&lt;pid&gt;/oom_adj</code>, 取值是-17到+15，取值越高，越容易被干掉。如果是-17，则表示不能被kill</li>
<li><code>/proc/&lt;pid&gt;/oom_score</code>, 是系统综合进程的内存消耗量、CPU时间(utime + stime)、存活时间(uptime - start time)和oom_adj计算出的，消耗内存越多分越高。</li>
</ul>
<p>除了这三个值，还有一种计算方式：子进程内存：Linux在计算进程的内存消耗的时候，会将子进程所耗内存的一半同时算到父进程中。这样，那些子进程比较多的进程就要小心了。</p>
<h3 id="如何确定进程是被OOM-killer干掉的"><a href="#如何确定进程是被OOM-killer干掉的" class="headerlink" title="如何确定进程是被OOM killer干掉的"></a>如何确定进程是被OOM killer干掉的</h3><p>java tomcat查看之前的进程id或进程名，可以通过命令<code>ps -ef | grep java</code>获取到。<br>其次，查找系统日志<code>grep &quot;Out of memory&quot; /var/log/messages</code>，对比一下进程id或进程名，进行判断。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e8bc25d25784a47ad2f4c2780581d1d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="关闭OOM机制-不推荐，可作为临时解决方案"><a href="#关闭OOM机制-不推荐，可作为临时解决方案" class="headerlink" title="关闭OOM机制(不推荐，可作为临时解决方案)"></a>关闭OOM机制(不推荐，可作为临时解决方案)</h2><p>执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sysctl -w vm.overcommit_memory=2</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "vm.overcommit_memory=2" &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure>

<p>或者修改进程oom_score_adj值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo echo -1000 &gt; /proc/$pid/oom_score_adj</span><br></pre></td></tr></table></figure>

<p>或者修改进程oom_adj值:</p>
<ul>
<li>/proc/PID/oom_adj文件，将其置位-17</li>
</ul>
<h2 id="设置java进程最大占用内存-推荐"><a href="#设置java进程最大占用内存-推荐" class="headerlink" title="设置java进程最大占用内存(推荐)"></a>设置java进程最大占用内存(推荐)</h2><p>java tomcat服务在启用进程的时候可以设置占用最大内存，具体数值可以参考当前服务器所剩余的内存设置，具体设置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -Xms512m -Xmx512m -jar xxx.jar</span><br></pre></td></tr></table></figure>

<ul>
<li>Xms: 最小内存</li>
<li>Xmx: 最大内存<br>tomcat可以在<code>TOMCAT_HOME/bin/catalina.sh</code>中设置:<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在cygwin=<span class="literal">false</span>前</span></span><br><span class="line">JAVA_OPTS="-server -Xms256m -Xmx512m -XX:PermSize=64M -XX:MaxPermSize=128m"</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="java守护进程-推荐"><a href="#java守护进程-推荐" class="headerlink" title="java守护进程(推荐)"></a>java守护进程(推荐)</h2><p>除了设置最大占用内存设置，还可以增加守护进程从而避免服务异常挂掉进行重启，主要有两种方案：</p>
<ol>
<li>第一种常用，通过设置<code>crontab</code>脚本去守护。</li>
<li>第二种是Java <code>jsvc</code>方案，利用启动守护进程去监控控制服务进程，从而避免进程无缘无故挂掉自动重启，tomcat本身已有<code>daemon.sh</code>，可以直接该脚本即可。</li>
</ol>
<h2 id="优化代码-有能力者可以采用"><a href="#优化代码-有能力者可以采用" class="headerlink" title="优化代码(有能力者可以采用)"></a>优化代码(有能力者可以采用)</h2><p>这个可能需要具体问题具体分析了，优化代码占用内存，java网上有很多方案，大家各自采纳符合自己的方案即可。</p>
<h2 id="申请更多内存-土豪随意"><a href="#申请更多内存-土豪随意" class="headerlink" title="申请更多内存(土豪随意)"></a>申请更多内存(土豪随意)</h2><p>既然是内存不够，那么就直接申请更多资源，就可以满足了，看来还是有钱就能更快解决问题。</p>
]]></content>
      <tags>
        <tag>技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>前端架构——微前端系列(二)之qiankun框架</title>
    <url>/framework/frontend-microapp-2.html</url>
    <content><![CDATA[<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>技术分享</tag>
        <tag>架构系列</tag>
      </tags>
  </entry>
  <entry>
    <title>React与Jest的单元测试(1)</title>
    <url>/study/react-test1.html</url>
    <content><![CDATA[<h1 id="什么是单元测试"><a href="#什么是单元测试" class="headerlink" title="什么是单元测试"></a>什么是单元测试</h1><p>如果你听说过“测试驱动开发”（TDD：Test-Driven Development），单元测试就不陌生。</p>
<p>单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。</p>
<a id="more"></a>
<h2 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h2><p>在github的开源项目经常会有单元测试覆盖率，长得比如<code>vuejs</code>框架，如下图所示：<br><img src="http://ww1.sinaimg.cn/large/68c990d9gy1g7c48fwqh5j21aa0ec408.jpg" alt="image.png"></p>
<ul>
<li>上图中的 build passing 表示 travis build 通过了，用绿色背景显示，表明很安全。</li>
<li>npm v2.6.10 表示最新版本是 v2.6.10，用蓝色背景显示，表明是稳定的版本。</li>
<li>downloads 4.7m/month 表示最近一个月 npm 里的下载数量为 4.7万 次。</li>
<li>coverage 97% 表示测试覆盖率达到了 100%，用蓝绿色背景显示，表明虽通过测试但是还存在未测试到地方。</li>
</ul>
<p>测试覆盖率就是运行的测试覆盖了多少代码里的逻辑，下一篇我们讲到如何建立github的测试覆盖率。</p>
<!-- https://juejin.im/entry/58c51defa22b9d0058ac1980 -->

<p>明白上面的概念后我们就开始进入学习。</p>
<h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><h2 id="Jest、Enzyme-介绍"><a href="#Jest、Enzyme-介绍" class="headerlink" title="Jest、Enzyme 介绍"></a>Jest、Enzyme 介绍</h2><p>Jest 是 Facebook 发布的一个开源的、基于 <code>Jasmine</code> 框架的 JavaScript 单元测试工具。提供了包括内置的测试环境 DOM API 支持、断言库、Mock 库等，还包含了 Spapshot Testing、 Instant Feedback 等特性。</p>
<p>Airbnb开源的 React 测试类库 Enzyme 提供了一套简洁强大的 API，并通过 jQuery 风格的方式进行DOM 处理，开发体验十分友好。不仅在开源社区有超高人气，同时也获得了React 官方的推荐。</p>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>通过<code>create-react-app</code>去创建项目，步骤如下：</p>
<ol>
<li><code>create-react-app test-app</code>后，等待几分钟安装依赖完成</li>
<li>项目自带<code>jest</code>测试框架，但是还需要安装其他测试框架</li>
<li>安装<code>yarn add enzyme enzyme-adapter-react-16 react-test-renderer</code></li>
</ol>
<h2 id="示例项目"><a href="#示例项目" class="headerlink" title="示例项目"></a>示例项目</h2><p>在项目中我们将实现一个待办事项，并进行TTD开发。</p>
<p>需求描述：在页面中有个输入框，并允许进行点击新增待办事项和删除事项。</p>
<p><a href>项目源码可以点击这里进行克隆</a></p>
<h2 id="jest常用API"><a href="#jest常用API" class="headerlink" title="jest常用API"></a>jest常用API</h2><ul>
<li>describe(name, fn)：描述块，讲一组功能相关的测试用例组合在一起</li>
<li>it(name, fn, timeout)：别名test，用来放测试用例</li>
<li>afterAll(fn, timeout)：所有测试用例跑完以后执行的方法</li>
<li>beforeAll(fn, timeout)：所有测试用例执行之前执行的方法</li>
<li>afterEach(fn)：在每个测试用例执行完后执行的方法</li>
<li>beforeEach(fn)：在每个测试用例执行之前需要执行的方法</li>
</ul>
]]></content>
      <tags>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title>周二技术周刊 20190924期</title>
    <url>/wx/20190924.html</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/68c990d9gy1g7au94i5grj21pe14x7wi.jpg" alt="好看的图片"></p>
<h1 id="一、技术知识"><a href="#一、技术知识" class="headerlink" title="一、技术知识"></a>一、技术知识</h1><h2 id="《降低软件复杂性一般原则和方法》"><a href="#《降低软件复杂性一般原则和方法》" class="headerlink" title="《降低软件复杂性一般原则和方法》"></a>《降低软件复杂性一般原则和方法》</h2><p>简介：</p>
<p>本篇文章是围绕着“降低复杂性”这个主题展开的，很多重要的结论来源于John Ousterhout的著作《A Philosophy of Software Design》，作者觉得很有共鸣，就做了一些相关话题的延伸、补充了一些实例。虽说是”一般原则“，也不意味着是绝对的真理，整理出来，只是为了引发大家对软件设计的思考。</p>
<a id="more"></a>

<h3 id="读后心得"><a href="#读后心得" class="headerlink" title="读后心得"></a>读后心得</h3><p><strong>现代系统复杂性解决原则</strong></p>
<ul>
<li>由于互联网的变化过快，系统是无法一次性满足的，都是通过一个个功能模块衍生迭代，系统才会逐步成型；</li>
<li>专业化分工和代码复用是促成了软件生产率的提升的准则，由专业的人负责专业的事；</li>
<li>分模块是从垂直方向来分解系统，如：微服务。分模块降低了单模块的复杂性，但是也会引入新的复杂性，例如模块与模块的交互；</li>
<li>完善文档和注释，因为代码能够描述程序的工作流程和结果，却很难描述开发人员的思路。</li>
</ul>
<blockquote>
<p>好的注释能够帮助解决软件复杂性问题，尤其是认知负担和不可知问题（Unknown Unknowns）。</p>
</blockquote>
<p><strong>设计技术方案前的两个问题</strong></p>
<ul>
<li>其一，为什么该方案可行？</li>
<li>其二，在已有资源限制下，为什么该方案是最优的？</li>
<li>为了回答第一个问题，我们需要在技术方案里补充架构图、接口设计和时间人力估算。</li>
<li>而要回答第二个问题，需要我们在关键点或争议处提供二到三种方案，并给出建议方案，这样才有说服力。</li>
</ul>
<p><strong>技术方案设计原则</strong></p>
<ul>
<li>复杂系统最好的设计原则就是严格分层——内部的层只对相邻的层次可见，这样就可以将一个复杂问题分解成增量步骤序列，分层系统最有名的实例是TCP/IP网络模型。</li>
<li>复杂性下沉，永远对用户友好的设计就是好设计。</li>
<li>异常错误处理原则就是：尽可能减少需要处理异常的可能性。而最佳实践就是确保错误终结，例如删除一个并不存在的文件，与其上报文件不存在的异常，不如什么都不做。确保文件不存在就好了。</li>
</ul>
<p><strong><em>阅读时间：15~20分钟</em></strong></p>
<p>其他更多关于软件设计原则可以前往:</p>
<blockquote>
<p><a href="https://tech.meituan.com/2019/09/19/common-method-of-reduce-complexity.html" target="_blank" rel="noopener">https://tech.meituan.com/2019/09/19/common-method-of-reduce-complexity.html</a></p>
</blockquote>
<h1 id="十大-npm-最佳安全指南，教你如何避免安全漏洞！"><a href="#十大-npm-最佳安全指南，教你如何避免安全漏洞！" class="headerlink" title="十大 npm 最佳安全指南，教你如何避免安全漏洞！"></a>十大 npm 最佳安全指南，教你如何避免安全漏洞！</h1><p>简介：</p>
<p>你重视 npm 漏洞吗？无论是前端还是后端开发人员，都应该重视 npm 的安全性最佳实践。开源代码的安全审查是提升安全性的关键所在，其中 npm 包的安全性应该是首要考虑因素，因为我们发现即使是官方的 npm 命令行工具也很容易受到攻击。</p>
<p>本文提供的这份备忘列表中，我们将列出针对开源维护人员和开发人员的十大最佳安全实践和生产力提示。</p>
<h2 id="快速阅读"><a href="#快速阅读" class="headerlink" title="快速阅读"></a>快速阅读</h2><p><strong>十大安全指南</strong></p>
<ol>
<li>不要把秘密发布到 npm 存储库上</li>
<li>强制锁文件</li>
<li>忽略运行脚本，最小化攻击面</li>
<li>评估 npm 项目的健康状况</li>
<li>审核开源依赖项中的漏洞(使用 Snyk 扫描安全漏洞)</li>
<li>使用本地 npm 代理</li>
<li>负责任地披露安全漏洞</li>
<li>启用 2FA</li>
<li>使用 npm 作者令牌</li>
<li>了解模块命名约定和域名仿冒攻击</li>
</ol>
<p>喜欢阅读或者对安全更加注意，请点击下方链接前往阅读：</p>
<blockquote>
<p><a href="https://www.infoq.cn/article/SI05RvA2QaeLhPx0kWmu" target="_blank" rel="noopener">https://www.infoq.cn/article/SI05RvA2QaeLhPx0kWmu</a></p>
</blockquote>
<h1 id="把网站升级到http-2"><a href="#把网站升级到http-2" class="headerlink" title="把网站升级到http/2"></a>把网站升级到http/2</h1><h1 id="二、一周新闻"><a href="#二、一周新闻" class="headerlink" title="二、一周新闻"></a>二、一周新闻</h1><h2 id="Vue-3-0-最新进展，Composition-API"><a href="#Vue-3-0-最新进展，Composition-API" class="headerlink" title="Vue 3.0 最新进展，Composition API"></a>Vue 3.0 最新进展，Composition API</h2><p>本文主要分以下几个主题讨论最新的Composition API：</p>
<ul>
<li>reactive API</li>
<li>ref API</li>
<li>watch API变化</li>
<li>computed API变化</li>
<li>生命周期钩子变化</li>
<li>TypeScript和JSX支持</li>
</ul>
<p>Composition API 可谓是修复了 Function API 诸多问题而提供的最新“修正案”，下面来看比起之前的vue-function-api，究竟修改了些什么呢？请前往阅读：</p>
<blockquote>
<p><a href="https://juejin.im/post/5d836458f265da03d871f6e9" target="_blank" rel="noopener">https://juejin.im/post/5d836458f265da03d871f6e9</a></p>
</blockquote>
<h1 id="三、玩遍前端"><a href="#三、玩遍前端" class="headerlink" title="三、玩遍前端"></a>三、玩遍前端</h1><h2 id="小tips-元素focus页面不滚动不定位的JS处理"><a href="#小tips-元素focus页面不滚动不定位的JS处理" class="headerlink" title="小tips: 元素focus页面不滚动不定位的JS处理"></a>小tips: 元素focus页面不滚动不定位的JS处理</h2><p>全新的API参数preventScroll，感觉请阅读原文：</p>
<blockquote>
<p><a href="https://www.zhangxinxu.com/wordpress/2019/09/js-focus-preventscroll/" target="_blank" rel="noopener">https://www.zhangxinxu.com/wordpress/2019/09/js-focus-preventscroll/</a></p>
</blockquote>
<h2 id="浏览器的一些“滚动”行为鉴赏"><a href="#浏览器的一些“滚动”行为鉴赏" class="headerlink" title="浏览器的一些“滚动”行为鉴赏"></a>浏览器的一些“滚动”行为鉴赏</h2><p>应该你遇到所有的“滚动”事件的相关问题和现象都可以在这篇文章里找到了：</p>
<blockquote>
<p><a href="https://juejin.im/post/5d75adfbe51d4561e84fcc9c" target="_blank" rel="noopener">https://juejin.im/post/5d75adfbe51d4561e84fcc9c</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>周二技术周刊</tag>
      </tags>
  </entry>
  <entry>
    <title>奇思妙想录</title>
    <url>/ideas/list.html</url>
    <content><![CDATA[<h1 id="2019-09-03"><a href="#2019-09-03" class="headerlink" title="2019-09-03"></a>2019-09-03</h1><h2 id="一个智能识别语音和输出的白板软件引擎"><a href="#一个智能识别语音和输出的白板软件引擎" class="headerlink" title="一个智能识别语音和输出的白板软件引擎"></a>一个智能识别语音和输出的白板软件引擎</h2><p>功能描述：</p>
<ul>
<li>通过人脸标识用户信息，得到当前输出用户</li>
<li>通过语音识别输出用户所描述内容</li>
<li>通过语义归类总结内容</li>
<li>通过流程图或思维导图输出最终白板任务图</li>
</ul>
<a id="more"></a>

<h1 id="2019-09-01"><a href="#2019-09-01" class="headerlink" title="2019-09-01"></a>2019-09-01</h1><h2 id="npm包评价系统"><a href="#npm包评价系统" class="headerlink" title="npm包评价系统"></a>npm包评价系统</h2><p>功能描述：</p>
<ul>
<li>通过cnpm或taobao搭建公有的npm包</li>
<li>筛选有github开源仓库</li>
<li>通过github的star数进行排名</li>
<li>增加类似豆瓣评分和评价系统</li>
</ul>
]]></content>
      <tags>
        <tag>奇思妙想</tag>
      </tags>
  </entry>
  <entry>
    <title>周二技术周刊 20190731期</title>
    <url>/wx/20190731.html</url>
    <content><![CDATA[<p><img src="https://pic.qqtn.com/up/2018-6/2018661629543719.jpg" alt="好看的图片"></p>
<h1 id="一、技术知识"><a href="#一、技术知识" class="headerlink" title="一、技术知识"></a>一、技术知识</h1><h2 id="1-1-蚂蚁金服前端框架和工程化实践"><a href="#1-1-蚂蚁金服前端框架和工程化实践" class="headerlink" title="1.1 蚂蚁金服前端框架和工程化实践"></a>1.1 蚂蚁金服前端框架和工程化实践</h2><p>作者：<a href="https://github.com/sorrycc" target="_blank" rel="noopener">阿里-云谦</a><br>简介：<br>讲述阿里Umi 和 Bigfish框架的发展历史，已经作者技术团队在里面做的哪些事情。</p>
<a id="more"></a>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>框架为什么能够成功的原因？</strong></p>
<ul>
<li>人：给使用者成就感和绩效——插件体系，插件体系是如何搭建的具体看原文详细介绍。</li>
<li>业务和流程：简化业务和流程，让程序员不必要浪费太多时间上上面。</li>
<li>开源：开源做地好，也更容易获得内部同学的认可。</li>
</ul>
<p><strong>资产市场分了四级:</strong></p>
<ul>
<li>组件，指通用组件，就是 antd，在下半年将要发布的 antd@4 里，我们会陆续提取更多通用组件到 antd 中。</li>
<li>业务组件，不能提取通用组件的，我们会提到内部统一的业务组件仓库中。</li>
<li>区块，由组件组成，可以想象成代码片段。</li>
<li>页面模板，由区块组成</li>
</ul>
<blockquote>
<p>后续要做配置化方案，可以参考一下。</p>
</blockquote>
<p><strong>微前端方案</strong></p>
<ul>
<li>相对狭义的理解，是一个解决多套技术栈共存的方案，比如首页用 jQuery，订单页用 React，客户系统用 Vue。</li>
<li>对微前端的理解是，他不仅是个技术方案，更是个解决流程、组织架构等问题的方案。</li>
</ul>
<blockquote>
<p>已有开源方案，乾坤:<a href="https://github.com/umijs/qiankun" target="_blank" rel="noopener">https://github.com/umijs/qiankun</a></p>
</blockquote>
<p><strong>前端永远不能忘记的：</strong></p>
<ul>
<li>优化：构建优化，性能优化等</li>
<li>测试+监控：单测、UI 测试、e2e 测试和集成测试，基本方案是基于 Jest + test-react-library + Puppeteer</li>
</ul>
<p><strong><em>阅读时间：15~20分钟</em></strong></p>
<p><a href="https://mp.weixin.qq.com/s/6-yjR_CsHaWUI8YqLK25rA" target="_blank" rel="noopener">点击原文阅读→</a></p>
<h2 id="1-2-哪些技术会决定前端开发者的未来发展？"><a href="#1-2-哪些技术会决定前端开发者的未来发展？" class="headerlink" title="1.2 哪些技术会决定前端开发者的未来发展？"></a>1.2 哪些技术会决定前端开发者的未来发展？</h2><p>简介：<br>大家有没有想过，通过学习Flutter，你的技术就提升了吗？</p>
<p>很多人第一反应是『当然了，学了一门新技术，学了一门新语言，难道技术不是提升了吗？』。</p>
<p>但是我觉得并没有，我其实依然在原地打转，<strong>一个Java开发者学会了用Ruby增删改查并不能代表能力提高了，一个前端开发者用RN或者Flutter开发了简单的APP也不能说明水平提高了，只不过是用另一种语言再写了一遍UI而已，会用三种框架写页面，并不是什么高技术含量的事情，会三种不如深入一种。</strong></p>
<p>##总结<br><strong>归纳两点</strong></p>
<ul>
<li>我们有时候看似在学很多技术，其实这些技术并不能提升你，但是给你造成了『我学了新东西能力提升了』的自我感觉偏差</li>
<li>不要盲目追寻社区的热点，很可能捡了芝麻丢了西瓜，要仔细思考这门技术对于你本身是否有提升，而不是被布道师们『洗脑』</li>
</ul>
<p><strong>处于趋势中的技术点</strong></p>
<ul>
<li><code>Flutter</code>，正是新框架，可以学习，但不要认为你的技术有了新的发展。</li>
<li><code>TypeScript</code>，会越来越多人用，因为其规范JavaScript的语法，降低很多不必要的类型错误，以及更多重大开源项目使用与支持。</li>
<li><code>图形技术</code>，将是未来所有前端程序员的痛点之一，进阶技术知识。</li>
<li><code>编辑器领域技术</code>，包括但不限于：代码编辑器（WebIDE）、图形编辑器（在线的3d建模或者ps）、文本编辑器等。</li>
<li><code>Serverless</code>是生产力上的直接提升，前端可以不考虑部署、运维、环境等场景，直接编写函数来实现后端逻辑的全干工程师。</li>
<li><code>IOT</code>（物联网 Internet of Things），js in IOT是因为js开发群众多，但是IOT是低性能低功耗低内存的设备，与js相反，所以最后js又会沦为写业务，但是和在浏览器开发有什么区别呢？</li>
<li><code>GraphQL</code>技术考验的是跨团队沟通协作能力，不是技术本身，干活是后端，得利的却是前端。</li>
<li><code>AI In FE</code>，tfjs的问题，基于浏览器的深度学习框架，其实应用范围非常非常窄，目前主要科研阶段。</li>
</ul>
<blockquote>
<p>因此，个人需要学习可以尝试学习<code>TypeScript</code>,<code>图形技术</code>和<code>编辑器领域技术</code>，顺便可以了解一下<code>Flutter</code>去实现HelloWorld。</p>
</blockquote>
<p>原文阅读链接：<br><a href="https://juejin.im/post/5d1589c8e51d45776031b02e" target="_blank" rel="noopener">https://juejin.im/post/5d1589c8e51d45776031b02e</a></p>
<h1 id="二、一周新闻"><a href="#二、一周新闻" class="headerlink" title="二、一周新闻"></a>二、一周新闻</h1><h2 id="2-1-npm-已落伍，下一代包管理器-Tink-正在孵化"><a href="#2-1-npm-已落伍，下一代包管理器-Tink-正在孵化" class="headerlink" title="2.1 npm 已落伍，下一代包管理器 Tink 正在孵化"></a>2.1 npm 已落伍，下一代包管理器 Tink 正在孵化</h2><blockquote>
<p>迄今为止，npm 生态系统已经拥有了近 1,000,000 个软件包，是规模最大的包管理平台。但这个生态系统及软件包管理器在诞生时并没有考虑如此复杂的局面，它们原本是适用于以 Node.js 生态系统为中心的小型项目和软件包的平台。</p>
</blockquote>
<blockquote>
<p>现在是时候重新定义适合现代 Web 开发的包管理技术了，而答案就是 Tink：它同样来自于 npm 团队，是下一代的 JS 包管理方案。Tink 将带来前所未有的性能表现、与 Node.js 等已有技术的深度兼容性，以及非常适合现代 Web 开发者的用户体验。<br><a href="https://www.infoq.cn/article/R*5JRVuOOHBRlw411PlZ" target="_blank" rel="noopener">https://www.infoq.cn/article/R*5JRVuOOHBRlw411PlZ</a></p>
</blockquote>
<h2 id="2-2-GMTC-2019-参会感想"><a href="#2-2-GMTC-2019-参会感想" class="headerlink" title="2.2 GMTC 2019 参会感想"></a>2.2 GMTC 2019 参会感想</h2><blockquote>
<p>得知 GMTC 2019 在北京举行还是今年 3 月份 EE 协作文档 的前端同学，推荐我们团队去 GMTC 做个分享，所以也顺便组织团队成员一起去向业界大佬学习。<br><a href="https://juejin.im/post/5d132ec16fb9a07efa092909" target="_blank" rel="noopener">https://juejin.im/post/5d132ec16fb9a07efa092909</a></p>
</blockquote>
<h1 id="三、玩遍前端"><a href="#三、玩遍前端" class="headerlink" title="三、玩遍前端"></a>三、玩遍前端</h1><h2 id="3-1-git-js"><a href="#3-1-git-js" class="headerlink" title="3.1 git-js"></a>3.1 git-js</h2><blockquote>
<p>一个可以在nodejs中去执行git命令的框架，大家可以尝试玩一下如何管理团队仓库，以及定制化的代码审核界面。<br><a href="https://github.com/steveukx/git-js" target="_blank" rel="noopener">https://github.com/steveukx/git-js</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>周二技术周刊</tag>
      </tags>
  </entry>
  <entry>
    <title>ios12 array.reverse问题</title>
    <url>/share/ios12-array-reverse.html</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>iOS12发布之后，在测试中发现一个关于Array.reverse的问题，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt;</span><br><span class="line">    &lt;title&gt;iOS 12 Safari bugs&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.addEventListener(&quot;load&quot;, function ()</span><br><span class="line">    &#123;</span><br><span class="line">        let arr = [1, 2, 3, 4, 5];</span><br><span class="line">        alert(arr.join());</span><br><span class="line"></span><br><span class="line">        document.querySelector(&quot;button&quot;).addEventListener(&quot;click&quot;, function ()</span><br><span class="line">        &#123;</span><br><span class="line">            arr.reverse();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button&gt;Array.reverse()&lt;/button&gt;</span><br><span class="line">    &lt;p style=&quot;color:red;&quot;&gt;test: click button and refresh page, code:&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>问题描述：第一次进入刷新alert:<code>1,2,3,4</code>，第二次刷新就一直为alert<code>4,3,2,1</code>。</p>
<h1 id="demo演示"><a href="#demo演示" class="headerlink" title="demo演示"></a>demo演示</h1><p><a href="https://fanmingfei.github.io/array-reverse-ios12/origin.html" target="_blank" rel="noopener">未修复的demo</a><br><a href="https://fanmingfei.github.io/array-reverse-ios12/fixed.html" target="_blank" rel="noopener">已修复的demo</a></p>
<a id="more"></a>

<h1 id="修复方法"><a href="#修复方法" class="headerlink" title="修复方法"></a>修复方法</h1><p>原理就是判断是否为iOS12版本，重写<code>Array.prototype.reverse</code>方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    var ua = navigator.userAgent;</span><br><span class="line">    if (!ua.match(/(iPhone|iPad|iPod)/)) return;</span><br><span class="line">    var matched = ua.match(/OS ([\d_\.]+) like Mac OS X/);</span><br><span class="line">    if (!matched || !matched[1]) return;</span><br><span class="line">    if (matched[1].indexOf(&apos;12&apos;) !== 0) return;</span><br><span class="line">    //以上判断是否为iOS12版本</span><br><span class="line">    </span><br><span class="line">    //以下为修复代码</span><br><span class="line">    Array.prototype._reverse = Array.prototype.reverse;</span><br><span class="line">    //重写reverse方法</span><br><span class="line">    Array.prototype.reverse = function reverse() &#123;</span><br><span class="line">        //重新设置数组长度 从而避免reverse方法改变数据后被缓存</span><br><span class="line">        if (Array.isArray(this)) this.length = this.length;</span><br><span class="line">        return Array.prototype._reverse.call(this);</span><br><span class="line">    &#125;</span><br><span class="line">    var nonenum = &#123;</span><br><span class="line">        enumerable: false</span><br><span class="line">    &#125;;</span><br><span class="line">    //设置Array原型链中的reverse方法不可枚举</span><br><span class="line">    Object.defineProperties(Array.prototype, &#123;</span><br><span class="line">        _reverse: nonenum,</span><br><span class="line">        reverse: nonenum,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>希望大家不要遇到该类生产问题咯！(否则你都不知道哪里出错了~~)</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://stackoverflow.com/questions/52390368/array-state-will-be-cached-in-ios-12-safari-is-bug-or-feature/52392901#52392901" target="_blank" rel="noopener">stackoverflow——iOS 12 Array.Reverse的Bug</a></li>
<li><a href="https://github.com/fanmingfei/array-reverse-ios12/" target="_blank" rel="noopener">github中阿里同事——如何修复iOS12 Array.reverse的bug方案</a></li>
</ul>
]]></content>
      <tags>
        <tag>技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS11.3 fastclick.js相关bug</title>
    <url>/share/iOS11-fastclick-js.html</url>
    <content><![CDATA[<p>最近遇到奇异的bug,在ios 11.3移动端页面 input输入框第一次触摸可以弹起键盘，后续再触摸需要很难弹起键盘，或者需要在输入框停一会才能弹起键盘。</p>
<h2 id="bug复现条件："><a href="#bug复现条件：" class="headerlink" title="bug复现条件："></a>bug复现条件：</h2><p>一、ios 11.3中app的webview为 UI WebView<br>二、在项目中使用了FastClick.js，页面包括输入框.</p>
<h2 id="发现源头问题："><a href="#发现源头问题：" class="headerlink" title="发现源头问题："></a>发现源头问题：</h2><p>在碰到问题脑子第一想法这不就是click延迟300ms的现象吗？所以就想到是不是FastClick.js导致，注释掉后发现bug现象消失了，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define([<span class="string">'zepto'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</span><br><span class="line"><span class="meta"> 'use strict'</span>;</span><br><span class="line"> <span class="comment">// FastClick.attach(document.body);</span></span><br><span class="line"> ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>但是这是为什么呢？我们一起看看为什么要加上FastClick，这个库解决了什么问题？</p>
<a id="more"></a>

<ul>
<li>click 300ms延迟：浏览器click会比touch延迟300ms触发</li>
<li>click穿透现象：当两个div同处一个position，上层div绑定touch，下层div绑定click,当上层div触发touch消失后，可能会触发下层div的click事件<br>既然Fastclick是为了解决这两类问题，其实现原理如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/11733108-a045cb92752f7ae8.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="fastclick原理"></li>
</ul>
<p>fastclick利用捕获顶层dom元素(如：body，html等)的click事件，拦截所有的click请求进行判断：是否有touch触发、是否需要阻碍click事件(stopImmediatePropagation)等。</p>
<h2 id="分析问题解决方案："><a href="#分析问题解决方案：" class="headerlink" title="分析问题解决方案："></a>分析问题解决方案：</h2><p>步骤一：input无法聚焦弹出键盘，fastclick中有一块判断当前元素targetElement是否需要needsFocus，看看其方法的实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">FastClick.prototype.needsFocus = <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123; <span class="comment">//判断当前元素是否需要focus</span></span><br><span class="line">        <span class="keyword">switch</span> (target.nodeName.toLowerCase()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'textarea'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'select'</span>:</span><br><span class="line">                <span class="keyword">return</span> !deviceIsAndroid;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'input'</span>:</span><br><span class="line">                <span class="keyword">switch</span> (target.type) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'button'</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'checkbox'</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'file'</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'image'</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'radio'</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'submit'</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// No point in attempting to focus disabled inputs</span></span><br><span class="line">                <span class="keyword">return</span> !target.disabled &amp;&amp; !target.readOnly;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> (<span class="regexp">/\bneedsfocus\b/</span>).test(target.className);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>步骤二：看到needsFocus下执行了什么？在touchEnd方法中，代码块如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.needsFocus(targetElement)) &#123;<span class="keyword">if</span> ((event.timeStamp - trackingClickStart) &gt; <span class="number">100</span> || (deviceIsIOS &amp;&amp; <span class="built_in">window</span>.top !== <span class="built_in">window</span> &amp;&amp; targetTagName === <span class="string">'input'</span>)) &#123;</span><br><span class="line"> <span class="keyword">this</span>.targetElement = <span class="literal">null</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">this</span>.focus(targetElement); <span class="comment">//调用focus进行聚焦</span></span><br><span class="line"> <span class="keyword">this</span>.sendClick(targetElement, event);</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">if</span> (!deviceIsIOS || targetTagName !== <span class="string">'select'</span>) &#123;</span><br><span class="line"> <span class="keyword">this</span>.targetElement = <span class="literal">null</span>;</span><br><span class="line"> event.preventDefault();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>步骤三：focus方法分析（包含解决方案），如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">FastClick.prototype.focus = <span class="function"><span class="keyword">function</span>(<span class="params">targetElement</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> length;</span><br><span class="line">        <span class="comment">//兼容处理:在iOS7中，有一些元素（如date、datetime、month等）在setSelectionRange会出现TypeError</span></span><br><span class="line">        <span class="comment">//这是因为这些元素并没有selectionStart和selectionEnd的整型数字属性，所以一旦引用就会报错，因此排除这些属性才使用setSelectionRange方法</span></span><br><span class="line">        <span class="keyword">if</span> (deviceIsIOS &amp;&amp; targetElement.setSelectionRange &amp;&amp; targetElement.type.indexOf(<span class="string">'date'</span>) !== <span class="number">0</span> &amp;&amp; targetElement.type !== <span class="string">'time'</span> &amp;&amp; targetElement.type !== <span class="string">'month'</span> &amp;&amp; targetElement.type !== <span class="string">'email'</span>) &#123;</span><br><span class="line">            length = targetElement.value.length;</span><br><span class="line">            targetElement.setSelectionRange(length, length);</span><br><span class="line">            <span class="comment">/*修复bug ios 11.3不弹出键盘，这里加上聚焦代码，让其强制聚焦弹出键盘*/</span></span><br><span class="line">            targetElement.focus();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            targetElement.focus();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>OK，上真机iphoneX验证bug已经消失了，但是我们并不知道为什么在ios 11.3会出现该问题，秉着探索真理的一颗心（ZZZZ），到github去查看FastClick的issues列表，果然发现早有人提出bug了，如下图：<br><img src="https://upload-images.jianshu.io/upload_images/11733108-dc00511b626e3496.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="fastclick issues"></p>
<p>下方有评论如下：<br>A：说framework7框架那边已经有解决方案啦，<a href="https://github.com/framework7io/framework7/issues/2314#issuecomment-377778034" target="_blank" rel="noopener">点击这里</a>。<br><img src="https://upload-images.jianshu.io/upload_images/11733108-2e17af0f0c9a7474.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="frameword7问题解决"></p>
<p>另外一位仁兄的解决方案和我类似，修改focus方法。<br><img src="https://upload-images.jianshu.io/upload_images/11733108-829a9db17ea2e4b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="focus解决方案"></p>
<p>因此跳到framework的issue中的解决方案，解决方案：<a href="https://stackoverflow.com/questions/49500339/cant-prevent-touchmove-from-scrolling-window-on-ios" target="_blank" rel="noopener">点击这里</a>，描述如下：<br><img src="https://upload-images.jianshu.io/upload_images/11733108-443f9d4c26e32cd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="解决方案描述"></p>
<p>跳过去stackoverflow后，其实根本源头已经查到了，ios 11.3更新 Safari 11.1，支持新web API :允许对事件支持 <code>{passive: false}</code>被动模式，减少滚动屏幕的性能损耗和奔溃。</p>
<h2 id="passive-mode解析"><a href="#passive-mode解析" class="headerlink" title="passive mode解析"></a>passive mode解析</h2><p>那么新的问题来了，{passive: false}是什么玩意？来，我们先看看它的使用方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'touchmove'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;, &#123; <span class="attr">passive</span>: <span class="literal">false</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>按照以往我们对添加事件监听的方法三个参数的认知，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(type , callback, capture); <span class="comment">//type是事件类型，callback是执行函数， capture是否进行捕获/冒泡，默认为false</span></span><br></pre></td></tr></table></figure>

<p>Passive event listeners是2016年Google I/O 上同 PWA 概念一起被提出，但是同PWA不同，Passive event listeners 的作用很简单，如果用简单一句话来解释就是：提升页面滑动的流畅度。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">target.addEventListener(type, listener[, options]);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">options 可选</span></span><br><span class="line"><span class="comment">一个指定有关 listener 属性的可选参数对象。</span></span><br><span class="line"><span class="comment">可用的选项如下：</span></span><br><span class="line"><span class="comment">capture:  Boolean，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发。</span></span><br><span class="line"><span class="comment">once:  Boolean，表示 listener 在添加之后最多只调用一次。如果是 true， listener 会在其被调用之后自动移除。</span></span><br><span class="line"><span class="comment">passive: Boolean，表示 listener 永远不会调用 preventDefault()。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//示例代码</span></span><br><span class="line">target.addEventListener(<span class="string">'touchstart'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">   e.preventDefault() <span class="comment">// 无效，报错</span></span><br><span class="line">&#125;, &#123;<span class="attr">passive</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>为什么增加支持这个属性会导致添加fastclick后input输入框很难弹出键盘？</p>
<p>在ios更新日志了，写到了“Updated root document touch event listeners to use passive mode improving scrolling performance and reducing crashes.”</p>
<p>翻译过来就是：针对document的touch事件监听添加passive配置，即是：{passive: true}，会永远不调用event.preventDefault()，以此来提高滚动性能。</p>
<p>源头推测：</p>
<p>fastclick是采用拦截click和监听touch事件去实现的，里面包括对tagetElement的focus方法重写，因此在11.3之前可能event.preventDefault生效了，同时用setSelectionRange是可以聚焦input的。</p>
<p>另外一个bug也是由这个导致的是：</p>
<p>在iOS11.3的UI webview使用fastclick.js，页面有个按钮点击事件，当app或锁屏超过几分钟时间，回到页面会导致click事件失效。</p>
<p>解决方案为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> passiveListener = (<span class="function"><span class="keyword">function</span> <span class="title">checkPassiveListener</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//判断浏览器是否支持 &#123;passive: true&#125;</span></span><br><span class="line">            <span class="keyword">var</span> supportsPassive = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> opts = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'passive'</span>, &#123;</span><br><span class="line">                    <span class="keyword">get</span>: function() &#123;</span><br><span class="line">                        supportsPassive = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="built_in">window</span>.addEventListener(<span class="string">'testPassiveListener'</span>, <span class="literal">null</span>, opts);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                supportsPassive = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> supportsPassive;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="keyword">var</span> activeListener = passiveListener ? &#123;<span class="attr">passive</span>:<span class="literal">false</span>&#125; : <span class="literal">false</span>;</span><br><span class="line">layer.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.onClick, <span class="literal">true</span>);</span><br><span class="line">layer.addEventListener(<span class="string">'touchstart'</span>, <span class="keyword">this</span>.onTouchStart, passiveListener);</span><br><span class="line">layer.addEventListener(<span class="string">'touchmove'</span>, <span class="keyword">this</span>.onTouchMove, passiveListener);</span><br><span class="line">layer.addEventListener(<span class="string">'touchend'</span>, <span class="keyword">this</span>.onTouchEnd, passiveListener);</span><br><span class="line">layer.addEventListener(<span class="string">'touchcancel'</span>, <span class="keyword">this</span>.onTouchCancel, passiveListener);</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="noopener">《EventTarget.addEventListener()增加passive属性说明——web MDN API网站》</a></li>
<li><a href="https://github.com/ftlabs/fastclick/issues/548" target="_blank" rel="noopener">《fastclick github issues#548》</a></li>
<li><a href="https://stackoverflow.com/questions/49500339/cant-prevent-touchmove-from-scrolling-window-on-ios" target="_blank" rel="noopener">《stackoverflow ——touchmove e.preventDefault失效问题》</a></li>
<li><a href="https://developer.apple.com/library/content/releasenotes/General/WhatsNewInSafari/Articles/Safari_11_1.html" target="_blank" rel="noopener">《Safari 11.1更新日志》</a></li>
</ul>
]]></content>
      <tags>
        <tag>技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>如何用自定义钩子重构 React 组件</title>
    <url>/translate/wait.html</url>
    <content><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://codescene.com/engineering-blog/refactoring-components-in-react-with-custom-hooks" target="_blank" rel="noopener">如何用自定义钩子重构 React 组件</a></p>
]]></content>
      <tags>
        <tag>翻译文章</tag>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>//404.html</url>
    <content><![CDATA[<html>
<head><meta name="generator" content="Hexo 3.9.0">
</head>
<body>
<script type="text/javascript" src="http://www.qq.com/404/search_children.js" charset="utf-8" homepageurl="http://leyar.me" homepagename="返回主页"></script>
</body>
</html>]]></content>
  </entry>
</search>
