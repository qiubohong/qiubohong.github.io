---
title: 5分钟AI，每天搞懂一个知识点(14) - Function Calling
date: 2025-12-16 12:00:00
toc: true
tags:
  - 学习总结
  - 5分钟AI
---

> 做一个有温度和有干货的技术分享作者 —— [Qborfy](https://qborfy.com)

今天我们来学习 **AI 函数调用 Function Calling**

> 一句话核心: **Function Calling**（函数调用）是大模型在对话过程中，根据用户需求调用外部函数或工具的一种能力。

通俗地讲，它让大模型从“能说会道”的参谋，变成了“能动手做事”的助手。当模型遇到自己无法直接解决的问题时（比如查询实时信息、进行复杂计算），它不再说“我做不到”，而是会“告诉”你的程序：“嘿，你需要调用那个叫 get_weather 的函数，并把 location 参数设置为‘北京’。”

需要注意的是，模型本身并不直接执行函数，它只负责生成调用的“指令”。真正的执行工作由你的程序来完成。

它的核心价值在于**将大模型的语言理解能力与外部工具的执行能力相结合**，从而突破其固有局限（如知识截止日期、无法访问网络等），完成更复杂的任务。

<!-- more -->

# 是什么

![5分钟AI知识网络图](/assets/img/ailearn/daily/14/1.png)

通过一张图来理解 Function Calling 的工作原理：

![Function Calling 工作原理](/assets/img/ailearn/daily/14/2.png)

这个流程的核心在于，大模型至少被调用了**两次**：第一次是分析意图并决定调用哪个函数，第二次是将函数的执行结果整合成对人类友好的自然语言回复。

# 怎么做

下面我们通过几个案例来理解 Function Calling 的使用场景和实现方式。

## 案例 1：智能天气查询助手

这是最经典的案例，展示了如何弥补大模型知识时效性的不足。

```python
# 1. 定义可供调用的工具（告诉模型你有什么函数）
tools = [
    {
        "type": "function",
        "function": {
            "name": "get_current_weather",  # 函数名
            "description": "获取指定城市的当前天气",  # 给模型看的功能描述
            "parameters": {  # 参数定义
                "type": "object",
                "properties": {
                    "location": {
                        "type": "string",
                        "description": "城市名称，例如：北京",
                    }
                },
                "required": ["location"],  # 必须提供的参数
            },
        },
    }
]

# 2. 用户提问
messages = [{"role": "user", "content": "北京天气怎么样？"}]

# 3. 首次调用模型，模型会返回类似以下的指令：
# function_call = {
#   "name": "get_current_weather",
#   "arguments": "{\"location\": \"北京\"}"
# }

# 4. 你的程序执行真实的天气API调用函数
# 5. 将执行结果 `weather_result` 传给模型进行第二次调用，生成最终回复
```

## 案例 2：并行查询（进阶技巧）

当用户的问题涉及多个独立查询时，可以开启并行调用功能，大幅提升效率。

> **用户提问**：“同时查询北京和上海的天气。”
> **实现**：设置 `parallel_tool_calls=True` 参数，模型可以同时生成两个函数调用请求，你的程序可以并行执行两个天气查询 API，然后一次性将结果返回给模型进行总结。

## 案例 3：股票查询系统

这个案例展示了如何将专业、实时的数据（如股价）接入对话系统。

```python
# 工具定义示例
tools = [
    {
        "type": "function",
        "function": {
            "name": "get_stock_price",
            "description": "获取指定股票的实时价格",
            "parameters": {
                "type": "object",
                "properties": {
                    "symbol": {"type": "string", "description": "股票代码"}
                },
                "required": ["symbol"],
            },
        }
    }
]
```

当用户询问“青岛啤酒的股价是多少？”，模型会调用此函数，你的程序可以连接真实的金融数据 API 获取信息，再由模型生成回复。

## 实战案例

下面我们通过 openai sdk 来实现一个简单的天气查询功能：

```python
from openai import OpenAI
import json

client = OpenAI()

# 1. 定义可供调用的工具（告诉模型你有什么函数）
tools = [
    {
        "type": "function",
        "function": {
            "name": "get_current_weather",  # 函数名
            "description": "获取指定城市的当前天气",  # 给模型看的功能描述
            "parameters": {  # 参数定义
                "type": "object",
                "properties": {
                    "location": {
                        "type": "string",
                        "description": "城市名称，例如：北京",
                    }
                },
                "required": ["location"],  # 必须提供的参数
            },
        },
    }
]

def get_current_weather(params):
    location = params.get("location")
    # 这里你可以调用真实的天气API，这里我们模拟返回数据
    return f"{location} 当前天气晴，温度25摄氏度"

# 这个列表会随着对话进行不断更新
input_list = [
    {"role": "user", "content": "请告诉我北京的天气。"}
]

# 2. 第一次调用模型，模型会返回函数调用指令
response = client.responses.create(
    model="gpt-5",
    tools=tools,
    input=input_list,
)

# 这时候我们把模型的输出添加到输入列表中
input_list += response.output

for item in response.output:
    if item.type == "function_call":
        if item.name == "get_current_weather":
            # 3. 执行函数调用
            args = json.loads(item.arguments)
            weather = get_current_weather(args)


            # 4. 将函数调用结果添加回输入列表，供模型继续处理
            input_list.append({
                "type": "function_call_output",
                "call_id": item.call_id,
                "output": json.dumps({
                  "horoscope": weather
                })
            })

print("最终的输入列表:")
print(input_list)

response = client.responses.create(
    model="gpt-5",
    instructions="根据用户的提问和函数调用结果，生成一个友好的回复。",
    tools=tools,
    input=input_list,
)

# 5. The model should be able to give a response!
print("最终输出：")
print(response.model_dump_json(indent=2))
print("\n" + response.output_text)
```

- **核心工具/库**：**OpenAI Python SDK**。即使你使用的不是 OpenAI 的模型（如通义千问、DeepSeek），许多国产大模型平台也兼容 OpenAI 的 API 格式。这意味着你只需简单配置不同的 `base_url` 和 `api_key`，就可以用几乎相同的代码调用不同品牌的模型，大大降低了学习和开发成本。
- **关键参数**：在调用 `client.chat.completions.create` 方法时，核心参数是 `tools`（用于定义可用函数列表）和 `tool_choice`（用于控制调用行为，如 `auto` 自动决定或强制调用某个函数）。

# ❄️ 冷知识

1.  **模型没有“手”**：一个大反直觉的真相是，大模型本身并不具备执行代码的能力。它只是一个“超级大脑”，负责生成调用函数的“计划”。真正去执行这个计划、拥有“手和脚”的是你自己的程序。
2.  **描述决定一切**：模型是否调用一个函数，很大程度上依赖于你为函数写的 `description`（描述）。描述必须清晰、准确，模型才能正确理解何时该调用它。
3.  **“思考”过程可控**：你可以通过 `tool_choice` 参数精细控制模型的行为。比如，可以强制模型必须调用某个函数（`tool_choice={"type": "function", "function": {"name": "get_weather"}}`），或者禁止它调用任何函数（`tool_choice="none"`），让它完全靠自己知识库回答。
4.  **与 MCP 的关系**：你可以把 Function Calling 看作是一个“基础版”的工具调用技术，简单直接。而**MCP（Model Context Protocol）** 则是一个更高级、更标准化的“企业级工具箱协议”，它旨在以统一的方式管理成千上万的工具，更适合构建复杂的 AI 智能体（Agent）工作流。它们是互补而非替代关系。

# 参考资料

- [OpenAI Function Calling 官方文档](https://platform.openai.com/docs/guides/function-calling)
- [阿里云百炼平台文档 Function Calling](https://help.aliyun.com/zh/model-studio/qwen-function-calling)
- [DeepSeek Function Calling 文档](https://api-docs.deepseek.com/zh-cn/guides/tool_calls)
